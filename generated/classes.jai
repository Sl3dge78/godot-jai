// AESContext
AESContext :: struct {
	__private: *void;

	Mode :: enum {
		MODE_ECB_ENCRYPT :: 0;
		MODE_ECB_DECRYPT :: 1;
		MODE_CBC_ENCRYPT :: 2;
		MODE_CBC_DECRYPT :: 3;
		MODE_MAX :: 4;
	}
}

AESContext_start :: (using self: *AESContext, mode: AESContext.Mode, key: PackedByteArray, iv: PackedByteArray) -> Error {
}
AESContext_update :: (using self: *AESContext, src: PackedByteArray) -> PackedByteArray {
}
AESContext_get_iv_state :: (using self: *AESContext) -> PackedByteArray {
}
AESContext_finish :: (using self: *AESContext) {
}

// AStar2D
AStar2D :: struct {
	__private: *void;
}

AStar2D__estimate_cost :: (using self: *AStar2D, from_id: int, to_id: int) -> float {
}
AStar2D__compute_cost :: (using self: *AStar2D, from_id: int, to_id: int) -> float {
}
AStar2D_get_available_point_id :: (using self: *AStar2D) -> int {
}
AStar2D_add_point :: (using self: *AStar2D, id: int, position: Vector2, weight_scale: float) {
}
AStar2D_get_point_position :: (using self: *AStar2D, id: int) -> Vector2 {
}
AStar2D_set_point_position :: (using self: *AStar2D, id: int, position: Vector2) {
}
AStar2D_get_point_weight_scale :: (using self: *AStar2D, id: int) -> float {
}
AStar2D_set_point_weight_scale :: (using self: *AStar2D, id: int, weight_scale: float) {
}
AStar2D_remove_point :: (using self: *AStar2D, id: int) {
}
AStar2D_has_point :: (using self: *AStar2D, id: int) -> bool {
}
AStar2D_get_point_connections :: (using self: *AStar2D, id: int) -> PackedInt64Array {
}
AStar2D_get_point_ids :: (using self: *AStar2D) -> PackedInt64Array {
}
AStar2D_set_point_disabled :: (using self: *AStar2D, id: int, disabled: bool) {
}
AStar2D_is_point_disabled :: (using self: *AStar2D, id: int) -> bool {
}
AStar2D_connect_points :: (using self: *AStar2D, id: int, to_id: int, bidirectional: bool) {
}
AStar2D_disconnect_points :: (using self: *AStar2D, id: int, to_id: int, bidirectional: bool) {
}
AStar2D_are_points_connected :: (using self: *AStar2D, id: int, to_id: int, bidirectional: bool) -> bool {
}
AStar2D_get_point_count :: (using self: *AStar2D) -> int {
}
AStar2D_get_point_capacity :: (using self: *AStar2D) -> int {
}
AStar2D_reserve_space :: (using self: *AStar2D, num_nodes: int) {
}
AStar2D_clear :: (using self: *AStar2D) {
}
AStar2D_get_closest_point :: (using self: *AStar2D, to_position: Vector2, include_disabled: bool) -> int {
}
AStar2D_get_closest_position_in_segment :: (using self: *AStar2D, to_position: Vector2) -> Vector2 {
}
AStar2D_get_point_path :: (using self: *AStar2D, from_id: int, to_id: int, allow_partial_path: bool) -> PackedVector2Array {
}
AStar2D_get_id_path :: (using self: *AStar2D, from_id: int, to_id: int, allow_partial_path: bool) -> PackedInt64Array {
}

// AStar3D
AStar3D :: struct {
	__private: *void;
}

AStar3D__estimate_cost :: (using self: *AStar3D, from_id: int, to_id: int) -> float {
}
AStar3D__compute_cost :: (using self: *AStar3D, from_id: int, to_id: int) -> float {
}
AStar3D_get_available_point_id :: (using self: *AStar3D) -> int {
}
AStar3D_add_point :: (using self: *AStar3D, id: int, position: Vector3, weight_scale: float) {
}
AStar3D_get_point_position :: (using self: *AStar3D, id: int) -> Vector3 {
}
AStar3D_set_point_position :: (using self: *AStar3D, id: int, position: Vector3) {
}
AStar3D_get_point_weight_scale :: (using self: *AStar3D, id: int) -> float {
}
AStar3D_set_point_weight_scale :: (using self: *AStar3D, id: int, weight_scale: float) {
}
AStar3D_remove_point :: (using self: *AStar3D, id: int) {
}
AStar3D_has_point :: (using self: *AStar3D, id: int) -> bool {
}
AStar3D_get_point_connections :: (using self: *AStar3D, id: int) -> PackedInt64Array {
}
AStar3D_get_point_ids :: (using self: *AStar3D) -> PackedInt64Array {
}
AStar3D_set_point_disabled :: (using self: *AStar3D, id: int, disabled: bool) {
}
AStar3D_is_point_disabled :: (using self: *AStar3D, id: int) -> bool {
}
AStar3D_connect_points :: (using self: *AStar3D, id: int, to_id: int, bidirectional: bool) {
}
AStar3D_disconnect_points :: (using self: *AStar3D, id: int, to_id: int, bidirectional: bool) {
}
AStar3D_are_points_connected :: (using self: *AStar3D, id: int, to_id: int, bidirectional: bool) -> bool {
}
AStar3D_get_point_count :: (using self: *AStar3D) -> int {
}
AStar3D_get_point_capacity :: (using self: *AStar3D) -> int {
}
AStar3D_reserve_space :: (using self: *AStar3D, num_nodes: int) {
}
AStar3D_clear :: (using self: *AStar3D) {
}
AStar3D_get_closest_point :: (using self: *AStar3D, to_position: Vector3, include_disabled: bool) -> int {
}
AStar3D_get_closest_position_in_segment :: (using self: *AStar3D, to_position: Vector3) -> Vector3 {
}
AStar3D_get_point_path :: (using self: *AStar3D, from_id: int, to_id: int, allow_partial_path: bool) -> PackedVector3Array {
}
AStar3D_get_id_path :: (using self: *AStar3D, from_id: int, to_id: int, allow_partial_path: bool) -> PackedInt64Array {
}

// AStarGrid2D
AStarGrid2D :: struct {
	__private: *void;

	Heuristic :: enum {
		HEURISTIC_EUCLIDEAN :: 0;
		HEURISTIC_MANHATTAN :: 1;
		HEURISTIC_OCTILE :: 2;
		HEURISTIC_CHEBYSHEV :: 3;
		HEURISTIC_MAX :: 4;
	}
	DiagonalMode :: enum {
		DIAGONAL_MODE_ALWAYS :: 0;
		DIAGONAL_MODE_NEVER :: 1;
		DIAGONAL_MODE_AT_LEAST_ONE_WALKABLE :: 2;
		DIAGONAL_MODE_ONLY_IF_NO_OBSTACLES :: 3;
		DIAGONAL_MODE_MAX :: 4;
	}
	CellShape :: enum {
		CELL_SHAPE_SQUARE :: 0;
		CELL_SHAPE_ISOMETRIC_RIGHT :: 1;
		CELL_SHAPE_ISOMETRIC_DOWN :: 2;
		CELL_SHAPE_MAX :: 3;
	}
}

AStarGrid2D__estimate_cost :: (using self: *AStarGrid2D, from_id: Vector2i, to_id: Vector2i) -> float {
}
AStarGrid2D__compute_cost :: (using self: *AStarGrid2D, from_id: Vector2i, to_id: Vector2i) -> float {
}
AStarGrid2D_set_region :: (using self: *AStarGrid2D, region: Rect2i) {
}
AStarGrid2D_get_region :: (using self: *AStarGrid2D) -> Rect2i {
}
AStarGrid2D_set_size :: (using self: *AStarGrid2D, size: Vector2i) {
}
AStarGrid2D_get_size :: (using self: *AStarGrid2D) -> Vector2i {
}
AStarGrid2D_set_offset :: (using self: *AStarGrid2D, offset: Vector2) {
}
AStarGrid2D_get_offset :: (using self: *AStarGrid2D) -> Vector2 {
}
AStarGrid2D_set_cell_size :: (using self: *AStarGrid2D, cell_size: Vector2) {
}
AStarGrid2D_get_cell_size :: (using self: *AStarGrid2D) -> Vector2 {
}
AStarGrid2D_set_cell_shape :: (using self: *AStarGrid2D, cell_shape: AStarGrid2D.CellShape) {
}
AStarGrid2D_get_cell_shape :: (using self: *AStarGrid2D) -> AStarGrid2D.CellShape {
}
AStarGrid2D_is_in_bounds :: (using self: *AStarGrid2D, x: int, y: int) -> bool {
}
AStarGrid2D_is_in_boundsv :: (using self: *AStarGrid2D, id: Vector2i) -> bool {
}
AStarGrid2D_is_dirty :: (using self: *AStarGrid2D) -> bool {
}
AStarGrid2D_update :: (using self: *AStarGrid2D) {
}
AStarGrid2D_set_jumping_enabled :: (using self: *AStarGrid2D, enabled: bool) {
}
AStarGrid2D_is_jumping_enabled :: (using self: *AStarGrid2D) -> bool {
}
AStarGrid2D_set_diagonal_mode :: (using self: *AStarGrid2D, mode: AStarGrid2D.DiagonalMode) {
}
AStarGrid2D_get_diagonal_mode :: (using self: *AStarGrid2D) -> AStarGrid2D.DiagonalMode {
}
AStarGrid2D_set_default_compute_heuristic :: (using self: *AStarGrid2D, heuristic: AStarGrid2D.Heuristic) {
}
AStarGrid2D_get_default_compute_heuristic :: (using self: *AStarGrid2D) -> AStarGrid2D.Heuristic {
}
AStarGrid2D_set_default_estimate_heuristic :: (using self: *AStarGrid2D, heuristic: AStarGrid2D.Heuristic) {
}
AStarGrid2D_get_default_estimate_heuristic :: (using self: *AStarGrid2D) -> AStarGrid2D.Heuristic {
}
AStarGrid2D_set_point_solid :: (using self: *AStarGrid2D, id: Vector2i, solid: bool) {
}
AStarGrid2D_is_point_solid :: (using self: *AStarGrid2D, id: Vector2i) -> bool {
}
AStarGrid2D_set_point_weight_scale :: (using self: *AStarGrid2D, id: Vector2i, weight_scale: float) {
}
AStarGrid2D_get_point_weight_scale :: (using self: *AStarGrid2D, id: Vector2i) -> float {
}
AStarGrid2D_fill_solid_region :: (using self: *AStarGrid2D, region: Rect2i, solid: bool) {
}
AStarGrid2D_fill_weight_scale_region :: (using self: *AStarGrid2D, region: Rect2i, weight_scale: float) {
}
AStarGrid2D_clear :: (using self: *AStarGrid2D) {
}
AStarGrid2D_get_point_position :: (using self: *AStarGrid2D, id: Vector2i) -> Vector2 {
}
AStarGrid2D_get_point_path :: (using self: *AStarGrid2D, from_id: Vector2i, to_id: Vector2i, allow_partial_path: bool) -> PackedVector2Array {
}
AStarGrid2D_get_id_path :: (using self: *AStarGrid2D, from_id: Vector2i, to_id: Vector2i, allow_partial_path: bool) -> Array {
}

// AcceptDialog
AcceptDialog :: struct {
	__private: *void;
}

AcceptDialog_get_ok_button :: (using self: *AcceptDialog) -> Button {
}
AcceptDialog_get_label :: (using self: *AcceptDialog) -> Label {
}
AcceptDialog_set_hide_on_ok :: (using self: *AcceptDialog, enabled: bool) {
}
AcceptDialog_get_hide_on_ok :: (using self: *AcceptDialog) -> bool {
}
AcceptDialog_set_close_on_escape :: (using self: *AcceptDialog, enabled: bool) {
}
AcceptDialog_get_close_on_escape :: (using self: *AcceptDialog) -> bool {
}
AcceptDialog_add_button :: (using self: *AcceptDialog, text: String, right: bool, action: String) -> Button {
}
AcceptDialog_add_cancel_button :: (using self: *AcceptDialog, name: String) -> Button {
}
AcceptDialog_remove_button :: (using self: *AcceptDialog, button: Button) {
}
AcceptDialog_register_text_enter :: (using self: *AcceptDialog, line_edit: LineEdit) {
}
AcceptDialog_set_text :: (using self: *AcceptDialog, text: String) {
}
AcceptDialog_get_text :: (using self: *AcceptDialog) -> String {
}
AcceptDialog_set_autowrap :: (using self: *AcceptDialog, autowrap: bool) {
}
AcceptDialog_has_autowrap :: (using self: *AcceptDialog) -> bool {
}
AcceptDialog_set_ok_button_text :: (using self: *AcceptDialog, text: String) {
}
AcceptDialog_get_ok_button_text :: (using self: *AcceptDialog) -> String {
}

// AnimatableBody2D
AnimatableBody2D :: struct {
	__private: *void;
}

AnimatableBody2D_set_sync_to_physics :: (using self: *AnimatableBody2D, enable: bool) {
}
AnimatableBody2D_is_sync_to_physics_enabled :: (using self: *AnimatableBody2D) -> bool {
}

// AnimatableBody3D
AnimatableBody3D :: struct {
	__private: *void;
}

AnimatableBody3D_set_sync_to_physics :: (using self: *AnimatableBody3D, enable: bool) {
}
AnimatableBody3D_is_sync_to_physics_enabled :: (using self: *AnimatableBody3D) -> bool {
}

// AnimatedSprite2D
AnimatedSprite2D :: struct {
	__private: *void;
}

AnimatedSprite2D_set_sprite_frames :: (using self: *AnimatedSprite2D, sprite_frames: SpriteFrames) {
}
AnimatedSprite2D_get_sprite_frames :: (using self: *AnimatedSprite2D) -> SpriteFrames {
}
AnimatedSprite2D_set_animation :: (using self: *AnimatedSprite2D, name: StringName) {
}
AnimatedSprite2D_get_animation :: (using self: *AnimatedSprite2D) -> StringName {
}
AnimatedSprite2D_set_autoplay :: (using self: *AnimatedSprite2D, name: String) {
}
AnimatedSprite2D_get_autoplay :: (using self: *AnimatedSprite2D) -> String {
}
AnimatedSprite2D_is_playing :: (using self: *AnimatedSprite2D) -> bool {
}
AnimatedSprite2D_play :: (using self: *AnimatedSprite2D, name: StringName, custom_speed: float, from_end: bool) {
}
AnimatedSprite2D_play_backwards :: (using self: *AnimatedSprite2D, name: StringName) {
}
AnimatedSprite2D_pause :: (using self: *AnimatedSprite2D) {
}
AnimatedSprite2D_stop :: (using self: *AnimatedSprite2D) {
}
AnimatedSprite2D_set_centered :: (using self: *AnimatedSprite2D, centered: bool) {
}
AnimatedSprite2D_is_centered :: (using self: *AnimatedSprite2D) -> bool {
}
AnimatedSprite2D_set_offset :: (using self: *AnimatedSprite2D, offset: Vector2) {
}
AnimatedSprite2D_get_offset :: (using self: *AnimatedSprite2D) -> Vector2 {
}
AnimatedSprite2D_set_flip_h :: (using self: *AnimatedSprite2D, flip_h: bool) {
}
AnimatedSprite2D_is_flipped_h :: (using self: *AnimatedSprite2D) -> bool {
}
AnimatedSprite2D_set_flip_v :: (using self: *AnimatedSprite2D, flip_v: bool) {
}
AnimatedSprite2D_is_flipped_v :: (using self: *AnimatedSprite2D) -> bool {
}
AnimatedSprite2D_set_frame :: (using self: *AnimatedSprite2D, frame: int) {
}
AnimatedSprite2D_get_frame :: (using self: *AnimatedSprite2D) -> int {
}
AnimatedSprite2D_set_frame_progress :: (using self: *AnimatedSprite2D, progress: float) {
}
AnimatedSprite2D_get_frame_progress :: (using self: *AnimatedSprite2D) -> float {
}
AnimatedSprite2D_set_frame_and_progress :: (using self: *AnimatedSprite2D, frame: int, progress: float) {
}
AnimatedSprite2D_set_speed_scale :: (using self: *AnimatedSprite2D, speed_scale: float) {
}
AnimatedSprite2D_get_speed_scale :: (using self: *AnimatedSprite2D) -> float {
}
AnimatedSprite2D_get_playing_speed :: (using self: *AnimatedSprite2D) -> float {
}

// AnimatedSprite3D
AnimatedSprite3D :: struct {
	__private: *void;
}

AnimatedSprite3D_set_sprite_frames :: (using self: *AnimatedSprite3D, sprite_frames: SpriteFrames) {
}
AnimatedSprite3D_get_sprite_frames :: (using self: *AnimatedSprite3D) -> SpriteFrames {
}
AnimatedSprite3D_set_animation :: (using self: *AnimatedSprite3D, name: StringName) {
}
AnimatedSprite3D_get_animation :: (using self: *AnimatedSprite3D) -> StringName {
}
AnimatedSprite3D_set_autoplay :: (using self: *AnimatedSprite3D, name: String) {
}
AnimatedSprite3D_get_autoplay :: (using self: *AnimatedSprite3D) -> String {
}
AnimatedSprite3D_is_playing :: (using self: *AnimatedSprite3D) -> bool {
}
AnimatedSprite3D_play :: (using self: *AnimatedSprite3D, name: StringName, custom_speed: float, from_end: bool) {
}
AnimatedSprite3D_play_backwards :: (using self: *AnimatedSprite3D, name: StringName) {
}
AnimatedSprite3D_pause :: (using self: *AnimatedSprite3D) {
}
AnimatedSprite3D_stop :: (using self: *AnimatedSprite3D) {
}
AnimatedSprite3D_set_frame :: (using self: *AnimatedSprite3D, frame: int) {
}
AnimatedSprite3D_get_frame :: (using self: *AnimatedSprite3D) -> int {
}
AnimatedSprite3D_set_frame_progress :: (using self: *AnimatedSprite3D, progress: float) {
}
AnimatedSprite3D_get_frame_progress :: (using self: *AnimatedSprite3D) -> float {
}
AnimatedSprite3D_set_frame_and_progress :: (using self: *AnimatedSprite3D, frame: int, progress: float) {
}
AnimatedSprite3D_set_speed_scale :: (using self: *AnimatedSprite3D, speed_scale: float) {
}
AnimatedSprite3D_get_speed_scale :: (using self: *AnimatedSprite3D) -> float {
}
AnimatedSprite3D_get_playing_speed :: (using self: *AnimatedSprite3D) -> float {
}

// AnimatedTexture
AnimatedTexture :: struct {
	__private: *void;

	MAX_FRAMES :: 256;
}

AnimatedTexture_set_frames :: (using self: *AnimatedTexture, frames: int) {
}
AnimatedTexture_get_frames :: (using self: *AnimatedTexture) -> int {
}
AnimatedTexture_set_current_frame :: (using self: *AnimatedTexture, frame: int) {
}
AnimatedTexture_get_current_frame :: (using self: *AnimatedTexture) -> int {
}
AnimatedTexture_set_pause :: (using self: *AnimatedTexture, pause: bool) {
}
AnimatedTexture_get_pause :: (using self: *AnimatedTexture) -> bool {
}
AnimatedTexture_set_one_shot :: (using self: *AnimatedTexture, one_shot: bool) {
}
AnimatedTexture_get_one_shot :: (using self: *AnimatedTexture) -> bool {
}
AnimatedTexture_set_speed_scale :: (using self: *AnimatedTexture, scale: float) {
}
AnimatedTexture_get_speed_scale :: (using self: *AnimatedTexture) -> float {
}
AnimatedTexture_set_frame_texture :: (using self: *AnimatedTexture, frame: int, texture: Texture2D) {
}
AnimatedTexture_get_frame_texture :: (using self: *AnimatedTexture, frame: int) -> Texture2D {
}
AnimatedTexture_set_frame_duration :: (using self: *AnimatedTexture, frame: int, duration: float) {
}
AnimatedTexture_get_frame_duration :: (using self: *AnimatedTexture, frame: int) -> float {
}

// Animation
Animation :: struct {
	__private: *void;

	TrackType :: enum {
		TYPE_VALUE :: 0;
		TYPE_POSITION_3D :: 1;
		TYPE_ROTATION_3D :: 2;
		TYPE_SCALE_3D :: 3;
		TYPE_BLEND_SHAPE :: 4;
		TYPE_METHOD :: 5;
		TYPE_BEZIER :: 6;
		TYPE_AUDIO :: 7;
		TYPE_ANIMATION :: 8;
	}
	InterpolationType :: enum {
		INTERPOLATION_NEAREST :: 0;
		INTERPOLATION_LINEAR :: 1;
		INTERPOLATION_CUBIC :: 2;
		INTERPOLATION_LINEAR_ANGLE :: 3;
		INTERPOLATION_CUBIC_ANGLE :: 4;
	}
	UpdateMode :: enum {
		UPDATE_CONTINUOUS :: 0;
		UPDATE_DISCRETE :: 1;
		UPDATE_CAPTURE :: 2;
	}
	LoopMode :: enum {
		LOOP_NONE :: 0;
		LOOP_LINEAR :: 1;
		LOOP_PINGPONG :: 2;
	}
	LoopedFlag :: enum {
		LOOPED_FLAG_NONE :: 0;
		LOOPED_FLAG_END :: 1;
		LOOPED_FLAG_START :: 2;
	}
	FindMode :: enum {
		FIND_MODE_NEAREST :: 0;
		FIND_MODE_APPROX :: 1;
		FIND_MODE_EXACT :: 2;
	}
}

Animation_add_track :: (using self: *Animation, type: Animation.TrackType, at_position: int) -> int {
}
Animation_remove_track :: (using self: *Animation, track_idx: int) {
}
Animation_get_track_count :: (using self: *Animation) -> int {
}
Animation_track_get_type :: (using self: *Animation, track_idx: int) -> Animation.TrackType {
}
Animation_track_get_path :: (using self: *Animation, track_idx: int) -> NodePath {
}
Animation_track_set_path :: (using self: *Animation, track_idx: int, path: NodePath) {
}
Animation_find_track :: (using self: *Animation, path: NodePath, type: Animation.TrackType) -> int {
}
Animation_track_move_up :: (using self: *Animation, track_idx: int) {
}
Animation_track_move_down :: (using self: *Animation, track_idx: int) {
}
Animation_track_move_to :: (using self: *Animation, track_idx: int, to_idx: int) {
}
Animation_track_swap :: (using self: *Animation, track_idx: int, with_idx: int) {
}
Animation_track_set_imported :: (using self: *Animation, track_idx: int, imported: bool) {
}
Animation_track_is_imported :: (using self: *Animation, track_idx: int) -> bool {
}
Animation_track_set_enabled :: (using self: *Animation, track_idx: int, enabled: bool) {
}
Animation_track_is_enabled :: (using self: *Animation, track_idx: int) -> bool {
}
Animation_position_track_insert_key :: (using self: *Animation, track_idx: int, time: float, position: Vector3) -> int {
}
Animation_rotation_track_insert_key :: (using self: *Animation, track_idx: int, time: float, rotation: Quaternion) -> int {
}
Animation_scale_track_insert_key :: (using self: *Animation, track_idx: int, time: float, scale: Vector3) -> int {
}
Animation_blend_shape_track_insert_key :: (using self: *Animation, track_idx: int, time: float, amount: float) -> int {
}
Animation_position_track_interpolate :: (using self: *Animation, track_idx: int, time_sec: float, backward: bool) -> Vector3 {
}
Animation_rotation_track_interpolate :: (using self: *Animation, track_idx: int, time_sec: float, backward: bool) -> Quaternion {
}
Animation_scale_track_interpolate :: (using self: *Animation, track_idx: int, time_sec: float, backward: bool) -> Vector3 {
}
Animation_blend_shape_track_interpolate :: (using self: *Animation, track_idx: int, time_sec: float, backward: bool) -> float {
}
Animation_track_insert_key :: (using self: *Animation, track_idx: int, time: float, key: Variant, transition: float) -> int {
}
Animation_track_remove_key :: (using self: *Animation, track_idx: int, key_idx: int) {
}
Animation_track_remove_key_at_time :: (using self: *Animation, track_idx: int, time: float) {
}
Animation_track_set_key_value :: (using self: *Animation, track_idx: int, key: int, value: Variant) {
}
Animation_track_set_key_transition :: (using self: *Animation, track_idx: int, key_idx: int, transition: float) {
}
Animation_track_set_key_time :: (using self: *Animation, track_idx: int, key_idx: int, time: float) {
}
Animation_track_get_key_transition :: (using self: *Animation, track_idx: int, key_idx: int) -> float {
}
Animation_track_get_key_count :: (using self: *Animation, track_idx: int) -> int {
}
Animation_track_get_key_value :: (using self: *Animation, track_idx: int, key_idx: int) -> Variant {
}
Animation_track_get_key_time :: (using self: *Animation, track_idx: int, key_idx: int) -> float {
}
Animation_track_find_key :: (using self: *Animation, track_idx: int, time: float, find_mode: Animation.FindMode, limit: bool, backward: bool) -> int {
}
Animation_track_set_interpolation_type :: (using self: *Animation, track_idx: int, interpolation: Animation.InterpolationType) {
}
Animation_track_get_interpolation_type :: (using self: *Animation, track_idx: int) -> Animation.InterpolationType {
}
Animation_track_set_interpolation_loop_wrap :: (using self: *Animation, track_idx: int, interpolation: bool) {
}
Animation_track_get_interpolation_loop_wrap :: (using self: *Animation, track_idx: int) -> bool {
}
Animation_track_is_compressed :: (using self: *Animation, track_idx: int) -> bool {
}
Animation_value_track_set_update_mode :: (using self: *Animation, track_idx: int, mode: Animation.UpdateMode) {
}
Animation_value_track_get_update_mode :: (using self: *Animation, track_idx: int) -> Animation.UpdateMode {
}
Animation_value_track_interpolate :: (using self: *Animation, track_idx: int, time_sec: float, backward: bool) -> Variant {
}
Animation_method_track_get_name :: (using self: *Animation, track_idx: int, key_idx: int) -> StringName {
}
Animation_method_track_get_params :: (using self: *Animation, track_idx: int, key_idx: int) -> Array {
}
Animation_bezier_track_insert_key :: (using self: *Animation, track_idx: int, time: float, value: float, in_handle: Vector2, out_handle: Vector2) -> int {
}
Animation_bezier_track_set_key_value :: (using self: *Animation, track_idx: int, key_idx: int, value: float) {
}
Animation_bezier_track_set_key_in_handle :: (using self: *Animation, track_idx: int, key_idx: int, in_handle: Vector2, balanced_value_time_ratio: float) {
}
Animation_bezier_track_set_key_out_handle :: (using self: *Animation, track_idx: int, key_idx: int, out_handle: Vector2, balanced_value_time_ratio: float) {
}
Animation_bezier_track_get_key_value :: (using self: *Animation, track_idx: int, key_idx: int) -> float {
}
Animation_bezier_track_get_key_in_handle :: (using self: *Animation, track_idx: int, key_idx: int) -> Vector2 {
}
Animation_bezier_track_get_key_out_handle :: (using self: *Animation, track_idx: int, key_idx: int) -> Vector2 {
}
Animation_bezier_track_interpolate :: (using self: *Animation, track_idx: int, time: float) -> float {
}
Animation_audio_track_insert_key :: (using self: *Animation, track_idx: int, time: float, stream: Resource, start_offset: float, end_offset: float) -> int {
}
Animation_audio_track_set_key_stream :: (using self: *Animation, track_idx: int, key_idx: int, stream: Resource) {
}
Animation_audio_track_set_key_start_offset :: (using self: *Animation, track_idx: int, key_idx: int, offset: float) {
}
Animation_audio_track_set_key_end_offset :: (using self: *Animation, track_idx: int, key_idx: int, offset: float) {
}
Animation_audio_track_get_key_stream :: (using self: *Animation, track_idx: int, key_idx: int) -> Resource {
}
Animation_audio_track_get_key_start_offset :: (using self: *Animation, track_idx: int, key_idx: int) -> float {
}
Animation_audio_track_get_key_end_offset :: (using self: *Animation, track_idx: int, key_idx: int) -> float {
}
Animation_audio_track_set_use_blend :: (using self: *Animation, track_idx: int, enable: bool) {
}
Animation_audio_track_is_use_blend :: (using self: *Animation, track_idx: int) -> bool {
}
Animation_animation_track_insert_key :: (using self: *Animation, track_idx: int, time: float, animation: StringName) -> int {
}
Animation_animation_track_set_key_animation :: (using self: *Animation, track_idx: int, key_idx: int, animation: StringName) {
}
Animation_animation_track_get_key_animation :: (using self: *Animation, track_idx: int, key_idx: int) -> StringName {
}
Animation_set_length :: (using self: *Animation, time_sec: float) {
}
Animation_get_length :: (using self: *Animation) -> float {
}
Animation_set_loop_mode :: (using self: *Animation, loop_mode: Animation.LoopMode) {
}
Animation_get_loop_mode :: (using self: *Animation) -> Animation.LoopMode {
}
Animation_set_step :: (using self: *Animation, size_sec: float) {
}
Animation_get_step :: (using self: *Animation) -> float {
}
Animation_clear :: (using self: *Animation) {
}
Animation_copy_track :: (using self: *Animation, track_idx: int, to_animation: Animation) {
}
Animation_compress :: (using self: *Animation, page_size: int, fps: int, split_tolerance: float) {
}
Animation_is_capture_included :: (using self: *Animation) -> bool {
}

// AnimationLibrary
AnimationLibrary :: struct {
	__private: *void;
}

AnimationLibrary_add_animation :: (using self: *AnimationLibrary, name: StringName, animation: Animation) -> Error {
}
AnimationLibrary_remove_animation :: (using self: *AnimationLibrary, name: StringName) {
}
AnimationLibrary_rename_animation :: (using self: *AnimationLibrary, name: StringName, newname: StringName) {
}
AnimationLibrary_has_animation :: (using self: *AnimationLibrary, name: StringName) -> bool {
}
AnimationLibrary_get_animation :: (using self: *AnimationLibrary, name: StringName) -> Animation {
}
AnimationLibrary_get_animation_list :: (using self: *AnimationLibrary) -> Array {
}

// AnimationMixer
AnimationMixer :: struct {
	__private: *void;

	AnimationCallbackModeProcess :: enum {
		ANIMATION_CALLBACK_MODE_PROCESS_PHYSICS :: 0;
		ANIMATION_CALLBACK_MODE_PROCESS_IDLE :: 1;
		ANIMATION_CALLBACK_MODE_PROCESS_MANUAL :: 2;
	}
	AnimationCallbackModeMethod :: enum {
		ANIMATION_CALLBACK_MODE_METHOD_DEFERRED :: 0;
		ANIMATION_CALLBACK_MODE_METHOD_IMMEDIATE :: 1;
	}
	AnimationCallbackModeDiscrete :: enum {
		ANIMATION_CALLBACK_MODE_DISCRETE_DOMINANT :: 0;
		ANIMATION_CALLBACK_MODE_DISCRETE_RECESSIVE :: 1;
		ANIMATION_CALLBACK_MODE_DISCRETE_FORCE_CONTINUOUS :: 2;
	}
}

AnimationMixer__post_process_key_value :: (using self: *AnimationMixer, animation: Animation, track: int, value: Variant, object_id: int, object_sub_idx: int) -> Variant {
}
AnimationMixer_add_animation_library :: (using self: *AnimationMixer, name: StringName, library: AnimationLibrary) -> Error {
}
AnimationMixer_remove_animation_library :: (using self: *AnimationMixer, name: StringName) {
}
AnimationMixer_rename_animation_library :: (using self: *AnimationMixer, name: StringName, newname: StringName) {
}
AnimationMixer_has_animation_library :: (using self: *AnimationMixer, name: StringName) -> bool {
}
AnimationMixer_get_animation_library :: (using self: *AnimationMixer, name: StringName) -> AnimationLibrary {
}
AnimationMixer_get_animation_library_list :: (using self: *AnimationMixer) -> Array {
}
AnimationMixer_has_animation :: (using self: *AnimationMixer, name: StringName) -> bool {
}
AnimationMixer_get_animation :: (using self: *AnimationMixer, name: StringName) -> Animation {
}
AnimationMixer_get_animation_list :: (using self: *AnimationMixer) -> PackedStringArray {
}
AnimationMixer_set_active :: (using self: *AnimationMixer, active: bool) {
}
AnimationMixer_is_active :: (using self: *AnimationMixer) -> bool {
}
AnimationMixer_set_deterministic :: (using self: *AnimationMixer, deterministic: bool) {
}
AnimationMixer_is_deterministic :: (using self: *AnimationMixer) -> bool {
}
AnimationMixer_set_root_node :: (using self: *AnimationMixer, path: NodePath) {
}
AnimationMixer_get_root_node :: (using self: *AnimationMixer) -> NodePath {
}
AnimationMixer_set_callback_mode_process :: (using self: *AnimationMixer, mode: AnimationMixer.AnimationCallbackModeProcess) {
}
AnimationMixer_get_callback_mode_process :: (using self: *AnimationMixer) -> AnimationMixer.AnimationCallbackModeProcess {
}
AnimationMixer_set_callback_mode_method :: (using self: *AnimationMixer, mode: AnimationMixer.AnimationCallbackModeMethod) {
}
AnimationMixer_get_callback_mode_method :: (using self: *AnimationMixer) -> AnimationMixer.AnimationCallbackModeMethod {
}
AnimationMixer_set_callback_mode_discrete :: (using self: *AnimationMixer, mode: AnimationMixer.AnimationCallbackModeDiscrete) {
}
AnimationMixer_get_callback_mode_discrete :: (using self: *AnimationMixer) -> AnimationMixer.AnimationCallbackModeDiscrete {
}
AnimationMixer_set_audio_max_polyphony :: (using self: *AnimationMixer, max_polyphony: int) {
}
AnimationMixer_get_audio_max_polyphony :: (using self: *AnimationMixer) -> int {
}
AnimationMixer_set_root_motion_track :: (using self: *AnimationMixer, path: NodePath) {
}
AnimationMixer_get_root_motion_track :: (using self: *AnimationMixer) -> NodePath {
}
AnimationMixer_get_root_motion_position :: (using self: *AnimationMixer) -> Vector3 {
}
AnimationMixer_get_root_motion_rotation :: (using self: *AnimationMixer) -> Quaternion {
}
AnimationMixer_get_root_motion_scale :: (using self: *AnimationMixer) -> Vector3 {
}
AnimationMixer_get_root_motion_position_accumulator :: (using self: *AnimationMixer) -> Vector3 {
}
AnimationMixer_get_root_motion_rotation_accumulator :: (using self: *AnimationMixer) -> Quaternion {
}
AnimationMixer_get_root_motion_scale_accumulator :: (using self: *AnimationMixer) -> Vector3 {
}
AnimationMixer_clear_caches :: (using self: *AnimationMixer) {
}
AnimationMixer_advance :: (using self: *AnimationMixer, delta: float) {
}
AnimationMixer_capture :: (using self: *AnimationMixer, name: StringName, duration: float, trans_type: Tween.TransitionType, ease_type: Tween.EaseType) {
}
AnimationMixer_set_reset_on_save_enabled :: (using self: *AnimationMixer, enabled: bool) {
}
AnimationMixer_is_reset_on_save_enabled :: (using self: *AnimationMixer) -> bool {
}
AnimationMixer_find_animation :: (using self: *AnimationMixer, animation: Animation) -> StringName {
}
AnimationMixer_find_animation_library :: (using self: *AnimationMixer, animation: Animation) -> StringName {
}

// AnimationNode
AnimationNode :: struct {
	__private: *void;

	FilterAction :: enum {
		FILTER_IGNORE :: 0;
		FILTER_PASS :: 1;
		FILTER_STOP :: 2;
		FILTER_BLEND :: 3;
	}
}

AnimationNode__get_child_nodes :: (using self: *AnimationNode) -> Dictionary {
}
AnimationNode__get_parameter_list :: (using self: *AnimationNode) -> Array {
}
AnimationNode__get_child_by_name :: (using self: *AnimationNode, name: StringName) -> AnimationNode {
}
AnimationNode__get_parameter_default_value :: (using self: *AnimationNode, parameter: StringName) -> Variant {
}
AnimationNode__is_parameter_read_only :: (using self: *AnimationNode, parameter: StringName) -> bool {
}
AnimationNode__process :: (using self: *AnimationNode, time: float, seek: bool, is_external_seeking: bool, test_only: bool) -> float {
}
AnimationNode__get_caption :: (using self: *AnimationNode) -> String {
}
AnimationNode__has_filter :: (using self: *AnimationNode) -> bool {
}
AnimationNode_add_input :: (using self: *AnimationNode, name: String) -> bool {
}
AnimationNode_remove_input :: (using self: *AnimationNode, index: int) {
}
AnimationNode_set_input_name :: (using self: *AnimationNode, input: int, name: String) -> bool {
}
AnimationNode_get_input_name :: (using self: *AnimationNode, input: int) -> String {
}
AnimationNode_get_input_count :: (using self: *AnimationNode) -> int {
}
AnimationNode_find_input :: (using self: *AnimationNode, name: String) -> int {
}
AnimationNode_set_filter_path :: (using self: *AnimationNode, path: NodePath, enable: bool) {
}
AnimationNode_is_path_filtered :: (using self: *AnimationNode, path: NodePath) -> bool {
}
AnimationNode_set_filter_enabled :: (using self: *AnimationNode, enable: bool) {
}
AnimationNode_is_filter_enabled :: (using self: *AnimationNode) -> bool {
}
AnimationNode_blend_animation :: (using self: *AnimationNode, animation: StringName, time: float, delta: float, seeked: bool, is_external_seeking: bool, blend: float, looped_flag: Animation.LoopedFlag) {
}
AnimationNode_blend_node :: (using self: *AnimationNode, name: StringName, node: AnimationNode, time: float, seek: bool, is_external_seeking: bool, blend: float, filter: AnimationNode.FilterAction, sync: bool, test_only: bool) -> float {
}
AnimationNode_blend_input :: (using self: *AnimationNode, input_index: int, time: float, seek: bool, is_external_seeking: bool, blend: float, filter: AnimationNode.FilterAction, sync: bool, test_only: bool) -> float {
}
AnimationNode_set_parameter :: (using self: *AnimationNode, name: StringName, value: Variant) {
}
AnimationNode_get_parameter :: (using self: *AnimationNode, name: StringName) -> Variant {
}

// AnimationNodeAdd2
AnimationNodeAdd2 :: struct {
	__private: *void;
}

// AnimationNodeAdd3
AnimationNodeAdd3 :: struct {
	__private: *void;
}

// AnimationNodeAnimation
AnimationNodeAnimation :: struct {
	__private: *void;

	PlayMode :: enum {
		PLAY_MODE_FORWARD :: 0;
		PLAY_MODE_BACKWARD :: 1;
	}
}

AnimationNodeAnimation_set_animation :: (using self: *AnimationNodeAnimation, name: StringName) {
}
AnimationNodeAnimation_get_animation :: (using self: *AnimationNodeAnimation) -> StringName {
}
AnimationNodeAnimation_set_play_mode :: (using self: *AnimationNodeAnimation, mode: AnimationNodeAnimation.PlayMode) {
}
AnimationNodeAnimation_get_play_mode :: (using self: *AnimationNodeAnimation) -> AnimationNodeAnimation.PlayMode {
}
AnimationNodeAnimation_set_use_custom_timeline :: (using self: *AnimationNodeAnimation, use_custom_timeline: bool) {
}
AnimationNodeAnimation_is_using_custom_timeline :: (using self: *AnimationNodeAnimation) -> bool {
}
AnimationNodeAnimation_set_timeline_length :: (using self: *AnimationNodeAnimation, timeline_length: float) {
}
AnimationNodeAnimation_get_timeline_length :: (using self: *AnimationNodeAnimation) -> float {
}
AnimationNodeAnimation_set_stretch_time_scale :: (using self: *AnimationNodeAnimation, stretch_time_scale: bool) {
}
AnimationNodeAnimation_is_stretching_time_scale :: (using self: *AnimationNodeAnimation) -> bool {
}
AnimationNodeAnimation_set_start_offset :: (using self: *AnimationNodeAnimation, start_offset: float) {
}
AnimationNodeAnimation_get_start_offset :: (using self: *AnimationNodeAnimation) -> float {
}
AnimationNodeAnimation_set_loop_mode :: (using self: *AnimationNodeAnimation, loop_mode: Animation.LoopMode) {
}
AnimationNodeAnimation_get_loop_mode :: (using self: *AnimationNodeAnimation) -> Animation.LoopMode {
}

// AnimationNodeBlend2
AnimationNodeBlend2 :: struct {
	__private: *void;
}

// AnimationNodeBlend3
AnimationNodeBlend3 :: struct {
	__private: *void;
}

// AnimationNodeBlendSpace1D
AnimationNodeBlendSpace1D :: struct {
	__private: *void;

	BlendMode :: enum {
		BLEND_MODE_INTERPOLATED :: 0;
		BLEND_MODE_DISCRETE :: 1;
		BLEND_MODE_DISCRETE_CARRY :: 2;
	}
}

AnimationNodeBlendSpace1D_add_blend_point :: (using self: *AnimationNodeBlendSpace1D, node: AnimationRootNode, pos: float, at_index: int) {
}
AnimationNodeBlendSpace1D_set_blend_point_position :: (using self: *AnimationNodeBlendSpace1D, point: int, pos: float) {
}
AnimationNodeBlendSpace1D_get_blend_point_position :: (using self: *AnimationNodeBlendSpace1D, point: int) -> float {
}
AnimationNodeBlendSpace1D_set_blend_point_node :: (using self: *AnimationNodeBlendSpace1D, point: int, node: AnimationRootNode) {
}
AnimationNodeBlendSpace1D_get_blend_point_node :: (using self: *AnimationNodeBlendSpace1D, point: int) -> AnimationRootNode {
}
AnimationNodeBlendSpace1D_remove_blend_point :: (using self: *AnimationNodeBlendSpace1D, point: int) {
}
AnimationNodeBlendSpace1D_get_blend_point_count :: (using self: *AnimationNodeBlendSpace1D) -> int {
}
AnimationNodeBlendSpace1D_set_min_space :: (using self: *AnimationNodeBlendSpace1D, min_space: float) {
}
AnimationNodeBlendSpace1D_get_min_space :: (using self: *AnimationNodeBlendSpace1D) -> float {
}
AnimationNodeBlendSpace1D_set_max_space :: (using self: *AnimationNodeBlendSpace1D, max_space: float) {
}
AnimationNodeBlendSpace1D_get_max_space :: (using self: *AnimationNodeBlendSpace1D) -> float {
}
AnimationNodeBlendSpace1D_set_snap :: (using self: *AnimationNodeBlendSpace1D, snap: float) {
}
AnimationNodeBlendSpace1D_get_snap :: (using self: *AnimationNodeBlendSpace1D) -> float {
}
AnimationNodeBlendSpace1D_set_value_label :: (using self: *AnimationNodeBlendSpace1D, text: String) {
}
AnimationNodeBlendSpace1D_get_value_label :: (using self: *AnimationNodeBlendSpace1D) -> String {
}
AnimationNodeBlendSpace1D_set_blend_mode :: (using self: *AnimationNodeBlendSpace1D, mode: AnimationNodeBlendSpace1D.BlendMode) {
}
AnimationNodeBlendSpace1D_get_blend_mode :: (using self: *AnimationNodeBlendSpace1D) -> AnimationNodeBlendSpace1D.BlendMode {
}
AnimationNodeBlendSpace1D_set_use_sync :: (using self: *AnimationNodeBlendSpace1D, enable: bool) {
}
AnimationNodeBlendSpace1D_is_using_sync :: (using self: *AnimationNodeBlendSpace1D) -> bool {
}

// AnimationNodeBlendSpace2D
AnimationNodeBlendSpace2D :: struct {
	__private: *void;

	BlendMode :: enum {
		BLEND_MODE_INTERPOLATED :: 0;
		BLEND_MODE_DISCRETE :: 1;
		BLEND_MODE_DISCRETE_CARRY :: 2;
	}
}

AnimationNodeBlendSpace2D_add_blend_point :: (using self: *AnimationNodeBlendSpace2D, node: AnimationRootNode, pos: Vector2, at_index: int) {
}
AnimationNodeBlendSpace2D_set_blend_point_position :: (using self: *AnimationNodeBlendSpace2D, point: int, pos: Vector2) {
}
AnimationNodeBlendSpace2D_get_blend_point_position :: (using self: *AnimationNodeBlendSpace2D, point: int) -> Vector2 {
}
AnimationNodeBlendSpace2D_set_blend_point_node :: (using self: *AnimationNodeBlendSpace2D, point: int, node: AnimationRootNode) {
}
AnimationNodeBlendSpace2D_get_blend_point_node :: (using self: *AnimationNodeBlendSpace2D, point: int) -> AnimationRootNode {
}
AnimationNodeBlendSpace2D_remove_blend_point :: (using self: *AnimationNodeBlendSpace2D, point: int) {
}
AnimationNodeBlendSpace2D_get_blend_point_count :: (using self: *AnimationNodeBlendSpace2D) -> int {
}
AnimationNodeBlendSpace2D_add_triangle :: (using self: *AnimationNodeBlendSpace2D, x: int, y: int, z: int, at_index: int) {
}
AnimationNodeBlendSpace2D_get_triangle_point :: (using self: *AnimationNodeBlendSpace2D, triangle: int, point: int) -> int {
}
AnimationNodeBlendSpace2D_remove_triangle :: (using self: *AnimationNodeBlendSpace2D, triangle: int) {
}
AnimationNodeBlendSpace2D_get_triangle_count :: (using self: *AnimationNodeBlendSpace2D) -> int {
}
AnimationNodeBlendSpace2D_set_min_space :: (using self: *AnimationNodeBlendSpace2D, min_space: Vector2) {
}
AnimationNodeBlendSpace2D_get_min_space :: (using self: *AnimationNodeBlendSpace2D) -> Vector2 {
}
AnimationNodeBlendSpace2D_set_max_space :: (using self: *AnimationNodeBlendSpace2D, max_space: Vector2) {
}
AnimationNodeBlendSpace2D_get_max_space :: (using self: *AnimationNodeBlendSpace2D) -> Vector2 {
}
AnimationNodeBlendSpace2D_set_snap :: (using self: *AnimationNodeBlendSpace2D, snap: Vector2) {
}
AnimationNodeBlendSpace2D_get_snap :: (using self: *AnimationNodeBlendSpace2D) -> Vector2 {
}
AnimationNodeBlendSpace2D_set_x_label :: (using self: *AnimationNodeBlendSpace2D, text: String) {
}
AnimationNodeBlendSpace2D_get_x_label :: (using self: *AnimationNodeBlendSpace2D) -> String {
}
AnimationNodeBlendSpace2D_set_y_label :: (using self: *AnimationNodeBlendSpace2D, text: String) {
}
AnimationNodeBlendSpace2D_get_y_label :: (using self: *AnimationNodeBlendSpace2D) -> String {
}
AnimationNodeBlendSpace2D_set_auto_triangles :: (using self: *AnimationNodeBlendSpace2D, enable: bool) {
}
AnimationNodeBlendSpace2D_get_auto_triangles :: (using self: *AnimationNodeBlendSpace2D) -> bool {
}
AnimationNodeBlendSpace2D_set_blend_mode :: (using self: *AnimationNodeBlendSpace2D, mode: AnimationNodeBlendSpace2D.BlendMode) {
}
AnimationNodeBlendSpace2D_get_blend_mode :: (using self: *AnimationNodeBlendSpace2D) -> AnimationNodeBlendSpace2D.BlendMode {
}
AnimationNodeBlendSpace2D_set_use_sync :: (using self: *AnimationNodeBlendSpace2D, enable: bool) {
}
AnimationNodeBlendSpace2D_is_using_sync :: (using self: *AnimationNodeBlendSpace2D) -> bool {
}

// AnimationNodeBlendTree
AnimationNodeBlendTree :: struct {
	__private: *void;

	CONNECTION_OK :: 0;
	CONNECTION_ERROR_NO_INPUT :: 1;
	CONNECTION_ERROR_NO_INPUT_INDEX :: 2;
	CONNECTION_ERROR_NO_OUTPUT :: 3;
	CONNECTION_ERROR_SAME_NODE :: 4;
	CONNECTION_ERROR_CONNECTION_EXISTS :: 5;
}

AnimationNodeBlendTree_add_node :: (using self: *AnimationNodeBlendTree, name: StringName, node: AnimationNode, position: Vector2) {
}
AnimationNodeBlendTree_get_node :: (using self: *AnimationNodeBlendTree, name: StringName) -> AnimationNode {
}
AnimationNodeBlendTree_remove_node :: (using self: *AnimationNodeBlendTree, name: StringName) {
}
AnimationNodeBlendTree_rename_node :: (using self: *AnimationNodeBlendTree, name: StringName, new_name: StringName) {
}
AnimationNodeBlendTree_has_node :: (using self: *AnimationNodeBlendTree, name: StringName) -> bool {
}
AnimationNodeBlendTree_connect_node :: (using self: *AnimationNodeBlendTree, input_node: StringName, input_index: int, output_node: StringName) {
}
AnimationNodeBlendTree_disconnect_node :: (using self: *AnimationNodeBlendTree, input_node: StringName, input_index: int) {
}
AnimationNodeBlendTree_set_node_position :: (using self: *AnimationNodeBlendTree, name: StringName, position: Vector2) {
}
AnimationNodeBlendTree_get_node_position :: (using self: *AnimationNodeBlendTree, name: StringName) -> Vector2 {
}
AnimationNodeBlendTree_set_graph_offset :: (using self: *AnimationNodeBlendTree, offset: Vector2) {
}
AnimationNodeBlendTree_get_graph_offset :: (using self: *AnimationNodeBlendTree) -> Vector2 {
}

// AnimationNodeOneShot
AnimationNodeOneShot :: struct {
	__private: *void;

	OneShotRequest :: enum {
		ONE_SHOT_REQUEST_NONE :: 0;
		ONE_SHOT_REQUEST_FIRE :: 1;
		ONE_SHOT_REQUEST_ABORT :: 2;
		ONE_SHOT_REQUEST_FADE_OUT :: 3;
	}
	MixMode :: enum {
		MIX_MODE_BLEND :: 0;
		MIX_MODE_ADD :: 1;
	}
}

AnimationNodeOneShot_set_fadein_time :: (using self: *AnimationNodeOneShot, time: float) {
}
AnimationNodeOneShot_get_fadein_time :: (using self: *AnimationNodeOneShot) -> float {
}
AnimationNodeOneShot_set_fadein_curve :: (using self: *AnimationNodeOneShot, curve: Curve) {
}
AnimationNodeOneShot_get_fadein_curve :: (using self: *AnimationNodeOneShot) -> Curve {
}
AnimationNodeOneShot_set_fadeout_time :: (using self: *AnimationNodeOneShot, time: float) {
}
AnimationNodeOneShot_get_fadeout_time :: (using self: *AnimationNodeOneShot) -> float {
}
AnimationNodeOneShot_set_fadeout_curve :: (using self: *AnimationNodeOneShot, curve: Curve) {
}
AnimationNodeOneShot_get_fadeout_curve :: (using self: *AnimationNodeOneShot) -> Curve {
}
AnimationNodeOneShot_set_break_loop_at_end :: (using self: *AnimationNodeOneShot, enable: bool) {
}
AnimationNodeOneShot_is_loop_broken_at_end :: (using self: *AnimationNodeOneShot) -> bool {
}
AnimationNodeOneShot_set_autorestart :: (using self: *AnimationNodeOneShot, active: bool) {
}
AnimationNodeOneShot_has_autorestart :: (using self: *AnimationNodeOneShot) -> bool {
}
AnimationNodeOneShot_set_autorestart_delay :: (using self: *AnimationNodeOneShot, time: float) {
}
AnimationNodeOneShot_get_autorestart_delay :: (using self: *AnimationNodeOneShot) -> float {
}
AnimationNodeOneShot_set_autorestart_random_delay :: (using self: *AnimationNodeOneShot, time: float) {
}
AnimationNodeOneShot_get_autorestart_random_delay :: (using self: *AnimationNodeOneShot) -> float {
}
AnimationNodeOneShot_set_mix_mode :: (using self: *AnimationNodeOneShot, mode: AnimationNodeOneShot.MixMode) {
}
AnimationNodeOneShot_get_mix_mode :: (using self: *AnimationNodeOneShot) -> AnimationNodeOneShot.MixMode {
}

// AnimationNodeOutput
AnimationNodeOutput :: struct {
	__private: *void;
}

// AnimationNodeStateMachine
AnimationNodeStateMachine :: struct {
	__private: *void;

	StateMachineType :: enum {
		STATE_MACHINE_TYPE_ROOT :: 0;
		STATE_MACHINE_TYPE_NESTED :: 1;
		STATE_MACHINE_TYPE_GROUPED :: 2;
	}
}

AnimationNodeStateMachine_add_node :: (using self: *AnimationNodeStateMachine, name: StringName, node: AnimationNode, position: Vector2) {
}
AnimationNodeStateMachine_replace_node :: (using self: *AnimationNodeStateMachine, name: StringName, node: AnimationNode) {
}
AnimationNodeStateMachine_get_node :: (using self: *AnimationNodeStateMachine, name: StringName) -> AnimationNode {
}
AnimationNodeStateMachine_remove_node :: (using self: *AnimationNodeStateMachine, name: StringName) {
}
AnimationNodeStateMachine_rename_node :: (using self: *AnimationNodeStateMachine, name: StringName, new_name: StringName) {
}
AnimationNodeStateMachine_has_node :: (using self: *AnimationNodeStateMachine, name: StringName) -> bool {
}
AnimationNodeStateMachine_get_node_name :: (using self: *AnimationNodeStateMachine, node: AnimationNode) -> StringName {
}
AnimationNodeStateMachine_set_node_position :: (using self: *AnimationNodeStateMachine, name: StringName, position: Vector2) {
}
AnimationNodeStateMachine_get_node_position :: (using self: *AnimationNodeStateMachine, name: StringName) -> Vector2 {
}
AnimationNodeStateMachine_has_transition :: (using self: *AnimationNodeStateMachine, from: StringName, to: StringName) -> bool {
}
AnimationNodeStateMachine_add_transition :: (using self: *AnimationNodeStateMachine, from: StringName, to: StringName, transition: AnimationNodeStateMachineTransition) {
}
AnimationNodeStateMachine_get_transition :: (using self: *AnimationNodeStateMachine, idx: int) -> AnimationNodeStateMachineTransition {
}
AnimationNodeStateMachine_get_transition_from :: (using self: *AnimationNodeStateMachine, idx: int) -> StringName {
}
AnimationNodeStateMachine_get_transition_to :: (using self: *AnimationNodeStateMachine, idx: int) -> StringName {
}
AnimationNodeStateMachine_get_transition_count :: (using self: *AnimationNodeStateMachine) -> int {
}
AnimationNodeStateMachine_remove_transition_by_index :: (using self: *AnimationNodeStateMachine, idx: int) {
}
AnimationNodeStateMachine_remove_transition :: (using self: *AnimationNodeStateMachine, from: StringName, to: StringName) {
}
AnimationNodeStateMachine_set_graph_offset :: (using self: *AnimationNodeStateMachine, offset: Vector2) {
}
AnimationNodeStateMachine_get_graph_offset :: (using self: *AnimationNodeStateMachine) -> Vector2 {
}
AnimationNodeStateMachine_set_state_machine_type :: (using self: *AnimationNodeStateMachine, state_machine_type: AnimationNodeStateMachine.StateMachineType) {
}
AnimationNodeStateMachine_get_state_machine_type :: (using self: *AnimationNodeStateMachine) -> AnimationNodeStateMachine.StateMachineType {
}
AnimationNodeStateMachine_set_allow_transition_to_self :: (using self: *AnimationNodeStateMachine, enable: bool) {
}
AnimationNodeStateMachine_is_allow_transition_to_self :: (using self: *AnimationNodeStateMachine) -> bool {
}
AnimationNodeStateMachine_set_reset_ends :: (using self: *AnimationNodeStateMachine, enable: bool) {
}
AnimationNodeStateMachine_are_ends_reset :: (using self: *AnimationNodeStateMachine) -> bool {
}

// AnimationNodeStateMachinePlayback
AnimationNodeStateMachinePlayback :: struct {
	__private: *void;
}

AnimationNodeStateMachinePlayback_travel :: (using self: *AnimationNodeStateMachinePlayback, to_node: StringName, reset_on_teleport: bool) {
}
AnimationNodeStateMachinePlayback_start :: (using self: *AnimationNodeStateMachinePlayback, node: StringName, reset: bool) {
}
AnimationNodeStateMachinePlayback_next :: (using self: *AnimationNodeStateMachinePlayback) {
}
AnimationNodeStateMachinePlayback_stop :: (using self: *AnimationNodeStateMachinePlayback) {
}
AnimationNodeStateMachinePlayback_is_playing :: (using self: *AnimationNodeStateMachinePlayback) -> bool {
}
AnimationNodeStateMachinePlayback_get_current_node :: (using self: *AnimationNodeStateMachinePlayback) -> StringName {
}
AnimationNodeStateMachinePlayback_get_current_play_position :: (using self: *AnimationNodeStateMachinePlayback) -> float {
}
AnimationNodeStateMachinePlayback_get_current_length :: (using self: *AnimationNodeStateMachinePlayback) -> float {
}
AnimationNodeStateMachinePlayback_get_fading_from_node :: (using self: *AnimationNodeStateMachinePlayback) -> StringName {
}
AnimationNodeStateMachinePlayback_get_travel_path :: (using self: *AnimationNodeStateMachinePlayback) -> Array {
}

// AnimationNodeStateMachineTransition
AnimationNodeStateMachineTransition :: struct {
	__private: *void;

	SwitchMode :: enum {
		SWITCH_MODE_IMMEDIATE :: 0;
		SWITCH_MODE_SYNC :: 1;
		SWITCH_MODE_AT_END :: 2;
	}
	AdvanceMode :: enum {
		ADVANCE_MODE_DISABLED :: 0;
		ADVANCE_MODE_ENABLED :: 1;
		ADVANCE_MODE_AUTO :: 2;
	}
}

AnimationNodeStateMachineTransition_set_switch_mode :: (using self: *AnimationNodeStateMachineTransition, mode: AnimationNodeStateMachineTransition.SwitchMode) {
}
AnimationNodeStateMachineTransition_get_switch_mode :: (using self: *AnimationNodeStateMachineTransition) -> AnimationNodeStateMachineTransition.SwitchMode {
}
AnimationNodeStateMachineTransition_set_advance_mode :: (using self: *AnimationNodeStateMachineTransition, mode: AnimationNodeStateMachineTransition.AdvanceMode) {
}
AnimationNodeStateMachineTransition_get_advance_mode :: (using self: *AnimationNodeStateMachineTransition) -> AnimationNodeStateMachineTransition.AdvanceMode {
}
AnimationNodeStateMachineTransition_set_advance_condition :: (using self: *AnimationNodeStateMachineTransition, name: StringName) {
}
AnimationNodeStateMachineTransition_get_advance_condition :: (using self: *AnimationNodeStateMachineTransition) -> StringName {
}
AnimationNodeStateMachineTransition_set_xfade_time :: (using self: *AnimationNodeStateMachineTransition, secs: float) {
}
AnimationNodeStateMachineTransition_get_xfade_time :: (using self: *AnimationNodeStateMachineTransition) -> float {
}
AnimationNodeStateMachineTransition_set_xfade_curve :: (using self: *AnimationNodeStateMachineTransition, curve: Curve) {
}
AnimationNodeStateMachineTransition_get_xfade_curve :: (using self: *AnimationNodeStateMachineTransition) -> Curve {
}
AnimationNodeStateMachineTransition_set_break_loop_at_end :: (using self: *AnimationNodeStateMachineTransition, enable: bool) {
}
AnimationNodeStateMachineTransition_is_loop_broken_at_end :: (using self: *AnimationNodeStateMachineTransition) -> bool {
}
AnimationNodeStateMachineTransition_set_reset :: (using self: *AnimationNodeStateMachineTransition, reset: bool) {
}
AnimationNodeStateMachineTransition_is_reset :: (using self: *AnimationNodeStateMachineTransition) -> bool {
}
AnimationNodeStateMachineTransition_set_priority :: (using self: *AnimationNodeStateMachineTransition, priority: int) {
}
AnimationNodeStateMachineTransition_get_priority :: (using self: *AnimationNodeStateMachineTransition) -> int {
}
AnimationNodeStateMachineTransition_set_advance_expression :: (using self: *AnimationNodeStateMachineTransition, text: String) {
}
AnimationNodeStateMachineTransition_get_advance_expression :: (using self: *AnimationNodeStateMachineTransition) -> String {
}

// AnimationNodeSub2
AnimationNodeSub2 :: struct {
	__private: *void;
}

// AnimationNodeSync
AnimationNodeSync :: struct {
	__private: *void;
}

AnimationNodeSync_set_use_sync :: (using self: *AnimationNodeSync, enable: bool) {
}
AnimationNodeSync_is_using_sync :: (using self: *AnimationNodeSync) -> bool {
}

// AnimationNodeTimeScale
AnimationNodeTimeScale :: struct {
	__private: *void;
}

// AnimationNodeTimeSeek
AnimationNodeTimeSeek :: struct {
	__private: *void;
}

// AnimationNodeTransition
AnimationNodeTransition :: struct {
	__private: *void;
}

AnimationNodeTransition_set_input_count :: (using self: *AnimationNodeTransition, input_count: int) {
}
AnimationNodeTransition_set_input_as_auto_advance :: (using self: *AnimationNodeTransition, input: int, enable: bool) {
}
AnimationNodeTransition_is_input_set_as_auto_advance :: (using self: *AnimationNodeTransition, input: int) -> bool {
}
AnimationNodeTransition_set_input_break_loop_at_end :: (using self: *AnimationNodeTransition, input: int, enable: bool) {
}
AnimationNodeTransition_is_input_loop_broken_at_end :: (using self: *AnimationNodeTransition, input: int) -> bool {
}
AnimationNodeTransition_set_input_reset :: (using self: *AnimationNodeTransition, input: int, enable: bool) {
}
AnimationNodeTransition_is_input_reset :: (using self: *AnimationNodeTransition, input: int) -> bool {
}
AnimationNodeTransition_set_xfade_time :: (using self: *AnimationNodeTransition, time: float) {
}
AnimationNodeTransition_get_xfade_time :: (using self: *AnimationNodeTransition) -> float {
}
AnimationNodeTransition_set_xfade_curve :: (using self: *AnimationNodeTransition, curve: Curve) {
}
AnimationNodeTransition_get_xfade_curve :: (using self: *AnimationNodeTransition) -> Curve {
}
AnimationNodeTransition_set_allow_transition_to_self :: (using self: *AnimationNodeTransition, enable: bool) {
}
AnimationNodeTransition_is_allow_transition_to_self :: (using self: *AnimationNodeTransition) -> bool {
}

// AnimationPlayer
AnimationPlayer :: struct {
	__private: *void;

	AnimationProcessCallback :: enum {
		ANIMATION_PROCESS_PHYSICS :: 0;
		ANIMATION_PROCESS_IDLE :: 1;
		ANIMATION_PROCESS_MANUAL :: 2;
	}
	AnimationMethodCallMode :: enum {
		ANIMATION_METHOD_CALL_DEFERRED :: 0;
		ANIMATION_METHOD_CALL_IMMEDIATE :: 1;
	}
}

AnimationPlayer_animation_set_next :: (using self: *AnimationPlayer, animation_from: StringName, animation_to: StringName) {
}
AnimationPlayer_animation_get_next :: (using self: *AnimationPlayer, animation_from: StringName) -> StringName {
}
AnimationPlayer_set_blend_time :: (using self: *AnimationPlayer, animation_from: StringName, animation_to: StringName, sec: float) {
}
AnimationPlayer_get_blend_time :: (using self: *AnimationPlayer, animation_from: StringName, animation_to: StringName) -> float {
}
AnimationPlayer_set_default_blend_time :: (using self: *AnimationPlayer, sec: float) {
}
AnimationPlayer_get_default_blend_time :: (using self: *AnimationPlayer) -> float {
}
AnimationPlayer_set_auto_capture :: (using self: *AnimationPlayer, auto_capture: bool) {
}
AnimationPlayer_is_auto_capture :: (using self: *AnimationPlayer) -> bool {
}
AnimationPlayer_set_auto_capture_duration :: (using self: *AnimationPlayer, auto_capture_duration: float) {
}
AnimationPlayer_get_auto_capture_duration :: (using self: *AnimationPlayer) -> float {
}
AnimationPlayer_set_auto_capture_transition_type :: (using self: *AnimationPlayer, auto_capture_transition_type: Tween.TransitionType) {
}
AnimationPlayer_get_auto_capture_transition_type :: (using self: *AnimationPlayer) -> Tween.TransitionType {
}
AnimationPlayer_set_auto_capture_ease_type :: (using self: *AnimationPlayer, auto_capture_ease_type: Tween.EaseType) {
}
AnimationPlayer_get_auto_capture_ease_type :: (using self: *AnimationPlayer) -> Tween.EaseType {
}
AnimationPlayer_play :: (using self: *AnimationPlayer, name: StringName, custom_blend: float, custom_speed: float, from_end: bool) {
}
AnimationPlayer_play_backwards :: (using self: *AnimationPlayer, name: StringName, custom_blend: float) {
}
AnimationPlayer_play_with_capture :: (using self: *AnimationPlayer, name: StringName, duration: float, custom_blend: float, custom_speed: float, from_end: bool, trans_type: Tween.TransitionType, ease_type: Tween.EaseType) {
}
AnimationPlayer_pause :: (using self: *AnimationPlayer) {
}
AnimationPlayer_stop :: (using self: *AnimationPlayer, keep_state: bool) {
}
AnimationPlayer_is_playing :: (using self: *AnimationPlayer) -> bool {
}
AnimationPlayer_set_current_animation :: (using self: *AnimationPlayer, animation: String) {
}
AnimationPlayer_get_current_animation :: (using self: *AnimationPlayer) -> String {
}
AnimationPlayer_set_assigned_animation :: (using self: *AnimationPlayer, animation: String) {
}
AnimationPlayer_get_assigned_animation :: (using self: *AnimationPlayer) -> String {
}
AnimationPlayer_queue :: (using self: *AnimationPlayer, name: StringName) {
}
AnimationPlayer_get_queue :: (using self: *AnimationPlayer) -> PackedStringArray {
}
AnimationPlayer_clear_queue :: (using self: *AnimationPlayer) {
}
AnimationPlayer_set_speed_scale :: (using self: *AnimationPlayer, speed: float) {
}
AnimationPlayer_get_speed_scale :: (using self: *AnimationPlayer) -> float {
}
AnimationPlayer_get_playing_speed :: (using self: *AnimationPlayer) -> float {
}
AnimationPlayer_set_autoplay :: (using self: *AnimationPlayer, name: String) {
}
AnimationPlayer_get_autoplay :: (using self: *AnimationPlayer) -> String {
}
AnimationPlayer_set_movie_quit_on_finish_enabled :: (using self: *AnimationPlayer, enabled: bool) {
}
AnimationPlayer_is_movie_quit_on_finish_enabled :: (using self: *AnimationPlayer) -> bool {
}
AnimationPlayer_get_current_animation_position :: (using self: *AnimationPlayer) -> float {
}
AnimationPlayer_get_current_animation_length :: (using self: *AnimationPlayer) -> float {
}
AnimationPlayer_seek :: (using self: *AnimationPlayer, seconds: float, update: bool, update_only: bool) {
}
AnimationPlayer_set_process_callback :: (using self: *AnimationPlayer, mode: AnimationPlayer.AnimationProcessCallback) {
}
AnimationPlayer_get_process_callback :: (using self: *AnimationPlayer) -> AnimationPlayer.AnimationProcessCallback {
}
AnimationPlayer_set_method_call_mode :: (using self: *AnimationPlayer, mode: AnimationPlayer.AnimationMethodCallMode) {
}
AnimationPlayer_get_method_call_mode :: (using self: *AnimationPlayer) -> AnimationPlayer.AnimationMethodCallMode {
}
AnimationPlayer_set_root :: (using self: *AnimationPlayer, path: NodePath) {
}
AnimationPlayer_get_root :: (using self: *AnimationPlayer) -> NodePath {
}

// AnimationRootNode
AnimationRootNode :: struct {
	__private: *void;
}

// AnimationTree
AnimationTree :: struct {
	__private: *void;

	AnimationProcessCallback :: enum {
		ANIMATION_PROCESS_PHYSICS :: 0;
		ANIMATION_PROCESS_IDLE :: 1;
		ANIMATION_PROCESS_MANUAL :: 2;
	}
}

AnimationTree_set_tree_root :: (using self: *AnimationTree, animation_node: AnimationRootNode) {
}
AnimationTree_get_tree_root :: (using self: *AnimationTree) -> AnimationRootNode {
}
AnimationTree_set_advance_expression_base_node :: (using self: *AnimationTree, path: NodePath) {
}
AnimationTree_get_advance_expression_base_node :: (using self: *AnimationTree) -> NodePath {
}
AnimationTree_set_animation_player :: (using self: *AnimationTree, path: NodePath) {
}
AnimationTree_get_animation_player :: (using self: *AnimationTree) -> NodePath {
}
AnimationTree_set_process_callback :: (using self: *AnimationTree, mode: AnimationTree.AnimationProcessCallback) {
}
AnimationTree_get_process_callback :: (using self: *AnimationTree) -> AnimationTree.AnimationProcessCallback {
}

// Area2D
Area2D :: struct {
	__private: *void;

	SpaceOverride :: enum {
		SPACE_OVERRIDE_DISABLED :: 0;
		SPACE_OVERRIDE_COMBINE :: 1;
		SPACE_OVERRIDE_COMBINE_REPLACE :: 2;
		SPACE_OVERRIDE_REPLACE :: 3;
		SPACE_OVERRIDE_REPLACE_COMBINE :: 4;
	}
}

Area2D_set_gravity_space_override_mode :: (using self: *Area2D, space_override_mode: Area2D.SpaceOverride) {
}
Area2D_get_gravity_space_override_mode :: (using self: *Area2D) -> Area2D.SpaceOverride {
}
Area2D_set_gravity_is_point :: (using self: *Area2D, enable: bool) {
}
Area2D_is_gravity_a_point :: (using self: *Area2D) -> bool {
}
Area2D_set_gravity_point_unit_distance :: (using self: *Area2D, distance_scale: float) {
}
Area2D_get_gravity_point_unit_distance :: (using self: *Area2D) -> float {
}
Area2D_set_gravity_point_center :: (using self: *Area2D, center: Vector2) {
}
Area2D_get_gravity_point_center :: (using self: *Area2D) -> Vector2 {
}
Area2D_set_gravity_direction :: (using self: *Area2D, direction: Vector2) {
}
Area2D_get_gravity_direction :: (using self: *Area2D) -> Vector2 {
}
Area2D_set_gravity :: (using self: *Area2D, gravity: float) {
}
Area2D_get_gravity :: (using self: *Area2D) -> float {
}
Area2D_set_linear_damp_space_override_mode :: (using self: *Area2D, space_override_mode: Area2D.SpaceOverride) {
}
Area2D_get_linear_damp_space_override_mode :: (using self: *Area2D) -> Area2D.SpaceOverride {
}
Area2D_set_angular_damp_space_override_mode :: (using self: *Area2D, space_override_mode: Area2D.SpaceOverride) {
}
Area2D_get_angular_damp_space_override_mode :: (using self: *Area2D) -> Area2D.SpaceOverride {
}
Area2D_set_linear_damp :: (using self: *Area2D, linear_damp: float) {
}
Area2D_get_linear_damp :: (using self: *Area2D) -> float {
}
Area2D_set_angular_damp :: (using self: *Area2D, angular_damp: float) {
}
Area2D_get_angular_damp :: (using self: *Area2D) -> float {
}
Area2D_set_priority :: (using self: *Area2D, priority: int) {
}
Area2D_get_priority :: (using self: *Area2D) -> int {
}
Area2D_set_monitoring :: (using self: *Area2D, enable: bool) {
}
Area2D_is_monitoring :: (using self: *Area2D) -> bool {
}
Area2D_set_monitorable :: (using self: *Area2D, enable: bool) {
}
Area2D_is_monitorable :: (using self: *Area2D) -> bool {
}
Area2D_get_overlapping_bodies :: (using self: *Area2D) -> Array {
}
Area2D_get_overlapping_areas :: (using self: *Area2D) -> Array {
}
Area2D_has_overlapping_bodies :: (using self: *Area2D) -> bool {
}
Area2D_has_overlapping_areas :: (using self: *Area2D) -> bool {
}
Area2D_overlaps_body :: (using self: *Area2D, body: Node) -> bool {
}
Area2D_overlaps_area :: (using self: *Area2D, area: Node) -> bool {
}
Area2D_set_audio_bus_name :: (using self: *Area2D, name: StringName) {
}
Area2D_get_audio_bus_name :: (using self: *Area2D) -> StringName {
}
Area2D_set_audio_bus_override :: (using self: *Area2D, enable: bool) {
}
Area2D_is_overriding_audio_bus :: (using self: *Area2D) -> bool {
}

// Area3D
Area3D :: struct {
	__private: *void;

	SpaceOverride :: enum {
		SPACE_OVERRIDE_DISABLED :: 0;
		SPACE_OVERRIDE_COMBINE :: 1;
		SPACE_OVERRIDE_COMBINE_REPLACE :: 2;
		SPACE_OVERRIDE_REPLACE :: 3;
		SPACE_OVERRIDE_REPLACE_COMBINE :: 4;
	}
}

Area3D_set_gravity_space_override_mode :: (using self: *Area3D, space_override_mode: Area3D.SpaceOverride) {
}
Area3D_get_gravity_space_override_mode :: (using self: *Area3D) -> Area3D.SpaceOverride {
}
Area3D_set_gravity_is_point :: (using self: *Area3D, enable: bool) {
}
Area3D_is_gravity_a_point :: (using self: *Area3D) -> bool {
}
Area3D_set_gravity_point_unit_distance :: (using self: *Area3D, distance_scale: float) {
}
Area3D_get_gravity_point_unit_distance :: (using self: *Area3D) -> float {
}
Area3D_set_gravity_point_center :: (using self: *Area3D, center: Vector3) {
}
Area3D_get_gravity_point_center :: (using self: *Area3D) -> Vector3 {
}
Area3D_set_gravity_direction :: (using self: *Area3D, direction: Vector3) {
}
Area3D_get_gravity_direction :: (using self: *Area3D) -> Vector3 {
}
Area3D_set_gravity :: (using self: *Area3D, gravity: float) {
}
Area3D_get_gravity :: (using self: *Area3D) -> float {
}
Area3D_set_linear_damp_space_override_mode :: (using self: *Area3D, space_override_mode: Area3D.SpaceOverride) {
}
Area3D_get_linear_damp_space_override_mode :: (using self: *Area3D) -> Area3D.SpaceOverride {
}
Area3D_set_angular_damp_space_override_mode :: (using self: *Area3D, space_override_mode: Area3D.SpaceOverride) {
}
Area3D_get_angular_damp_space_override_mode :: (using self: *Area3D) -> Area3D.SpaceOverride {
}
Area3D_set_angular_damp :: (using self: *Area3D, angular_damp: float) {
}
Area3D_get_angular_damp :: (using self: *Area3D) -> float {
}
Area3D_set_linear_damp :: (using self: *Area3D, linear_damp: float) {
}
Area3D_get_linear_damp :: (using self: *Area3D) -> float {
}
Area3D_set_priority :: (using self: *Area3D, priority: int) {
}
Area3D_get_priority :: (using self: *Area3D) -> int {
}
Area3D_set_wind_force_magnitude :: (using self: *Area3D, wind_force_magnitude: float) {
}
Area3D_get_wind_force_magnitude :: (using self: *Area3D) -> float {
}
Area3D_set_wind_attenuation_factor :: (using self: *Area3D, wind_attenuation_factor: float) {
}
Area3D_get_wind_attenuation_factor :: (using self: *Area3D) -> float {
}
Area3D_set_wind_source_path :: (using self: *Area3D, wind_source_path: NodePath) {
}
Area3D_get_wind_source_path :: (using self: *Area3D) -> NodePath {
}
Area3D_set_monitorable :: (using self: *Area3D, enable: bool) {
}
Area3D_is_monitorable :: (using self: *Area3D) -> bool {
}
Area3D_set_monitoring :: (using self: *Area3D, enable: bool) {
}
Area3D_is_monitoring :: (using self: *Area3D) -> bool {
}
Area3D_get_overlapping_bodies :: (using self: *Area3D) -> Array {
}
Area3D_get_overlapping_areas :: (using self: *Area3D) -> Array {
}
Area3D_has_overlapping_bodies :: (using self: *Area3D) -> bool {
}
Area3D_has_overlapping_areas :: (using self: *Area3D) -> bool {
}
Area3D_overlaps_body :: (using self: *Area3D, body: Node) -> bool {
}
Area3D_overlaps_area :: (using self: *Area3D, area: Node) -> bool {
}
Area3D_set_audio_bus_override :: (using self: *Area3D, enable: bool) {
}
Area3D_is_overriding_audio_bus :: (using self: *Area3D) -> bool {
}
Area3D_set_audio_bus_name :: (using self: *Area3D, name: StringName) {
}
Area3D_get_audio_bus_name :: (using self: *Area3D) -> StringName {
}
Area3D_set_use_reverb_bus :: (using self: *Area3D, enable: bool) {
}
Area3D_is_using_reverb_bus :: (using self: *Area3D) -> bool {
}
Area3D_set_reverb_bus_name :: (using self: *Area3D, name: StringName) {
}
Area3D_get_reverb_bus_name :: (using self: *Area3D) -> StringName {
}
Area3D_set_reverb_amount :: (using self: *Area3D, amount: float) {
}
Area3D_get_reverb_amount :: (using self: *Area3D) -> float {
}
Area3D_set_reverb_uniformity :: (using self: *Area3D, amount: float) {
}
Area3D_get_reverb_uniformity :: (using self: *Area3D) -> float {
}

// ArrayMesh
ArrayMesh :: struct {
	__private: *void;
}

ArrayMesh_add_blend_shape :: (using self: *ArrayMesh, name: StringName) {
}
ArrayMesh_get_blend_shape_count :: (using self: *ArrayMesh) -> int {
}
ArrayMesh_get_blend_shape_name :: (using self: *ArrayMesh, index: int) -> StringName {
}
ArrayMesh_set_blend_shape_name :: (using self: *ArrayMesh, index: int, name: StringName) {
}
ArrayMesh_clear_blend_shapes :: (using self: *ArrayMesh) {
}
ArrayMesh_set_blend_shape_mode :: (using self: *ArrayMesh, mode: Mesh.BlendShapeMode) {
}
ArrayMesh_get_blend_shape_mode :: (using self: *ArrayMesh) -> Mesh.BlendShapeMode {
}
ArrayMesh_add_surface_from_arrays :: (using self: *ArrayMesh, primitive: Mesh.PrimitiveType, arrays: Array, blend_shapes: Array, lods: Dictionary, flags: Mesh.ArrayFormat) {
}
ArrayMesh_clear_surfaces :: (using self: *ArrayMesh) {
}
ArrayMesh_surface_update_vertex_region :: (using self: *ArrayMesh, surf_idx: int, offset: int, data: PackedByteArray) {
}
ArrayMesh_surface_update_attribute_region :: (using self: *ArrayMesh, surf_idx: int, offset: int, data: PackedByteArray) {
}
ArrayMesh_surface_update_skin_region :: (using self: *ArrayMesh, surf_idx: int, offset: int, data: PackedByteArray) {
}
ArrayMesh_surface_get_array_len :: (using self: *ArrayMesh, surf_idx: int) -> int {
}
ArrayMesh_surface_get_array_index_len :: (using self: *ArrayMesh, surf_idx: int) -> int {
}
ArrayMesh_surface_get_format :: (using self: *ArrayMesh, surf_idx: int) -> Mesh.ArrayFormat {
}
ArrayMesh_surface_get_primitive_type :: (using self: *ArrayMesh, surf_idx: int) -> Mesh.PrimitiveType {
}
ArrayMesh_surface_find_by_name :: (using self: *ArrayMesh, name: String) -> int {
}
ArrayMesh_surface_set_name :: (using self: *ArrayMesh, surf_idx: int, name: String) {
}
ArrayMesh_surface_get_name :: (using self: *ArrayMesh, surf_idx: int) -> String {
}
ArrayMesh_regen_normal_maps :: (using self: *ArrayMesh) {
}
ArrayMesh_lightmap_unwrap :: (using self: *ArrayMesh, transform: Transform3D, texel_size: float) -> Error {
}
ArrayMesh_set_custom_aabb :: (using self: *ArrayMesh, aabb: AABB) {
}
ArrayMesh_get_custom_aabb :: (using self: *ArrayMesh) -> AABB {
}
ArrayMesh_set_shadow_mesh :: (using self: *ArrayMesh, mesh: ArrayMesh) {
}
ArrayMesh_get_shadow_mesh :: (using self: *ArrayMesh) -> ArrayMesh {
}

// ArrayOccluder3D
ArrayOccluder3D :: struct {
	__private: *void;
}

ArrayOccluder3D_set_arrays :: (using self: *ArrayOccluder3D, vertices: PackedVector3Array, indices: PackedInt32Array) {
}
ArrayOccluder3D_set_vertices :: (using self: *ArrayOccluder3D, vertices: PackedVector3Array) {
}
ArrayOccluder3D_set_indices :: (using self: *ArrayOccluder3D, indices: PackedInt32Array) {
}

// AspectRatioContainer
AspectRatioContainer :: struct {
	__private: *void;

	StretchMode :: enum {
		STRETCH_WIDTH_CONTROLS_HEIGHT :: 0;
		STRETCH_HEIGHT_CONTROLS_WIDTH :: 1;
		STRETCH_FIT :: 2;
		STRETCH_COVER :: 3;
	}
	AlignmentMode :: enum {
		ALIGNMENT_BEGIN :: 0;
		ALIGNMENT_CENTER :: 1;
		ALIGNMENT_END :: 2;
	}
}

AspectRatioContainer_set_ratio :: (using self: *AspectRatioContainer, ratio: float) {
}
AspectRatioContainer_get_ratio :: (using self: *AspectRatioContainer) -> float {
}
AspectRatioContainer_set_stretch_mode :: (using self: *AspectRatioContainer, stretch_mode: AspectRatioContainer.StretchMode) {
}
AspectRatioContainer_get_stretch_mode :: (using self: *AspectRatioContainer) -> AspectRatioContainer.StretchMode {
}
AspectRatioContainer_set_alignment_horizontal :: (using self: *AspectRatioContainer, alignment_horizontal: AspectRatioContainer.AlignmentMode) {
}
AspectRatioContainer_get_alignment_horizontal :: (using self: *AspectRatioContainer) -> AspectRatioContainer.AlignmentMode {
}
AspectRatioContainer_set_alignment_vertical :: (using self: *AspectRatioContainer, alignment_vertical: AspectRatioContainer.AlignmentMode) {
}
AspectRatioContainer_get_alignment_vertical :: (using self: *AspectRatioContainer) -> AspectRatioContainer.AlignmentMode {
}

// AtlasTexture
AtlasTexture :: struct {
	__private: *void;
}

AtlasTexture_set_atlas :: (using self: *AtlasTexture, atlas: Texture2D) {
}
AtlasTexture_get_atlas :: (using self: *AtlasTexture) -> Texture2D {
}
AtlasTexture_set_region :: (using self: *AtlasTexture, region: Rect2) {
}
AtlasTexture_get_region :: (using self: *AtlasTexture) -> Rect2 {
}
AtlasTexture_set_margin :: (using self: *AtlasTexture, margin: Rect2) {
}
AtlasTexture_get_margin :: (using self: *AtlasTexture) -> Rect2 {
}
AtlasTexture_set_filter_clip :: (using self: *AtlasTexture, enable: bool) {
}
AtlasTexture_has_filter_clip :: (using self: *AtlasTexture) -> bool {
}

// AudioBusLayout
AudioBusLayout :: struct {
	__private: *void;
}

// AudioEffect
AudioEffect :: struct {
	__private: *void;
}

AudioEffect__instantiate :: (using self: *AudioEffect) -> AudioEffectInstance {
}

// AudioEffectAmplify
AudioEffectAmplify :: struct {
	__private: *void;
}

AudioEffectAmplify_set_volume_db :: (using self: *AudioEffectAmplify, volume: float) {
}
AudioEffectAmplify_get_volume_db :: (using self: *AudioEffectAmplify) -> float {
}

// AudioEffectBandLimitFilter
AudioEffectBandLimitFilter :: struct {
	__private: *void;
}

// AudioEffectBandPassFilter
AudioEffectBandPassFilter :: struct {
	__private: *void;
}

// AudioEffectCapture
AudioEffectCapture :: struct {
	__private: *void;
}

AudioEffectCapture_can_get_buffer :: (using self: *AudioEffectCapture, frames: int) -> bool {
}
AudioEffectCapture_get_buffer :: (using self: *AudioEffectCapture, frames: int) -> PackedVector2Array {
}
AudioEffectCapture_clear_buffer :: (using self: *AudioEffectCapture) {
}
AudioEffectCapture_set_buffer_length :: (using self: *AudioEffectCapture, buffer_length_seconds: float) {
}
AudioEffectCapture_get_buffer_length :: (using self: *AudioEffectCapture) -> float {
}
AudioEffectCapture_get_frames_available :: (using self: *AudioEffectCapture) -> int {
}
AudioEffectCapture_get_discarded_frames :: (using self: *AudioEffectCapture) -> int {
}
AudioEffectCapture_get_buffer_length_frames :: (using self: *AudioEffectCapture) -> int {
}
AudioEffectCapture_get_pushed_frames :: (using self: *AudioEffectCapture) -> int {
}

// AudioEffectChorus
AudioEffectChorus :: struct {
	__private: *void;
}

AudioEffectChorus_set_voice_count :: (using self: *AudioEffectChorus, voices: int) {
}
AudioEffectChorus_get_voice_count :: (using self: *AudioEffectChorus) -> int {
}
AudioEffectChorus_set_voice_delay_ms :: (using self: *AudioEffectChorus, voice_idx: int, delay_ms: float) {
}
AudioEffectChorus_get_voice_delay_ms :: (using self: *AudioEffectChorus, voice_idx: int) -> float {
}
AudioEffectChorus_set_voice_rate_hz :: (using self: *AudioEffectChorus, voice_idx: int, rate_hz: float) {
}
AudioEffectChorus_get_voice_rate_hz :: (using self: *AudioEffectChorus, voice_idx: int) -> float {
}
AudioEffectChorus_set_voice_depth_ms :: (using self: *AudioEffectChorus, voice_idx: int, depth_ms: float) {
}
AudioEffectChorus_get_voice_depth_ms :: (using self: *AudioEffectChorus, voice_idx: int) -> float {
}
AudioEffectChorus_set_voice_level_db :: (using self: *AudioEffectChorus, voice_idx: int, level_db: float) {
}
AudioEffectChorus_get_voice_level_db :: (using self: *AudioEffectChorus, voice_idx: int) -> float {
}
AudioEffectChorus_set_voice_cutoff_hz :: (using self: *AudioEffectChorus, voice_idx: int, cutoff_hz: float) {
}
AudioEffectChorus_get_voice_cutoff_hz :: (using self: *AudioEffectChorus, voice_idx: int) -> float {
}
AudioEffectChorus_set_voice_pan :: (using self: *AudioEffectChorus, voice_idx: int, pan: float) {
}
AudioEffectChorus_get_voice_pan :: (using self: *AudioEffectChorus, voice_idx: int) -> float {
}
AudioEffectChorus_set_wet :: (using self: *AudioEffectChorus, amount: float) {
}
AudioEffectChorus_get_wet :: (using self: *AudioEffectChorus) -> float {
}
AudioEffectChorus_set_dry :: (using self: *AudioEffectChorus, amount: float) {
}
AudioEffectChorus_get_dry :: (using self: *AudioEffectChorus) -> float {
}

// AudioEffectCompressor
AudioEffectCompressor :: struct {
	__private: *void;
}

AudioEffectCompressor_set_threshold :: (using self: *AudioEffectCompressor, threshold: float) {
}
AudioEffectCompressor_get_threshold :: (using self: *AudioEffectCompressor) -> float {
}
AudioEffectCompressor_set_ratio :: (using self: *AudioEffectCompressor, ratio: float) {
}
AudioEffectCompressor_get_ratio :: (using self: *AudioEffectCompressor) -> float {
}
AudioEffectCompressor_set_gain :: (using self: *AudioEffectCompressor, gain: float) {
}
AudioEffectCompressor_get_gain :: (using self: *AudioEffectCompressor) -> float {
}
AudioEffectCompressor_set_attack_us :: (using self: *AudioEffectCompressor, attack_us: float) {
}
AudioEffectCompressor_get_attack_us :: (using self: *AudioEffectCompressor) -> float {
}
AudioEffectCompressor_set_release_ms :: (using self: *AudioEffectCompressor, release_ms: float) {
}
AudioEffectCompressor_get_release_ms :: (using self: *AudioEffectCompressor) -> float {
}
AudioEffectCompressor_set_mix :: (using self: *AudioEffectCompressor, mix: float) {
}
AudioEffectCompressor_get_mix :: (using self: *AudioEffectCompressor) -> float {
}
AudioEffectCompressor_set_sidechain :: (using self: *AudioEffectCompressor, sidechain: StringName) {
}
AudioEffectCompressor_get_sidechain :: (using self: *AudioEffectCompressor) -> StringName {
}

// AudioEffectDelay
AudioEffectDelay :: struct {
	__private: *void;
}

AudioEffectDelay_set_dry :: (using self: *AudioEffectDelay, amount: float) {
}
AudioEffectDelay_get_dry :: (using self: *AudioEffectDelay) -> float {
}
AudioEffectDelay_set_tap1_active :: (using self: *AudioEffectDelay, amount: bool) {
}
AudioEffectDelay_is_tap1_active :: (using self: *AudioEffectDelay) -> bool {
}
AudioEffectDelay_set_tap1_delay_ms :: (using self: *AudioEffectDelay, amount: float) {
}
AudioEffectDelay_get_tap1_delay_ms :: (using self: *AudioEffectDelay) -> float {
}
AudioEffectDelay_set_tap1_level_db :: (using self: *AudioEffectDelay, amount: float) {
}
AudioEffectDelay_get_tap1_level_db :: (using self: *AudioEffectDelay) -> float {
}
AudioEffectDelay_set_tap1_pan :: (using self: *AudioEffectDelay, amount: float) {
}
AudioEffectDelay_get_tap1_pan :: (using self: *AudioEffectDelay) -> float {
}
AudioEffectDelay_set_tap2_active :: (using self: *AudioEffectDelay, amount: bool) {
}
AudioEffectDelay_is_tap2_active :: (using self: *AudioEffectDelay) -> bool {
}
AudioEffectDelay_set_tap2_delay_ms :: (using self: *AudioEffectDelay, amount: float) {
}
AudioEffectDelay_get_tap2_delay_ms :: (using self: *AudioEffectDelay) -> float {
}
AudioEffectDelay_set_tap2_level_db :: (using self: *AudioEffectDelay, amount: float) {
}
AudioEffectDelay_get_tap2_level_db :: (using self: *AudioEffectDelay) -> float {
}
AudioEffectDelay_set_tap2_pan :: (using self: *AudioEffectDelay, amount: float) {
}
AudioEffectDelay_get_tap2_pan :: (using self: *AudioEffectDelay) -> float {
}
AudioEffectDelay_set_feedback_active :: (using self: *AudioEffectDelay, amount: bool) {
}
AudioEffectDelay_is_feedback_active :: (using self: *AudioEffectDelay) -> bool {
}
AudioEffectDelay_set_feedback_delay_ms :: (using self: *AudioEffectDelay, amount: float) {
}
AudioEffectDelay_get_feedback_delay_ms :: (using self: *AudioEffectDelay) -> float {
}
AudioEffectDelay_set_feedback_level_db :: (using self: *AudioEffectDelay, amount: float) {
}
AudioEffectDelay_get_feedback_level_db :: (using self: *AudioEffectDelay) -> float {
}
AudioEffectDelay_set_feedback_lowpass :: (using self: *AudioEffectDelay, amount: float) {
}
AudioEffectDelay_get_feedback_lowpass :: (using self: *AudioEffectDelay) -> float {
}

// AudioEffectDistortion
AudioEffectDistortion :: struct {
	__private: *void;

	Mode :: enum {
		MODE_CLIP :: 0;
		MODE_ATAN :: 1;
		MODE_LOFI :: 2;
		MODE_OVERDRIVE :: 3;
		MODE_WAVESHAPE :: 4;
	}
}

AudioEffectDistortion_set_mode :: (using self: *AudioEffectDistortion, mode: AudioEffectDistortion.Mode) {
}
AudioEffectDistortion_get_mode :: (using self: *AudioEffectDistortion) -> AudioEffectDistortion.Mode {
}
AudioEffectDistortion_set_pre_gain :: (using self: *AudioEffectDistortion, pre_gain: float) {
}
AudioEffectDistortion_get_pre_gain :: (using self: *AudioEffectDistortion) -> float {
}
AudioEffectDistortion_set_keep_hf_hz :: (using self: *AudioEffectDistortion, keep_hf_hz: float) {
}
AudioEffectDistortion_get_keep_hf_hz :: (using self: *AudioEffectDistortion) -> float {
}
AudioEffectDistortion_set_drive :: (using self: *AudioEffectDistortion, drive: float) {
}
AudioEffectDistortion_get_drive :: (using self: *AudioEffectDistortion) -> float {
}
AudioEffectDistortion_set_post_gain :: (using self: *AudioEffectDistortion, post_gain: float) {
}
AudioEffectDistortion_get_post_gain :: (using self: *AudioEffectDistortion) -> float {
}

// AudioEffectEQ
AudioEffectEQ :: struct {
	__private: *void;
}

AudioEffectEQ_set_band_gain_db :: (using self: *AudioEffectEQ, band_idx: int, volume_db: float) {
}
AudioEffectEQ_get_band_gain_db :: (using self: *AudioEffectEQ, band_idx: int) -> float {
}
AudioEffectEQ_get_band_count :: (using self: *AudioEffectEQ) -> int {
}

// AudioEffectEQ10
AudioEffectEQ10 :: struct {
	__private: *void;
}

// AudioEffectEQ21
AudioEffectEQ21 :: struct {
	__private: *void;
}

// AudioEffectEQ6
AudioEffectEQ6 :: struct {
	__private: *void;
}

// AudioEffectFilter
AudioEffectFilter :: struct {
	__private: *void;

	FilterDB :: enum {
		FILTER_6DB :: 0;
		FILTER_12DB :: 1;
		FILTER_18DB :: 2;
		FILTER_24DB :: 3;
	}
}

AudioEffectFilter_set_cutoff :: (using self: *AudioEffectFilter, freq: float) {
}
AudioEffectFilter_get_cutoff :: (using self: *AudioEffectFilter) -> float {
}
AudioEffectFilter_set_resonance :: (using self: *AudioEffectFilter, amount: float) {
}
AudioEffectFilter_get_resonance :: (using self: *AudioEffectFilter) -> float {
}
AudioEffectFilter_set_gain :: (using self: *AudioEffectFilter, amount: float) {
}
AudioEffectFilter_get_gain :: (using self: *AudioEffectFilter) -> float {
}
AudioEffectFilter_set_db :: (using self: *AudioEffectFilter, amount: AudioEffectFilter.FilterDB) {
}
AudioEffectFilter_get_db :: (using self: *AudioEffectFilter) -> AudioEffectFilter.FilterDB {
}

// AudioEffectHardLimiter
AudioEffectHardLimiter :: struct {
	__private: *void;
}

AudioEffectHardLimiter_set_ceiling_db :: (using self: *AudioEffectHardLimiter, ceiling: float) {
}
AudioEffectHardLimiter_get_ceiling_db :: (using self: *AudioEffectHardLimiter) -> float {
}
AudioEffectHardLimiter_set_pre_gain_db :: (using self: *AudioEffectHardLimiter, p_pre_gain: float) {
}
AudioEffectHardLimiter_get_pre_gain_db :: (using self: *AudioEffectHardLimiter) -> float {
}
AudioEffectHardLimiter_set_release :: (using self: *AudioEffectHardLimiter, p_release: float) {
}
AudioEffectHardLimiter_get_release :: (using self: *AudioEffectHardLimiter) -> float {
}

// AudioEffectHighPassFilter
AudioEffectHighPassFilter :: struct {
	__private: *void;
}

// AudioEffectHighShelfFilter
AudioEffectHighShelfFilter :: struct {
	__private: *void;
}

// AudioEffectInstance
AudioEffectInstance :: struct {
	__private: *void;
}

AudioEffectInstance__process :: (using self: *AudioEffectInstance, src_buffer: *void, dst_buffer: *AudioFrame, frame_count: int) {
}
AudioEffectInstance__process_silence :: (using self: *AudioEffectInstance) -> bool {
}

// AudioEffectLimiter
AudioEffectLimiter :: struct {
	__private: *void;
}

AudioEffectLimiter_set_ceiling_db :: (using self: *AudioEffectLimiter, ceiling: float) {
}
AudioEffectLimiter_get_ceiling_db :: (using self: *AudioEffectLimiter) -> float {
}
AudioEffectLimiter_set_threshold_db :: (using self: *AudioEffectLimiter, threshold: float) {
}
AudioEffectLimiter_get_threshold_db :: (using self: *AudioEffectLimiter) -> float {
}
AudioEffectLimiter_set_soft_clip_db :: (using self: *AudioEffectLimiter, soft_clip: float) {
}
AudioEffectLimiter_get_soft_clip_db :: (using self: *AudioEffectLimiter) -> float {
}
AudioEffectLimiter_set_soft_clip_ratio :: (using self: *AudioEffectLimiter, soft_clip: float) {
}
AudioEffectLimiter_get_soft_clip_ratio :: (using self: *AudioEffectLimiter) -> float {
}

// AudioEffectLowPassFilter
AudioEffectLowPassFilter :: struct {
	__private: *void;
}

// AudioEffectLowShelfFilter
AudioEffectLowShelfFilter :: struct {
	__private: *void;
}

// AudioEffectNotchFilter
AudioEffectNotchFilter :: struct {
	__private: *void;
}

// AudioEffectPanner
AudioEffectPanner :: struct {
	__private: *void;
}

AudioEffectPanner_set_pan :: (using self: *AudioEffectPanner, cpanume: float) {
}
AudioEffectPanner_get_pan :: (using self: *AudioEffectPanner) -> float {
}

// AudioEffectPhaser
AudioEffectPhaser :: struct {
	__private: *void;
}

AudioEffectPhaser_set_range_min_hz :: (using self: *AudioEffectPhaser, hz: float) {
}
AudioEffectPhaser_get_range_min_hz :: (using self: *AudioEffectPhaser) -> float {
}
AudioEffectPhaser_set_range_max_hz :: (using self: *AudioEffectPhaser, hz: float) {
}
AudioEffectPhaser_get_range_max_hz :: (using self: *AudioEffectPhaser) -> float {
}
AudioEffectPhaser_set_rate_hz :: (using self: *AudioEffectPhaser, hz: float) {
}
AudioEffectPhaser_get_rate_hz :: (using self: *AudioEffectPhaser) -> float {
}
AudioEffectPhaser_set_feedback :: (using self: *AudioEffectPhaser, fbk: float) {
}
AudioEffectPhaser_get_feedback :: (using self: *AudioEffectPhaser) -> float {
}
AudioEffectPhaser_set_depth :: (using self: *AudioEffectPhaser, depth: float) {
}
AudioEffectPhaser_get_depth :: (using self: *AudioEffectPhaser) -> float {
}

// AudioEffectPitchShift
AudioEffectPitchShift :: struct {
	__private: *void;

	FFTSize :: enum {
		FFT_SIZE_256 :: 0;
		FFT_SIZE_512 :: 1;
		FFT_SIZE_1024 :: 2;
		FFT_SIZE_2048 :: 3;
		FFT_SIZE_4096 :: 4;
		FFT_SIZE_MAX :: 5;
	}
}

AudioEffectPitchShift_set_pitch_scale :: (using self: *AudioEffectPitchShift, rate: float) {
}
AudioEffectPitchShift_get_pitch_scale :: (using self: *AudioEffectPitchShift) -> float {
}
AudioEffectPitchShift_set_oversampling :: (using self: *AudioEffectPitchShift, amount: int) {
}
AudioEffectPitchShift_get_oversampling :: (using self: *AudioEffectPitchShift) -> int {
}
AudioEffectPitchShift_set_fft_size :: (using self: *AudioEffectPitchShift, size: AudioEffectPitchShift.FFTSize) {
}
AudioEffectPitchShift_get_fft_size :: (using self: *AudioEffectPitchShift) -> AudioEffectPitchShift.FFTSize {
}

// AudioEffectRecord
AudioEffectRecord :: struct {
	__private: *void;
}

AudioEffectRecord_set_recording_active :: (using self: *AudioEffectRecord, record: bool) {
}
AudioEffectRecord_is_recording_active :: (using self: *AudioEffectRecord) -> bool {
}
AudioEffectRecord_set_format :: (using self: *AudioEffectRecord, format: AudioStreamWAV.Format) {
}
AudioEffectRecord_get_format :: (using self: *AudioEffectRecord) -> AudioStreamWAV.Format {
}
AudioEffectRecord_get_recording :: (using self: *AudioEffectRecord) -> AudioStreamWAV {
}

// AudioEffectReverb
AudioEffectReverb :: struct {
	__private: *void;
}

AudioEffectReverb_set_predelay_msec :: (using self: *AudioEffectReverb, msec: float) {
}
AudioEffectReverb_get_predelay_msec :: (using self: *AudioEffectReverb) -> float {
}
AudioEffectReverb_set_predelay_feedback :: (using self: *AudioEffectReverb, feedback: float) {
}
AudioEffectReverb_get_predelay_feedback :: (using self: *AudioEffectReverb) -> float {
}
AudioEffectReverb_set_room_size :: (using self: *AudioEffectReverb, size: float) {
}
AudioEffectReverb_get_room_size :: (using self: *AudioEffectReverb) -> float {
}
AudioEffectReverb_set_damping :: (using self: *AudioEffectReverb, amount: float) {
}
AudioEffectReverb_get_damping :: (using self: *AudioEffectReverb) -> float {
}
AudioEffectReverb_set_spread :: (using self: *AudioEffectReverb, amount: float) {
}
AudioEffectReverb_get_spread :: (using self: *AudioEffectReverb) -> float {
}
AudioEffectReverb_set_dry :: (using self: *AudioEffectReverb, amount: float) {
}
AudioEffectReverb_get_dry :: (using self: *AudioEffectReverb) -> float {
}
AudioEffectReverb_set_wet :: (using self: *AudioEffectReverb, amount: float) {
}
AudioEffectReverb_get_wet :: (using self: *AudioEffectReverb) -> float {
}
AudioEffectReverb_set_hpf :: (using self: *AudioEffectReverb, amount: float) {
}
AudioEffectReverb_get_hpf :: (using self: *AudioEffectReverb) -> float {
}

// AudioEffectSpectrumAnalyzer
AudioEffectSpectrumAnalyzer :: struct {
	__private: *void;

	FFTSize :: enum {
		FFT_SIZE_256 :: 0;
		FFT_SIZE_512 :: 1;
		FFT_SIZE_1024 :: 2;
		FFT_SIZE_2048 :: 3;
		FFT_SIZE_4096 :: 4;
		FFT_SIZE_MAX :: 5;
	}
}

AudioEffectSpectrumAnalyzer_set_buffer_length :: (using self: *AudioEffectSpectrumAnalyzer, seconds: float) {
}
AudioEffectSpectrumAnalyzer_get_buffer_length :: (using self: *AudioEffectSpectrumAnalyzer) -> float {
}
AudioEffectSpectrumAnalyzer_set_tap_back_pos :: (using self: *AudioEffectSpectrumAnalyzer, seconds: float) {
}
AudioEffectSpectrumAnalyzer_get_tap_back_pos :: (using self: *AudioEffectSpectrumAnalyzer) -> float {
}
AudioEffectSpectrumAnalyzer_set_fft_size :: (using self: *AudioEffectSpectrumAnalyzer, size: AudioEffectSpectrumAnalyzer.FFTSize) {
}
AudioEffectSpectrumAnalyzer_get_fft_size :: (using self: *AudioEffectSpectrumAnalyzer) -> AudioEffectSpectrumAnalyzer.FFTSize {
}

// AudioEffectSpectrumAnalyzerInstance
AudioEffectSpectrumAnalyzerInstance :: struct {
	__private: *void;

	MagnitudeMode :: enum {
		MAGNITUDE_AVERAGE :: 0;
		MAGNITUDE_MAX :: 1;
	}
}

AudioEffectSpectrumAnalyzerInstance_get_magnitude_for_frequency_range :: (using self: *AudioEffectSpectrumAnalyzerInstance, from_hz: float, to_hz: float, mode: AudioEffectSpectrumAnalyzerInstance.MagnitudeMode) -> Vector2 {
}

// AudioEffectStereoEnhance
AudioEffectStereoEnhance :: struct {
	__private: *void;
}

AudioEffectStereoEnhance_set_pan_pullout :: (using self: *AudioEffectStereoEnhance, amount: float) {
}
AudioEffectStereoEnhance_get_pan_pullout :: (using self: *AudioEffectStereoEnhance) -> float {
}
AudioEffectStereoEnhance_set_time_pullout :: (using self: *AudioEffectStereoEnhance, amount: float) {
}
AudioEffectStereoEnhance_get_time_pullout :: (using self: *AudioEffectStereoEnhance) -> float {
}
AudioEffectStereoEnhance_set_surround :: (using self: *AudioEffectStereoEnhance, amount: float) {
}
AudioEffectStereoEnhance_get_surround :: (using self: *AudioEffectStereoEnhance) -> float {
}

// AudioListener2D
AudioListener2D :: struct {
	__private: *void;
}

AudioListener2D_make_current :: (using self: *AudioListener2D) {
}
AudioListener2D_clear_current :: (using self: *AudioListener2D) {
}
AudioListener2D_is_current :: (using self: *AudioListener2D) -> bool {
}

// AudioListener3D
AudioListener3D :: struct {
	__private: *void;
}

AudioListener3D_make_current :: (using self: *AudioListener3D) {
}
AudioListener3D_clear_current :: (using self: *AudioListener3D) {
}
AudioListener3D_is_current :: (using self: *AudioListener3D) -> bool {
}
AudioListener3D_get_listener_transform :: (using self: *AudioListener3D) -> Transform3D {
}

// AudioSample
AudioSample :: struct {
	__private: *void;
}

// AudioSamplePlayback
AudioSamplePlayback :: struct {
	__private: *void;
}

// AudioServer
AudioServer :: struct {
	__private: *void;

	SpeakerMode :: enum {
		SPEAKER_MODE_STEREO :: 0;
		SPEAKER_SURROUND_31 :: 1;
		SPEAKER_SURROUND_51 :: 2;
		SPEAKER_SURROUND_71 :: 3;
	}
	PlaybackType :: enum {
		PLAYBACK_TYPE_DEFAULT :: 0;
		PLAYBACK_TYPE_STREAM :: 1;
		PLAYBACK_TYPE_SAMPLE :: 2;
		PLAYBACK_TYPE_MAX :: 3;
	}
}

AudioServer_set_bus_count :: (using self: *AudioServer, amount: int) {
}
AudioServer_get_bus_count :: (using self: *AudioServer) -> int {
}
AudioServer_remove_bus :: (using self: *AudioServer, index: int) {
}
AudioServer_add_bus :: (using self: *AudioServer, at_position: int) {
}
AudioServer_move_bus :: (using self: *AudioServer, index: int, to_index: int) {
}
AudioServer_set_bus_name :: (using self: *AudioServer, bus_idx: int, name: String) {
}
AudioServer_get_bus_name :: (using self: *AudioServer, bus_idx: int) -> String {
}
AudioServer_get_bus_index :: (using self: *AudioServer, bus_name: StringName) -> int {
}
AudioServer_get_bus_channels :: (using self: *AudioServer, bus_idx: int) -> int {
}
AudioServer_set_bus_volume_db :: (using self: *AudioServer, bus_idx: int, volume_db: float) {
}
AudioServer_get_bus_volume_db :: (using self: *AudioServer, bus_idx: int) -> float {
}
AudioServer_set_bus_send :: (using self: *AudioServer, bus_idx: int, send: StringName) {
}
AudioServer_get_bus_send :: (using self: *AudioServer, bus_idx: int) -> StringName {
}
AudioServer_set_bus_solo :: (using self: *AudioServer, bus_idx: int, enable: bool) {
}
AudioServer_is_bus_solo :: (using self: *AudioServer, bus_idx: int) -> bool {
}
AudioServer_set_bus_mute :: (using self: *AudioServer, bus_idx: int, enable: bool) {
}
AudioServer_is_bus_mute :: (using self: *AudioServer, bus_idx: int) -> bool {
}
AudioServer_set_bus_bypass_effects :: (using self: *AudioServer, bus_idx: int, enable: bool) {
}
AudioServer_is_bus_bypassing_effects :: (using self: *AudioServer, bus_idx: int) -> bool {
}
AudioServer_add_bus_effect :: (using self: *AudioServer, bus_idx: int, effect: AudioEffect, at_position: int) {
}
AudioServer_remove_bus_effect :: (using self: *AudioServer, bus_idx: int, effect_idx: int) {
}
AudioServer_get_bus_effect_count :: (using self: *AudioServer, bus_idx: int) -> int {
}
AudioServer_get_bus_effect :: (using self: *AudioServer, bus_idx: int, effect_idx: int) -> AudioEffect {
}
AudioServer_get_bus_effect_instance :: (using self: *AudioServer, bus_idx: int, effect_idx: int, channel: int) -> AudioEffectInstance {
}
AudioServer_swap_bus_effects :: (using self: *AudioServer, bus_idx: int, effect_idx: int, by_effect_idx: int) {
}
AudioServer_set_bus_effect_enabled :: (using self: *AudioServer, bus_idx: int, effect_idx: int, enabled: bool) {
}
AudioServer_is_bus_effect_enabled :: (using self: *AudioServer, bus_idx: int, effect_idx: int) -> bool {
}
AudioServer_get_bus_peak_volume_left_db :: (using self: *AudioServer, bus_idx: int, channel: int) -> float {
}
AudioServer_get_bus_peak_volume_right_db :: (using self: *AudioServer, bus_idx: int, channel: int) -> float {
}
AudioServer_set_playback_speed_scale :: (using self: *AudioServer, scale: float) {
}
AudioServer_get_playback_speed_scale :: (using self: *AudioServer) -> float {
}
AudioServer_lock :: (using self: *AudioServer) {
}
AudioServer_unlock :: (using self: *AudioServer) {
}
AudioServer_get_speaker_mode :: (using self: *AudioServer) -> AudioServer.SpeakerMode {
}
AudioServer_get_mix_rate :: (using self: *AudioServer) -> float {
}
AudioServer_get_output_device_list :: (using self: *AudioServer) -> PackedStringArray {
}
AudioServer_get_output_device :: (using self: *AudioServer) -> String {
}
AudioServer_set_output_device :: (using self: *AudioServer, name: String) {
}
AudioServer_get_time_to_next_mix :: (using self: *AudioServer) -> float {
}
AudioServer_get_time_since_last_mix :: (using self: *AudioServer) -> float {
}
AudioServer_get_output_latency :: (using self: *AudioServer) -> float {
}
AudioServer_get_input_device_list :: (using self: *AudioServer) -> PackedStringArray {
}
AudioServer_get_input_device :: (using self: *AudioServer) -> String {
}
AudioServer_set_input_device :: (using self: *AudioServer, name: String) {
}
AudioServer_set_bus_layout :: (using self: *AudioServer, bus_layout: AudioBusLayout) {
}
AudioServer_generate_bus_layout :: (using self: *AudioServer) -> AudioBusLayout {
}
AudioServer_set_enable_tagging_used_audio_streams :: (using self: *AudioServer, enable: bool) {
}
AudioServer_is_stream_registered_as_sample :: (using self: *AudioServer, stream: AudioStream) -> bool {
}
AudioServer_register_stream_as_sample :: (using self: *AudioServer, stream: AudioStream) {
}

// AudioStream
AudioStream :: struct {
	__private: *void;
}

AudioStream__instantiate_playback :: (using self: *AudioStream) -> AudioStreamPlayback {
}
AudioStream__get_stream_name :: (using self: *AudioStream) -> String {
}
AudioStream__get_length :: (using self: *AudioStream) -> float {
}
AudioStream__is_monophonic :: (using self: *AudioStream) -> bool {
}
AudioStream__get_bpm :: (using self: *AudioStream) -> float {
}
AudioStream__get_beat_count :: (using self: *AudioStream) -> int {
}
AudioStream__get_parameter_list :: (using self: *AudioStream) -> Dictionary {
}
AudioStream_get_length :: (using self: *AudioStream) -> float {
}
AudioStream_is_monophonic :: (using self: *AudioStream) -> bool {
}
AudioStream_instantiate_playback :: (using self: *AudioStream) -> AudioStreamPlayback {
}
AudioStream_can_be_sampled :: (using self: *AudioStream) -> bool {
}
AudioStream_generate_sample :: (using self: *AudioStream) -> AudioSample {
}
AudioStream_is_meta_stream :: (using self: *AudioStream) -> bool {
}

// AudioStreamGenerator
AudioStreamGenerator :: struct {
	__private: *void;
}

AudioStreamGenerator_set_mix_rate :: (using self: *AudioStreamGenerator, hz: float) {
}
AudioStreamGenerator_get_mix_rate :: (using self: *AudioStreamGenerator) -> float {
}
AudioStreamGenerator_set_buffer_length :: (using self: *AudioStreamGenerator, seconds: float) {
}
AudioStreamGenerator_get_buffer_length :: (using self: *AudioStreamGenerator) -> float {
}

// AudioStreamGeneratorPlayback
AudioStreamGeneratorPlayback :: struct {
	__private: *void;
}

AudioStreamGeneratorPlayback_push_frame :: (using self: *AudioStreamGeneratorPlayback, frame: Vector2) -> bool {
}
AudioStreamGeneratorPlayback_can_push_buffer :: (using self: *AudioStreamGeneratorPlayback, amount: int) -> bool {
}
AudioStreamGeneratorPlayback_push_buffer :: (using self: *AudioStreamGeneratorPlayback, frames: PackedVector2Array) -> bool {
}
AudioStreamGeneratorPlayback_get_frames_available :: (using self: *AudioStreamGeneratorPlayback) -> int {
}
AudioStreamGeneratorPlayback_get_skips :: (using self: *AudioStreamGeneratorPlayback) -> int {
}
AudioStreamGeneratorPlayback_clear_buffer :: (using self: *AudioStreamGeneratorPlayback) {
}

// AudioStreamInteractive
AudioStreamInteractive :: struct {
	__private: *void;

	CLIP_ANY :: -1;

	TransitionFromTime :: enum {
		TRANSITION_FROM_TIME_IMMEDIATE :: 0;
		TRANSITION_FROM_TIME_NEXT_BEAT :: 1;
		TRANSITION_FROM_TIME_NEXT_BAR :: 2;
		TRANSITION_FROM_TIME_END :: 3;
	}
	TransitionToTime :: enum {
		TRANSITION_TO_TIME_SAME_POSITION :: 0;
		TRANSITION_TO_TIME_START :: 1;
	}
	FadeMode :: enum {
		FADE_DISABLED :: 0;
		FADE_IN :: 1;
		FADE_OUT :: 2;
		FADE_CROSS :: 3;
		FADE_AUTOMATIC :: 4;
	}
	AutoAdvanceMode :: enum {
		AUTO_ADVANCE_DISABLED :: 0;
		AUTO_ADVANCE_ENABLED :: 1;
		AUTO_ADVANCE_RETURN_TO_HOLD :: 2;
	}
}

AudioStreamInteractive_set_clip_count :: (using self: *AudioStreamInteractive, clip_count: int) {
}
AudioStreamInteractive_get_clip_count :: (using self: *AudioStreamInteractive) -> int {
}
AudioStreamInteractive_set_initial_clip :: (using self: *AudioStreamInteractive, clip_index: int) {
}
AudioStreamInteractive_get_initial_clip :: (using self: *AudioStreamInteractive) -> int {
}
AudioStreamInteractive_set_clip_name :: (using self: *AudioStreamInteractive, clip_index: int, name: StringName) {
}
AudioStreamInteractive_get_clip_name :: (using self: *AudioStreamInteractive, clip_index: int) -> StringName {
}
AudioStreamInteractive_set_clip_stream :: (using self: *AudioStreamInteractive, clip_index: int, stream: AudioStream) {
}
AudioStreamInteractive_get_clip_stream :: (using self: *AudioStreamInteractive, clip_index: int) -> AudioStream {
}
AudioStreamInteractive_set_clip_auto_advance :: (using self: *AudioStreamInteractive, clip_index: int, mode: AudioStreamInteractive.AutoAdvanceMode) {
}
AudioStreamInteractive_get_clip_auto_advance :: (using self: *AudioStreamInteractive, clip_index: int) -> AudioStreamInteractive.AutoAdvanceMode {
}
AudioStreamInteractive_set_clip_auto_advance_next_clip :: (using self: *AudioStreamInteractive, clip_index: int, auto_advance_next_clip: int) {
}
AudioStreamInteractive_get_clip_auto_advance_next_clip :: (using self: *AudioStreamInteractive, clip_index: int) -> int {
}
AudioStreamInteractive_add_transition :: (using self: *AudioStreamInteractive, from_clip: int, to_clip: int, from_time: AudioStreamInteractive.TransitionFromTime, to_time: AudioStreamInteractive.TransitionToTime, fade_mode: AudioStreamInteractive.FadeMode, fade_beats: float, use_filler_clip: bool, filler_clip: int, hold_previous: bool) {
}
AudioStreamInteractive_has_transition :: (using self: *AudioStreamInteractive, from_clip: int, to_clip: int) -> bool {
}
AudioStreamInteractive_erase_transition :: (using self: *AudioStreamInteractive, from_clip: int, to_clip: int) {
}
AudioStreamInteractive_get_transition_list :: (using self: *AudioStreamInteractive) -> PackedInt32Array {
}
AudioStreamInteractive_get_transition_from_time :: (using self: *AudioStreamInteractive, from_clip: int, to_clip: int) -> AudioStreamInteractive.TransitionFromTime {
}
AudioStreamInteractive_get_transition_to_time :: (using self: *AudioStreamInteractive, from_clip: int, to_clip: int) -> AudioStreamInteractive.TransitionToTime {
}
AudioStreamInteractive_get_transition_fade_mode :: (using self: *AudioStreamInteractive, from_clip: int, to_clip: int) -> AudioStreamInteractive.FadeMode {
}
AudioStreamInteractive_get_transition_fade_beats :: (using self: *AudioStreamInteractive, from_clip: int, to_clip: int) -> float {
}
AudioStreamInteractive_is_transition_using_filler_clip :: (using self: *AudioStreamInteractive, from_clip: int, to_clip: int) -> bool {
}
AudioStreamInteractive_get_transition_filler_clip :: (using self: *AudioStreamInteractive, from_clip: int, to_clip: int) -> int {
}
AudioStreamInteractive_is_transition_holding_previous :: (using self: *AudioStreamInteractive, from_clip: int, to_clip: int) -> bool {
}

// AudioStreamMP3
AudioStreamMP3 :: struct {
	__private: *void;
}

AudioStreamMP3_set_data :: (using self: *AudioStreamMP3, data: PackedByteArray) {
}
AudioStreamMP3_get_data :: (using self: *AudioStreamMP3) -> PackedByteArray {
}
AudioStreamMP3_set_loop :: (using self: *AudioStreamMP3, enable: bool) {
}
AudioStreamMP3_has_loop :: (using self: *AudioStreamMP3) -> bool {
}
AudioStreamMP3_set_loop_offset :: (using self: *AudioStreamMP3, seconds: float) {
}
AudioStreamMP3_get_loop_offset :: (using self: *AudioStreamMP3) -> float {
}
AudioStreamMP3_set_bpm :: (using self: *AudioStreamMP3, bpm: float) {
}
AudioStreamMP3_get_bpm :: (using self: *AudioStreamMP3) -> float {
}
AudioStreamMP3_set_beat_count :: (using self: *AudioStreamMP3, count: int) {
}
AudioStreamMP3_get_beat_count :: (using self: *AudioStreamMP3) -> int {
}
AudioStreamMP3_set_bar_beats :: (using self: *AudioStreamMP3, count: int) {
}
AudioStreamMP3_get_bar_beats :: (using self: *AudioStreamMP3) -> int {
}

// AudioStreamMicrophone
AudioStreamMicrophone :: struct {
	__private: *void;
}

// AudioStreamOggVorbis
AudioStreamOggVorbis :: struct {
	__private: *void;
}

AudioStreamOggVorbis_load_from_buffer :: (using self: *AudioStreamOggVorbis, buffer: PackedByteArray) -> AudioStreamOggVorbis {
}
AudioStreamOggVorbis_load_from_file :: (using self: *AudioStreamOggVorbis, path: String) -> AudioStreamOggVorbis {
}
AudioStreamOggVorbis_set_packet_sequence :: (using self: *AudioStreamOggVorbis, packet_sequence: OggPacketSequence) {
}
AudioStreamOggVorbis_get_packet_sequence :: (using self: *AudioStreamOggVorbis) -> OggPacketSequence {
}
AudioStreamOggVorbis_set_loop :: (using self: *AudioStreamOggVorbis, enable: bool) {
}
AudioStreamOggVorbis_has_loop :: (using self: *AudioStreamOggVorbis) -> bool {
}
AudioStreamOggVorbis_set_loop_offset :: (using self: *AudioStreamOggVorbis, seconds: float) {
}
AudioStreamOggVorbis_get_loop_offset :: (using self: *AudioStreamOggVorbis) -> float {
}
AudioStreamOggVorbis_set_bpm :: (using self: *AudioStreamOggVorbis, bpm: float) {
}
AudioStreamOggVorbis_get_bpm :: (using self: *AudioStreamOggVorbis) -> float {
}
AudioStreamOggVorbis_set_beat_count :: (using self: *AudioStreamOggVorbis, count: int) {
}
AudioStreamOggVorbis_get_beat_count :: (using self: *AudioStreamOggVorbis) -> int {
}
AudioStreamOggVorbis_set_bar_beats :: (using self: *AudioStreamOggVorbis, count: int) {
}
AudioStreamOggVorbis_get_bar_beats :: (using self: *AudioStreamOggVorbis) -> int {
}

// AudioStreamPlayback
AudioStreamPlayback :: struct {
	__private: *void;
}

AudioStreamPlayback__start :: (using self: *AudioStreamPlayback, from_pos: float) {
}
AudioStreamPlayback__stop :: (using self: *AudioStreamPlayback) {
}
AudioStreamPlayback__is_playing :: (using self: *AudioStreamPlayback) -> bool {
}
AudioStreamPlayback__get_loop_count :: (using self: *AudioStreamPlayback) -> int {
}
AudioStreamPlayback__get_playback_position :: (using self: *AudioStreamPlayback) -> float {
}
AudioStreamPlayback__seek :: (using self: *AudioStreamPlayback, position: float) {
}
AudioStreamPlayback__mix :: (using self: *AudioStreamPlayback, buffer: *AudioFrame, rate_scale: float, frames: int) -> int {
}
AudioStreamPlayback__tag_used_streams :: (using self: *AudioStreamPlayback) {
}
AudioStreamPlayback__set_parameter :: (using self: *AudioStreamPlayback, name: StringName, value: Variant) {
}
AudioStreamPlayback__get_parameter :: (using self: *AudioStreamPlayback, name: StringName) -> Variant {
}
AudioStreamPlayback_set_sample_playback :: (using self: *AudioStreamPlayback, playback_sample: AudioSamplePlayback) {
}
AudioStreamPlayback_get_sample_playback :: (using self: *AudioStreamPlayback) -> AudioSamplePlayback {
}

// AudioStreamPlaybackInteractive
AudioStreamPlaybackInteractive :: struct {
	__private: *void;
}

AudioStreamPlaybackInteractive_switch_to_clip_by_name :: (using self: *AudioStreamPlaybackInteractive, clip_name: StringName) {
}
AudioStreamPlaybackInteractive_switch_to_clip :: (using self: *AudioStreamPlaybackInteractive, clip_index: int) {
}

// AudioStreamPlaybackOggVorbis
AudioStreamPlaybackOggVorbis :: struct {
	__private: *void;
}

// AudioStreamPlaybackPlaylist
AudioStreamPlaybackPlaylist :: struct {
	__private: *void;
}

// AudioStreamPlaybackPolyphonic
AudioStreamPlaybackPolyphonic :: struct {
	__private: *void;

	INVALID_ID :: -1;
}

AudioStreamPlaybackPolyphonic_play_stream :: (using self: *AudioStreamPlaybackPolyphonic, stream: AudioStream, from_offset: float, volume_db: float, pitch_scale: float, playback_type: AudioServer.PlaybackType, bus: StringName) -> int {
}
AudioStreamPlaybackPolyphonic_set_stream_volume :: (using self: *AudioStreamPlaybackPolyphonic, stream: int, volume_db: float) {
}
AudioStreamPlaybackPolyphonic_set_stream_pitch_scale :: (using self: *AudioStreamPlaybackPolyphonic, stream: int, pitch_scale: float) {
}
AudioStreamPlaybackPolyphonic_is_stream_playing :: (using self: *AudioStreamPlaybackPolyphonic, stream: int) -> bool {
}
AudioStreamPlaybackPolyphonic_stop_stream :: (using self: *AudioStreamPlaybackPolyphonic, stream: int) {
}

// AudioStreamPlaybackResampled
AudioStreamPlaybackResampled :: struct {
	__private: *void;
}

AudioStreamPlaybackResampled__mix_resampled :: (using self: *AudioStreamPlaybackResampled, dst_buffer: *AudioFrame, frame_count: int) -> int {
}
AudioStreamPlaybackResampled__get_stream_sampling_rate :: (using self: *AudioStreamPlaybackResampled) -> float {
}
AudioStreamPlaybackResampled_begin_resample :: (using self: *AudioStreamPlaybackResampled) {
}

// AudioStreamPlaybackSynchronized
AudioStreamPlaybackSynchronized :: struct {
	__private: *void;
}

// AudioStreamPlayer
AudioStreamPlayer :: struct {
	__private: *void;

	MixTarget :: enum {
		MIX_TARGET_STEREO :: 0;
		MIX_TARGET_SURROUND :: 1;
		MIX_TARGET_CENTER :: 2;
	}
}

AudioStreamPlayer_set_stream :: (using self: *AudioStreamPlayer, stream: AudioStream) {
}
AudioStreamPlayer_get_stream :: (using self: *AudioStreamPlayer) -> AudioStream {
}
AudioStreamPlayer_set_volume_db :: (using self: *AudioStreamPlayer, volume_db: float) {
}
AudioStreamPlayer_get_volume_db :: (using self: *AudioStreamPlayer) -> float {
}
AudioStreamPlayer_set_pitch_scale :: (using self: *AudioStreamPlayer, pitch_scale: float) {
}
AudioStreamPlayer_get_pitch_scale :: (using self: *AudioStreamPlayer) -> float {
}
AudioStreamPlayer_play :: (using self: *AudioStreamPlayer, from_position: float) {
}
AudioStreamPlayer_seek :: (using self: *AudioStreamPlayer, to_position: float) {
}
AudioStreamPlayer_stop :: (using self: *AudioStreamPlayer) {
}
AudioStreamPlayer_is_playing :: (using self: *AudioStreamPlayer) -> bool {
}
AudioStreamPlayer_get_playback_position :: (using self: *AudioStreamPlayer) -> float {
}
AudioStreamPlayer_set_bus :: (using self: *AudioStreamPlayer, bus: StringName) {
}
AudioStreamPlayer_get_bus :: (using self: *AudioStreamPlayer) -> StringName {
}
AudioStreamPlayer_set_autoplay :: (using self: *AudioStreamPlayer, enable: bool) {
}
AudioStreamPlayer_is_autoplay_enabled :: (using self: *AudioStreamPlayer) -> bool {
}
AudioStreamPlayer_set_mix_target :: (using self: *AudioStreamPlayer, mix_target: AudioStreamPlayer.MixTarget) {
}
AudioStreamPlayer_get_mix_target :: (using self: *AudioStreamPlayer) -> AudioStreamPlayer.MixTarget {
}
AudioStreamPlayer_set_stream_paused :: (using self: *AudioStreamPlayer, pause: bool) {
}
AudioStreamPlayer_get_stream_paused :: (using self: *AudioStreamPlayer) -> bool {
}
AudioStreamPlayer_set_max_polyphony :: (using self: *AudioStreamPlayer, max_polyphony: int) {
}
AudioStreamPlayer_get_max_polyphony :: (using self: *AudioStreamPlayer) -> int {
}
AudioStreamPlayer_has_stream_playback :: (using self: *AudioStreamPlayer) -> bool {
}
AudioStreamPlayer_get_stream_playback :: (using self: *AudioStreamPlayer) -> AudioStreamPlayback {
}
AudioStreamPlayer_set_playback_type :: (using self: *AudioStreamPlayer, playback_type: AudioServer.PlaybackType) {
}
AudioStreamPlayer_get_playback_type :: (using self: *AudioStreamPlayer) -> AudioServer.PlaybackType {
}

// AudioStreamPlayer2D
AudioStreamPlayer2D :: struct {
	__private: *void;
}

AudioStreamPlayer2D_set_stream :: (using self: *AudioStreamPlayer2D, stream: AudioStream) {
}
AudioStreamPlayer2D_get_stream :: (using self: *AudioStreamPlayer2D) -> AudioStream {
}
AudioStreamPlayer2D_set_volume_db :: (using self: *AudioStreamPlayer2D, volume_db: float) {
}
AudioStreamPlayer2D_get_volume_db :: (using self: *AudioStreamPlayer2D) -> float {
}
AudioStreamPlayer2D_set_pitch_scale :: (using self: *AudioStreamPlayer2D, pitch_scale: float) {
}
AudioStreamPlayer2D_get_pitch_scale :: (using self: *AudioStreamPlayer2D) -> float {
}
AudioStreamPlayer2D_play :: (using self: *AudioStreamPlayer2D, from_position: float) {
}
AudioStreamPlayer2D_seek :: (using self: *AudioStreamPlayer2D, to_position: float) {
}
AudioStreamPlayer2D_stop :: (using self: *AudioStreamPlayer2D) {
}
AudioStreamPlayer2D_is_playing :: (using self: *AudioStreamPlayer2D) -> bool {
}
AudioStreamPlayer2D_get_playback_position :: (using self: *AudioStreamPlayer2D) -> float {
}
AudioStreamPlayer2D_set_bus :: (using self: *AudioStreamPlayer2D, bus: StringName) {
}
AudioStreamPlayer2D_get_bus :: (using self: *AudioStreamPlayer2D) -> StringName {
}
AudioStreamPlayer2D_set_autoplay :: (using self: *AudioStreamPlayer2D, enable: bool) {
}
AudioStreamPlayer2D_is_autoplay_enabled :: (using self: *AudioStreamPlayer2D) -> bool {
}
AudioStreamPlayer2D_set_max_distance :: (using self: *AudioStreamPlayer2D, pixels: float) {
}
AudioStreamPlayer2D_get_max_distance :: (using self: *AudioStreamPlayer2D) -> float {
}
AudioStreamPlayer2D_set_attenuation :: (using self: *AudioStreamPlayer2D, curve: float) {
}
AudioStreamPlayer2D_get_attenuation :: (using self: *AudioStreamPlayer2D) -> float {
}
AudioStreamPlayer2D_set_area_mask :: (using self: *AudioStreamPlayer2D, mask: int) {
}
AudioStreamPlayer2D_get_area_mask :: (using self: *AudioStreamPlayer2D) -> int {
}
AudioStreamPlayer2D_set_stream_paused :: (using self: *AudioStreamPlayer2D, pause: bool) {
}
AudioStreamPlayer2D_get_stream_paused :: (using self: *AudioStreamPlayer2D) -> bool {
}
AudioStreamPlayer2D_set_max_polyphony :: (using self: *AudioStreamPlayer2D, max_polyphony: int) {
}
AudioStreamPlayer2D_get_max_polyphony :: (using self: *AudioStreamPlayer2D) -> int {
}
AudioStreamPlayer2D_set_panning_strength :: (using self: *AudioStreamPlayer2D, panning_strength: float) {
}
AudioStreamPlayer2D_get_panning_strength :: (using self: *AudioStreamPlayer2D) -> float {
}
AudioStreamPlayer2D_has_stream_playback :: (using self: *AudioStreamPlayer2D) -> bool {
}
AudioStreamPlayer2D_get_stream_playback :: (using self: *AudioStreamPlayer2D) -> AudioStreamPlayback {
}
AudioStreamPlayer2D_set_playback_type :: (using self: *AudioStreamPlayer2D, playback_type: AudioServer.PlaybackType) {
}
AudioStreamPlayer2D_get_playback_type :: (using self: *AudioStreamPlayer2D) -> AudioServer.PlaybackType {
}

// AudioStreamPlayer3D
AudioStreamPlayer3D :: struct {
	__private: *void;

	AttenuationModel :: enum {
		ATTENUATION_INVERSE_DISTANCE :: 0;
		ATTENUATION_INVERSE_SQUARE_DISTANCE :: 1;
		ATTENUATION_LOGARITHMIC :: 2;
		ATTENUATION_DISABLED :: 3;
	}
	DopplerTracking :: enum {
		DOPPLER_TRACKING_DISABLED :: 0;
		DOPPLER_TRACKING_IDLE_STEP :: 1;
		DOPPLER_TRACKING_PHYSICS_STEP :: 2;
	}
}

AudioStreamPlayer3D_set_stream :: (using self: *AudioStreamPlayer3D, stream: AudioStream) {
}
AudioStreamPlayer3D_get_stream :: (using self: *AudioStreamPlayer3D) -> AudioStream {
}
AudioStreamPlayer3D_set_volume_db :: (using self: *AudioStreamPlayer3D, volume_db: float) {
}
AudioStreamPlayer3D_get_volume_db :: (using self: *AudioStreamPlayer3D) -> float {
}
AudioStreamPlayer3D_set_unit_size :: (using self: *AudioStreamPlayer3D, unit_size: float) {
}
AudioStreamPlayer3D_get_unit_size :: (using self: *AudioStreamPlayer3D) -> float {
}
AudioStreamPlayer3D_set_max_db :: (using self: *AudioStreamPlayer3D, max_db: float) {
}
AudioStreamPlayer3D_get_max_db :: (using self: *AudioStreamPlayer3D) -> float {
}
AudioStreamPlayer3D_set_pitch_scale :: (using self: *AudioStreamPlayer3D, pitch_scale: float) {
}
AudioStreamPlayer3D_get_pitch_scale :: (using self: *AudioStreamPlayer3D) -> float {
}
AudioStreamPlayer3D_play :: (using self: *AudioStreamPlayer3D, from_position: float) {
}
AudioStreamPlayer3D_seek :: (using self: *AudioStreamPlayer3D, to_position: float) {
}
AudioStreamPlayer3D_stop :: (using self: *AudioStreamPlayer3D) {
}
AudioStreamPlayer3D_is_playing :: (using self: *AudioStreamPlayer3D) -> bool {
}
AudioStreamPlayer3D_get_playback_position :: (using self: *AudioStreamPlayer3D) -> float {
}
AudioStreamPlayer3D_set_bus :: (using self: *AudioStreamPlayer3D, bus: StringName) {
}
AudioStreamPlayer3D_get_bus :: (using self: *AudioStreamPlayer3D) -> StringName {
}
AudioStreamPlayer3D_set_autoplay :: (using self: *AudioStreamPlayer3D, enable: bool) {
}
AudioStreamPlayer3D_is_autoplay_enabled :: (using self: *AudioStreamPlayer3D) -> bool {
}
AudioStreamPlayer3D_set_max_distance :: (using self: *AudioStreamPlayer3D, meters: float) {
}
AudioStreamPlayer3D_get_max_distance :: (using self: *AudioStreamPlayer3D) -> float {
}
AudioStreamPlayer3D_set_area_mask :: (using self: *AudioStreamPlayer3D, mask: int) {
}
AudioStreamPlayer3D_get_area_mask :: (using self: *AudioStreamPlayer3D) -> int {
}
AudioStreamPlayer3D_set_emission_angle :: (using self: *AudioStreamPlayer3D, degrees: float) {
}
AudioStreamPlayer3D_get_emission_angle :: (using self: *AudioStreamPlayer3D) -> float {
}
AudioStreamPlayer3D_set_emission_angle_enabled :: (using self: *AudioStreamPlayer3D, enabled: bool) {
}
AudioStreamPlayer3D_is_emission_angle_enabled :: (using self: *AudioStreamPlayer3D) -> bool {
}
AudioStreamPlayer3D_set_emission_angle_filter_attenuation_db :: (using self: *AudioStreamPlayer3D, db: float) {
}
AudioStreamPlayer3D_get_emission_angle_filter_attenuation_db :: (using self: *AudioStreamPlayer3D) -> float {
}
AudioStreamPlayer3D_set_attenuation_filter_cutoff_hz :: (using self: *AudioStreamPlayer3D, degrees: float) {
}
AudioStreamPlayer3D_get_attenuation_filter_cutoff_hz :: (using self: *AudioStreamPlayer3D) -> float {
}
AudioStreamPlayer3D_set_attenuation_filter_db :: (using self: *AudioStreamPlayer3D, db: float) {
}
AudioStreamPlayer3D_get_attenuation_filter_db :: (using self: *AudioStreamPlayer3D) -> float {
}
AudioStreamPlayer3D_set_attenuation_model :: (using self: *AudioStreamPlayer3D, model: AudioStreamPlayer3D.AttenuationModel) {
}
AudioStreamPlayer3D_get_attenuation_model :: (using self: *AudioStreamPlayer3D) -> AudioStreamPlayer3D.AttenuationModel {
}
AudioStreamPlayer3D_set_doppler_tracking :: (using self: *AudioStreamPlayer3D, mode: AudioStreamPlayer3D.DopplerTracking) {
}
AudioStreamPlayer3D_get_doppler_tracking :: (using self: *AudioStreamPlayer3D) -> AudioStreamPlayer3D.DopplerTracking {
}
AudioStreamPlayer3D_set_stream_paused :: (using self: *AudioStreamPlayer3D, pause: bool) {
}
AudioStreamPlayer3D_get_stream_paused :: (using self: *AudioStreamPlayer3D) -> bool {
}
AudioStreamPlayer3D_set_max_polyphony :: (using self: *AudioStreamPlayer3D, max_polyphony: int) {
}
AudioStreamPlayer3D_get_max_polyphony :: (using self: *AudioStreamPlayer3D) -> int {
}
AudioStreamPlayer3D_set_panning_strength :: (using self: *AudioStreamPlayer3D, panning_strength: float) {
}
AudioStreamPlayer3D_get_panning_strength :: (using self: *AudioStreamPlayer3D) -> float {
}
AudioStreamPlayer3D_has_stream_playback :: (using self: *AudioStreamPlayer3D) -> bool {
}
AudioStreamPlayer3D_get_stream_playback :: (using self: *AudioStreamPlayer3D) -> AudioStreamPlayback {
}
AudioStreamPlayer3D_set_playback_type :: (using self: *AudioStreamPlayer3D, playback_type: AudioServer.PlaybackType) {
}
AudioStreamPlayer3D_get_playback_type :: (using self: *AudioStreamPlayer3D) -> AudioServer.PlaybackType {
}

// AudioStreamPlaylist
AudioStreamPlaylist :: struct {
	__private: *void;

	MAX_STREAMS :: 64;
}

AudioStreamPlaylist_set_stream_count :: (using self: *AudioStreamPlaylist, stream_count: int) {
}
AudioStreamPlaylist_get_stream_count :: (using self: *AudioStreamPlaylist) -> int {
}
AudioStreamPlaylist_get_bpm :: (using self: *AudioStreamPlaylist) -> float {
}
AudioStreamPlaylist_set_list_stream :: (using self: *AudioStreamPlaylist, stream_index: int, audio_stream: AudioStream) {
}
AudioStreamPlaylist_get_list_stream :: (using self: *AudioStreamPlaylist, stream_index: int) -> AudioStream {
}
AudioStreamPlaylist_set_shuffle :: (using self: *AudioStreamPlaylist, shuffle: bool) {
}
AudioStreamPlaylist_get_shuffle :: (using self: *AudioStreamPlaylist) -> bool {
}
AudioStreamPlaylist_set_fade_time :: (using self: *AudioStreamPlaylist, dec: float) {
}
AudioStreamPlaylist_get_fade_time :: (using self: *AudioStreamPlaylist) -> float {
}
AudioStreamPlaylist_set_loop :: (using self: *AudioStreamPlaylist, loop: bool) {
}
AudioStreamPlaylist_has_loop :: (using self: *AudioStreamPlaylist) -> bool {
}

// AudioStreamPolyphonic
AudioStreamPolyphonic :: struct {
	__private: *void;
}

AudioStreamPolyphonic_set_polyphony :: (using self: *AudioStreamPolyphonic, voices: int) {
}
AudioStreamPolyphonic_get_polyphony :: (using self: *AudioStreamPolyphonic) -> int {
}

// AudioStreamRandomizer
AudioStreamRandomizer :: struct {
	__private: *void;

	PlaybackMode :: enum {
		PLAYBACK_RANDOM_NO_REPEATS :: 0;
		PLAYBACK_RANDOM :: 1;
		PLAYBACK_SEQUENTIAL :: 2;
	}
}

AudioStreamRandomizer_add_stream :: (using self: *AudioStreamRandomizer, index: int, stream: AudioStream, weight: float) {
}
AudioStreamRandomizer_move_stream :: (using self: *AudioStreamRandomizer, index_from: int, index_to: int) {
}
AudioStreamRandomizer_remove_stream :: (using self: *AudioStreamRandomizer, index: int) {
}
AudioStreamRandomizer_set_stream :: (using self: *AudioStreamRandomizer, index: int, stream: AudioStream) {
}
AudioStreamRandomizer_get_stream :: (using self: *AudioStreamRandomizer, index: int) -> AudioStream {
}
AudioStreamRandomizer_set_stream_probability_weight :: (using self: *AudioStreamRandomizer, index: int, weight: float) {
}
AudioStreamRandomizer_get_stream_probability_weight :: (using self: *AudioStreamRandomizer, index: int) -> float {
}
AudioStreamRandomizer_set_streams_count :: (using self: *AudioStreamRandomizer, count: int) {
}
AudioStreamRandomizer_get_streams_count :: (using self: *AudioStreamRandomizer) -> int {
}
AudioStreamRandomizer_set_random_pitch :: (using self: *AudioStreamRandomizer, scale: float) {
}
AudioStreamRandomizer_get_random_pitch :: (using self: *AudioStreamRandomizer) -> float {
}
AudioStreamRandomizer_set_random_volume_offset_db :: (using self: *AudioStreamRandomizer, db_offset: float) {
}
AudioStreamRandomizer_get_random_volume_offset_db :: (using self: *AudioStreamRandomizer) -> float {
}
AudioStreamRandomizer_set_playback_mode :: (using self: *AudioStreamRandomizer, mode: AudioStreamRandomizer.PlaybackMode) {
}
AudioStreamRandomizer_get_playback_mode :: (using self: *AudioStreamRandomizer) -> AudioStreamRandomizer.PlaybackMode {
}

// AudioStreamSynchronized
AudioStreamSynchronized :: struct {
	__private: *void;

	MAX_STREAMS :: 32;
}

AudioStreamSynchronized_set_stream_count :: (using self: *AudioStreamSynchronized, stream_count: int) {
}
AudioStreamSynchronized_get_stream_count :: (using self: *AudioStreamSynchronized) -> int {
}
AudioStreamSynchronized_set_sync_stream :: (using self: *AudioStreamSynchronized, stream_index: int, audio_stream: AudioStream) {
}
AudioStreamSynchronized_get_sync_stream :: (using self: *AudioStreamSynchronized, stream_index: int) -> AudioStream {
}
AudioStreamSynchronized_set_sync_stream_volume :: (using self: *AudioStreamSynchronized, stream_index: int, volume_db: float) {
}
AudioStreamSynchronized_get_sync_stream_volume :: (using self: *AudioStreamSynchronized, stream_index: int) -> float {
}

// AudioStreamWAV
AudioStreamWAV :: struct {
	__private: *void;

	Format :: enum {
		FORMAT_8_BITS :: 0;
		FORMAT_16_BITS :: 1;
		FORMAT_IMA_ADPCM :: 2;
		FORMAT_QOA :: 3;
	}
	LoopMode :: enum {
		LOOP_DISABLED :: 0;
		LOOP_FORWARD :: 1;
		LOOP_PINGPONG :: 2;
		LOOP_BACKWARD :: 3;
	}
}

AudioStreamWAV_set_data :: (using self: *AudioStreamWAV, data: PackedByteArray) {
}
AudioStreamWAV_get_data :: (using self: *AudioStreamWAV) -> PackedByteArray {
}
AudioStreamWAV_set_format :: (using self: *AudioStreamWAV, format: AudioStreamWAV.Format) {
}
AudioStreamWAV_get_format :: (using self: *AudioStreamWAV) -> AudioStreamWAV.Format {
}
AudioStreamWAV_set_loop_mode :: (using self: *AudioStreamWAV, loop_mode: AudioStreamWAV.LoopMode) {
}
AudioStreamWAV_get_loop_mode :: (using self: *AudioStreamWAV) -> AudioStreamWAV.LoopMode {
}
AudioStreamWAV_set_loop_begin :: (using self: *AudioStreamWAV, loop_begin: int) {
}
AudioStreamWAV_get_loop_begin :: (using self: *AudioStreamWAV) -> int {
}
AudioStreamWAV_set_loop_end :: (using self: *AudioStreamWAV, loop_end: int) {
}
AudioStreamWAV_get_loop_end :: (using self: *AudioStreamWAV) -> int {
}
AudioStreamWAV_set_mix_rate :: (using self: *AudioStreamWAV, mix_rate: int) {
}
AudioStreamWAV_get_mix_rate :: (using self: *AudioStreamWAV) -> int {
}
AudioStreamWAV_set_stereo :: (using self: *AudioStreamWAV, stereo: bool) {
}
AudioStreamWAV_is_stereo :: (using self: *AudioStreamWAV) -> bool {
}
AudioStreamWAV_save_to_wav :: (using self: *AudioStreamWAV, path: String) -> Error {
}

// BackBufferCopy
BackBufferCopy :: struct {
	__private: *void;

	CopyMode :: enum {
		COPY_MODE_DISABLED :: 0;
		COPY_MODE_RECT :: 1;
		COPY_MODE_VIEWPORT :: 2;
	}
}

BackBufferCopy_set_rect :: (using self: *BackBufferCopy, rect: Rect2) {
}
BackBufferCopy_get_rect :: (using self: *BackBufferCopy) -> Rect2 {
}
BackBufferCopy_set_copy_mode :: (using self: *BackBufferCopy, copy_mode: BackBufferCopy.CopyMode) {
}
BackBufferCopy_get_copy_mode :: (using self: *BackBufferCopy) -> BackBufferCopy.CopyMode {
}

// BaseButton
BaseButton :: struct {
	__private: *void;

	DrawMode :: enum {
		DRAW_NORMAL :: 0;
		DRAW_PRESSED :: 1;
		DRAW_HOVER :: 2;
		DRAW_DISABLED :: 3;
		DRAW_HOVER_PRESSED :: 4;
	}
	ActionMode :: enum {
		ACTION_MODE_BUTTON_PRESS :: 0;
		ACTION_MODE_BUTTON_RELEASE :: 1;
	}
}

BaseButton__pressed :: (using self: *BaseButton) {
}
BaseButton__toggled :: (using self: *BaseButton, toggled_on: bool) {
}
BaseButton_set_pressed :: (using self: *BaseButton, pressed: bool) {
}
BaseButton_is_pressed :: (using self: *BaseButton) -> bool {
}
BaseButton_set_pressed_no_signal :: (using self: *BaseButton, pressed: bool) {
}
BaseButton_is_hovered :: (using self: *BaseButton) -> bool {
}
BaseButton_set_toggle_mode :: (using self: *BaseButton, enabled: bool) {
}
BaseButton_is_toggle_mode :: (using self: *BaseButton) -> bool {
}
BaseButton_set_shortcut_in_tooltip :: (using self: *BaseButton, enabled: bool) {
}
BaseButton_is_shortcut_in_tooltip_enabled :: (using self: *BaseButton) -> bool {
}
BaseButton_set_disabled :: (using self: *BaseButton, disabled: bool) {
}
BaseButton_is_disabled :: (using self: *BaseButton) -> bool {
}
BaseButton_set_action_mode :: (using self: *BaseButton, mode: BaseButton.ActionMode) {
}
BaseButton_get_action_mode :: (using self: *BaseButton) -> BaseButton.ActionMode {
}
BaseButton_set_button_mask :: (using self: *BaseButton, mask: MouseButtonMask) {
}
BaseButton_get_button_mask :: (using self: *BaseButton) -> MouseButtonMask {
}
BaseButton_get_draw_mode :: (using self: *BaseButton) -> BaseButton.DrawMode {
}
BaseButton_set_keep_pressed_outside :: (using self: *BaseButton, enabled: bool) {
}
BaseButton_is_keep_pressed_outside :: (using self: *BaseButton) -> bool {
}
BaseButton_set_shortcut_feedback :: (using self: *BaseButton, enabled: bool) {
}
BaseButton_is_shortcut_feedback :: (using self: *BaseButton) -> bool {
}
BaseButton_set_shortcut :: (using self: *BaseButton, shortcut: Shortcut) {
}
BaseButton_get_shortcut :: (using self: *BaseButton) -> Shortcut {
}
BaseButton_set_button_group :: (using self: *BaseButton, button_group: ButtonGroup) {
}
BaseButton_get_button_group :: (using self: *BaseButton) -> ButtonGroup {
}

// BaseMaterial3D
BaseMaterial3D :: struct {
	__private: *void;

	TextureParam :: enum {
		TEXTURE_ALBEDO :: 0;
		TEXTURE_METALLIC :: 1;
		TEXTURE_ROUGHNESS :: 2;
		TEXTURE_EMISSION :: 3;
		TEXTURE_NORMAL :: 4;
		TEXTURE_RIM :: 5;
		TEXTURE_CLEARCOAT :: 6;
		TEXTURE_FLOWMAP :: 7;
		TEXTURE_AMBIENT_OCCLUSION :: 8;
		TEXTURE_HEIGHTMAP :: 9;
		TEXTURE_SUBSURFACE_SCATTERING :: 10;
		TEXTURE_SUBSURFACE_TRANSMITTANCE :: 11;
		TEXTURE_BACKLIGHT :: 12;
		TEXTURE_REFRACTION :: 13;
		TEXTURE_DETAIL_MASK :: 14;
		TEXTURE_DETAIL_ALBEDO :: 15;
		TEXTURE_DETAIL_NORMAL :: 16;
		TEXTURE_ORM :: 17;
		TEXTURE_MAX :: 18;
	}
	TextureFilter :: enum {
		TEXTURE_FILTER_NEAREST :: 0;
		TEXTURE_FILTER_LINEAR :: 1;
		TEXTURE_FILTER_NEAREST_WITH_MIPMAPS :: 2;
		TEXTURE_FILTER_LINEAR_WITH_MIPMAPS :: 3;
		TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC :: 4;
		TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC :: 5;
		TEXTURE_FILTER_MAX :: 6;
	}
	DetailUV :: enum {
		DETAIL_UV_1 :: 0;
		DETAIL_UV_2 :: 1;
	}
	Transparency :: enum {
		TRANSPARENCY_DISABLED :: 0;
		TRANSPARENCY_ALPHA :: 1;
		TRANSPARENCY_ALPHA_SCISSOR :: 2;
		TRANSPARENCY_ALPHA_HASH :: 3;
		TRANSPARENCY_ALPHA_DEPTH_PRE_PASS :: 4;
		TRANSPARENCY_MAX :: 5;
	}
	ShadingMode :: enum {
		SHADING_MODE_UNSHADED :: 0;
		SHADING_MODE_PER_PIXEL :: 1;
		SHADING_MODE_PER_VERTEX :: 2;
		SHADING_MODE_MAX :: 3;
	}
	Feature :: enum {
		FEATURE_EMISSION :: 0;
		FEATURE_NORMAL_MAPPING :: 1;
		FEATURE_RIM :: 2;
		FEATURE_CLEARCOAT :: 3;
		FEATURE_ANISOTROPY :: 4;
		FEATURE_AMBIENT_OCCLUSION :: 5;
		FEATURE_HEIGHT_MAPPING :: 6;
		FEATURE_SUBSURFACE_SCATTERING :: 7;
		FEATURE_SUBSURFACE_TRANSMITTANCE :: 8;
		FEATURE_BACKLIGHT :: 9;
		FEATURE_REFRACTION :: 10;
		FEATURE_DETAIL :: 11;
		FEATURE_MAX :: 12;
	}
	BlendMode :: enum {
		BLEND_MODE_MIX :: 0;
		BLEND_MODE_ADD :: 1;
		BLEND_MODE_SUB :: 2;
		BLEND_MODE_MUL :: 3;
		BLEND_MODE_PREMULT_ALPHA :: 4;
	}
	AlphaAntiAliasing :: enum {
		ALPHA_ANTIALIASING_OFF :: 0;
		ALPHA_ANTIALIASING_ALPHA_TO_COVERAGE :: 1;
		ALPHA_ANTIALIASING_ALPHA_TO_COVERAGE_AND_TO_ONE :: 2;
	}
	DepthDrawMode :: enum {
		DEPTH_DRAW_OPAQUE_ONLY :: 0;
		DEPTH_DRAW_ALWAYS :: 1;
		DEPTH_DRAW_DISABLED :: 2;
	}
	CullMode :: enum {
		CULL_BACK :: 0;
		CULL_FRONT :: 1;
		CULL_DISABLED :: 2;
	}
	Flags :: enum {
		FLAG_DISABLE_DEPTH_TEST :: 0;
		FLAG_ALBEDO_FROM_VERTEX_COLOR :: 1;
		FLAG_SRGB_VERTEX_COLOR :: 2;
		FLAG_USE_POINT_SIZE :: 3;
		FLAG_FIXED_SIZE :: 4;
		FLAG_BILLBOARD_KEEP_SCALE :: 5;
		FLAG_UV1_USE_TRIPLANAR :: 6;
		FLAG_UV2_USE_TRIPLANAR :: 7;
		FLAG_UV1_USE_WORLD_TRIPLANAR :: 8;
		FLAG_UV2_USE_WORLD_TRIPLANAR :: 9;
		FLAG_AO_ON_UV2 :: 10;
		FLAG_EMISSION_ON_UV2 :: 11;
		FLAG_ALBEDO_TEXTURE_FORCE_SRGB :: 12;
		FLAG_DONT_RECEIVE_SHADOWS :: 13;
		FLAG_DISABLE_AMBIENT_LIGHT :: 14;
		FLAG_USE_SHADOW_TO_OPACITY :: 15;
		FLAG_USE_TEXTURE_REPEAT :: 16;
		FLAG_INVERT_HEIGHTMAP :: 17;
		FLAG_SUBSURFACE_MODE_SKIN :: 18;
		FLAG_PARTICLE_TRAILS_MODE :: 19;
		FLAG_ALBEDO_TEXTURE_MSDF :: 20;
		FLAG_DISABLE_FOG :: 21;
		FLAG_MAX :: 22;
	}
	DiffuseMode :: enum {
		DIFFUSE_BURLEY :: 0;
		DIFFUSE_LAMBERT :: 1;
		DIFFUSE_LAMBERT_WRAP :: 2;
		DIFFUSE_TOON :: 3;
	}
	SpecularMode :: enum {
		SPECULAR_SCHLICK_GGX :: 0;
		SPECULAR_TOON :: 1;
		SPECULAR_DISABLED :: 2;
	}
	BillboardMode :: enum {
		BILLBOARD_DISABLED :: 0;
		BILLBOARD_ENABLED :: 1;
		BILLBOARD_FIXED_Y :: 2;
		BILLBOARD_PARTICLES :: 3;
	}
	TextureChannel :: enum {
		TEXTURE_CHANNEL_RED :: 0;
		TEXTURE_CHANNEL_GREEN :: 1;
		TEXTURE_CHANNEL_BLUE :: 2;
		TEXTURE_CHANNEL_ALPHA :: 3;
		TEXTURE_CHANNEL_GRAYSCALE :: 4;
	}
	EmissionOperator :: enum {
		EMISSION_OP_ADD :: 0;
		EMISSION_OP_MULTIPLY :: 1;
	}
	DistanceFadeMode :: enum {
		DISTANCE_FADE_DISABLED :: 0;
		DISTANCE_FADE_PIXEL_ALPHA :: 1;
		DISTANCE_FADE_PIXEL_DITHER :: 2;
		DISTANCE_FADE_OBJECT_DITHER :: 3;
	}
}

BaseMaterial3D_set_albedo :: (using self: *BaseMaterial3D, albedo: Color) {
}
BaseMaterial3D_get_albedo :: (using self: *BaseMaterial3D) -> Color {
}
BaseMaterial3D_set_transparency :: (using self: *BaseMaterial3D, transparency: BaseMaterial3D.Transparency) {
}
BaseMaterial3D_get_transparency :: (using self: *BaseMaterial3D) -> BaseMaterial3D.Transparency {
}
BaseMaterial3D_set_alpha_antialiasing :: (using self: *BaseMaterial3D, alpha_aa: BaseMaterial3D.AlphaAntiAliasing) {
}
BaseMaterial3D_get_alpha_antialiasing :: (using self: *BaseMaterial3D) -> BaseMaterial3D.AlphaAntiAliasing {
}
BaseMaterial3D_set_alpha_antialiasing_edge :: (using self: *BaseMaterial3D, edge: float) {
}
BaseMaterial3D_get_alpha_antialiasing_edge :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_shading_mode :: (using self: *BaseMaterial3D, shading_mode: BaseMaterial3D.ShadingMode) {
}
BaseMaterial3D_get_shading_mode :: (using self: *BaseMaterial3D) -> BaseMaterial3D.ShadingMode {
}
BaseMaterial3D_set_specular :: (using self: *BaseMaterial3D, specular: float) {
}
BaseMaterial3D_get_specular :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_metallic :: (using self: *BaseMaterial3D, metallic: float) {
}
BaseMaterial3D_get_metallic :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_roughness :: (using self: *BaseMaterial3D, roughness: float) {
}
BaseMaterial3D_get_roughness :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_emission :: (using self: *BaseMaterial3D, emission: Color) {
}
BaseMaterial3D_get_emission :: (using self: *BaseMaterial3D) -> Color {
}
BaseMaterial3D_set_emission_energy_multiplier :: (using self: *BaseMaterial3D, emission_energy_multiplier: float) {
}
BaseMaterial3D_get_emission_energy_multiplier :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_emission_intensity :: (using self: *BaseMaterial3D, emission_energy_multiplier: float) {
}
BaseMaterial3D_get_emission_intensity :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_normal_scale :: (using self: *BaseMaterial3D, normal_scale: float) {
}
BaseMaterial3D_get_normal_scale :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_rim :: (using self: *BaseMaterial3D, rim: float) {
}
BaseMaterial3D_get_rim :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_rim_tint :: (using self: *BaseMaterial3D, rim_tint: float) {
}
BaseMaterial3D_get_rim_tint :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_clearcoat :: (using self: *BaseMaterial3D, clearcoat: float) {
}
BaseMaterial3D_get_clearcoat :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_clearcoat_roughness :: (using self: *BaseMaterial3D, clearcoat_roughness: float) {
}
BaseMaterial3D_get_clearcoat_roughness :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_anisotropy :: (using self: *BaseMaterial3D, anisotropy: float) {
}
BaseMaterial3D_get_anisotropy :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_heightmap_scale :: (using self: *BaseMaterial3D, heightmap_scale: float) {
}
BaseMaterial3D_get_heightmap_scale :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_subsurface_scattering_strength :: (using self: *BaseMaterial3D, strength: float) {
}
BaseMaterial3D_get_subsurface_scattering_strength :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_transmittance_color :: (using self: *BaseMaterial3D, color: Color) {
}
BaseMaterial3D_get_transmittance_color :: (using self: *BaseMaterial3D) -> Color {
}
BaseMaterial3D_set_transmittance_depth :: (using self: *BaseMaterial3D, depth: float) {
}
BaseMaterial3D_get_transmittance_depth :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_transmittance_boost :: (using self: *BaseMaterial3D, boost: float) {
}
BaseMaterial3D_get_transmittance_boost :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_backlight :: (using self: *BaseMaterial3D, backlight: Color) {
}
BaseMaterial3D_get_backlight :: (using self: *BaseMaterial3D) -> Color {
}
BaseMaterial3D_set_refraction :: (using self: *BaseMaterial3D, refraction: float) {
}
BaseMaterial3D_get_refraction :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_point_size :: (using self: *BaseMaterial3D, point_size: float) {
}
BaseMaterial3D_get_point_size :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_detail_uv :: (using self: *BaseMaterial3D, detail_uv: BaseMaterial3D.DetailUV) {
}
BaseMaterial3D_get_detail_uv :: (using self: *BaseMaterial3D) -> BaseMaterial3D.DetailUV {
}
BaseMaterial3D_set_blend_mode :: (using self: *BaseMaterial3D, blend_mode: BaseMaterial3D.BlendMode) {
}
BaseMaterial3D_get_blend_mode :: (using self: *BaseMaterial3D) -> BaseMaterial3D.BlendMode {
}
BaseMaterial3D_set_depth_draw_mode :: (using self: *BaseMaterial3D, depth_draw_mode: BaseMaterial3D.DepthDrawMode) {
}
BaseMaterial3D_get_depth_draw_mode :: (using self: *BaseMaterial3D) -> BaseMaterial3D.DepthDrawMode {
}
BaseMaterial3D_set_cull_mode :: (using self: *BaseMaterial3D, cull_mode: BaseMaterial3D.CullMode) {
}
BaseMaterial3D_get_cull_mode :: (using self: *BaseMaterial3D) -> BaseMaterial3D.CullMode {
}
BaseMaterial3D_set_diffuse_mode :: (using self: *BaseMaterial3D, diffuse_mode: BaseMaterial3D.DiffuseMode) {
}
BaseMaterial3D_get_diffuse_mode :: (using self: *BaseMaterial3D) -> BaseMaterial3D.DiffuseMode {
}
BaseMaterial3D_set_specular_mode :: (using self: *BaseMaterial3D, specular_mode: BaseMaterial3D.SpecularMode) {
}
BaseMaterial3D_get_specular_mode :: (using self: *BaseMaterial3D) -> BaseMaterial3D.SpecularMode {
}
BaseMaterial3D_set_flag :: (using self: *BaseMaterial3D, flag: BaseMaterial3D.Flags, enable: bool) {
}
BaseMaterial3D_get_flag :: (using self: *BaseMaterial3D, flag: BaseMaterial3D.Flags) -> bool {
}
BaseMaterial3D_set_texture_filter :: (using self: *BaseMaterial3D, mode: BaseMaterial3D.TextureFilter) {
}
BaseMaterial3D_get_texture_filter :: (using self: *BaseMaterial3D) -> BaseMaterial3D.TextureFilter {
}
BaseMaterial3D_set_feature :: (using self: *BaseMaterial3D, feature: BaseMaterial3D.Feature, enable: bool) {
}
BaseMaterial3D_get_feature :: (using self: *BaseMaterial3D, feature: BaseMaterial3D.Feature) -> bool {
}
BaseMaterial3D_set_texture :: (using self: *BaseMaterial3D, param: BaseMaterial3D.TextureParam, texture: Texture2D) {
}
BaseMaterial3D_get_texture :: (using self: *BaseMaterial3D, param: BaseMaterial3D.TextureParam) -> Texture2D {
}
BaseMaterial3D_set_detail_blend_mode :: (using self: *BaseMaterial3D, detail_blend_mode: BaseMaterial3D.BlendMode) {
}
BaseMaterial3D_get_detail_blend_mode :: (using self: *BaseMaterial3D) -> BaseMaterial3D.BlendMode {
}
BaseMaterial3D_set_uv1_scale :: (using self: *BaseMaterial3D, scale: Vector3) {
}
BaseMaterial3D_get_uv1_scale :: (using self: *BaseMaterial3D) -> Vector3 {
}
BaseMaterial3D_set_uv1_offset :: (using self: *BaseMaterial3D, offset: Vector3) {
}
BaseMaterial3D_get_uv1_offset :: (using self: *BaseMaterial3D) -> Vector3 {
}
BaseMaterial3D_set_uv1_triplanar_blend_sharpness :: (using self: *BaseMaterial3D, sharpness: float) {
}
BaseMaterial3D_get_uv1_triplanar_blend_sharpness :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_uv2_scale :: (using self: *BaseMaterial3D, scale: Vector3) {
}
BaseMaterial3D_get_uv2_scale :: (using self: *BaseMaterial3D) -> Vector3 {
}
BaseMaterial3D_set_uv2_offset :: (using self: *BaseMaterial3D, offset: Vector3) {
}
BaseMaterial3D_get_uv2_offset :: (using self: *BaseMaterial3D) -> Vector3 {
}
BaseMaterial3D_set_uv2_triplanar_blend_sharpness :: (using self: *BaseMaterial3D, sharpness: float) {
}
BaseMaterial3D_get_uv2_triplanar_blend_sharpness :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_billboard_mode :: (using self: *BaseMaterial3D, mode: BaseMaterial3D.BillboardMode) {
}
BaseMaterial3D_get_billboard_mode :: (using self: *BaseMaterial3D) -> BaseMaterial3D.BillboardMode {
}
BaseMaterial3D_set_particles_anim_h_frames :: (using self: *BaseMaterial3D, frames: int) {
}
BaseMaterial3D_get_particles_anim_h_frames :: (using self: *BaseMaterial3D) -> int {
}
BaseMaterial3D_set_particles_anim_v_frames :: (using self: *BaseMaterial3D, frames: int) {
}
BaseMaterial3D_get_particles_anim_v_frames :: (using self: *BaseMaterial3D) -> int {
}
BaseMaterial3D_set_particles_anim_loop :: (using self: *BaseMaterial3D, loop: bool) {
}
BaseMaterial3D_get_particles_anim_loop :: (using self: *BaseMaterial3D) -> bool {
}
BaseMaterial3D_set_heightmap_deep_parallax :: (using self: *BaseMaterial3D, enable: bool) {
}
BaseMaterial3D_is_heightmap_deep_parallax_enabled :: (using self: *BaseMaterial3D) -> bool {
}
BaseMaterial3D_set_heightmap_deep_parallax_min_layers :: (using self: *BaseMaterial3D, layer: int) {
}
BaseMaterial3D_get_heightmap_deep_parallax_min_layers :: (using self: *BaseMaterial3D) -> int {
}
BaseMaterial3D_set_heightmap_deep_parallax_max_layers :: (using self: *BaseMaterial3D, layer: int) {
}
BaseMaterial3D_get_heightmap_deep_parallax_max_layers :: (using self: *BaseMaterial3D) -> int {
}
BaseMaterial3D_set_heightmap_deep_parallax_flip_tangent :: (using self: *BaseMaterial3D, flip: bool) {
}
BaseMaterial3D_get_heightmap_deep_parallax_flip_tangent :: (using self: *BaseMaterial3D) -> bool {
}
BaseMaterial3D_set_heightmap_deep_parallax_flip_binormal :: (using self: *BaseMaterial3D, flip: bool) {
}
BaseMaterial3D_get_heightmap_deep_parallax_flip_binormal :: (using self: *BaseMaterial3D) -> bool {
}
BaseMaterial3D_set_grow :: (using self: *BaseMaterial3D, amount: float) {
}
BaseMaterial3D_get_grow :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_emission_operator :: (using self: *BaseMaterial3D, _operator: BaseMaterial3D.EmissionOperator) {
}
BaseMaterial3D_get_emission_operator :: (using self: *BaseMaterial3D) -> BaseMaterial3D.EmissionOperator {
}
BaseMaterial3D_set_ao_light_affect :: (using self: *BaseMaterial3D, amount: float) {
}
BaseMaterial3D_get_ao_light_affect :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_alpha_scissor_threshold :: (using self: *BaseMaterial3D, threshold: float) {
}
BaseMaterial3D_get_alpha_scissor_threshold :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_alpha_hash_scale :: (using self: *BaseMaterial3D, threshold: float) {
}
BaseMaterial3D_get_alpha_hash_scale :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_grow_enabled :: (using self: *BaseMaterial3D, enable: bool) {
}
BaseMaterial3D_is_grow_enabled :: (using self: *BaseMaterial3D) -> bool {
}
BaseMaterial3D_set_metallic_texture_channel :: (using self: *BaseMaterial3D, channel: BaseMaterial3D.TextureChannel) {
}
BaseMaterial3D_get_metallic_texture_channel :: (using self: *BaseMaterial3D) -> BaseMaterial3D.TextureChannel {
}
BaseMaterial3D_set_roughness_texture_channel :: (using self: *BaseMaterial3D, channel: BaseMaterial3D.TextureChannel) {
}
BaseMaterial3D_get_roughness_texture_channel :: (using self: *BaseMaterial3D) -> BaseMaterial3D.TextureChannel {
}
BaseMaterial3D_set_ao_texture_channel :: (using self: *BaseMaterial3D, channel: BaseMaterial3D.TextureChannel) {
}
BaseMaterial3D_get_ao_texture_channel :: (using self: *BaseMaterial3D) -> BaseMaterial3D.TextureChannel {
}
BaseMaterial3D_set_refraction_texture_channel :: (using self: *BaseMaterial3D, channel: BaseMaterial3D.TextureChannel) {
}
BaseMaterial3D_get_refraction_texture_channel :: (using self: *BaseMaterial3D) -> BaseMaterial3D.TextureChannel {
}
BaseMaterial3D_set_proximity_fade_enabled :: (using self: *BaseMaterial3D, enabled: bool) {
}
BaseMaterial3D_is_proximity_fade_enabled :: (using self: *BaseMaterial3D) -> bool {
}
BaseMaterial3D_set_proximity_fade_distance :: (using self: *BaseMaterial3D, distance: float) {
}
BaseMaterial3D_get_proximity_fade_distance :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_msdf_pixel_range :: (using self: *BaseMaterial3D, range: float) {
}
BaseMaterial3D_get_msdf_pixel_range :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_msdf_outline_size :: (using self: *BaseMaterial3D, size: float) {
}
BaseMaterial3D_get_msdf_outline_size :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_distance_fade :: (using self: *BaseMaterial3D, mode: BaseMaterial3D.DistanceFadeMode) {
}
BaseMaterial3D_get_distance_fade :: (using self: *BaseMaterial3D) -> BaseMaterial3D.DistanceFadeMode {
}
BaseMaterial3D_set_distance_fade_max_distance :: (using self: *BaseMaterial3D, distance: float) {
}
BaseMaterial3D_get_distance_fade_max_distance :: (using self: *BaseMaterial3D) -> float {
}
BaseMaterial3D_set_distance_fade_min_distance :: (using self: *BaseMaterial3D, distance: float) {
}
BaseMaterial3D_get_distance_fade_min_distance :: (using self: *BaseMaterial3D) -> float {
}

// BitMap
BitMap :: struct {
	__private: *void;
}

BitMap_create :: (using self: *BitMap, size: Vector2i) {
}
BitMap_create_from_image_alpha :: (using self: *BitMap, image: Image, threshold: float) {
}
BitMap_set_bitv :: (using self: *BitMap, position: Vector2i, bit: bool) {
}
BitMap_set_bit :: (using self: *BitMap, x: int, y: int, bit: bool) {
}
BitMap_get_bitv :: (using self: *BitMap, position: Vector2i) -> bool {
}
BitMap_get_bit :: (using self: *BitMap, x: int, y: int) -> bool {
}
BitMap_set_bit_rect :: (using self: *BitMap, rect: Rect2i, bit: bool) {
}
BitMap_get_true_bit_count :: (using self: *BitMap) -> int {
}
BitMap_get_size :: (using self: *BitMap) -> Vector2i {
}
BitMap_resize :: (using self: *BitMap, new_size: Vector2i) {
}
BitMap_grow_mask :: (using self: *BitMap, pixels: int, rect: Rect2i) {
}
BitMap_convert_to_image :: (using self: *BitMap) -> Image {
}
BitMap_opaque_to_polygons :: (using self: *BitMap, rect: Rect2i, epsilon: float) -> Array {
}

// Bone2D
Bone2D :: struct {
	__private: *void;
}

Bone2D_set_rest :: (using self: *Bone2D, rest: Transform2D) {
}
Bone2D_get_rest :: (using self: *Bone2D) -> Transform2D {
}
Bone2D_apply_rest :: (using self: *Bone2D) {
}
Bone2D_get_skeleton_rest :: (using self: *Bone2D) -> Transform2D {
}
Bone2D_get_index_in_skeleton :: (using self: *Bone2D) -> int {
}
Bone2D_set_autocalculate_length_and_angle :: (using self: *Bone2D, auto_calculate: bool) {
}
Bone2D_get_autocalculate_length_and_angle :: (using self: *Bone2D) -> bool {
}
Bone2D_set_length :: (using self: *Bone2D, length: float) {
}
Bone2D_get_length :: (using self: *Bone2D) -> float {
}
Bone2D_set_bone_angle :: (using self: *Bone2D, angle: float) {
}
Bone2D_get_bone_angle :: (using self: *Bone2D) -> float {
}

// BoneAttachment3D
BoneAttachment3D :: struct {
	__private: *void;
}

BoneAttachment3D_set_bone_name :: (using self: *BoneAttachment3D, bone_name: String) {
}
BoneAttachment3D_get_bone_name :: (using self: *BoneAttachment3D) -> String {
}
BoneAttachment3D_set_bone_idx :: (using self: *BoneAttachment3D, bone_idx: int) {
}
BoneAttachment3D_get_bone_idx :: (using self: *BoneAttachment3D) -> int {
}
BoneAttachment3D_on_skeleton_update :: (using self: *BoneAttachment3D) {
}
BoneAttachment3D_set_override_pose :: (using self: *BoneAttachment3D, override_pose: bool) {
}
BoneAttachment3D_get_override_pose :: (using self: *BoneAttachment3D) -> bool {
}
BoneAttachment3D_set_use_external_skeleton :: (using self: *BoneAttachment3D, use_external_skeleton: bool) {
}
BoneAttachment3D_get_use_external_skeleton :: (using self: *BoneAttachment3D) -> bool {
}
BoneAttachment3D_set_external_skeleton :: (using self: *BoneAttachment3D, external_skeleton: NodePath) {
}
BoneAttachment3D_get_external_skeleton :: (using self: *BoneAttachment3D) -> NodePath {
}

// BoneMap
BoneMap :: struct {
	__private: *void;
}

BoneMap_get_profile :: (using self: *BoneMap) -> SkeletonProfile {
}
BoneMap_set_profile :: (using self: *BoneMap, profile: SkeletonProfile) {
}
BoneMap_get_skeleton_bone_name :: (using self: *BoneMap, profile_bone_name: StringName) -> StringName {
}
BoneMap_set_skeleton_bone_name :: (using self: *BoneMap, profile_bone_name: StringName, skeleton_bone_name: StringName) {
}
BoneMap_find_profile_bone_name :: (using self: *BoneMap, skeleton_bone_name: StringName) -> StringName {
}

// BoxContainer
BoxContainer :: struct {
	__private: *void;

	AlignmentMode :: enum {
		ALIGNMENT_BEGIN :: 0;
		ALIGNMENT_CENTER :: 1;
		ALIGNMENT_END :: 2;
	}
}

BoxContainer_add_spacer :: (using self: *BoxContainer, begin: bool) -> Control {
}
BoxContainer_set_alignment :: (using self: *BoxContainer, alignment: BoxContainer.AlignmentMode) {
}
BoxContainer_get_alignment :: (using self: *BoxContainer) -> BoxContainer.AlignmentMode {
}
BoxContainer_set_vertical :: (using self: *BoxContainer, vertical: bool) {
}
BoxContainer_is_vertical :: (using self: *BoxContainer) -> bool {
}

// BoxMesh
BoxMesh :: struct {
	__private: *void;
}

BoxMesh_set_size :: (using self: *BoxMesh, size: Vector3) {
}
BoxMesh_get_size :: (using self: *BoxMesh) -> Vector3 {
}
BoxMesh_set_subdivide_width :: (using self: *BoxMesh, subdivide: int) {
}
BoxMesh_get_subdivide_width :: (using self: *BoxMesh) -> int {
}
BoxMesh_set_subdivide_height :: (using self: *BoxMesh, divisions: int) {
}
BoxMesh_get_subdivide_height :: (using self: *BoxMesh) -> int {
}
BoxMesh_set_subdivide_depth :: (using self: *BoxMesh, divisions: int) {
}
BoxMesh_get_subdivide_depth :: (using self: *BoxMesh) -> int {
}

// BoxOccluder3D
BoxOccluder3D :: struct {
	__private: *void;
}

BoxOccluder3D_set_size :: (using self: *BoxOccluder3D, size: Vector3) {
}
BoxOccluder3D_get_size :: (using self: *BoxOccluder3D) -> Vector3 {
}

// BoxShape3D
BoxShape3D :: struct {
	__private: *void;
}

BoxShape3D_set_size :: (using self: *BoxShape3D, size: Vector3) {
}
BoxShape3D_get_size :: (using self: *BoxShape3D) -> Vector3 {
}

// Button
Button :: struct {
	__private: *void;
}

Button_set_text :: (using self: *Button, text: String) {
}
Button_get_text :: (using self: *Button) -> String {
}
Button_set_text_overrun_behavior :: (using self: *Button, overrun_behavior: TextServer.OverrunBehavior) {
}
Button_get_text_overrun_behavior :: (using self: *Button) -> TextServer.OverrunBehavior {
}
Button_set_autowrap_mode :: (using self: *Button, autowrap_mode: TextServer.AutowrapMode) {
}
Button_get_autowrap_mode :: (using self: *Button) -> TextServer.AutowrapMode {
}
Button_set_text_direction :: (using self: *Button, direction: Control.TextDirection) {
}
Button_get_text_direction :: (using self: *Button) -> Control.TextDirection {
}
Button_set_language :: (using self: *Button, language: String) {
}
Button_get_language :: (using self: *Button) -> String {
}
Button_set_button_icon :: (using self: *Button, texture: Texture2D) {
}
Button_get_button_icon :: (using self: *Button) -> Texture2D {
}
Button_set_flat :: (using self: *Button, enabled: bool) {
}
Button_is_flat :: (using self: *Button) -> bool {
}
Button_set_clip_text :: (using self: *Button, enabled: bool) {
}
Button_get_clip_text :: (using self: *Button) -> bool {
}
Button_set_text_alignment :: (using self: *Button, alignment: HorizontalAlignment) {
}
Button_get_text_alignment :: (using self: *Button) -> HorizontalAlignment {
}
Button_set_icon_alignment :: (using self: *Button, icon_alignment: HorizontalAlignment) {
}
Button_get_icon_alignment :: (using self: *Button) -> HorizontalAlignment {
}
Button_set_vertical_icon_alignment :: (using self: *Button, vertical_icon_alignment: VerticalAlignment) {
}
Button_get_vertical_icon_alignment :: (using self: *Button) -> VerticalAlignment {
}
Button_set_expand_icon :: (using self: *Button, enabled: bool) {
}
Button_is_expand_icon :: (using self: *Button) -> bool {
}

// ButtonGroup
ButtonGroup :: struct {
	__private: *void;
}

ButtonGroup_get_pressed_button :: (using self: *ButtonGroup) -> BaseButton {
}
ButtonGroup_get_buttons :: (using self: *ButtonGroup) -> Array {
}
ButtonGroup_set_allow_unpress :: (using self: *ButtonGroup, enabled: bool) {
}
ButtonGroup_is_allow_unpress :: (using self: *ButtonGroup) -> bool {
}

// CPUParticles2D
CPUParticles2D :: struct {
	__private: *void;

	DrawOrder :: enum {
		DRAW_ORDER_INDEX :: 0;
		DRAW_ORDER_LIFETIME :: 1;
	}
	Parameter :: enum {
		PARAM_INITIAL_LINEAR_VELOCITY :: 0;
		PARAM_ANGULAR_VELOCITY :: 1;
		PARAM_ORBIT_VELOCITY :: 2;
		PARAM_LINEAR_ACCEL :: 3;
		PARAM_RADIAL_ACCEL :: 4;
		PARAM_TANGENTIAL_ACCEL :: 5;
		PARAM_DAMPING :: 6;
		PARAM_ANGLE :: 7;
		PARAM_SCALE :: 8;
		PARAM_HUE_VARIATION :: 9;
		PARAM_ANIM_SPEED :: 10;
		PARAM_ANIM_OFFSET :: 11;
		PARAM_MAX :: 12;
	}
	ParticleFlags :: enum {
		PARTICLE_FLAG_ALIGN_Y_TO_VELOCITY :: 0;
		PARTICLE_FLAG_ROTATE_Y :: 1;
		PARTICLE_FLAG_DISABLE_Z :: 2;
		PARTICLE_FLAG_MAX :: 3;
	}
	EmissionShape :: enum {
		EMISSION_SHAPE_POINT :: 0;
		EMISSION_SHAPE_SPHERE :: 1;
		EMISSION_SHAPE_SPHERE_SURFACE :: 2;
		EMISSION_SHAPE_RECTANGLE :: 3;
		EMISSION_SHAPE_POINTS :: 4;
		EMISSION_SHAPE_DIRECTED_POINTS :: 5;
		EMISSION_SHAPE_MAX :: 6;
	}
}

CPUParticles2D_set_emitting :: (using self: *CPUParticles2D, emitting: bool) {
}
CPUParticles2D_set_amount :: (using self: *CPUParticles2D, amount: int) {
}
CPUParticles2D_set_lifetime :: (using self: *CPUParticles2D, secs: float) {
}
CPUParticles2D_set_one_shot :: (using self: *CPUParticles2D, enable: bool) {
}
CPUParticles2D_set_pre_process_time :: (using self: *CPUParticles2D, secs: float) {
}
CPUParticles2D_set_explosiveness_ratio :: (using self: *CPUParticles2D, ratio: float) {
}
CPUParticles2D_set_randomness_ratio :: (using self: *CPUParticles2D, ratio: float) {
}
CPUParticles2D_set_lifetime_randomness :: (using self: *CPUParticles2D, random: float) {
}
CPUParticles2D_set_use_local_coordinates :: (using self: *CPUParticles2D, enable: bool) {
}
CPUParticles2D_set_fixed_fps :: (using self: *CPUParticles2D, fps: int) {
}
CPUParticles2D_set_fractional_delta :: (using self: *CPUParticles2D, enable: bool) {
}
CPUParticles2D_set_speed_scale :: (using self: *CPUParticles2D, scale: float) {
}
CPUParticles2D_is_emitting :: (using self: *CPUParticles2D) -> bool {
}
CPUParticles2D_get_amount :: (using self: *CPUParticles2D) -> int {
}
CPUParticles2D_get_lifetime :: (using self: *CPUParticles2D) -> float {
}
CPUParticles2D_get_one_shot :: (using self: *CPUParticles2D) -> bool {
}
CPUParticles2D_get_pre_process_time :: (using self: *CPUParticles2D) -> float {
}
CPUParticles2D_get_explosiveness_ratio :: (using self: *CPUParticles2D) -> float {
}
CPUParticles2D_get_randomness_ratio :: (using self: *CPUParticles2D) -> float {
}
CPUParticles2D_get_lifetime_randomness :: (using self: *CPUParticles2D) -> float {
}
CPUParticles2D_get_use_local_coordinates :: (using self: *CPUParticles2D) -> bool {
}
CPUParticles2D_get_fixed_fps :: (using self: *CPUParticles2D) -> int {
}
CPUParticles2D_get_fractional_delta :: (using self: *CPUParticles2D) -> bool {
}
CPUParticles2D_get_speed_scale :: (using self: *CPUParticles2D) -> float {
}
CPUParticles2D_set_draw_order :: (using self: *CPUParticles2D, order: CPUParticles2D.DrawOrder) {
}
CPUParticles2D_get_draw_order :: (using self: *CPUParticles2D) -> CPUParticles2D.DrawOrder {
}
CPUParticles2D_set_texture :: (using self: *CPUParticles2D, texture: Texture2D) {
}
CPUParticles2D_get_texture :: (using self: *CPUParticles2D) -> Texture2D {
}
CPUParticles2D_restart :: (using self: *CPUParticles2D) {
}
CPUParticles2D_set_direction :: (using self: *CPUParticles2D, direction: Vector2) {
}
CPUParticles2D_get_direction :: (using self: *CPUParticles2D) -> Vector2 {
}
CPUParticles2D_set_spread :: (using self: *CPUParticles2D, spread: float) {
}
CPUParticles2D_get_spread :: (using self: *CPUParticles2D) -> float {
}
CPUParticles2D_set_param_min :: (using self: *CPUParticles2D, param: CPUParticles2D.Parameter, value: float) {
}
CPUParticles2D_get_param_min :: (using self: *CPUParticles2D, param: CPUParticles2D.Parameter) -> float {
}
CPUParticles2D_set_param_max :: (using self: *CPUParticles2D, param: CPUParticles2D.Parameter, value: float) {
}
CPUParticles2D_get_param_max :: (using self: *CPUParticles2D, param: CPUParticles2D.Parameter) -> float {
}
CPUParticles2D_set_param_curve :: (using self: *CPUParticles2D, param: CPUParticles2D.Parameter, curve: Curve) {
}
CPUParticles2D_get_param_curve :: (using self: *CPUParticles2D, param: CPUParticles2D.Parameter) -> Curve {
}
CPUParticles2D_set_color :: (using self: *CPUParticles2D, color: Color) {
}
CPUParticles2D_get_color :: (using self: *CPUParticles2D) -> Color {
}
CPUParticles2D_set_color_ramp :: (using self: *CPUParticles2D, ramp: Gradient) {
}
CPUParticles2D_get_color_ramp :: (using self: *CPUParticles2D) -> Gradient {
}
CPUParticles2D_set_color_initial_ramp :: (using self: *CPUParticles2D, ramp: Gradient) {
}
CPUParticles2D_get_color_initial_ramp :: (using self: *CPUParticles2D) -> Gradient {
}
CPUParticles2D_set_particle_flag :: (using self: *CPUParticles2D, particle_flag: CPUParticles2D.ParticleFlags, enable: bool) {
}
CPUParticles2D_get_particle_flag :: (using self: *CPUParticles2D, particle_flag: CPUParticles2D.ParticleFlags) -> bool {
}
CPUParticles2D_set_emission_shape :: (using self: *CPUParticles2D, shape: CPUParticles2D.EmissionShape) {
}
CPUParticles2D_get_emission_shape :: (using self: *CPUParticles2D) -> CPUParticles2D.EmissionShape {
}
CPUParticles2D_set_emission_sphere_radius :: (using self: *CPUParticles2D, radius: float) {
}
CPUParticles2D_get_emission_sphere_radius :: (using self: *CPUParticles2D) -> float {
}
CPUParticles2D_set_emission_rect_extents :: (using self: *CPUParticles2D, extents: Vector2) {
}
CPUParticles2D_get_emission_rect_extents :: (using self: *CPUParticles2D) -> Vector2 {
}
CPUParticles2D_set_emission_points :: (using self: *CPUParticles2D, array: PackedVector2Array) {
}
CPUParticles2D_get_emission_points :: (using self: *CPUParticles2D) -> PackedVector2Array {
}
CPUParticles2D_set_emission_normals :: (using self: *CPUParticles2D, array: PackedVector2Array) {
}
CPUParticles2D_get_emission_normals :: (using self: *CPUParticles2D) -> PackedVector2Array {
}
CPUParticles2D_set_emission_colors :: (using self: *CPUParticles2D, array: PackedColorArray) {
}
CPUParticles2D_get_emission_colors :: (using self: *CPUParticles2D) -> PackedColorArray {
}
CPUParticles2D_get_gravity :: (using self: *CPUParticles2D) -> Vector2 {
}
CPUParticles2D_set_gravity :: (using self: *CPUParticles2D, accel_vec: Vector2) {
}
CPUParticles2D_get_split_scale :: (using self: *CPUParticles2D) -> bool {
}
CPUParticles2D_set_split_scale :: (using self: *CPUParticles2D, split_scale: bool) {
}
CPUParticles2D_get_scale_curve_x :: (using self: *CPUParticles2D) -> Curve {
}
CPUParticles2D_set_scale_curve_x :: (using self: *CPUParticles2D, scale_curve: Curve) {
}
CPUParticles2D_get_scale_curve_y :: (using self: *CPUParticles2D) -> Curve {
}
CPUParticles2D_set_scale_curve_y :: (using self: *CPUParticles2D, scale_curve: Curve) {
}
CPUParticles2D_convert_from_particles :: (using self: *CPUParticles2D, particles: Node) {
}

// CPUParticles3D
CPUParticles3D :: struct {
	__private: *void;

	DrawOrder :: enum {
		DRAW_ORDER_INDEX :: 0;
		DRAW_ORDER_LIFETIME :: 1;
		DRAW_ORDER_VIEW_DEPTH :: 2;
	}
	Parameter :: enum {
		PARAM_INITIAL_LINEAR_VELOCITY :: 0;
		PARAM_ANGULAR_VELOCITY :: 1;
		PARAM_ORBIT_VELOCITY :: 2;
		PARAM_LINEAR_ACCEL :: 3;
		PARAM_RADIAL_ACCEL :: 4;
		PARAM_TANGENTIAL_ACCEL :: 5;
		PARAM_DAMPING :: 6;
		PARAM_ANGLE :: 7;
		PARAM_SCALE :: 8;
		PARAM_HUE_VARIATION :: 9;
		PARAM_ANIM_SPEED :: 10;
		PARAM_ANIM_OFFSET :: 11;
		PARAM_MAX :: 12;
	}
	ParticleFlags :: enum {
		PARTICLE_FLAG_ALIGN_Y_TO_VELOCITY :: 0;
		PARTICLE_FLAG_ROTATE_Y :: 1;
		PARTICLE_FLAG_DISABLE_Z :: 2;
		PARTICLE_FLAG_MAX :: 3;
	}
	EmissionShape :: enum {
		EMISSION_SHAPE_POINT :: 0;
		EMISSION_SHAPE_SPHERE :: 1;
		EMISSION_SHAPE_SPHERE_SURFACE :: 2;
		EMISSION_SHAPE_BOX :: 3;
		EMISSION_SHAPE_POINTS :: 4;
		EMISSION_SHAPE_DIRECTED_POINTS :: 5;
		EMISSION_SHAPE_RING :: 6;
		EMISSION_SHAPE_MAX :: 7;
	}
}

CPUParticles3D_set_emitting :: (using self: *CPUParticles3D, emitting: bool) {
}
CPUParticles3D_set_amount :: (using self: *CPUParticles3D, amount: int) {
}
CPUParticles3D_set_lifetime :: (using self: *CPUParticles3D, secs: float) {
}
CPUParticles3D_set_one_shot :: (using self: *CPUParticles3D, enable: bool) {
}
CPUParticles3D_set_pre_process_time :: (using self: *CPUParticles3D, secs: float) {
}
CPUParticles3D_set_explosiveness_ratio :: (using self: *CPUParticles3D, ratio: float) {
}
CPUParticles3D_set_randomness_ratio :: (using self: *CPUParticles3D, ratio: float) {
}
CPUParticles3D_set_visibility_aabb :: (using self: *CPUParticles3D, aabb: AABB) {
}
CPUParticles3D_set_lifetime_randomness :: (using self: *CPUParticles3D, random: float) {
}
CPUParticles3D_set_use_local_coordinates :: (using self: *CPUParticles3D, enable: bool) {
}
CPUParticles3D_set_fixed_fps :: (using self: *CPUParticles3D, fps: int) {
}
CPUParticles3D_set_fractional_delta :: (using self: *CPUParticles3D, enable: bool) {
}
CPUParticles3D_set_speed_scale :: (using self: *CPUParticles3D, scale: float) {
}
CPUParticles3D_is_emitting :: (using self: *CPUParticles3D) -> bool {
}
CPUParticles3D_get_amount :: (using self: *CPUParticles3D) -> int {
}
CPUParticles3D_get_lifetime :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_get_one_shot :: (using self: *CPUParticles3D) -> bool {
}
CPUParticles3D_get_pre_process_time :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_get_explosiveness_ratio :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_get_randomness_ratio :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_get_visibility_aabb :: (using self: *CPUParticles3D) -> AABB {
}
CPUParticles3D_get_lifetime_randomness :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_get_use_local_coordinates :: (using self: *CPUParticles3D) -> bool {
}
CPUParticles3D_get_fixed_fps :: (using self: *CPUParticles3D) -> int {
}
CPUParticles3D_get_fractional_delta :: (using self: *CPUParticles3D) -> bool {
}
CPUParticles3D_get_speed_scale :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_set_draw_order :: (using self: *CPUParticles3D, order: CPUParticles3D.DrawOrder) {
}
CPUParticles3D_get_draw_order :: (using self: *CPUParticles3D) -> CPUParticles3D.DrawOrder {
}
CPUParticles3D_set_mesh :: (using self: *CPUParticles3D, mesh: Mesh) {
}
CPUParticles3D_get_mesh :: (using self: *CPUParticles3D) -> Mesh {
}
CPUParticles3D_restart :: (using self: *CPUParticles3D) {
}
CPUParticles3D_set_direction :: (using self: *CPUParticles3D, direction: Vector3) {
}
CPUParticles3D_get_direction :: (using self: *CPUParticles3D) -> Vector3 {
}
CPUParticles3D_set_spread :: (using self: *CPUParticles3D, degrees: float) {
}
CPUParticles3D_get_spread :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_set_flatness :: (using self: *CPUParticles3D, amount: float) {
}
CPUParticles3D_get_flatness :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_set_param_min :: (using self: *CPUParticles3D, param: CPUParticles3D.Parameter, value: float) {
}
CPUParticles3D_get_param_min :: (using self: *CPUParticles3D, param: CPUParticles3D.Parameter) -> float {
}
CPUParticles3D_set_param_max :: (using self: *CPUParticles3D, param: CPUParticles3D.Parameter, value: float) {
}
CPUParticles3D_get_param_max :: (using self: *CPUParticles3D, param: CPUParticles3D.Parameter) -> float {
}
CPUParticles3D_set_param_curve :: (using self: *CPUParticles3D, param: CPUParticles3D.Parameter, curve: Curve) {
}
CPUParticles3D_get_param_curve :: (using self: *CPUParticles3D, param: CPUParticles3D.Parameter) -> Curve {
}
CPUParticles3D_set_color :: (using self: *CPUParticles3D, color: Color) {
}
CPUParticles3D_get_color :: (using self: *CPUParticles3D) -> Color {
}
CPUParticles3D_set_color_ramp :: (using self: *CPUParticles3D, ramp: Gradient) {
}
CPUParticles3D_get_color_ramp :: (using self: *CPUParticles3D) -> Gradient {
}
CPUParticles3D_set_color_initial_ramp :: (using self: *CPUParticles3D, ramp: Gradient) {
}
CPUParticles3D_get_color_initial_ramp :: (using self: *CPUParticles3D) -> Gradient {
}
CPUParticles3D_set_particle_flag :: (using self: *CPUParticles3D, particle_flag: CPUParticles3D.ParticleFlags, enable: bool) {
}
CPUParticles3D_get_particle_flag :: (using self: *CPUParticles3D, particle_flag: CPUParticles3D.ParticleFlags) -> bool {
}
CPUParticles3D_set_emission_shape :: (using self: *CPUParticles3D, shape: CPUParticles3D.EmissionShape) {
}
CPUParticles3D_get_emission_shape :: (using self: *CPUParticles3D) -> CPUParticles3D.EmissionShape {
}
CPUParticles3D_set_emission_sphere_radius :: (using self: *CPUParticles3D, radius: float) {
}
CPUParticles3D_get_emission_sphere_radius :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_set_emission_box_extents :: (using self: *CPUParticles3D, extents: Vector3) {
}
CPUParticles3D_get_emission_box_extents :: (using self: *CPUParticles3D) -> Vector3 {
}
CPUParticles3D_set_emission_points :: (using self: *CPUParticles3D, array: PackedVector3Array) {
}
CPUParticles3D_get_emission_points :: (using self: *CPUParticles3D) -> PackedVector3Array {
}
CPUParticles3D_set_emission_normals :: (using self: *CPUParticles3D, array: PackedVector3Array) {
}
CPUParticles3D_get_emission_normals :: (using self: *CPUParticles3D) -> PackedVector3Array {
}
CPUParticles3D_set_emission_colors :: (using self: *CPUParticles3D, array: PackedColorArray) {
}
CPUParticles3D_get_emission_colors :: (using self: *CPUParticles3D) -> PackedColorArray {
}
CPUParticles3D_set_emission_ring_axis :: (using self: *CPUParticles3D, axis: Vector3) {
}
CPUParticles3D_get_emission_ring_axis :: (using self: *CPUParticles3D) -> Vector3 {
}
CPUParticles3D_set_emission_ring_height :: (using self: *CPUParticles3D, height: float) {
}
CPUParticles3D_get_emission_ring_height :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_set_emission_ring_radius :: (using self: *CPUParticles3D, radius: float) {
}
CPUParticles3D_get_emission_ring_radius :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_set_emission_ring_inner_radius :: (using self: *CPUParticles3D, inner_radius: float) {
}
CPUParticles3D_get_emission_ring_inner_radius :: (using self: *CPUParticles3D) -> float {
}
CPUParticles3D_get_gravity :: (using self: *CPUParticles3D) -> Vector3 {
}
CPUParticles3D_set_gravity :: (using self: *CPUParticles3D, accel_vec: Vector3) {
}
CPUParticles3D_get_split_scale :: (using self: *CPUParticles3D) -> bool {
}
CPUParticles3D_set_split_scale :: (using self: *CPUParticles3D, split_scale: bool) {
}
CPUParticles3D_get_scale_curve_x :: (using self: *CPUParticles3D) -> Curve {
}
CPUParticles3D_set_scale_curve_x :: (using self: *CPUParticles3D, scale_curve: Curve) {
}
CPUParticles3D_get_scale_curve_y :: (using self: *CPUParticles3D) -> Curve {
}
CPUParticles3D_set_scale_curve_y :: (using self: *CPUParticles3D, scale_curve: Curve) {
}
CPUParticles3D_get_scale_curve_z :: (using self: *CPUParticles3D) -> Curve {
}
CPUParticles3D_set_scale_curve_z :: (using self: *CPUParticles3D, scale_curve: Curve) {
}
CPUParticles3D_convert_from_particles :: (using self: *CPUParticles3D, particles: Node) {
}

// CSGBox3D
CSGBox3D :: struct {
	__private: *void;
}

CSGBox3D_set_size :: (using self: *CSGBox3D, size: Vector3) {
}
CSGBox3D_get_size :: (using self: *CSGBox3D) -> Vector3 {
}
CSGBox3D_set_material :: (using self: *CSGBox3D, material: Material) {
}
CSGBox3D_get_material :: (using self: *CSGBox3D) -> Material {
}

// CSGCombiner3D
CSGCombiner3D :: struct {
	__private: *void;
}

// CSGCylinder3D
CSGCylinder3D :: struct {
	__private: *void;
}

CSGCylinder3D_set_radius :: (using self: *CSGCylinder3D, radius: float) {
}
CSGCylinder3D_get_radius :: (using self: *CSGCylinder3D) -> float {
}
CSGCylinder3D_set_height :: (using self: *CSGCylinder3D, height: float) {
}
CSGCylinder3D_get_height :: (using self: *CSGCylinder3D) -> float {
}
CSGCylinder3D_set_sides :: (using self: *CSGCylinder3D, sides: int) {
}
CSGCylinder3D_get_sides :: (using self: *CSGCylinder3D) -> int {
}
CSGCylinder3D_set_cone :: (using self: *CSGCylinder3D, cone: bool) {
}
CSGCylinder3D_is_cone :: (using self: *CSGCylinder3D) -> bool {
}
CSGCylinder3D_set_material :: (using self: *CSGCylinder3D, material: Material) {
}
CSGCylinder3D_get_material :: (using self: *CSGCylinder3D) -> Material {
}
CSGCylinder3D_set_smooth_faces :: (using self: *CSGCylinder3D, smooth_faces: bool) {
}
CSGCylinder3D_get_smooth_faces :: (using self: *CSGCylinder3D) -> bool {
}

// CSGMesh3D
CSGMesh3D :: struct {
	__private: *void;
}

CSGMesh3D_set_mesh :: (using self: *CSGMesh3D, mesh: Mesh) {
}
CSGMesh3D_get_mesh :: (using self: *CSGMesh3D) -> Mesh {
}
CSGMesh3D_set_material :: (using self: *CSGMesh3D, material: Material) {
}
CSGMesh3D_get_material :: (using self: *CSGMesh3D) -> Material {
}

// CSGPolygon3D
CSGPolygon3D :: struct {
	__private: *void;

	Mode :: enum {
		MODE_DEPTH :: 0;
		MODE_SPIN :: 1;
		MODE_PATH :: 2;
	}
	PathRotation :: enum {
		PATH_ROTATION_POLYGON :: 0;
		PATH_ROTATION_PATH :: 1;
		PATH_ROTATION_PATH_FOLLOW :: 2;
	}
	PathIntervalType :: enum {
		PATH_INTERVAL_DISTANCE :: 0;
		PATH_INTERVAL_SUBDIVIDE :: 1;
	}
}

CSGPolygon3D_set_polygon :: (using self: *CSGPolygon3D, polygon: PackedVector2Array) {
}
CSGPolygon3D_get_polygon :: (using self: *CSGPolygon3D) -> PackedVector2Array {
}
CSGPolygon3D_set_mode :: (using self: *CSGPolygon3D, mode: CSGPolygon3D.Mode) {
}
CSGPolygon3D_get_mode :: (using self: *CSGPolygon3D) -> CSGPolygon3D.Mode {
}
CSGPolygon3D_set_depth :: (using self: *CSGPolygon3D, depth: float) {
}
CSGPolygon3D_get_depth :: (using self: *CSGPolygon3D) -> float {
}
CSGPolygon3D_set_spin_degrees :: (using self: *CSGPolygon3D, degrees: float) {
}
CSGPolygon3D_get_spin_degrees :: (using self: *CSGPolygon3D) -> float {
}
CSGPolygon3D_set_spin_sides :: (using self: *CSGPolygon3D, spin_sides: int) {
}
CSGPolygon3D_get_spin_sides :: (using self: *CSGPolygon3D) -> int {
}
CSGPolygon3D_set_path_node :: (using self: *CSGPolygon3D, path: NodePath) {
}
CSGPolygon3D_get_path_node :: (using self: *CSGPolygon3D) -> NodePath {
}
CSGPolygon3D_set_path_interval_type :: (using self: *CSGPolygon3D, interval_type: CSGPolygon3D.PathIntervalType) {
}
CSGPolygon3D_get_path_interval_type :: (using self: *CSGPolygon3D) -> CSGPolygon3D.PathIntervalType {
}
CSGPolygon3D_set_path_interval :: (using self: *CSGPolygon3D, interval: float) {
}
CSGPolygon3D_get_path_interval :: (using self: *CSGPolygon3D) -> float {
}
CSGPolygon3D_set_path_simplify_angle :: (using self: *CSGPolygon3D, degrees: float) {
}
CSGPolygon3D_get_path_simplify_angle :: (using self: *CSGPolygon3D) -> float {
}
CSGPolygon3D_set_path_rotation :: (using self: *CSGPolygon3D, path_rotation: CSGPolygon3D.PathRotation) {
}
CSGPolygon3D_get_path_rotation :: (using self: *CSGPolygon3D) -> CSGPolygon3D.PathRotation {
}
CSGPolygon3D_set_path_local :: (using self: *CSGPolygon3D, enable: bool) {
}
CSGPolygon3D_is_path_local :: (using self: *CSGPolygon3D) -> bool {
}
CSGPolygon3D_set_path_continuous_u :: (using self: *CSGPolygon3D, enable: bool) {
}
CSGPolygon3D_is_path_continuous_u :: (using self: *CSGPolygon3D) -> bool {
}
CSGPolygon3D_set_path_u_distance :: (using self: *CSGPolygon3D, distance: float) {
}
CSGPolygon3D_get_path_u_distance :: (using self: *CSGPolygon3D) -> float {
}
CSGPolygon3D_set_path_joined :: (using self: *CSGPolygon3D, enable: bool) {
}
CSGPolygon3D_is_path_joined :: (using self: *CSGPolygon3D) -> bool {
}
CSGPolygon3D_set_material :: (using self: *CSGPolygon3D, material: Material) {
}
CSGPolygon3D_get_material :: (using self: *CSGPolygon3D) -> Material {
}
CSGPolygon3D_set_smooth_faces :: (using self: *CSGPolygon3D, smooth_faces: bool) {
}
CSGPolygon3D_get_smooth_faces :: (using self: *CSGPolygon3D) -> bool {
}

// CSGPrimitive3D
CSGPrimitive3D :: struct {
	__private: *void;
}

CSGPrimitive3D_set_flip_faces :: (using self: *CSGPrimitive3D, flip_faces: bool) {
}
CSGPrimitive3D_get_flip_faces :: (using self: *CSGPrimitive3D) -> bool {
}

// CSGShape3D
CSGShape3D :: struct {
	__private: *void;

	Operation :: enum {
		OPERATION_UNION :: 0;
		OPERATION_INTERSECTION :: 1;
		OPERATION_SUBTRACTION :: 2;
	}
}

CSGShape3D_is_root_shape :: (using self: *CSGShape3D) -> bool {
}
CSGShape3D_set_operation :: (using self: *CSGShape3D, operation: CSGShape3D.Operation) {
}
CSGShape3D_get_operation :: (using self: *CSGShape3D) -> CSGShape3D.Operation {
}
CSGShape3D_set_snap :: (using self: *CSGShape3D, snap: float) {
}
CSGShape3D_get_snap :: (using self: *CSGShape3D) -> float {
}
CSGShape3D_set_use_collision :: (using self: *CSGShape3D, operation: bool) {
}
CSGShape3D_is_using_collision :: (using self: *CSGShape3D) -> bool {
}
CSGShape3D_set_collision_layer :: (using self: *CSGShape3D, layer: int) {
}
CSGShape3D_get_collision_layer :: (using self: *CSGShape3D) -> int {
}
CSGShape3D_set_collision_mask :: (using self: *CSGShape3D, mask: int) {
}
CSGShape3D_get_collision_mask :: (using self: *CSGShape3D) -> int {
}
CSGShape3D_set_collision_mask_value :: (using self: *CSGShape3D, layer_number: int, value: bool) {
}
CSGShape3D_get_collision_mask_value :: (using self: *CSGShape3D, layer_number: int) -> bool {
}
CSGShape3D_set_collision_layer_value :: (using self: *CSGShape3D, layer_number: int, value: bool) {
}
CSGShape3D_get_collision_layer_value :: (using self: *CSGShape3D, layer_number: int) -> bool {
}
CSGShape3D_set_collision_priority :: (using self: *CSGShape3D, priority: float) {
}
CSGShape3D_get_collision_priority :: (using self: *CSGShape3D) -> float {
}
CSGShape3D_set_calculate_tangents :: (using self: *CSGShape3D, enabled: bool) {
}
CSGShape3D_is_calculating_tangents :: (using self: *CSGShape3D) -> bool {
}
CSGShape3D_get_meshes :: (using self: *CSGShape3D) -> Array {
}

// CSGSphere3D
CSGSphere3D :: struct {
	__private: *void;
}

CSGSphere3D_set_radius :: (using self: *CSGSphere3D, radius: float) {
}
CSGSphere3D_get_radius :: (using self: *CSGSphere3D) -> float {
}
CSGSphere3D_set_radial_segments :: (using self: *CSGSphere3D, radial_segments: int) {
}
CSGSphere3D_get_radial_segments :: (using self: *CSGSphere3D) -> int {
}
CSGSphere3D_set_rings :: (using self: *CSGSphere3D, rings: int) {
}
CSGSphere3D_get_rings :: (using self: *CSGSphere3D) -> int {
}
CSGSphere3D_set_smooth_faces :: (using self: *CSGSphere3D, smooth_faces: bool) {
}
CSGSphere3D_get_smooth_faces :: (using self: *CSGSphere3D) -> bool {
}
CSGSphere3D_set_material :: (using self: *CSGSphere3D, material: Material) {
}
CSGSphere3D_get_material :: (using self: *CSGSphere3D) -> Material {
}

// CSGTorus3D
CSGTorus3D :: struct {
	__private: *void;
}

CSGTorus3D_set_inner_radius :: (using self: *CSGTorus3D, radius: float) {
}
CSGTorus3D_get_inner_radius :: (using self: *CSGTorus3D) -> float {
}
CSGTorus3D_set_outer_radius :: (using self: *CSGTorus3D, radius: float) {
}
CSGTorus3D_get_outer_radius :: (using self: *CSGTorus3D) -> float {
}
CSGTorus3D_set_sides :: (using self: *CSGTorus3D, sides: int) {
}
CSGTorus3D_get_sides :: (using self: *CSGTorus3D) -> int {
}
CSGTorus3D_set_ring_sides :: (using self: *CSGTorus3D, sides: int) {
}
CSGTorus3D_get_ring_sides :: (using self: *CSGTorus3D) -> int {
}
CSGTorus3D_set_material :: (using self: *CSGTorus3D, material: Material) {
}
CSGTorus3D_get_material :: (using self: *CSGTorus3D) -> Material {
}
CSGTorus3D_set_smooth_faces :: (using self: *CSGTorus3D, smooth_faces: bool) {
}
CSGTorus3D_get_smooth_faces :: (using self: *CSGTorus3D) -> bool {
}

// CallbackTweener
CallbackTweener :: struct {
	__private: *void;
}

CallbackTweener_set_delay :: (using self: *CallbackTweener, delay: float) -> CallbackTweener {
}

// Camera2D
Camera2D :: struct {
	__private: *void;

	AnchorMode :: enum {
		ANCHOR_MODE_FIXED_TOP_LEFT :: 0;
		ANCHOR_MODE_DRAG_CENTER :: 1;
	}
	Camera2DProcessCallback :: enum {
		CAMERA2D_PROCESS_PHYSICS :: 0;
		CAMERA2D_PROCESS_IDLE :: 1;
	}
}

Camera2D_set_offset :: (using self: *Camera2D, offset: Vector2) {
}
Camera2D_get_offset :: (using self: *Camera2D) -> Vector2 {
}
Camera2D_set_anchor_mode :: (using self: *Camera2D, anchor_mode: Camera2D.AnchorMode) {
}
Camera2D_get_anchor_mode :: (using self: *Camera2D) -> Camera2D.AnchorMode {
}
Camera2D_set_ignore_rotation :: (using self: *Camera2D, ignore: bool) {
}
Camera2D_is_ignoring_rotation :: (using self: *Camera2D) -> bool {
}
Camera2D_set_process_callback :: (using self: *Camera2D, mode: Camera2D.Camera2DProcessCallback) {
}
Camera2D_get_process_callback :: (using self: *Camera2D) -> Camera2D.Camera2DProcessCallback {
}
Camera2D_set_enabled :: (using self: *Camera2D, enabled: bool) {
}
Camera2D_is_enabled :: (using self: *Camera2D) -> bool {
}
Camera2D_make_current :: (using self: *Camera2D) {
}
Camera2D_is_current :: (using self: *Camera2D) -> bool {
}
Camera2D_set_limit :: (using self: *Camera2D, margin: Side, limit: int) {
}
Camera2D_get_limit :: (using self: *Camera2D, margin: Side) -> int {
}
Camera2D_set_limit_smoothing_enabled :: (using self: *Camera2D, limit_smoothing_enabled: bool) {
}
Camera2D_is_limit_smoothing_enabled :: (using self: *Camera2D) -> bool {
}
Camera2D_set_drag_vertical_enabled :: (using self: *Camera2D, enabled: bool) {
}
Camera2D_is_drag_vertical_enabled :: (using self: *Camera2D) -> bool {
}
Camera2D_set_drag_horizontal_enabled :: (using self: *Camera2D, enabled: bool) {
}
Camera2D_is_drag_horizontal_enabled :: (using self: *Camera2D) -> bool {
}
Camera2D_set_drag_vertical_offset :: (using self: *Camera2D, offset: float) {
}
Camera2D_get_drag_vertical_offset :: (using self: *Camera2D) -> float {
}
Camera2D_set_drag_horizontal_offset :: (using self: *Camera2D, offset: float) {
}
Camera2D_get_drag_horizontal_offset :: (using self: *Camera2D) -> float {
}
Camera2D_set_drag_margin :: (using self: *Camera2D, margin: Side, drag_margin: float) {
}
Camera2D_get_drag_margin :: (using self: *Camera2D, margin: Side) -> float {
}
Camera2D_get_target_position :: (using self: *Camera2D) -> Vector2 {
}
Camera2D_get_screen_center_position :: (using self: *Camera2D) -> Vector2 {
}
Camera2D_set_zoom :: (using self: *Camera2D, zoom: Vector2) {
}
Camera2D_get_zoom :: (using self: *Camera2D) -> Vector2 {
}
Camera2D_set_custom_viewport :: (using self: *Camera2D, viewport: Node) {
}
Camera2D_get_custom_viewport :: (using self: *Camera2D) -> Node {
}
Camera2D_set_position_smoothing_speed :: (using self: *Camera2D, position_smoothing_speed: float) {
}
Camera2D_get_position_smoothing_speed :: (using self: *Camera2D) -> float {
}
Camera2D_set_position_smoothing_enabled :: (using self: *Camera2D, position_smoothing_speed: bool) {
}
Camera2D_is_position_smoothing_enabled :: (using self: *Camera2D) -> bool {
}
Camera2D_set_rotation_smoothing_enabled :: (using self: *Camera2D, enabled: bool) {
}
Camera2D_is_rotation_smoothing_enabled :: (using self: *Camera2D) -> bool {
}
Camera2D_set_rotation_smoothing_speed :: (using self: *Camera2D, speed: float) {
}
Camera2D_get_rotation_smoothing_speed :: (using self: *Camera2D) -> float {
}
Camera2D_force_update_scroll :: (using self: *Camera2D) {
}
Camera2D_reset_smoothing :: (using self: *Camera2D) {
}
Camera2D_align :: (using self: *Camera2D) {
}
Camera2D_set_screen_drawing_enabled :: (using self: *Camera2D, screen_drawing_enabled: bool) {
}
Camera2D_is_screen_drawing_enabled :: (using self: *Camera2D) -> bool {
}
Camera2D_set_limit_drawing_enabled :: (using self: *Camera2D, limit_drawing_enabled: bool) {
}
Camera2D_is_limit_drawing_enabled :: (using self: *Camera2D) -> bool {
}
Camera2D_set_margin_drawing_enabled :: (using self: *Camera2D, margin_drawing_enabled: bool) {
}
Camera2D_is_margin_drawing_enabled :: (using self: *Camera2D) -> bool {
}

// Camera3D
Camera3D :: struct {
	__private: *void;

	ProjectionType :: enum {
		PROJECTION_PERSPECTIVE :: 0;
		PROJECTION_ORTHOGONAL :: 1;
		PROJECTION_FRUSTUM :: 2;
	}
	KeepAspect :: enum {
		KEEP_WIDTH :: 0;
		KEEP_HEIGHT :: 1;
	}
	DopplerTracking :: enum {
		DOPPLER_TRACKING_DISABLED :: 0;
		DOPPLER_TRACKING_IDLE_STEP :: 1;
		DOPPLER_TRACKING_PHYSICS_STEP :: 2;
	}
}

Camera3D_project_ray_normal :: (using self: *Camera3D, screen_point: Vector2) -> Vector3 {
}
Camera3D_project_local_ray_normal :: (using self: *Camera3D, screen_point: Vector2) -> Vector3 {
}
Camera3D_project_ray_origin :: (using self: *Camera3D, screen_point: Vector2) -> Vector3 {
}
Camera3D_unproject_position :: (using self: *Camera3D, world_point: Vector3) -> Vector2 {
}
Camera3D_is_position_behind :: (using self: *Camera3D, world_point: Vector3) -> bool {
}
Camera3D_project_position :: (using self: *Camera3D, screen_point: Vector2, z_depth: float) -> Vector3 {
}
Camera3D_set_perspective :: (using self: *Camera3D, fov: float, z_near: float, z_far: float) {
}
Camera3D_set_orthogonal :: (using self: *Camera3D, size: float, z_near: float, z_far: float) {
}
Camera3D_set_frustum :: (using self: *Camera3D, size: float, offset: Vector2, z_near: float, z_far: float) {
}
Camera3D_make_current :: (using self: *Camera3D) {
}
Camera3D_clear_current :: (using self: *Camera3D, enable_next: bool) {
}
Camera3D_set_current :: (using self: *Camera3D, enabled: bool) {
}
Camera3D_is_current :: (using self: *Camera3D) -> bool {
}
Camera3D_get_camera_transform :: (using self: *Camera3D) -> Transform3D {
}
Camera3D_get_camera_projection :: (using self: *Camera3D) -> Projection {
}
Camera3D_get_fov :: (using self: *Camera3D) -> float {
}
Camera3D_get_frustum_offset :: (using self: *Camera3D) -> Vector2 {
}
Camera3D_get_size :: (using self: *Camera3D) -> float {
}
Camera3D_get_far :: (using self: *Camera3D) -> float {
}
Camera3D_get_near :: (using self: *Camera3D) -> float {
}
Camera3D_set_fov :: (using self: *Camera3D, fov: float) {
}
Camera3D_set_frustum_offset :: (using self: *Camera3D, offset: Vector2) {
}
Camera3D_set_size :: (using self: *Camera3D, size: float) {
}
Camera3D_set_far :: (using self: *Camera3D, far: float) {
}
Camera3D_set_near :: (using self: *Camera3D, near: float) {
}
Camera3D_get_projection :: (using self: *Camera3D) -> Camera3D.ProjectionType {
}
Camera3D_set_projection :: (using self: *Camera3D, mode: Camera3D.ProjectionType) {
}
Camera3D_set_h_offset :: (using self: *Camera3D, offset: float) {
}
Camera3D_get_h_offset :: (using self: *Camera3D) -> float {
}
Camera3D_set_v_offset :: (using self: *Camera3D, offset: float) {
}
Camera3D_get_v_offset :: (using self: *Camera3D) -> float {
}
Camera3D_set_cull_mask :: (using self: *Camera3D, mask: int) {
}
Camera3D_get_cull_mask :: (using self: *Camera3D) -> int {
}
Camera3D_set_environment :: (using self: *Camera3D, env: Environment) {
}
Camera3D_get_environment :: (using self: *Camera3D) -> Environment {
}
Camera3D_set_attributes :: (using self: *Camera3D, env: CameraAttributes) {
}
Camera3D_get_attributes :: (using self: *Camera3D) -> CameraAttributes {
}
Camera3D_set_compositor :: (using self: *Camera3D, compositor: Compositor) {
}
Camera3D_get_compositor :: (using self: *Camera3D) -> Compositor {
}
Camera3D_set_keep_aspect_mode :: (using self: *Camera3D, mode: Camera3D.KeepAspect) {
}
Camera3D_get_keep_aspect_mode :: (using self: *Camera3D) -> Camera3D.KeepAspect {
}
Camera3D_set_doppler_tracking :: (using self: *Camera3D, mode: Camera3D.DopplerTracking) {
}
Camera3D_get_doppler_tracking :: (using self: *Camera3D) -> Camera3D.DopplerTracking {
}
Camera3D_get_frustum :: (using self: *Camera3D) -> Array {
}
Camera3D_is_position_in_frustum :: (using self: *Camera3D, world_point: Vector3) -> bool {
}
Camera3D_get_camera_rid :: (using self: *Camera3D) -> RID {
}
Camera3D_get_pyramid_shape_rid :: (using self: *Camera3D) -> RID {
}
Camera3D_set_cull_mask_value :: (using self: *Camera3D, layer_number: int, value: bool) {
}
Camera3D_get_cull_mask_value :: (using self: *Camera3D, layer_number: int) -> bool {
}

// CameraAttributes
CameraAttributes :: struct {
	__private: *void;
}

CameraAttributes_set_exposure_multiplier :: (using self: *CameraAttributes, multiplier: float) {
}
CameraAttributes_get_exposure_multiplier :: (using self: *CameraAttributes) -> float {
}
CameraAttributes_set_exposure_sensitivity :: (using self: *CameraAttributes, sensitivity: float) {
}
CameraAttributes_get_exposure_sensitivity :: (using self: *CameraAttributes) -> float {
}
CameraAttributes_set_auto_exposure_enabled :: (using self: *CameraAttributes, enabled: bool) {
}
CameraAttributes_is_auto_exposure_enabled :: (using self: *CameraAttributes) -> bool {
}
CameraAttributes_set_auto_exposure_speed :: (using self: *CameraAttributes, exposure_speed: float) {
}
CameraAttributes_get_auto_exposure_speed :: (using self: *CameraAttributes) -> float {
}
CameraAttributes_set_auto_exposure_scale :: (using self: *CameraAttributes, exposure_grey: float) {
}
CameraAttributes_get_auto_exposure_scale :: (using self: *CameraAttributes) -> float {
}

// CameraAttributesPhysical
CameraAttributesPhysical :: struct {
	__private: *void;
}

CameraAttributesPhysical_set_aperture :: (using self: *CameraAttributesPhysical, aperture: float) {
}
CameraAttributesPhysical_get_aperture :: (using self: *CameraAttributesPhysical) -> float {
}
CameraAttributesPhysical_set_shutter_speed :: (using self: *CameraAttributesPhysical, shutter_speed: float) {
}
CameraAttributesPhysical_get_shutter_speed :: (using self: *CameraAttributesPhysical) -> float {
}
CameraAttributesPhysical_set_focal_length :: (using self: *CameraAttributesPhysical, focal_length: float) {
}
CameraAttributesPhysical_get_focal_length :: (using self: *CameraAttributesPhysical) -> float {
}
CameraAttributesPhysical_set_focus_distance :: (using self: *CameraAttributesPhysical, focus_distance: float) {
}
CameraAttributesPhysical_get_focus_distance :: (using self: *CameraAttributesPhysical) -> float {
}
CameraAttributesPhysical_set_near :: (using self: *CameraAttributesPhysical, near: float) {
}
CameraAttributesPhysical_get_near :: (using self: *CameraAttributesPhysical) -> float {
}
CameraAttributesPhysical_set_far :: (using self: *CameraAttributesPhysical, far: float) {
}
CameraAttributesPhysical_get_far :: (using self: *CameraAttributesPhysical) -> float {
}
CameraAttributesPhysical_get_fov :: (using self: *CameraAttributesPhysical) -> float {
}
CameraAttributesPhysical_set_auto_exposure_max_exposure_value :: (using self: *CameraAttributesPhysical, exposure_value_max: float) {
}
CameraAttributesPhysical_get_auto_exposure_max_exposure_value :: (using self: *CameraAttributesPhysical) -> float {
}
CameraAttributesPhysical_set_auto_exposure_min_exposure_value :: (using self: *CameraAttributesPhysical, exposure_value_min: float) {
}
CameraAttributesPhysical_get_auto_exposure_min_exposure_value :: (using self: *CameraAttributesPhysical) -> float {
}

// CameraAttributesPractical
CameraAttributesPractical :: struct {
	__private: *void;
}

CameraAttributesPractical_set_dof_blur_far_enabled :: (using self: *CameraAttributesPractical, enabled: bool) {
}
CameraAttributesPractical_is_dof_blur_far_enabled :: (using self: *CameraAttributesPractical) -> bool {
}
CameraAttributesPractical_set_dof_blur_far_distance :: (using self: *CameraAttributesPractical, distance: float) {
}
CameraAttributesPractical_get_dof_blur_far_distance :: (using self: *CameraAttributesPractical) -> float {
}
CameraAttributesPractical_set_dof_blur_far_transition :: (using self: *CameraAttributesPractical, distance: float) {
}
CameraAttributesPractical_get_dof_blur_far_transition :: (using self: *CameraAttributesPractical) -> float {
}
CameraAttributesPractical_set_dof_blur_near_enabled :: (using self: *CameraAttributesPractical, enabled: bool) {
}
CameraAttributesPractical_is_dof_blur_near_enabled :: (using self: *CameraAttributesPractical) -> bool {
}
CameraAttributesPractical_set_dof_blur_near_distance :: (using self: *CameraAttributesPractical, distance: float) {
}
CameraAttributesPractical_get_dof_blur_near_distance :: (using self: *CameraAttributesPractical) -> float {
}
CameraAttributesPractical_set_dof_blur_near_transition :: (using self: *CameraAttributesPractical, distance: float) {
}
CameraAttributesPractical_get_dof_blur_near_transition :: (using self: *CameraAttributesPractical) -> float {
}
CameraAttributesPractical_set_dof_blur_amount :: (using self: *CameraAttributesPractical, amount: float) {
}
CameraAttributesPractical_get_dof_blur_amount :: (using self: *CameraAttributesPractical) -> float {
}
CameraAttributesPractical_set_auto_exposure_max_sensitivity :: (using self: *CameraAttributesPractical, max_sensitivity: float) {
}
CameraAttributesPractical_get_auto_exposure_max_sensitivity :: (using self: *CameraAttributesPractical) -> float {
}
CameraAttributesPractical_set_auto_exposure_min_sensitivity :: (using self: *CameraAttributesPractical, min_sensitivity: float) {
}
CameraAttributesPractical_get_auto_exposure_min_sensitivity :: (using self: *CameraAttributesPractical) -> float {
}

// CameraFeed
CameraFeed :: struct {
	__private: *void;

	FeedDataType :: enum {
		FEED_NOIMAGE :: 0;
		FEED_RGB :: 1;
		FEED_YCBCR :: 2;
		FEED_YCBCR_SEP :: 3;
	}
	FeedPosition :: enum {
		FEED_UNSPECIFIED :: 0;
		FEED_FRONT :: 1;
		FEED_BACK :: 2;
	}
}

CameraFeed_get_id :: (using self: *CameraFeed) -> int {
}
CameraFeed_is_active :: (using self: *CameraFeed) -> bool {
}
CameraFeed_set_active :: (using self: *CameraFeed, active: bool) {
}
CameraFeed_get_name :: (using self: *CameraFeed) -> String {
}
CameraFeed_get_position :: (using self: *CameraFeed) -> CameraFeed.FeedPosition {
}
CameraFeed_get_transform :: (using self: *CameraFeed) -> Transform2D {
}
CameraFeed_set_transform :: (using self: *CameraFeed, transform: Transform2D) {
}
CameraFeed_get_datatype :: (using self: *CameraFeed) -> CameraFeed.FeedDataType {
}

// CameraServer
CameraServer :: struct {
	__private: *void;

	FeedImage :: enum {
		FEED_RGBA_IMAGE :: 0;
		FEED_YCBCR_IMAGE :: 0;
		FEED_Y_IMAGE :: 0;
		FEED_CBCR_IMAGE :: 1;
	}
}

CameraServer_get_feed :: (using self: *CameraServer, index: int) -> CameraFeed {
}
CameraServer_get_feed_count :: (using self: *CameraServer) -> int {
}
CameraServer_feeds :: (using self: *CameraServer) -> Array {
}
CameraServer_add_feed :: (using self: *CameraServer, feed: CameraFeed) {
}
CameraServer_remove_feed :: (using self: *CameraServer, feed: CameraFeed) {
}

// CameraTexture
CameraTexture :: struct {
	__private: *void;
}

CameraTexture_set_camera_feed_id :: (using self: *CameraTexture, feed_id: int) {
}
CameraTexture_get_camera_feed_id :: (using self: *CameraTexture) -> int {
}
CameraTexture_set_which_feed :: (using self: *CameraTexture, which_feed: CameraServer.FeedImage) {
}
CameraTexture_get_which_feed :: (using self: *CameraTexture) -> CameraServer.FeedImage {
}
CameraTexture_set_camera_active :: (using self: *CameraTexture, active: bool) {
}
CameraTexture_get_camera_active :: (using self: *CameraTexture) -> bool {
}

// CanvasGroup
CanvasGroup :: struct {
	__private: *void;
}

CanvasGroup_set_fit_margin :: (using self: *CanvasGroup, fit_margin: float) {
}
CanvasGroup_get_fit_margin :: (using self: *CanvasGroup) -> float {
}
CanvasGroup_set_clear_margin :: (using self: *CanvasGroup, clear_margin: float) {
}
CanvasGroup_get_clear_margin :: (using self: *CanvasGroup) -> float {
}
CanvasGroup_set_use_mipmaps :: (using self: *CanvasGroup, use_mipmaps: bool) {
}
CanvasGroup_is_using_mipmaps :: (using self: *CanvasGroup) -> bool {
}

// CanvasItem
CanvasItem :: struct {
	__private: *void;

	NOTIFICATION_TRANSFORM_CHANGED :: 2000;
	NOTIFICATION_LOCAL_TRANSFORM_CHANGED :: 35;
	NOTIFICATION_DRAW :: 30;
	NOTIFICATION_VISIBILITY_CHANGED :: 31;
	NOTIFICATION_ENTER_CANVAS :: 32;
	NOTIFICATION_EXIT_CANVAS :: 33;
	NOTIFICATION_WORLD_2D_CHANGED :: 36;

	TextureFilter :: enum {
		TEXTURE_FILTER_PARENT_NODE :: 0;
		TEXTURE_FILTER_NEAREST :: 1;
		TEXTURE_FILTER_LINEAR :: 2;
		TEXTURE_FILTER_NEAREST_WITH_MIPMAPS :: 3;
		TEXTURE_FILTER_LINEAR_WITH_MIPMAPS :: 4;
		TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC :: 5;
		TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC :: 6;
		TEXTURE_FILTER_MAX :: 7;
	}
	TextureRepeat :: enum {
		TEXTURE_REPEAT_PARENT_NODE :: 0;
		TEXTURE_REPEAT_DISABLED :: 1;
		TEXTURE_REPEAT_ENABLED :: 2;
		TEXTURE_REPEAT_MIRROR :: 3;
		TEXTURE_REPEAT_MAX :: 4;
	}
	ClipChildrenMode :: enum {
		CLIP_CHILDREN_DISABLED :: 0;
		CLIP_CHILDREN_ONLY :: 1;
		CLIP_CHILDREN_AND_DRAW :: 2;
		CLIP_CHILDREN_MAX :: 3;
	}
}

CanvasItem__draw :: (using self: *CanvasItem) {
}
CanvasItem_get_canvas_item :: (using self: *CanvasItem) -> RID {
}
CanvasItem_set_visible :: (using self: *CanvasItem, visible: bool) {
}
CanvasItem_is_visible :: (using self: *CanvasItem) -> bool {
}
CanvasItem_is_visible_in_tree :: (using self: *CanvasItem) -> bool {
}
CanvasItem_show :: (using self: *CanvasItem) {
}
CanvasItem_hide :: (using self: *CanvasItem) {
}
CanvasItem_queue_redraw :: (using self: *CanvasItem) {
}
CanvasItem_move_to_front :: (using self: *CanvasItem) {
}
CanvasItem_set_as_top_level :: (using self: *CanvasItem, enable: bool) {
}
CanvasItem_is_set_as_top_level :: (using self: *CanvasItem) -> bool {
}
CanvasItem_set_light_mask :: (using self: *CanvasItem, light_mask: int) {
}
CanvasItem_get_light_mask :: (using self: *CanvasItem) -> int {
}
CanvasItem_set_modulate :: (using self: *CanvasItem, modulate: Color) {
}
CanvasItem_get_modulate :: (using self: *CanvasItem) -> Color {
}
CanvasItem_set_self_modulate :: (using self: *CanvasItem, self_modulate: Color) {
}
CanvasItem_get_self_modulate :: (using self: *CanvasItem) -> Color {
}
CanvasItem_set_z_index :: (using self: *CanvasItem, z_index: int) {
}
CanvasItem_get_z_index :: (using self: *CanvasItem) -> int {
}
CanvasItem_set_z_as_relative :: (using self: *CanvasItem, enable: bool) {
}
CanvasItem_is_z_relative :: (using self: *CanvasItem) -> bool {
}
CanvasItem_set_y_sort_enabled :: (using self: *CanvasItem, enabled: bool) {
}
CanvasItem_is_y_sort_enabled :: (using self: *CanvasItem) -> bool {
}
CanvasItem_set_draw_behind_parent :: (using self: *CanvasItem, enable: bool) {
}
CanvasItem_is_draw_behind_parent_enabled :: (using self: *CanvasItem) -> bool {
}
CanvasItem_draw_line :: (using self: *CanvasItem, from: Vector2, to: Vector2, color: Color, width: float, antialiased: bool) {
}
CanvasItem_draw_dashed_line :: (using self: *CanvasItem, from: Vector2, to: Vector2, color: Color, width: float, dash: float, aligned: bool, antialiased: bool) {
}
CanvasItem_draw_polyline :: (using self: *CanvasItem, points: PackedVector2Array, color: Color, width: float, antialiased: bool) {
}
CanvasItem_draw_polyline_colors :: (using self: *CanvasItem, points: PackedVector2Array, colors: PackedColorArray, width: float, antialiased: bool) {
}
CanvasItem_draw_arc :: (using self: *CanvasItem, center: Vector2, radius: float, start_angle: float, end_angle: float, point_count: int, color: Color, width: float, antialiased: bool) {
}
CanvasItem_draw_multiline :: (using self: *CanvasItem, points: PackedVector2Array, color: Color, width: float, antialiased: bool) {
}
CanvasItem_draw_multiline_colors :: (using self: *CanvasItem, points: PackedVector2Array, colors: PackedColorArray, width: float, antialiased: bool) {
}
CanvasItem_draw_rect :: (using self: *CanvasItem, rect: Rect2, color: Color, filled: bool, width: float, antialiased: bool) {
}
CanvasItem_draw_circle :: (using self: *CanvasItem, position: Vector2, radius: float, color: Color, filled: bool, width: float, antialiased: bool) {
}
CanvasItem_draw_texture :: (using self: *CanvasItem, texture: Texture2D, position: Vector2, modulate: Color) {
}
CanvasItem_draw_texture_rect :: (using self: *CanvasItem, texture: Texture2D, rect: Rect2, tile: bool, modulate: Color, transpose: bool) {
}
CanvasItem_draw_texture_rect_region :: (using self: *CanvasItem, texture: Texture2D, rect: Rect2, src_rect: Rect2, modulate: Color, transpose: bool, clip_uv: bool) {
}
CanvasItem_draw_msdf_texture_rect_region :: (using self: *CanvasItem, texture: Texture2D, rect: Rect2, src_rect: Rect2, modulate: Color, outline: float, pixel_range: float, scale: float) {
}
CanvasItem_draw_lcd_texture_rect_region :: (using self: *CanvasItem, texture: Texture2D, rect: Rect2, src_rect: Rect2, modulate: Color) {
}
CanvasItem_draw_style_box :: (using self: *CanvasItem, style_box: StyleBox, rect: Rect2) {
}
CanvasItem_draw_primitive :: (using self: *CanvasItem, points: PackedVector2Array, colors: PackedColorArray, uvs: PackedVector2Array, texture: Texture2D) {
}
CanvasItem_draw_polygon :: (using self: *CanvasItem, points: PackedVector2Array, colors: PackedColorArray, uvs: PackedVector2Array, texture: Texture2D) {
}
CanvasItem_draw_colored_polygon :: (using self: *CanvasItem, points: PackedVector2Array, color: Color, uvs: PackedVector2Array, texture: Texture2D) {
}
CanvasItem_draw_string :: (using self: *CanvasItem, font: Font, pos: Vector2, text: String, alignment: HorizontalAlignment, width: float, font_size: int, modulate: Color, justification_flags: TextServer.JustificationFlag, direction: TextServer.Direction, orientation: TextServer.Orientation) {
}
CanvasItem_draw_multiline_string :: (using self: *CanvasItem, font: Font, pos: Vector2, text: String, alignment: HorizontalAlignment, width: float, font_size: int, max_lines: int, modulate: Color, brk_flags: TextServer.LineBreakFlag, justification_flags: TextServer.JustificationFlag, direction: TextServer.Direction, orientation: TextServer.Orientation) {
}
CanvasItem_draw_string_outline :: (using self: *CanvasItem, font: Font, pos: Vector2, text: String, alignment: HorizontalAlignment, width: float, font_size: int, size: int, modulate: Color, justification_flags: TextServer.JustificationFlag, direction: TextServer.Direction, orientation: TextServer.Orientation) {
}
CanvasItem_draw_multiline_string_outline :: (using self: *CanvasItem, font: Font, pos: Vector2, text: String, alignment: HorizontalAlignment, width: float, font_size: int, max_lines: int, size: int, modulate: Color, brk_flags: TextServer.LineBreakFlag, justification_flags: TextServer.JustificationFlag, direction: TextServer.Direction, orientation: TextServer.Orientation) {
}
CanvasItem_draw_char :: (using self: *CanvasItem, font: Font, pos: Vector2, char: String, font_size: int, modulate: Color) {
}
CanvasItem_draw_char_outline :: (using self: *CanvasItem, font: Font, pos: Vector2, char: String, font_size: int, size: int, modulate: Color) {
}
CanvasItem_draw_mesh :: (using self: *CanvasItem, mesh: Mesh, texture: Texture2D, transform: Transform2D, modulate: Color) {
}
CanvasItem_draw_multimesh :: (using self: *CanvasItem, multimesh: MultiMesh, texture: Texture2D) {
}
CanvasItem_draw_set_transform :: (using self: *CanvasItem, position: Vector2, rotation: float, scale: Vector2) {
}
CanvasItem_draw_set_transform_matrix :: (using self: *CanvasItem, xform: Transform2D) {
}
CanvasItem_draw_animation_slice :: (using self: *CanvasItem, animation_length: float, slice_begin: float, slice_end: float, offset: float) {
}
CanvasItem_draw_end_animation :: (using self: *CanvasItem) {
}
CanvasItem_get_transform :: (using self: *CanvasItem) -> Transform2D {
}
CanvasItem_get_global_transform :: (using self: *CanvasItem) -> Transform2D {
}
CanvasItem_get_global_transform_with_canvas :: (using self: *CanvasItem) -> Transform2D {
}
CanvasItem_get_viewport_transform :: (using self: *CanvasItem) -> Transform2D {
}
CanvasItem_get_viewport_rect :: (using self: *CanvasItem) -> Rect2 {
}
CanvasItem_get_canvas_transform :: (using self: *CanvasItem) -> Transform2D {
}
CanvasItem_get_screen_transform :: (using self: *CanvasItem) -> Transform2D {
}
CanvasItem_get_local_mouse_position :: (using self: *CanvasItem) -> Vector2 {
}
CanvasItem_get_global_mouse_position :: (using self: *CanvasItem) -> Vector2 {
}
CanvasItem_get_canvas :: (using self: *CanvasItem) -> RID {
}
CanvasItem_get_canvas_layer_node :: (using self: *CanvasItem) -> CanvasLayer {
}
CanvasItem_get_world_2d :: (using self: *CanvasItem) -> World2D {
}
CanvasItem_set_material :: (using self: *CanvasItem, material: Material) {
}
CanvasItem_get_material :: (using self: *CanvasItem) -> Material {
}
CanvasItem_set_use_parent_material :: (using self: *CanvasItem, enable: bool) {
}
CanvasItem_get_use_parent_material :: (using self: *CanvasItem) -> bool {
}
CanvasItem_set_notify_local_transform :: (using self: *CanvasItem, enable: bool) {
}
CanvasItem_is_local_transform_notification_enabled :: (using self: *CanvasItem) -> bool {
}
CanvasItem_set_notify_transform :: (using self: *CanvasItem, enable: bool) {
}
CanvasItem_is_transform_notification_enabled :: (using self: *CanvasItem) -> bool {
}
CanvasItem_force_update_transform :: (using self: *CanvasItem) {
}
CanvasItem_make_canvas_position_local :: (using self: *CanvasItem, screen_point: Vector2) -> Vector2 {
}
CanvasItem_make_input_local :: (using self: *CanvasItem, event: InputEvent) -> InputEvent {
}
CanvasItem_set_visibility_layer :: (using self: *CanvasItem, layer: int) {
}
CanvasItem_get_visibility_layer :: (using self: *CanvasItem) -> int {
}
CanvasItem_set_visibility_layer_bit :: (using self: *CanvasItem, layer: int, enabled: bool) {
}
CanvasItem_get_visibility_layer_bit :: (using self: *CanvasItem, layer: int) -> bool {
}
CanvasItem_set_texture_filter :: (using self: *CanvasItem, mode: CanvasItem.TextureFilter) {
}
CanvasItem_get_texture_filter :: (using self: *CanvasItem) -> CanvasItem.TextureFilter {
}
CanvasItem_set_texture_repeat :: (using self: *CanvasItem, mode: CanvasItem.TextureRepeat) {
}
CanvasItem_get_texture_repeat :: (using self: *CanvasItem) -> CanvasItem.TextureRepeat {
}
CanvasItem_set_clip_children_mode :: (using self: *CanvasItem, mode: CanvasItem.ClipChildrenMode) {
}
CanvasItem_get_clip_children_mode :: (using self: *CanvasItem) -> CanvasItem.ClipChildrenMode {
}

// CanvasItemMaterial
CanvasItemMaterial :: struct {
	__private: *void;

	BlendMode :: enum {
		BLEND_MODE_MIX :: 0;
		BLEND_MODE_ADD :: 1;
		BLEND_MODE_SUB :: 2;
		BLEND_MODE_MUL :: 3;
		BLEND_MODE_PREMULT_ALPHA :: 4;
	}
	LightMode :: enum {
		LIGHT_MODE_NORMAL :: 0;
		LIGHT_MODE_UNSHADED :: 1;
		LIGHT_MODE_LIGHT_ONLY :: 2;
	}
}

CanvasItemMaterial_set_blend_mode :: (using self: *CanvasItemMaterial, blend_mode: CanvasItemMaterial.BlendMode) {
}
CanvasItemMaterial_get_blend_mode :: (using self: *CanvasItemMaterial) -> CanvasItemMaterial.BlendMode {
}
CanvasItemMaterial_set_light_mode :: (using self: *CanvasItemMaterial, light_mode: CanvasItemMaterial.LightMode) {
}
CanvasItemMaterial_get_light_mode :: (using self: *CanvasItemMaterial) -> CanvasItemMaterial.LightMode {
}
CanvasItemMaterial_set_particles_animation :: (using self: *CanvasItemMaterial, particles_anim: bool) {
}
CanvasItemMaterial_get_particles_animation :: (using self: *CanvasItemMaterial) -> bool {
}
CanvasItemMaterial_set_particles_anim_h_frames :: (using self: *CanvasItemMaterial, frames: int) {
}
CanvasItemMaterial_get_particles_anim_h_frames :: (using self: *CanvasItemMaterial) -> int {
}
CanvasItemMaterial_set_particles_anim_v_frames :: (using self: *CanvasItemMaterial, frames: int) {
}
CanvasItemMaterial_get_particles_anim_v_frames :: (using self: *CanvasItemMaterial) -> int {
}
CanvasItemMaterial_set_particles_anim_loop :: (using self: *CanvasItemMaterial, loop: bool) {
}
CanvasItemMaterial_get_particles_anim_loop :: (using self: *CanvasItemMaterial) -> bool {
}

// CanvasLayer
CanvasLayer :: struct {
	__private: *void;
}

CanvasLayer_set_layer :: (using self: *CanvasLayer, layer: int) {
}
CanvasLayer_get_layer :: (using self: *CanvasLayer) -> int {
}
CanvasLayer_set_visible :: (using self: *CanvasLayer, visible: bool) {
}
CanvasLayer_is_visible :: (using self: *CanvasLayer) -> bool {
}
CanvasLayer_show :: (using self: *CanvasLayer) {
}
CanvasLayer_hide :: (using self: *CanvasLayer) {
}
CanvasLayer_set_transform :: (using self: *CanvasLayer, transform: Transform2D) {
}
CanvasLayer_get_transform :: (using self: *CanvasLayer) -> Transform2D {
}
CanvasLayer_get_final_transform :: (using self: *CanvasLayer) -> Transform2D {
}
CanvasLayer_set_offset :: (using self: *CanvasLayer, offset: Vector2) {
}
CanvasLayer_get_offset :: (using self: *CanvasLayer) -> Vector2 {
}
CanvasLayer_set_rotation :: (using self: *CanvasLayer, radians: float) {
}
CanvasLayer_get_rotation :: (using self: *CanvasLayer) -> float {
}
CanvasLayer_set_scale :: (using self: *CanvasLayer, scale: Vector2) {
}
CanvasLayer_get_scale :: (using self: *CanvasLayer) -> Vector2 {
}
CanvasLayer_set_follow_viewport :: (using self: *CanvasLayer, enable: bool) {
}
CanvasLayer_is_following_viewport :: (using self: *CanvasLayer) -> bool {
}
CanvasLayer_set_follow_viewport_scale :: (using self: *CanvasLayer, scale: float) {
}
CanvasLayer_get_follow_viewport_scale :: (using self: *CanvasLayer) -> float {
}
CanvasLayer_set_custom_viewport :: (using self: *CanvasLayer, viewport: Node) {
}
CanvasLayer_get_custom_viewport :: (using self: *CanvasLayer) -> Node {
}
CanvasLayer_get_canvas :: (using self: *CanvasLayer) -> RID {
}

// CanvasModulate
CanvasModulate :: struct {
	__private: *void;
}

CanvasModulate_set_color :: (using self: *CanvasModulate, color: Color) {
}
CanvasModulate_get_color :: (using self: *CanvasModulate) -> Color {
}

// CanvasTexture
CanvasTexture :: struct {
	__private: *void;
}

CanvasTexture_set_diffuse_texture :: (using self: *CanvasTexture, texture: Texture2D) {
}
CanvasTexture_get_diffuse_texture :: (using self: *CanvasTexture) -> Texture2D {
}
CanvasTexture_set_normal_texture :: (using self: *CanvasTexture, texture: Texture2D) {
}
CanvasTexture_get_normal_texture :: (using self: *CanvasTexture) -> Texture2D {
}
CanvasTexture_set_specular_texture :: (using self: *CanvasTexture, texture: Texture2D) {
}
CanvasTexture_get_specular_texture :: (using self: *CanvasTexture) -> Texture2D {
}
CanvasTexture_set_specular_color :: (using self: *CanvasTexture, color: Color) {
}
CanvasTexture_get_specular_color :: (using self: *CanvasTexture) -> Color {
}
CanvasTexture_set_specular_shininess :: (using self: *CanvasTexture, shininess: float) {
}
CanvasTexture_get_specular_shininess :: (using self: *CanvasTexture) -> float {
}
CanvasTexture_set_texture_filter :: (using self: *CanvasTexture, filter: CanvasItem.TextureFilter) {
}
CanvasTexture_get_texture_filter :: (using self: *CanvasTexture) -> CanvasItem.TextureFilter {
}
CanvasTexture_set_texture_repeat :: (using self: *CanvasTexture, repeat: CanvasItem.TextureRepeat) {
}
CanvasTexture_get_texture_repeat :: (using self: *CanvasTexture) -> CanvasItem.TextureRepeat {
}

// CapsuleMesh
CapsuleMesh :: struct {
	__private: *void;
}

CapsuleMesh_set_radius :: (using self: *CapsuleMesh, radius: float) {
}
CapsuleMesh_get_radius :: (using self: *CapsuleMesh) -> float {
}
CapsuleMesh_set_height :: (using self: *CapsuleMesh, height: float) {
}
CapsuleMesh_get_height :: (using self: *CapsuleMesh) -> float {
}
CapsuleMesh_set_radial_segments :: (using self: *CapsuleMesh, segments: int) {
}
CapsuleMesh_get_radial_segments :: (using self: *CapsuleMesh) -> int {
}
CapsuleMesh_set_rings :: (using self: *CapsuleMesh, rings: int) {
}
CapsuleMesh_get_rings :: (using self: *CapsuleMesh) -> int {
}

// CapsuleShape2D
CapsuleShape2D :: struct {
	__private: *void;
}

CapsuleShape2D_set_radius :: (using self: *CapsuleShape2D, radius: float) {
}
CapsuleShape2D_get_radius :: (using self: *CapsuleShape2D) -> float {
}
CapsuleShape2D_set_height :: (using self: *CapsuleShape2D, height: float) {
}
CapsuleShape2D_get_height :: (using self: *CapsuleShape2D) -> float {
}

// CapsuleShape3D
CapsuleShape3D :: struct {
	__private: *void;
}

CapsuleShape3D_set_radius :: (using self: *CapsuleShape3D, radius: float) {
}
CapsuleShape3D_get_radius :: (using self: *CapsuleShape3D) -> float {
}
CapsuleShape3D_set_height :: (using self: *CapsuleShape3D, height: float) {
}
CapsuleShape3D_get_height :: (using self: *CapsuleShape3D) -> float {
}

// CenterContainer
CenterContainer :: struct {
	__private: *void;
}

CenterContainer_set_use_top_left :: (using self: *CenterContainer, enable: bool) {
}
CenterContainer_is_using_top_left :: (using self: *CenterContainer) -> bool {
}

// CharFXTransform
CharFXTransform :: struct {
	__private: *void;
}

CharFXTransform_get_transform :: (using self: *CharFXTransform) -> Transform2D {
}
CharFXTransform_set_transform :: (using self: *CharFXTransform, transform: Transform2D) {
}
CharFXTransform_get_range :: (using self: *CharFXTransform) -> Vector2i {
}
CharFXTransform_set_range :: (using self: *CharFXTransform, range: Vector2i) {
}
CharFXTransform_get_elapsed_time :: (using self: *CharFXTransform) -> float {
}
CharFXTransform_set_elapsed_time :: (using self: *CharFXTransform, time: float) {
}
CharFXTransform_is_visible :: (using self: *CharFXTransform) -> bool {
}
CharFXTransform_set_visibility :: (using self: *CharFXTransform, visibility: bool) {
}
CharFXTransform_is_outline :: (using self: *CharFXTransform) -> bool {
}
CharFXTransform_set_outline :: (using self: *CharFXTransform, outline: bool) {
}
CharFXTransform_get_offset :: (using self: *CharFXTransform) -> Vector2 {
}
CharFXTransform_set_offset :: (using self: *CharFXTransform, offset: Vector2) {
}
CharFXTransform_get_color :: (using self: *CharFXTransform) -> Color {
}
CharFXTransform_set_color :: (using self: *CharFXTransform, color: Color) {
}
CharFXTransform_get_environment :: (using self: *CharFXTransform) -> Dictionary {
}
CharFXTransform_set_environment :: (using self: *CharFXTransform, environment: Dictionary) {
}
CharFXTransform_get_glyph_index :: (using self: *CharFXTransform) -> int {
}
CharFXTransform_set_glyph_index :: (using self: *CharFXTransform, glyph_index: int) {
}
CharFXTransform_get_relative_index :: (using self: *CharFXTransform) -> int {
}
CharFXTransform_set_relative_index :: (using self: *CharFXTransform, relative_index: int) {
}
CharFXTransform_get_glyph_count :: (using self: *CharFXTransform) -> int {
}
CharFXTransform_set_glyph_count :: (using self: *CharFXTransform, glyph_count: int) {
}
CharFXTransform_get_glyph_flags :: (using self: *CharFXTransform) -> int {
}
CharFXTransform_set_glyph_flags :: (using self: *CharFXTransform, glyph_flags: int) {
}
CharFXTransform_get_font :: (using self: *CharFXTransform) -> RID {
}
CharFXTransform_set_font :: (using self: *CharFXTransform, font: RID) {
}

// CharacterBody2D
CharacterBody2D :: struct {
	__private: *void;

	MotionMode :: enum {
		MOTION_MODE_GROUNDED :: 0;
		MOTION_MODE_FLOATING :: 1;
	}
	PlatformOnLeave :: enum {
		PLATFORM_ON_LEAVE_ADD_VELOCITY :: 0;
		PLATFORM_ON_LEAVE_ADD_UPWARD_VELOCITY :: 1;
		PLATFORM_ON_LEAVE_DO_NOTHING :: 2;
	}
}

CharacterBody2D_move_and_slide :: (using self: *CharacterBody2D) -> bool {
}
CharacterBody2D_apply_floor_snap :: (using self: *CharacterBody2D) {
}
CharacterBody2D_set_velocity :: (using self: *CharacterBody2D, velocity: Vector2) {
}
CharacterBody2D_get_velocity :: (using self: *CharacterBody2D) -> Vector2 {
}
CharacterBody2D_set_safe_margin :: (using self: *CharacterBody2D, margin: float) {
}
CharacterBody2D_get_safe_margin :: (using self: *CharacterBody2D) -> float {
}
CharacterBody2D_is_floor_stop_on_slope_enabled :: (using self: *CharacterBody2D) -> bool {
}
CharacterBody2D_set_floor_stop_on_slope_enabled :: (using self: *CharacterBody2D, enabled: bool) {
}
CharacterBody2D_set_floor_constant_speed_enabled :: (using self: *CharacterBody2D, enabled: bool) {
}
CharacterBody2D_is_floor_constant_speed_enabled :: (using self: *CharacterBody2D) -> bool {
}
CharacterBody2D_set_floor_block_on_wall_enabled :: (using self: *CharacterBody2D, enabled: bool) {
}
CharacterBody2D_is_floor_block_on_wall_enabled :: (using self: *CharacterBody2D) -> bool {
}
CharacterBody2D_set_slide_on_ceiling_enabled :: (using self: *CharacterBody2D, enabled: bool) {
}
CharacterBody2D_is_slide_on_ceiling_enabled :: (using self: *CharacterBody2D) -> bool {
}
CharacterBody2D_set_platform_floor_layers :: (using self: *CharacterBody2D, exclude_layer: int) {
}
CharacterBody2D_get_platform_floor_layers :: (using self: *CharacterBody2D) -> int {
}
CharacterBody2D_set_platform_wall_layers :: (using self: *CharacterBody2D, exclude_layer: int) {
}
CharacterBody2D_get_platform_wall_layers :: (using self: *CharacterBody2D) -> int {
}
CharacterBody2D_get_max_slides :: (using self: *CharacterBody2D) -> int {
}
CharacterBody2D_set_max_slides :: (using self: *CharacterBody2D, max_slides: int) {
}
CharacterBody2D_get_floor_max_angle :: (using self: *CharacterBody2D) -> float {
}
CharacterBody2D_set_floor_max_angle :: (using self: *CharacterBody2D, radians: float) {
}
CharacterBody2D_get_floor_snap_length :: (using self: *CharacterBody2D) -> float {
}
CharacterBody2D_set_floor_snap_length :: (using self: *CharacterBody2D, floor_snap_length: float) {
}
CharacterBody2D_get_wall_min_slide_angle :: (using self: *CharacterBody2D) -> float {
}
CharacterBody2D_set_wall_min_slide_angle :: (using self: *CharacterBody2D, radians: float) {
}
CharacterBody2D_get_up_direction :: (using self: *CharacterBody2D) -> Vector2 {
}
CharacterBody2D_set_up_direction :: (using self: *CharacterBody2D, up_direction: Vector2) {
}
CharacterBody2D_set_motion_mode :: (using self: *CharacterBody2D, mode: CharacterBody2D.MotionMode) {
}
CharacterBody2D_get_motion_mode :: (using self: *CharacterBody2D) -> CharacterBody2D.MotionMode {
}
CharacterBody2D_set_platform_on_leave :: (using self: *CharacterBody2D, on_leave_apply_velocity: CharacterBody2D.PlatformOnLeave) {
}
CharacterBody2D_get_platform_on_leave :: (using self: *CharacterBody2D) -> CharacterBody2D.PlatformOnLeave {
}
CharacterBody2D_is_on_floor :: (using self: *CharacterBody2D) -> bool {
}
CharacterBody2D_is_on_floor_only :: (using self: *CharacterBody2D) -> bool {
}
CharacterBody2D_is_on_ceiling :: (using self: *CharacterBody2D) -> bool {
}
CharacterBody2D_is_on_ceiling_only :: (using self: *CharacterBody2D) -> bool {
}
CharacterBody2D_is_on_wall :: (using self: *CharacterBody2D) -> bool {
}
CharacterBody2D_is_on_wall_only :: (using self: *CharacterBody2D) -> bool {
}
CharacterBody2D_get_floor_normal :: (using self: *CharacterBody2D) -> Vector2 {
}
CharacterBody2D_get_wall_normal :: (using self: *CharacterBody2D) -> Vector2 {
}
CharacterBody2D_get_last_motion :: (using self: *CharacterBody2D) -> Vector2 {
}
CharacterBody2D_get_position_delta :: (using self: *CharacterBody2D) -> Vector2 {
}
CharacterBody2D_get_real_velocity :: (using self: *CharacterBody2D) -> Vector2 {
}
CharacterBody2D_get_floor_angle :: (using self: *CharacterBody2D, up_direction: Vector2) -> float {
}
CharacterBody2D_get_platform_velocity :: (using self: *CharacterBody2D) -> Vector2 {
}
CharacterBody2D_get_slide_collision_count :: (using self: *CharacterBody2D) -> int {
}
CharacterBody2D_get_slide_collision :: (using self: *CharacterBody2D, slide_idx: int) -> KinematicCollision2D {
}
CharacterBody2D_get_last_slide_collision :: (using self: *CharacterBody2D) -> KinematicCollision2D {
}

// CharacterBody3D
CharacterBody3D :: struct {
	__private: *void;

	MotionMode :: enum {
		MOTION_MODE_GROUNDED :: 0;
		MOTION_MODE_FLOATING :: 1;
	}
	PlatformOnLeave :: enum {
		PLATFORM_ON_LEAVE_ADD_VELOCITY :: 0;
		PLATFORM_ON_LEAVE_ADD_UPWARD_VELOCITY :: 1;
		PLATFORM_ON_LEAVE_DO_NOTHING :: 2;
	}
}

CharacterBody3D_move_and_slide :: (using self: *CharacterBody3D) -> bool {
}
CharacterBody3D_apply_floor_snap :: (using self: *CharacterBody3D) {
}
CharacterBody3D_set_velocity :: (using self: *CharacterBody3D, velocity: Vector3) {
}
CharacterBody3D_get_velocity :: (using self: *CharacterBody3D) -> Vector3 {
}
CharacterBody3D_set_safe_margin :: (using self: *CharacterBody3D, margin: float) {
}
CharacterBody3D_get_safe_margin :: (using self: *CharacterBody3D) -> float {
}
CharacterBody3D_is_floor_stop_on_slope_enabled :: (using self: *CharacterBody3D) -> bool {
}
CharacterBody3D_set_floor_stop_on_slope_enabled :: (using self: *CharacterBody3D, enabled: bool) {
}
CharacterBody3D_set_floor_constant_speed_enabled :: (using self: *CharacterBody3D, enabled: bool) {
}
CharacterBody3D_is_floor_constant_speed_enabled :: (using self: *CharacterBody3D) -> bool {
}
CharacterBody3D_set_floor_block_on_wall_enabled :: (using self: *CharacterBody3D, enabled: bool) {
}
CharacterBody3D_is_floor_block_on_wall_enabled :: (using self: *CharacterBody3D) -> bool {
}
CharacterBody3D_set_slide_on_ceiling_enabled :: (using self: *CharacterBody3D, enabled: bool) {
}
CharacterBody3D_is_slide_on_ceiling_enabled :: (using self: *CharacterBody3D) -> bool {
}
CharacterBody3D_set_platform_floor_layers :: (using self: *CharacterBody3D, exclude_layer: int) {
}
CharacterBody3D_get_platform_floor_layers :: (using self: *CharacterBody3D) -> int {
}
CharacterBody3D_set_platform_wall_layers :: (using self: *CharacterBody3D, exclude_layer: int) {
}
CharacterBody3D_get_platform_wall_layers :: (using self: *CharacterBody3D) -> int {
}
CharacterBody3D_get_max_slides :: (using self: *CharacterBody3D) -> int {
}
CharacterBody3D_set_max_slides :: (using self: *CharacterBody3D, max_slides: int) {
}
CharacterBody3D_get_floor_max_angle :: (using self: *CharacterBody3D) -> float {
}
CharacterBody3D_set_floor_max_angle :: (using self: *CharacterBody3D, radians: float) {
}
CharacterBody3D_get_floor_snap_length :: (using self: *CharacterBody3D) -> float {
}
CharacterBody3D_set_floor_snap_length :: (using self: *CharacterBody3D, floor_snap_length: float) {
}
CharacterBody3D_get_wall_min_slide_angle :: (using self: *CharacterBody3D) -> float {
}
CharacterBody3D_set_wall_min_slide_angle :: (using self: *CharacterBody3D, radians: float) {
}
CharacterBody3D_get_up_direction :: (using self: *CharacterBody3D) -> Vector3 {
}
CharacterBody3D_set_up_direction :: (using self: *CharacterBody3D, up_direction: Vector3) {
}
CharacterBody3D_set_motion_mode :: (using self: *CharacterBody3D, mode: CharacterBody3D.MotionMode) {
}
CharacterBody3D_get_motion_mode :: (using self: *CharacterBody3D) -> CharacterBody3D.MotionMode {
}
CharacterBody3D_set_platform_on_leave :: (using self: *CharacterBody3D, on_leave_apply_velocity: CharacterBody3D.PlatformOnLeave) {
}
CharacterBody3D_get_platform_on_leave :: (using self: *CharacterBody3D) -> CharacterBody3D.PlatformOnLeave {
}
CharacterBody3D_is_on_floor :: (using self: *CharacterBody3D) -> bool {
}
CharacterBody3D_is_on_floor_only :: (using self: *CharacterBody3D) -> bool {
}
CharacterBody3D_is_on_ceiling :: (using self: *CharacterBody3D) -> bool {
}
CharacterBody3D_is_on_ceiling_only :: (using self: *CharacterBody3D) -> bool {
}
CharacterBody3D_is_on_wall :: (using self: *CharacterBody3D) -> bool {
}
CharacterBody3D_is_on_wall_only :: (using self: *CharacterBody3D) -> bool {
}
CharacterBody3D_get_floor_normal :: (using self: *CharacterBody3D) -> Vector3 {
}
CharacterBody3D_get_wall_normal :: (using self: *CharacterBody3D) -> Vector3 {
}
CharacterBody3D_get_last_motion :: (using self: *CharacterBody3D) -> Vector3 {
}
CharacterBody3D_get_position_delta :: (using self: *CharacterBody3D) -> Vector3 {
}
CharacterBody3D_get_real_velocity :: (using self: *CharacterBody3D) -> Vector3 {
}
CharacterBody3D_get_floor_angle :: (using self: *CharacterBody3D, up_direction: Vector3) -> float {
}
CharacterBody3D_get_platform_velocity :: (using self: *CharacterBody3D) -> Vector3 {
}
CharacterBody3D_get_platform_angular_velocity :: (using self: *CharacterBody3D) -> Vector3 {
}
CharacterBody3D_get_slide_collision_count :: (using self: *CharacterBody3D) -> int {
}
CharacterBody3D_get_slide_collision :: (using self: *CharacterBody3D, slide_idx: int) -> KinematicCollision3D {
}
CharacterBody3D_get_last_slide_collision :: (using self: *CharacterBody3D) -> KinematicCollision3D {
}

// CheckBox
CheckBox :: struct {
	__private: *void;
}

// CheckButton
CheckButton :: struct {
	__private: *void;
}

// CircleShape2D
CircleShape2D :: struct {
	__private: *void;
}

CircleShape2D_set_radius :: (using self: *CircleShape2D, radius: float) {
}
CircleShape2D_get_radius :: (using self: *CircleShape2D) -> float {
}

// ClassDB
ClassDB :: struct {
	__private: *void;
}

ClassDB_get_class_list :: (using self: *ClassDB) -> PackedStringArray {
}
ClassDB_get_inheriters_from_class :: (using self: *ClassDB, class: StringName) -> PackedStringArray {
}
ClassDB_get_parent_class :: (using self: *ClassDB, class: StringName) -> StringName {
}
ClassDB_class_exists :: (using self: *ClassDB, class: StringName) -> bool {
}
ClassDB_is_parent_class :: (using self: *ClassDB, class: StringName, inherits: StringName) -> bool {
}
ClassDB_can_instantiate :: (using self: *ClassDB, class: StringName) -> bool {
}
ClassDB_instantiate :: (using self: *ClassDB, class: StringName) -> Variant {
}
ClassDB_class_has_signal :: (using self: *ClassDB, class: StringName, signal: StringName) -> bool {
}
ClassDB_class_get_signal :: (using self: *ClassDB, class: StringName, signal: StringName) -> Dictionary {
}
ClassDB_class_get_signal_list :: (using self: *ClassDB, class: StringName, no_inheritance: bool) -> Dictionary {
}
ClassDB_class_get_property_list :: (using self: *ClassDB, class: StringName, no_inheritance: bool) -> Dictionary {
}
ClassDB_class_get_property :: (using self: *ClassDB, object: Object, property: StringName) -> Variant {
}
ClassDB_class_set_property :: (using self: *ClassDB, object: Object, property: StringName, value: Variant) -> Error {
}
ClassDB_class_get_property_default_value :: (using self: *ClassDB, class: StringName, property: StringName) -> Variant {
}
ClassDB_class_has_method :: (using self: *ClassDB, class: StringName, method: StringName, no_inheritance: bool) -> bool {
}
ClassDB_class_get_method_argument_count :: (using self: *ClassDB, class: StringName, method: StringName, no_inheritance: bool) -> int {
}
ClassDB_class_get_method_list :: (using self: *ClassDB, class: StringName, no_inheritance: bool) -> Dictionary {
}
ClassDB_class_get_integer_constant_list :: (using self: *ClassDB, class: StringName, no_inheritance: bool) -> PackedStringArray {
}
ClassDB_class_has_integer_constant :: (using self: *ClassDB, class: StringName, name: StringName) -> bool {
}
ClassDB_class_get_integer_constant :: (using self: *ClassDB, class: StringName, name: StringName) -> int {
}
ClassDB_class_has_enum :: (using self: *ClassDB, class: StringName, name: StringName, no_inheritance: bool) -> bool {
}
ClassDB_class_get_enum_list :: (using self: *ClassDB, class: StringName, no_inheritance: bool) -> PackedStringArray {
}
ClassDB_class_get_enum_constants :: (using self: *ClassDB, class: StringName, _enum: StringName, no_inheritance: bool) -> PackedStringArray {
}
ClassDB_class_get_integer_constant_enum :: (using self: *ClassDB, class: StringName, name: StringName, no_inheritance: bool) -> StringName {
}
ClassDB_is_class_enum_bitfield :: (using self: *ClassDB, class: StringName, _enum: StringName, no_inheritance: bool) -> bool {
}
ClassDB_is_class_enabled :: (using self: *ClassDB, class: StringName) -> bool {
}

// CodeEdit
CodeEdit :: struct {
	__private: *void;

	CodeCompletionKind :: enum {
		KIND_CLASS :: 0;
		KIND_FUNCTION :: 1;
		KIND_SIGNAL :: 2;
		KIND_VARIABLE :: 3;
		KIND_MEMBER :: 4;
		KIND_ENUM :: 5;
		KIND_CONSTANT :: 6;
		KIND_NODE_PATH :: 7;
		KIND_FILE_PATH :: 8;
		KIND_PLAIN_TEXT :: 9;
	}
	CodeCompletionLocation :: enum {
		LOCATION_LOCAL :: 0;
		LOCATION_PARENT_MASK :: 256;
		LOCATION_OTHER_USER_CODE :: 512;
		LOCATION_OTHER :: 1024;
	}
}

CodeEdit__confirm_code_completion :: (using self: *CodeEdit, replace: bool) {
}
CodeEdit__request_code_completion :: (using self: *CodeEdit, force: bool) {
}
CodeEdit__filter_code_completion_candidates :: (using self: *CodeEdit, candidates: Dictionary) -> Dictionary {
}
CodeEdit_set_indent_size :: (using self: *CodeEdit, size: int) {
}
CodeEdit_get_indent_size :: (using self: *CodeEdit) -> int {
}
CodeEdit_set_indent_using_spaces :: (using self: *CodeEdit, use_spaces: bool) {
}
CodeEdit_is_indent_using_spaces :: (using self: *CodeEdit) -> bool {
}
CodeEdit_set_auto_indent_enabled :: (using self: *CodeEdit, enable: bool) {
}
CodeEdit_is_auto_indent_enabled :: (using self: *CodeEdit) -> bool {
}
CodeEdit_set_auto_indent_prefixes :: (using self: *CodeEdit, prefixes: Array) {
}
CodeEdit_get_auto_indent_prefixes :: (using self: *CodeEdit) -> Array {
}
CodeEdit_do_indent :: (using self: *CodeEdit) {
}
CodeEdit_indent_lines :: (using self: *CodeEdit) {
}
CodeEdit_unindent_lines :: (using self: *CodeEdit) {
}
CodeEdit_convert_indent :: (using self: *CodeEdit, from_line: int, to_line: int) {
}
CodeEdit_set_auto_brace_completion_enabled :: (using self: *CodeEdit, enable: bool) {
}
CodeEdit_is_auto_brace_completion_enabled :: (using self: *CodeEdit) -> bool {
}
CodeEdit_set_highlight_matching_braces_enabled :: (using self: *CodeEdit, enable: bool) {
}
CodeEdit_is_highlight_matching_braces_enabled :: (using self: *CodeEdit) -> bool {
}
CodeEdit_add_auto_brace_completion_pair :: (using self: *CodeEdit, start_key: String, end_key: String) {
}
CodeEdit_set_auto_brace_completion_pairs :: (using self: *CodeEdit, pairs: Dictionary) {
}
CodeEdit_get_auto_brace_completion_pairs :: (using self: *CodeEdit) -> Dictionary {
}
CodeEdit_has_auto_brace_completion_open_key :: (using self: *CodeEdit, open_key: String) -> bool {
}
CodeEdit_has_auto_brace_completion_close_key :: (using self: *CodeEdit, close_key: String) -> bool {
}
CodeEdit_get_auto_brace_completion_close_key :: (using self: *CodeEdit, open_key: String) -> String {
}
CodeEdit_set_draw_breakpoints_gutter :: (using self: *CodeEdit, enable: bool) {
}
CodeEdit_is_drawing_breakpoints_gutter :: (using self: *CodeEdit) -> bool {
}
CodeEdit_set_draw_bookmarks_gutter :: (using self: *CodeEdit, enable: bool) {
}
CodeEdit_is_drawing_bookmarks_gutter :: (using self: *CodeEdit) -> bool {
}
CodeEdit_set_draw_executing_lines_gutter :: (using self: *CodeEdit, enable: bool) {
}
CodeEdit_is_drawing_executing_lines_gutter :: (using self: *CodeEdit) -> bool {
}
CodeEdit_set_line_as_breakpoint :: (using self: *CodeEdit, line: int, breakpointed: bool) {
}
CodeEdit_is_line_breakpointed :: (using self: *CodeEdit, line: int) -> bool {
}
CodeEdit_clear_breakpointed_lines :: (using self: *CodeEdit) {
}
CodeEdit_get_breakpointed_lines :: (using self: *CodeEdit) -> PackedInt32Array {
}
CodeEdit_set_line_as_bookmarked :: (using self: *CodeEdit, line: int, bookmarked: bool) {
}
CodeEdit_is_line_bookmarked :: (using self: *CodeEdit, line: int) -> bool {
}
CodeEdit_clear_bookmarked_lines :: (using self: *CodeEdit) {
}
CodeEdit_get_bookmarked_lines :: (using self: *CodeEdit) -> PackedInt32Array {
}
CodeEdit_set_line_as_executing :: (using self: *CodeEdit, line: int, executing: bool) {
}
CodeEdit_is_line_executing :: (using self: *CodeEdit, line: int) -> bool {
}
CodeEdit_clear_executing_lines :: (using self: *CodeEdit) {
}
CodeEdit_get_executing_lines :: (using self: *CodeEdit) -> PackedInt32Array {
}
CodeEdit_set_draw_line_numbers :: (using self: *CodeEdit, enable: bool) {
}
CodeEdit_is_draw_line_numbers_enabled :: (using self: *CodeEdit) -> bool {
}
CodeEdit_set_line_numbers_zero_padded :: (using self: *CodeEdit, enable: bool) {
}
CodeEdit_is_line_numbers_zero_padded :: (using self: *CodeEdit) -> bool {
}
CodeEdit_set_draw_fold_gutter :: (using self: *CodeEdit, enable: bool) {
}
CodeEdit_is_drawing_fold_gutter :: (using self: *CodeEdit) -> bool {
}
CodeEdit_set_line_folding_enabled :: (using self: *CodeEdit, enabled: bool) {
}
CodeEdit_is_line_folding_enabled :: (using self: *CodeEdit) -> bool {
}
CodeEdit_can_fold_line :: (using self: *CodeEdit, line: int) -> bool {
}
CodeEdit_fold_line :: (using self: *CodeEdit, line: int) {
}
CodeEdit_unfold_line :: (using self: *CodeEdit, line: int) {
}
CodeEdit_fold_all_lines :: (using self: *CodeEdit) {
}
CodeEdit_unfold_all_lines :: (using self: *CodeEdit) {
}
CodeEdit_toggle_foldable_line :: (using self: *CodeEdit, line: int) {
}
CodeEdit_toggle_foldable_lines_at_carets :: (using self: *CodeEdit) {
}
CodeEdit_is_line_folded :: (using self: *CodeEdit, line: int) -> bool {
}
CodeEdit_get_folded_lines :: (using self: *CodeEdit) -> Array {
}
CodeEdit_create_code_region :: (using self: *CodeEdit) {
}
CodeEdit_get_code_region_start_tag :: (using self: *CodeEdit) -> String {
}
CodeEdit_get_code_region_end_tag :: (using self: *CodeEdit) -> String {
}
CodeEdit_set_code_region_tags :: (using self: *CodeEdit, start: String, end: String) {
}
CodeEdit_is_line_code_region_start :: (using self: *CodeEdit, line: int) -> bool {
}
CodeEdit_is_line_code_region_end :: (using self: *CodeEdit, line: int) -> bool {
}
CodeEdit_add_string_delimiter :: (using self: *CodeEdit, start_key: String, end_key: String, line_only: bool) {
}
CodeEdit_remove_string_delimiter :: (using self: *CodeEdit, start_key: String) {
}
CodeEdit_has_string_delimiter :: (using self: *CodeEdit, start_key: String) -> bool {
}
CodeEdit_set_string_delimiters :: (using self: *CodeEdit, string_delimiters: Array) {
}
CodeEdit_clear_string_delimiters :: (using self: *CodeEdit) {
}
CodeEdit_get_string_delimiters :: (using self: *CodeEdit) -> Array {
}
CodeEdit_is_in_string :: (using self: *CodeEdit, line: int, column: int) -> int {
}
CodeEdit_add_comment_delimiter :: (using self: *CodeEdit, start_key: String, end_key: String, line_only: bool) {
}
CodeEdit_remove_comment_delimiter :: (using self: *CodeEdit, start_key: String) {
}
CodeEdit_has_comment_delimiter :: (using self: *CodeEdit, start_key: String) -> bool {
}
CodeEdit_set_comment_delimiters :: (using self: *CodeEdit, comment_delimiters: Array) {
}
CodeEdit_clear_comment_delimiters :: (using self: *CodeEdit) {
}
CodeEdit_get_comment_delimiters :: (using self: *CodeEdit) -> Array {
}
CodeEdit_is_in_comment :: (using self: *CodeEdit, line: int, column: int) -> int {
}
CodeEdit_get_delimiter_start_key :: (using self: *CodeEdit, delimiter_index: int) -> String {
}
CodeEdit_get_delimiter_end_key :: (using self: *CodeEdit, delimiter_index: int) -> String {
}
CodeEdit_get_delimiter_start_position :: (using self: *CodeEdit, line: int, column: int) -> Vector2 {
}
CodeEdit_get_delimiter_end_position :: (using self: *CodeEdit, line: int, column: int) -> Vector2 {
}
CodeEdit_set_code_hint :: (using self: *CodeEdit, code_hint: String) {
}
CodeEdit_set_code_hint_draw_below :: (using self: *CodeEdit, draw_below: bool) {
}
CodeEdit_get_text_for_code_completion :: (using self: *CodeEdit) -> String {
}
CodeEdit_request_code_completion :: (using self: *CodeEdit, force: bool) {
}
CodeEdit_add_code_completion_option :: (using self: *CodeEdit, type: CodeEdit.CodeCompletionKind, display_text: String, insert_text: String, text_color: Color, icon: Resource, value: Variant, location: int) {
}
CodeEdit_update_code_completion_options :: (using self: *CodeEdit, force: bool) {
}
CodeEdit_get_code_completion_options :: (using self: *CodeEdit) -> Dictionary {
}
CodeEdit_get_code_completion_option :: (using self: *CodeEdit, index: int) -> Dictionary {
}
CodeEdit_get_code_completion_selected_index :: (using self: *CodeEdit) -> int {
}
CodeEdit_set_code_completion_selected_index :: (using self: *CodeEdit, index: int) {
}
CodeEdit_confirm_code_completion :: (using self: *CodeEdit, replace: bool) {
}
CodeEdit_cancel_code_completion :: (using self: *CodeEdit) {
}
CodeEdit_set_code_completion_enabled :: (using self: *CodeEdit, enable: bool) {
}
CodeEdit_is_code_completion_enabled :: (using self: *CodeEdit) -> bool {
}
CodeEdit_set_code_completion_prefixes :: (using self: *CodeEdit, prefixes: Array) {
}
CodeEdit_get_code_completion_prefixes :: (using self: *CodeEdit) -> Array {
}
CodeEdit_set_line_length_guidelines :: (using self: *CodeEdit, guideline_columns: Array) {
}
CodeEdit_get_line_length_guidelines :: (using self: *CodeEdit) -> Array {
}
CodeEdit_set_symbol_lookup_on_click_enabled :: (using self: *CodeEdit, enable: bool) {
}
CodeEdit_is_symbol_lookup_on_click_enabled :: (using self: *CodeEdit) -> bool {
}
CodeEdit_get_text_for_symbol_lookup :: (using self: *CodeEdit) -> String {
}
CodeEdit_get_text_with_cursor_char :: (using self: *CodeEdit, line: int, column: int) -> String {
}
CodeEdit_set_symbol_lookup_word_as_valid :: (using self: *CodeEdit, valid: bool) {
}
CodeEdit_move_lines_up :: (using self: *CodeEdit) {
}
CodeEdit_move_lines_down :: (using self: *CodeEdit) {
}
CodeEdit_delete_lines :: (using self: *CodeEdit) {
}
CodeEdit_duplicate_selection :: (using self: *CodeEdit) {
}
CodeEdit_duplicate_lines :: (using self: *CodeEdit) {
}

// CodeHighlighter
CodeHighlighter :: struct {
	__private: *void;
}

CodeHighlighter_add_keyword_color :: (using self: *CodeHighlighter, keyword: String, color: Color) {
}
CodeHighlighter_remove_keyword_color :: (using self: *CodeHighlighter, keyword: String) {
}
CodeHighlighter_has_keyword_color :: (using self: *CodeHighlighter, keyword: String) -> bool {
}
CodeHighlighter_get_keyword_color :: (using self: *CodeHighlighter, keyword: String) -> Color {
}
CodeHighlighter_set_keyword_colors :: (using self: *CodeHighlighter, keywords: Dictionary) {
}
CodeHighlighter_clear_keyword_colors :: (using self: *CodeHighlighter) {
}
CodeHighlighter_get_keyword_colors :: (using self: *CodeHighlighter) -> Dictionary {
}
CodeHighlighter_add_member_keyword_color :: (using self: *CodeHighlighter, member_keyword: String, color: Color) {
}
CodeHighlighter_remove_member_keyword_color :: (using self: *CodeHighlighter, member_keyword: String) {
}
CodeHighlighter_has_member_keyword_color :: (using self: *CodeHighlighter, member_keyword: String) -> bool {
}
CodeHighlighter_get_member_keyword_color :: (using self: *CodeHighlighter, member_keyword: String) -> Color {
}
CodeHighlighter_set_member_keyword_colors :: (using self: *CodeHighlighter, member_keyword: Dictionary) {
}
CodeHighlighter_clear_member_keyword_colors :: (using self: *CodeHighlighter) {
}
CodeHighlighter_get_member_keyword_colors :: (using self: *CodeHighlighter) -> Dictionary {
}
CodeHighlighter_add_color_region :: (using self: *CodeHighlighter, start_key: String, end_key: String, color: Color, line_only: bool) {
}
CodeHighlighter_remove_color_region :: (using self: *CodeHighlighter, start_key: String) {
}
CodeHighlighter_has_color_region :: (using self: *CodeHighlighter, start_key: String) -> bool {
}
CodeHighlighter_set_color_regions :: (using self: *CodeHighlighter, color_regions: Dictionary) {
}
CodeHighlighter_clear_color_regions :: (using self: *CodeHighlighter) {
}
CodeHighlighter_get_color_regions :: (using self: *CodeHighlighter) -> Dictionary {
}
CodeHighlighter_set_function_color :: (using self: *CodeHighlighter, color: Color) {
}
CodeHighlighter_get_function_color :: (using self: *CodeHighlighter) -> Color {
}
CodeHighlighter_set_number_color :: (using self: *CodeHighlighter, color: Color) {
}
CodeHighlighter_get_number_color :: (using self: *CodeHighlighter) -> Color {
}
CodeHighlighter_set_symbol_color :: (using self: *CodeHighlighter, color: Color) {
}
CodeHighlighter_get_symbol_color :: (using self: *CodeHighlighter) -> Color {
}
CodeHighlighter_set_member_variable_color :: (using self: *CodeHighlighter, color: Color) {
}
CodeHighlighter_get_member_variable_color :: (using self: *CodeHighlighter) -> Color {
}

// CollisionObject2D
CollisionObject2D :: struct {
	__private: *void;

	DisableMode :: enum {
		DISABLE_MODE_REMOVE :: 0;
		DISABLE_MODE_MAKE_STATIC :: 1;
		DISABLE_MODE_KEEP_ACTIVE :: 2;
	}
}

CollisionObject2D__input_event :: (using self: *CollisionObject2D, viewport: Viewport, event: InputEvent, shape_idx: int) {
}
CollisionObject2D__mouse_enter :: (using self: *CollisionObject2D) {
}
CollisionObject2D__mouse_exit :: (using self: *CollisionObject2D) {
}
CollisionObject2D__mouse_shape_enter :: (using self: *CollisionObject2D, shape_idx: int) {
}
CollisionObject2D__mouse_shape_exit :: (using self: *CollisionObject2D, shape_idx: int) {
}
CollisionObject2D_get_rid :: (using self: *CollisionObject2D) -> RID {
}
CollisionObject2D_set_collision_layer :: (using self: *CollisionObject2D, layer: int) {
}
CollisionObject2D_get_collision_layer :: (using self: *CollisionObject2D) -> int {
}
CollisionObject2D_set_collision_mask :: (using self: *CollisionObject2D, mask: int) {
}
CollisionObject2D_get_collision_mask :: (using self: *CollisionObject2D) -> int {
}
CollisionObject2D_set_collision_layer_value :: (using self: *CollisionObject2D, layer_number: int, value: bool) {
}
CollisionObject2D_get_collision_layer_value :: (using self: *CollisionObject2D, layer_number: int) -> bool {
}
CollisionObject2D_set_collision_mask_value :: (using self: *CollisionObject2D, layer_number: int, value: bool) {
}
CollisionObject2D_get_collision_mask_value :: (using self: *CollisionObject2D, layer_number: int) -> bool {
}
CollisionObject2D_set_collision_priority :: (using self: *CollisionObject2D, priority: float) {
}
CollisionObject2D_get_collision_priority :: (using self: *CollisionObject2D) -> float {
}
CollisionObject2D_set_disable_mode :: (using self: *CollisionObject2D, mode: CollisionObject2D.DisableMode) {
}
CollisionObject2D_get_disable_mode :: (using self: *CollisionObject2D) -> CollisionObject2D.DisableMode {
}
CollisionObject2D_set_pickable :: (using self: *CollisionObject2D, enabled: bool) {
}
CollisionObject2D_is_pickable :: (using self: *CollisionObject2D) -> bool {
}
CollisionObject2D_create_shape_owner :: (using self: *CollisionObject2D, owner: Object) -> int {
}
CollisionObject2D_remove_shape_owner :: (using self: *CollisionObject2D, owner_id: int) {
}
CollisionObject2D_get_shape_owners :: (using self: *CollisionObject2D) -> PackedInt32Array {
}
CollisionObject2D_shape_owner_set_transform :: (using self: *CollisionObject2D, owner_id: int, transform: Transform2D) {
}
CollisionObject2D_shape_owner_get_transform :: (using self: *CollisionObject2D, owner_id: int) -> Transform2D {
}
CollisionObject2D_shape_owner_get_owner :: (using self: *CollisionObject2D, owner_id: int) -> Object {
}
CollisionObject2D_shape_owner_set_disabled :: (using self: *CollisionObject2D, owner_id: int, disabled: bool) {
}
CollisionObject2D_is_shape_owner_disabled :: (using self: *CollisionObject2D, owner_id: int) -> bool {
}
CollisionObject2D_shape_owner_set_one_way_collision :: (using self: *CollisionObject2D, owner_id: int, enable: bool) {
}
CollisionObject2D_is_shape_owner_one_way_collision_enabled :: (using self: *CollisionObject2D, owner_id: int) -> bool {
}
CollisionObject2D_shape_owner_set_one_way_collision_margin :: (using self: *CollisionObject2D, owner_id: int, margin: float) {
}
CollisionObject2D_get_shape_owner_one_way_collision_margin :: (using self: *CollisionObject2D, owner_id: int) -> float {
}
CollisionObject2D_shape_owner_add_shape :: (using self: *CollisionObject2D, owner_id: int, shape: Shape2D) {
}
CollisionObject2D_shape_owner_get_shape_count :: (using self: *CollisionObject2D, owner_id: int) -> int {
}
CollisionObject2D_shape_owner_get_shape :: (using self: *CollisionObject2D, owner_id: int, shape_id: int) -> Shape2D {
}
CollisionObject2D_shape_owner_get_shape_index :: (using self: *CollisionObject2D, owner_id: int, shape_id: int) -> int {
}
CollisionObject2D_shape_owner_remove_shape :: (using self: *CollisionObject2D, owner_id: int, shape_id: int) {
}
CollisionObject2D_shape_owner_clear_shapes :: (using self: *CollisionObject2D, owner_id: int) {
}
CollisionObject2D_shape_find_owner :: (using self: *CollisionObject2D, shape_index: int) -> int {
}

// CollisionObject3D
CollisionObject3D :: struct {
	__private: *void;

	DisableMode :: enum {
		DISABLE_MODE_REMOVE :: 0;
		DISABLE_MODE_MAKE_STATIC :: 1;
		DISABLE_MODE_KEEP_ACTIVE :: 2;
	}
}

CollisionObject3D__input_event :: (using self: *CollisionObject3D, camera: Camera3D, event: InputEvent, event_position: Vector3, normal: Vector3, shape_idx: int) {
}
CollisionObject3D__mouse_enter :: (using self: *CollisionObject3D) {
}
CollisionObject3D__mouse_exit :: (using self: *CollisionObject3D) {
}
CollisionObject3D_set_collision_layer :: (using self: *CollisionObject3D, layer: int) {
}
CollisionObject3D_get_collision_layer :: (using self: *CollisionObject3D) -> int {
}
CollisionObject3D_set_collision_mask :: (using self: *CollisionObject3D, mask: int) {
}
CollisionObject3D_get_collision_mask :: (using self: *CollisionObject3D) -> int {
}
CollisionObject3D_set_collision_layer_value :: (using self: *CollisionObject3D, layer_number: int, value: bool) {
}
CollisionObject3D_get_collision_layer_value :: (using self: *CollisionObject3D, layer_number: int) -> bool {
}
CollisionObject3D_set_collision_mask_value :: (using self: *CollisionObject3D, layer_number: int, value: bool) {
}
CollisionObject3D_get_collision_mask_value :: (using self: *CollisionObject3D, layer_number: int) -> bool {
}
CollisionObject3D_set_collision_priority :: (using self: *CollisionObject3D, priority: float) {
}
CollisionObject3D_get_collision_priority :: (using self: *CollisionObject3D) -> float {
}
CollisionObject3D_set_disable_mode :: (using self: *CollisionObject3D, mode: CollisionObject3D.DisableMode) {
}
CollisionObject3D_get_disable_mode :: (using self: *CollisionObject3D) -> CollisionObject3D.DisableMode {
}
CollisionObject3D_set_ray_pickable :: (using self: *CollisionObject3D, ray_pickable: bool) {
}
CollisionObject3D_is_ray_pickable :: (using self: *CollisionObject3D) -> bool {
}
CollisionObject3D_set_capture_input_on_drag :: (using self: *CollisionObject3D, enable: bool) {
}
CollisionObject3D_get_capture_input_on_drag :: (using self: *CollisionObject3D) -> bool {
}
CollisionObject3D_get_rid :: (using self: *CollisionObject3D) -> RID {
}
CollisionObject3D_create_shape_owner :: (using self: *CollisionObject3D, owner: Object) -> int {
}
CollisionObject3D_remove_shape_owner :: (using self: *CollisionObject3D, owner_id: int) {
}
CollisionObject3D_get_shape_owners :: (using self: *CollisionObject3D) -> PackedInt32Array {
}
CollisionObject3D_shape_owner_set_transform :: (using self: *CollisionObject3D, owner_id: int, transform: Transform3D) {
}
CollisionObject3D_shape_owner_get_transform :: (using self: *CollisionObject3D, owner_id: int) -> Transform3D {
}
CollisionObject3D_shape_owner_get_owner :: (using self: *CollisionObject3D, owner_id: int) -> Object {
}
CollisionObject3D_shape_owner_set_disabled :: (using self: *CollisionObject3D, owner_id: int, disabled: bool) {
}
CollisionObject3D_is_shape_owner_disabled :: (using self: *CollisionObject3D, owner_id: int) -> bool {
}
CollisionObject3D_shape_owner_add_shape :: (using self: *CollisionObject3D, owner_id: int, shape: Shape3D) {
}
CollisionObject3D_shape_owner_get_shape_count :: (using self: *CollisionObject3D, owner_id: int) -> int {
}
CollisionObject3D_shape_owner_get_shape :: (using self: *CollisionObject3D, owner_id: int, shape_id: int) -> Shape3D {
}
CollisionObject3D_shape_owner_get_shape_index :: (using self: *CollisionObject3D, owner_id: int, shape_id: int) -> int {
}
CollisionObject3D_shape_owner_remove_shape :: (using self: *CollisionObject3D, owner_id: int, shape_id: int) {
}
CollisionObject3D_shape_owner_clear_shapes :: (using self: *CollisionObject3D, owner_id: int) {
}
CollisionObject3D_shape_find_owner :: (using self: *CollisionObject3D, shape_index: int) -> int {
}

// CollisionPolygon2D
CollisionPolygon2D :: struct {
	__private: *void;

	BuildMode :: enum {
		BUILD_SOLIDS :: 0;
		BUILD_SEGMENTS :: 1;
	}
}

CollisionPolygon2D_set_polygon :: (using self: *CollisionPolygon2D, polygon: PackedVector2Array) {
}
CollisionPolygon2D_get_polygon :: (using self: *CollisionPolygon2D) -> PackedVector2Array {
}
CollisionPolygon2D_set_build_mode :: (using self: *CollisionPolygon2D, build_mode: CollisionPolygon2D.BuildMode) {
}
CollisionPolygon2D_get_build_mode :: (using self: *CollisionPolygon2D) -> CollisionPolygon2D.BuildMode {
}
CollisionPolygon2D_set_disabled :: (using self: *CollisionPolygon2D, disabled: bool) {
}
CollisionPolygon2D_is_disabled :: (using self: *CollisionPolygon2D) -> bool {
}
CollisionPolygon2D_set_one_way_collision :: (using self: *CollisionPolygon2D, enabled: bool) {
}
CollisionPolygon2D_is_one_way_collision_enabled :: (using self: *CollisionPolygon2D) -> bool {
}
CollisionPolygon2D_set_one_way_collision_margin :: (using self: *CollisionPolygon2D, margin: float) {
}
CollisionPolygon2D_get_one_way_collision_margin :: (using self: *CollisionPolygon2D) -> float {
}

// CollisionPolygon3D
CollisionPolygon3D :: struct {
	__private: *void;
}

CollisionPolygon3D_set_depth :: (using self: *CollisionPolygon3D, depth: float) {
}
CollisionPolygon3D_get_depth :: (using self: *CollisionPolygon3D) -> float {
}
CollisionPolygon3D_set_polygon :: (using self: *CollisionPolygon3D, polygon: PackedVector2Array) {
}
CollisionPolygon3D_get_polygon :: (using self: *CollisionPolygon3D) -> PackedVector2Array {
}
CollisionPolygon3D_set_disabled :: (using self: *CollisionPolygon3D, disabled: bool) {
}
CollisionPolygon3D_is_disabled :: (using self: *CollisionPolygon3D) -> bool {
}
CollisionPolygon3D_set_margin :: (using self: *CollisionPolygon3D, margin: float) {
}
CollisionPolygon3D_get_margin :: (using self: *CollisionPolygon3D) -> float {
}

// CollisionShape2D
CollisionShape2D :: struct {
	__private: *void;
}

CollisionShape2D_set_shape :: (using self: *CollisionShape2D, shape: Shape2D) {
}
CollisionShape2D_get_shape :: (using self: *CollisionShape2D) -> Shape2D {
}
CollisionShape2D_set_disabled :: (using self: *CollisionShape2D, disabled: bool) {
}
CollisionShape2D_is_disabled :: (using self: *CollisionShape2D) -> bool {
}
CollisionShape2D_set_one_way_collision :: (using self: *CollisionShape2D, enabled: bool) {
}
CollisionShape2D_is_one_way_collision_enabled :: (using self: *CollisionShape2D) -> bool {
}
CollisionShape2D_set_one_way_collision_margin :: (using self: *CollisionShape2D, margin: float) {
}
CollisionShape2D_get_one_way_collision_margin :: (using self: *CollisionShape2D) -> float {
}
CollisionShape2D_set_debug_color :: (using self: *CollisionShape2D, color: Color) {
}
CollisionShape2D_get_debug_color :: (using self: *CollisionShape2D) -> Color {
}

// CollisionShape3D
CollisionShape3D :: struct {
	__private: *void;
}

CollisionShape3D_resource_changed :: (using self: *CollisionShape3D, resource: Resource) {
}
CollisionShape3D_set_shape :: (using self: *CollisionShape3D, shape: Shape3D) {
}
CollisionShape3D_get_shape :: (using self: *CollisionShape3D) -> Shape3D {
}
CollisionShape3D_set_disabled :: (using self: *CollisionShape3D, enable: bool) {
}
CollisionShape3D_is_disabled :: (using self: *CollisionShape3D) -> bool {
}
CollisionShape3D_make_convex_from_siblings :: (using self: *CollisionShape3D) {
}

// ColorPicker
ColorPicker :: struct {
	__private: *void;

	ColorModeType :: enum {
		MODE_RGB :: 0;
		MODE_HSV :: 1;
		MODE_RAW :: 2;
		MODE_OKHSL :: 3;
	}
	PickerShapeType :: enum {
		SHAPE_HSV_RECTANGLE :: 0;
		SHAPE_HSV_WHEEL :: 1;
		SHAPE_VHS_CIRCLE :: 2;
		SHAPE_OKHSL_CIRCLE :: 3;
		SHAPE_NONE :: 4;
	}
}

ColorPicker_set_pick_color :: (using self: *ColorPicker, color: Color) {
}
ColorPicker_get_pick_color :: (using self: *ColorPicker) -> Color {
}
ColorPicker_set_deferred_mode :: (using self: *ColorPicker, mode: bool) {
}
ColorPicker_is_deferred_mode :: (using self: *ColorPicker) -> bool {
}
ColorPicker_set_color_mode :: (using self: *ColorPicker, color_mode: ColorPicker.ColorModeType) {
}
ColorPicker_get_color_mode :: (using self: *ColorPicker) -> ColorPicker.ColorModeType {
}
ColorPicker_set_edit_alpha :: (using self: *ColorPicker, show: bool) {
}
ColorPicker_is_editing_alpha :: (using self: *ColorPicker) -> bool {
}
ColorPicker_set_can_add_swatches :: (using self: *ColorPicker, enabled: bool) {
}
ColorPicker_are_swatches_enabled :: (using self: *ColorPicker) -> bool {
}
ColorPicker_set_presets_visible :: (using self: *ColorPicker, visible: bool) {
}
ColorPicker_are_presets_visible :: (using self: *ColorPicker) -> bool {
}
ColorPicker_set_modes_visible :: (using self: *ColorPicker, visible: bool) {
}
ColorPicker_are_modes_visible :: (using self: *ColorPicker) -> bool {
}
ColorPicker_set_sampler_visible :: (using self: *ColorPicker, visible: bool) {
}
ColorPicker_is_sampler_visible :: (using self: *ColorPicker) -> bool {
}
ColorPicker_set_sliders_visible :: (using self: *ColorPicker, visible: bool) {
}
ColorPicker_are_sliders_visible :: (using self: *ColorPicker) -> bool {
}
ColorPicker_set_hex_visible :: (using self: *ColorPicker, visible: bool) {
}
ColorPicker_is_hex_visible :: (using self: *ColorPicker) -> bool {
}
ColorPicker_add_preset :: (using self: *ColorPicker, color: Color) {
}
ColorPicker_erase_preset :: (using self: *ColorPicker, color: Color) {
}
ColorPicker_get_presets :: (using self: *ColorPicker) -> PackedColorArray {
}
ColorPicker_add_recent_preset :: (using self: *ColorPicker, color: Color) {
}
ColorPicker_erase_recent_preset :: (using self: *ColorPicker, color: Color) {
}
ColorPicker_get_recent_presets :: (using self: *ColorPicker) -> PackedColorArray {
}
ColorPicker_set_picker_shape :: (using self: *ColorPicker, shape: ColorPicker.PickerShapeType) {
}
ColorPicker_get_picker_shape :: (using self: *ColorPicker) -> ColorPicker.PickerShapeType {
}

// ColorPickerButton
ColorPickerButton :: struct {
	__private: *void;
}

ColorPickerButton_set_pick_color :: (using self: *ColorPickerButton, color: Color) {
}
ColorPickerButton_get_pick_color :: (using self: *ColorPickerButton) -> Color {
}
ColorPickerButton_get_picker :: (using self: *ColorPickerButton) -> ColorPicker {
}
ColorPickerButton_get_popup :: (using self: *ColorPickerButton) -> PopupPanel {
}
ColorPickerButton_set_edit_alpha :: (using self: *ColorPickerButton, show: bool) {
}
ColorPickerButton_is_editing_alpha :: (using self: *ColorPickerButton) -> bool {
}

// ColorRect
ColorRect :: struct {
	__private: *void;
}

ColorRect_set_color :: (using self: *ColorRect, color: Color) {
}
ColorRect_get_color :: (using self: *ColorRect) -> Color {
}

// Compositor
Compositor :: struct {
	__private: *void;
}

Compositor_set_compositor_effects :: (using self: *Compositor, compositor_effects: Array) {
}
Compositor_get_compositor_effects :: (using self: *Compositor) -> Array {
}

// CompositorEffect
CompositorEffect :: struct {
	__private: *void;

	EffectCallbackType :: enum {
		EFFECT_CALLBACK_TYPE_PRE_OPAQUE :: 0;
		EFFECT_CALLBACK_TYPE_POST_OPAQUE :: 1;
		EFFECT_CALLBACK_TYPE_POST_SKY :: 2;
		EFFECT_CALLBACK_TYPE_PRE_TRANSPARENT :: 3;
		EFFECT_CALLBACK_TYPE_POST_TRANSPARENT :: 4;
		EFFECT_CALLBACK_TYPE_MAX :: 5;
	}
}

CompositorEffect__render_callback :: (using self: *CompositorEffect, effect_callback_type: int, render_data: RenderData) {
}
CompositorEffect_set_enabled :: (using self: *CompositorEffect, enabled: bool) {
}
CompositorEffect_get_enabled :: (using self: *CompositorEffect) -> bool {
}
CompositorEffect_set_effect_callback_type :: (using self: *CompositorEffect, effect_callback_type: CompositorEffect.EffectCallbackType) {
}
CompositorEffect_get_effect_callback_type :: (using self: *CompositorEffect) -> CompositorEffect.EffectCallbackType {
}
CompositorEffect_set_access_resolved_color :: (using self: *CompositorEffect, enable: bool) {
}
CompositorEffect_get_access_resolved_color :: (using self: *CompositorEffect) -> bool {
}
CompositorEffect_set_access_resolved_depth :: (using self: *CompositorEffect, enable: bool) {
}
CompositorEffect_get_access_resolved_depth :: (using self: *CompositorEffect) -> bool {
}
CompositorEffect_set_needs_motion_vectors :: (using self: *CompositorEffect, enable: bool) {
}
CompositorEffect_get_needs_motion_vectors :: (using self: *CompositorEffect) -> bool {
}
CompositorEffect_set_needs_normal_roughness :: (using self: *CompositorEffect, enable: bool) {
}
CompositorEffect_get_needs_normal_roughness :: (using self: *CompositorEffect) -> bool {
}
CompositorEffect_set_needs_separate_specular :: (using self: *CompositorEffect, enable: bool) {
}
CompositorEffect_get_needs_separate_specular :: (using self: *CompositorEffect) -> bool {
}

// CompressedCubemap
CompressedCubemap :: struct {
	__private: *void;
}

// CompressedCubemapArray
CompressedCubemapArray :: struct {
	__private: *void;
}

// CompressedTexture2D
CompressedTexture2D :: struct {
	__private: *void;
}

CompressedTexture2D_load :: (using self: *CompressedTexture2D, path: String) -> Error {
}
CompressedTexture2D_get_load_path :: (using self: *CompressedTexture2D) -> String {
}

// CompressedTexture2DArray
CompressedTexture2DArray :: struct {
	__private: *void;
}

// CompressedTexture3D
CompressedTexture3D :: struct {
	__private: *void;
}

CompressedTexture3D_load :: (using self: *CompressedTexture3D, path: String) -> Error {
}
CompressedTexture3D_get_load_path :: (using self: *CompressedTexture3D) -> String {
}

// CompressedTextureLayered
CompressedTextureLayered :: struct {
	__private: *void;
}

CompressedTextureLayered_load :: (using self: *CompressedTextureLayered, path: String) -> Error {
}
CompressedTextureLayered_get_load_path :: (using self: *CompressedTextureLayered) -> String {
}

// ConcavePolygonShape2D
ConcavePolygonShape2D :: struct {
	__private: *void;
}

ConcavePolygonShape2D_set_segments :: (using self: *ConcavePolygonShape2D, segments: PackedVector2Array) {
}
ConcavePolygonShape2D_get_segments :: (using self: *ConcavePolygonShape2D) -> PackedVector2Array {
}

// ConcavePolygonShape3D
ConcavePolygonShape3D :: struct {
	__private: *void;
}

ConcavePolygonShape3D_set_faces :: (using self: *ConcavePolygonShape3D, faces: PackedVector3Array) {
}
ConcavePolygonShape3D_get_faces :: (using self: *ConcavePolygonShape3D) -> PackedVector3Array {
}
ConcavePolygonShape3D_set_backface_collision_enabled :: (using self: *ConcavePolygonShape3D, enabled: bool) {
}
ConcavePolygonShape3D_is_backface_collision_enabled :: (using self: *ConcavePolygonShape3D) -> bool {
}

// ConeTwistJoint3D
ConeTwistJoint3D :: struct {
	__private: *void;

	Param :: enum {
		PARAM_SWING_SPAN :: 0;
		PARAM_TWIST_SPAN :: 1;
		PARAM_BIAS :: 2;
		PARAM_SOFTNESS :: 3;
		PARAM_RELAXATION :: 4;
		PARAM_MAX :: 5;
	}
}

ConeTwistJoint3D_set_param :: (using self: *ConeTwistJoint3D, param: ConeTwistJoint3D.Param, value: float) {
}
ConeTwistJoint3D_get_param :: (using self: *ConeTwistJoint3D, param: ConeTwistJoint3D.Param) -> float {
}

// ConfigFile
ConfigFile :: struct {
	__private: *void;
}

ConfigFile_set_value :: (using self: *ConfigFile, section: String, key: String, value: Variant) {
}
ConfigFile_get_value :: (using self: *ConfigFile, section: String, key: String, default: Variant) -> Variant {
}
ConfigFile_has_section :: (using self: *ConfigFile, section: String) -> bool {
}
ConfigFile_has_section_key :: (using self: *ConfigFile, section: String, key: String) -> bool {
}
ConfigFile_get_sections :: (using self: *ConfigFile) -> PackedStringArray {
}
ConfigFile_get_section_keys :: (using self: *ConfigFile, section: String) -> PackedStringArray {
}
ConfigFile_erase_section :: (using self: *ConfigFile, section: String) {
}
ConfigFile_erase_section_key :: (using self: *ConfigFile, section: String, key: String) {
}
ConfigFile_load :: (using self: *ConfigFile, path: String) -> Error {
}
ConfigFile_parse :: (using self: *ConfigFile, data: String) -> Error {
}
ConfigFile_save :: (using self: *ConfigFile, path: String) -> Error {
}
ConfigFile_encode_to_text :: (using self: *ConfigFile) -> String {
}
ConfigFile_load_encrypted :: (using self: *ConfigFile, path: String, key: PackedByteArray) -> Error {
}
ConfigFile_load_encrypted_pass :: (using self: *ConfigFile, path: String, password: String) -> Error {
}
ConfigFile_save_encrypted :: (using self: *ConfigFile, path: String, key: PackedByteArray) -> Error {
}
ConfigFile_save_encrypted_pass :: (using self: *ConfigFile, path: String, password: String) -> Error {
}
ConfigFile_clear :: (using self: *ConfigFile) {
}

// ConfirmationDialog
ConfirmationDialog :: struct {
	__private: *void;
}

ConfirmationDialog_get_cancel_button :: (using self: *ConfirmationDialog) -> Button {
}
ConfirmationDialog_set_cancel_button_text :: (using self: *ConfirmationDialog, text: String) {
}
ConfirmationDialog_get_cancel_button_text :: (using self: *ConfirmationDialog) -> String {
}

// Container
Container :: struct {
	__private: *void;

	NOTIFICATION_PRE_SORT_CHILDREN :: 50;
	NOTIFICATION_SORT_CHILDREN :: 51;
}

Container__get_allowed_size_flags_horizontal :: (using self: *Container) -> PackedInt32Array {
}
Container__get_allowed_size_flags_vertical :: (using self: *Container) -> PackedInt32Array {
}
Container_queue_sort :: (using self: *Container) {
}
Container_fit_child_in_rect :: (using self: *Container, child: Control, rect: Rect2) {
}

// Control
Control :: struct {
	__private: *void;

	NOTIFICATION_RESIZED :: 40;
	NOTIFICATION_MOUSE_ENTER :: 41;
	NOTIFICATION_MOUSE_EXIT :: 42;
	NOTIFICATION_MOUSE_ENTER_SELF :: 60;
	NOTIFICATION_MOUSE_EXIT_SELF :: 61;
	NOTIFICATION_FOCUS_ENTER :: 43;
	NOTIFICATION_FOCUS_EXIT :: 44;
	NOTIFICATION_THEME_CHANGED :: 45;
	NOTIFICATION_SCROLL_BEGIN :: 47;
	NOTIFICATION_SCROLL_END :: 48;
	NOTIFICATION_LAYOUT_DIRECTION_CHANGED :: 49;

	FocusMode :: enum {
		FOCUS_NONE :: 0;
		FOCUS_CLICK :: 1;
		FOCUS_ALL :: 2;
	}
	CursorShape :: enum {
		CURSOR_ARROW :: 0;
		CURSOR_IBEAM :: 1;
		CURSOR_POINTING_HAND :: 2;
		CURSOR_CROSS :: 3;
		CURSOR_WAIT :: 4;
		CURSOR_BUSY :: 5;
		CURSOR_DRAG :: 6;
		CURSOR_CAN_DROP :: 7;
		CURSOR_FORBIDDEN :: 8;
		CURSOR_VSIZE :: 9;
		CURSOR_HSIZE :: 10;
		CURSOR_BDIAGSIZE :: 11;
		CURSOR_FDIAGSIZE :: 12;
		CURSOR_MOVE :: 13;
		CURSOR_VSPLIT :: 14;
		CURSOR_HSPLIT :: 15;
		CURSOR_HELP :: 16;
	}
	LayoutPreset :: enum {
		PRESET_TOP_LEFT :: 0;
		PRESET_TOP_RIGHT :: 1;
		PRESET_BOTTOM_LEFT :: 2;
		PRESET_BOTTOM_RIGHT :: 3;
		PRESET_CENTER_LEFT :: 4;
		PRESET_CENTER_TOP :: 5;
		PRESET_CENTER_RIGHT :: 6;
		PRESET_CENTER_BOTTOM :: 7;
		PRESET_CENTER :: 8;
		PRESET_LEFT_WIDE :: 9;
		PRESET_TOP_WIDE :: 10;
		PRESET_RIGHT_WIDE :: 11;
		PRESET_BOTTOM_WIDE :: 12;
		PRESET_VCENTER_WIDE :: 13;
		PRESET_HCENTER_WIDE :: 14;
		PRESET_FULL_RECT :: 15;
	}
	LayoutPresetMode :: enum {
		PRESET_MODE_MINSIZE :: 0;
		PRESET_MODE_KEEP_WIDTH :: 1;
		PRESET_MODE_KEEP_HEIGHT :: 2;
		PRESET_MODE_KEEP_SIZE :: 3;
	}
	SizeFlags :: enum_flags {
		SIZE_SHRINK_BEGIN :: 0;
		SIZE_FILL :: 1;
		SIZE_EXPAND :: 2;
		SIZE_EXPAND_FILL :: 3;
		SIZE_SHRINK_CENTER :: 4;
		SIZE_SHRINK_END :: 8;
	}
	MouseFilter :: enum {
		MOUSE_FILTER_STOP :: 0;
		MOUSE_FILTER_PASS :: 1;
		MOUSE_FILTER_IGNORE :: 2;
	}
	GrowDirection :: enum {
		GROW_DIRECTION_BEGIN :: 0;
		GROW_DIRECTION_END :: 1;
		GROW_DIRECTION_BOTH :: 2;
	}
	Anchor :: enum {
		ANCHOR_BEGIN :: 0;
		ANCHOR_END :: 1;
	}
	LayoutDirection :: enum {
		LAYOUT_DIRECTION_INHERITED :: 0;
		LAYOUT_DIRECTION_LOCALE :: 1;
		LAYOUT_DIRECTION_LTR :: 2;
		LAYOUT_DIRECTION_RTL :: 3;
	}
	TextDirection :: enum {
		TEXT_DIRECTION_INHERITED :: 3;
		TEXT_DIRECTION_AUTO :: 0;
		TEXT_DIRECTION_LTR :: 1;
		TEXT_DIRECTION_RTL :: 2;
	}
}

Control__has_point :: (using self: *Control, point: Vector2) -> bool {
}
Control__structured_text_parser :: (using self: *Control, args: Array, text: String) -> Array {
}
Control__get_minimum_size :: (using self: *Control) -> Vector2 {
}
Control__get_tooltip :: (using self: *Control, at_position: Vector2) -> String {
}
Control__get_drag_data :: (using self: *Control, at_position: Vector2) -> Variant {
}
Control__can_drop_data :: (using self: *Control, at_position: Vector2, data: Variant) -> bool {
}
Control__drop_data :: (using self: *Control, at_position: Vector2, data: Variant) {
}
Control__make_custom_tooltip :: (using self: *Control, for_text: String) -> Object {
}
Control__gui_input :: (using self: *Control, event: InputEvent) {
}
Control_accept_event :: (using self: *Control) {
}
Control_get_minimum_size :: (using self: *Control) -> Vector2 {
}
Control_get_combined_minimum_size :: (using self: *Control) -> Vector2 {
}
Control_set_anchors_preset :: (using self: *Control, preset: Control.LayoutPreset, keep_offsets: bool) {
}
Control_set_offsets_preset :: (using self: *Control, preset: Control.LayoutPreset, resize_mode: Control.LayoutPresetMode, margin: int) {
}
Control_set_anchors_and_offsets_preset :: (using self: *Control, preset: Control.LayoutPreset, resize_mode: Control.LayoutPresetMode, margin: int) {
}
Control_set_anchor :: (using self: *Control, side: Side, anchor: float, keep_offset: bool, push_opposite_anchor: bool) {
}
Control_get_anchor :: (using self: *Control, side: Side) -> float {
}
Control_set_offset :: (using self: *Control, side: Side, offset: float) {
}
Control_get_offset :: (using self: *Control, offset: Side) -> float {
}
Control_set_anchor_and_offset :: (using self: *Control, side: Side, anchor: float, offset: float, push_opposite_anchor: bool) {
}
Control_set_begin :: (using self: *Control, position: Vector2) {
}
Control_set_end :: (using self: *Control, position: Vector2) {
}
Control_set_position :: (using self: *Control, position: Vector2, keep_offsets: bool) {
}
Control_set_size :: (using self: *Control, size: Vector2, keep_offsets: bool) {
}
Control_reset_size :: (using self: *Control) {
}
Control_set_custom_minimum_size :: (using self: *Control, size: Vector2) {
}
Control_set_global_position :: (using self: *Control, position: Vector2, keep_offsets: bool) {
}
Control_set_rotation :: (using self: *Control, radians: float) {
}
Control_set_rotation_degrees :: (using self: *Control, degrees: float) {
}
Control_set_scale :: (using self: *Control, scale: Vector2) {
}
Control_set_pivot_offset :: (using self: *Control, pivot_offset: Vector2) {
}
Control_get_begin :: (using self: *Control) -> Vector2 {
}
Control_get_end :: (using self: *Control) -> Vector2 {
}
Control_get_position :: (using self: *Control) -> Vector2 {
}
Control_get_size :: (using self: *Control) -> Vector2 {
}
Control_get_rotation :: (using self: *Control) -> float {
}
Control_get_rotation_degrees :: (using self: *Control) -> float {
}
Control_get_scale :: (using self: *Control) -> Vector2 {
}
Control_get_pivot_offset :: (using self: *Control) -> Vector2 {
}
Control_get_custom_minimum_size :: (using self: *Control) -> Vector2 {
}
Control_get_parent_area_size :: (using self: *Control) -> Vector2 {
}
Control_get_global_position :: (using self: *Control) -> Vector2 {
}
Control_get_screen_position :: (using self: *Control) -> Vector2 {
}
Control_get_rect :: (using self: *Control) -> Rect2 {
}
Control_get_global_rect :: (using self: *Control) -> Rect2 {
}
Control_set_focus_mode :: (using self: *Control, mode: Control.FocusMode) {
}
Control_get_focus_mode :: (using self: *Control) -> Control.FocusMode {
}
Control_has_focus :: (using self: *Control) -> bool {
}
Control_grab_focus :: (using self: *Control) {
}
Control_release_focus :: (using self: *Control) {
}
Control_find_prev_valid_focus :: (using self: *Control) -> Control {
}
Control_find_next_valid_focus :: (using self: *Control) -> Control {
}
Control_find_valid_focus_neighbor :: (using self: *Control, side: Side) -> Control {
}
Control_set_h_size_flags :: (using self: *Control, flags: Control.SizeFlags) {
}
Control_get_h_size_flags :: (using self: *Control) -> Control.SizeFlags {
}
Control_set_stretch_ratio :: (using self: *Control, ratio: float) {
}
Control_get_stretch_ratio :: (using self: *Control) -> float {
}
Control_set_v_size_flags :: (using self: *Control, flags: Control.SizeFlags) {
}
Control_get_v_size_flags :: (using self: *Control) -> Control.SizeFlags {
}
Control_set_theme :: (using self: *Control, theme: Theme) {
}
Control_get_theme :: (using self: *Control) -> Theme {
}
Control_set_theme_type_variation :: (using self: *Control, theme_type: StringName) {
}
Control_get_theme_type_variation :: (using self: *Control) -> StringName {
}
Control_begin_bulk_theme_override :: (using self: *Control) {
}
Control_end_bulk_theme_override :: (using self: *Control) {
}
Control_add_theme_icon_override :: (using self: *Control, name: StringName, texture: Texture2D) {
}
Control_add_theme_stylebox_override :: (using self: *Control, name: StringName, stylebox: StyleBox) {
}
Control_add_theme_font_override :: (using self: *Control, name: StringName, font: Font) {
}
Control_add_theme_font_size_override :: (using self: *Control, name: StringName, font_size: int) {
}
Control_add_theme_color_override :: (using self: *Control, name: StringName, color: Color) {
}
Control_add_theme_constant_override :: (using self: *Control, name: StringName, constant: int) {
}
Control_remove_theme_icon_override :: (using self: *Control, name: StringName) {
}
Control_remove_theme_stylebox_override :: (using self: *Control, name: StringName) {
}
Control_remove_theme_font_override :: (using self: *Control, name: StringName) {
}
Control_remove_theme_font_size_override :: (using self: *Control, name: StringName) {
}
Control_remove_theme_color_override :: (using self: *Control, name: StringName) {
}
Control_remove_theme_constant_override :: (using self: *Control, name: StringName) {
}
Control_get_theme_icon :: (using self: *Control, name: StringName, theme_type: StringName) -> Texture2D {
}
Control_get_theme_stylebox :: (using self: *Control, name: StringName, theme_type: StringName) -> StyleBox {
}
Control_get_theme_font :: (using self: *Control, name: StringName, theme_type: StringName) -> Font {
}
Control_get_theme_font_size :: (using self: *Control, name: StringName, theme_type: StringName) -> int {
}
Control_get_theme_color :: (using self: *Control, name: StringName, theme_type: StringName) -> Color {
}
Control_get_theme_constant :: (using self: *Control, name: StringName, theme_type: StringName) -> int {
}
Control_has_theme_icon_override :: (using self: *Control, name: StringName) -> bool {
}
Control_has_theme_stylebox_override :: (using self: *Control, name: StringName) -> bool {
}
Control_has_theme_font_override :: (using self: *Control, name: StringName) -> bool {
}
Control_has_theme_font_size_override :: (using self: *Control, name: StringName) -> bool {
}
Control_has_theme_color_override :: (using self: *Control, name: StringName) -> bool {
}
Control_has_theme_constant_override :: (using self: *Control, name: StringName) -> bool {
}
Control_has_theme_icon :: (using self: *Control, name: StringName, theme_type: StringName) -> bool {
}
Control_has_theme_stylebox :: (using self: *Control, name: StringName, theme_type: StringName) -> bool {
}
Control_has_theme_font :: (using self: *Control, name: StringName, theme_type: StringName) -> bool {
}
Control_has_theme_font_size :: (using self: *Control, name: StringName, theme_type: StringName) -> bool {
}
Control_has_theme_color :: (using self: *Control, name: StringName, theme_type: StringName) -> bool {
}
Control_has_theme_constant :: (using self: *Control, name: StringName, theme_type: StringName) -> bool {
}
Control_get_theme_default_base_scale :: (using self: *Control) -> float {
}
Control_get_theme_default_font :: (using self: *Control) -> Font {
}
Control_get_theme_default_font_size :: (using self: *Control) -> int {
}
Control_get_parent_control :: (using self: *Control) -> Control {
}
Control_set_h_grow_direction :: (using self: *Control, direction: Control.GrowDirection) {
}
Control_get_h_grow_direction :: (using self: *Control) -> Control.GrowDirection {
}
Control_set_v_grow_direction :: (using self: *Control, direction: Control.GrowDirection) {
}
Control_get_v_grow_direction :: (using self: *Control) -> Control.GrowDirection {
}
Control_set_tooltip_text :: (using self: *Control, hint: String) {
}
Control_get_tooltip_text :: (using self: *Control) -> String {
}
Control_get_tooltip :: (using self: *Control, at_position: Vector2) -> String {
}
Control_set_default_cursor_shape :: (using self: *Control, shape: Control.CursorShape) {
}
Control_get_default_cursor_shape :: (using self: *Control) -> Control.CursorShape {
}
Control_get_cursor_shape :: (using self: *Control, position: Vector2) -> Control.CursorShape {
}
Control_set_focus_neighbor :: (using self: *Control, side: Side, neighbor: NodePath) {
}
Control_get_focus_neighbor :: (using self: *Control, side: Side) -> NodePath {
}
Control_set_focus_next :: (using self: *Control, next: NodePath) {
}
Control_get_focus_next :: (using self: *Control) -> NodePath {
}
Control_set_focus_previous :: (using self: *Control, previous: NodePath) {
}
Control_get_focus_previous :: (using self: *Control) -> NodePath {
}
Control_force_drag :: (using self: *Control, data: Variant, preview: Control) {
}
Control_set_mouse_filter :: (using self: *Control, filter: Control.MouseFilter) {
}
Control_get_mouse_filter :: (using self: *Control) -> Control.MouseFilter {
}
Control_set_force_pass_scroll_events :: (using self: *Control, force_pass_scroll_events: bool) {
}
Control_is_force_pass_scroll_events :: (using self: *Control) -> bool {
}
Control_set_clip_contents :: (using self: *Control, enable: bool) {
}
Control_is_clipping_contents :: (using self: *Control) -> bool {
}
Control_grab_click_focus :: (using self: *Control) {
}
Control_set_drag_forwarding :: (using self: *Control, drag_func: Callable, can_drop_func: Callable, drop_func: Callable) {
}
Control_set_drag_preview :: (using self: *Control, control: Control) {
}
Control_is_drag_successful :: (using self: *Control) -> bool {
}
Control_warp_mouse :: (using self: *Control, position: Vector2) {
}
Control_set_shortcut_context :: (using self: *Control, node: Node) {
}
Control_get_shortcut_context :: (using self: *Control) -> Node {
}
Control_update_minimum_size :: (using self: *Control) {
}
Control_set_layout_direction :: (using self: *Control, direction: Control.LayoutDirection) {
}
Control_get_layout_direction :: (using self: *Control) -> Control.LayoutDirection {
}
Control_is_layout_rtl :: (using self: *Control) -> bool {
}
Control_set_auto_translate :: (using self: *Control, enable: bool) {
}
Control_is_auto_translating :: (using self: *Control) -> bool {
}
Control_set_localize_numeral_system :: (using self: *Control, enable: bool) {
}
Control_is_localizing_numeral_system :: (using self: *Control) -> bool {
}

// ConvexPolygonShape2D
ConvexPolygonShape2D :: struct {
	__private: *void;
}

ConvexPolygonShape2D_set_point_cloud :: (using self: *ConvexPolygonShape2D, point_cloud: PackedVector2Array) {
}
ConvexPolygonShape2D_set_points :: (using self: *ConvexPolygonShape2D, points: PackedVector2Array) {
}
ConvexPolygonShape2D_get_points :: (using self: *ConvexPolygonShape2D) -> PackedVector2Array {
}

// ConvexPolygonShape3D
ConvexPolygonShape3D :: struct {
	__private: *void;
}

ConvexPolygonShape3D_set_points :: (using self: *ConvexPolygonShape3D, points: PackedVector3Array) {
}
ConvexPolygonShape3D_get_points :: (using self: *ConvexPolygonShape3D) -> PackedVector3Array {
}

// Crypto
Crypto :: struct {
	__private: *void;
}

Crypto_generate_random_bytes :: (using self: *Crypto, size: int) -> PackedByteArray {
}
Crypto_generate_rsa :: (using self: *Crypto, size: int) -> CryptoKey {
}
Crypto_generate_self_signed_certificate :: (using self: *Crypto, key: CryptoKey, issuer_name: String, not_before: String, not_after: String) -> X509Certificate {
}
Crypto_sign :: (using self: *Crypto, hash_type: HashingContext.HashType, hash: PackedByteArray, key: CryptoKey) -> PackedByteArray {
}
Crypto_verify :: (using self: *Crypto, hash_type: HashingContext.HashType, hash: PackedByteArray, signature: PackedByteArray, key: CryptoKey) -> bool {
}
Crypto_encrypt :: (using self: *Crypto, key: CryptoKey, plaintext: PackedByteArray) -> PackedByteArray {
}
Crypto_decrypt :: (using self: *Crypto, key: CryptoKey, ciphertext: PackedByteArray) -> PackedByteArray {
}
Crypto_hmac_digest :: (using self: *Crypto, hash_type: HashingContext.HashType, key: PackedByteArray, msg: PackedByteArray) -> PackedByteArray {
}
Crypto_constant_time_compare :: (using self: *Crypto, trusted: PackedByteArray, received: PackedByteArray) -> bool {
}

// CryptoKey
CryptoKey :: struct {
	__private: *void;
}

CryptoKey_save :: (using self: *CryptoKey, path: String, public_only: bool) -> Error {
}
CryptoKey_load :: (using self: *CryptoKey, path: String, public_only: bool) -> Error {
}
CryptoKey_is_public_only :: (using self: *CryptoKey) -> bool {
}
CryptoKey_save_to_string :: (using self: *CryptoKey, public_only: bool) -> String {
}
CryptoKey_load_from_string :: (using self: *CryptoKey, string_key: String, public_only: bool) -> Error {
}

// Cubemap
Cubemap :: struct {
	__private: *void;
}

Cubemap_create_placeholder :: (using self: *Cubemap) -> Resource {
}

// CubemapArray
CubemapArray :: struct {
	__private: *void;
}

CubemapArray_create_placeholder :: (using self: *CubemapArray) -> Resource {
}

// Curve
Curve :: struct {
	__private: *void;

	TangentMode :: enum {
		TANGENT_FREE :: 0;
		TANGENT_LINEAR :: 1;
		TANGENT_MODE_COUNT :: 2;
	}
}

Curve_get_point_count :: (using self: *Curve) -> int {
}
Curve_set_point_count :: (using self: *Curve, count: int) {
}
Curve_add_point :: (using self: *Curve, position: Vector2, left_tangent: float, right_tangent: float, left_mode: Curve.TangentMode, right_mode: Curve.TangentMode) -> int {
}
Curve_remove_point :: (using self: *Curve, index: int) {
}
Curve_clear_points :: (using self: *Curve) {
}
Curve_get_point_position :: (using self: *Curve, index: int) -> Vector2 {
}
Curve_set_point_value :: (using self: *Curve, index: int, y: float) {
}
Curve_set_point_offset :: (using self: *Curve, index: int, offset: float) -> int {
}
Curve_sample :: (using self: *Curve, offset: float) -> float {
}
Curve_sample_baked :: (using self: *Curve, offset: float) -> float {
}
Curve_get_point_left_tangent :: (using self: *Curve, index: int) -> float {
}
Curve_get_point_right_tangent :: (using self: *Curve, index: int) -> float {
}
Curve_get_point_left_mode :: (using self: *Curve, index: int) -> Curve.TangentMode {
}
Curve_get_point_right_mode :: (using self: *Curve, index: int) -> Curve.TangentMode {
}
Curve_set_point_left_tangent :: (using self: *Curve, index: int, tangent: float) {
}
Curve_set_point_right_tangent :: (using self: *Curve, index: int, tangent: float) {
}
Curve_set_point_left_mode :: (using self: *Curve, index: int, mode: Curve.TangentMode) {
}
Curve_set_point_right_mode :: (using self: *Curve, index: int, mode: Curve.TangentMode) {
}
Curve_get_min_value :: (using self: *Curve) -> float {
}
Curve_set_min_value :: (using self: *Curve, min: float) {
}
Curve_get_max_value :: (using self: *Curve) -> float {
}
Curve_set_max_value :: (using self: *Curve, max: float) {
}
Curve_clean_dupes :: (using self: *Curve) {
}
Curve_bake :: (using self: *Curve) {
}
Curve_get_bake_resolution :: (using self: *Curve) -> int {
}
Curve_set_bake_resolution :: (using self: *Curve, resolution: int) {
}

// Curve2D
Curve2D :: struct {
	__private: *void;
}

Curve2D_get_point_count :: (using self: *Curve2D) -> int {
}
Curve2D_set_point_count :: (using self: *Curve2D, count: int) {
}
Curve2D_add_point :: (using self: *Curve2D, position: Vector2, in: Vector2, out: Vector2, index: int) {
}
Curve2D_set_point_position :: (using self: *Curve2D, idx: int, position: Vector2) {
}
Curve2D_get_point_position :: (using self: *Curve2D, idx: int) -> Vector2 {
}
Curve2D_set_point_in :: (using self: *Curve2D, idx: int, position: Vector2) {
}
Curve2D_get_point_in :: (using self: *Curve2D, idx: int) -> Vector2 {
}
Curve2D_set_point_out :: (using self: *Curve2D, idx: int, position: Vector2) {
}
Curve2D_get_point_out :: (using self: *Curve2D, idx: int) -> Vector2 {
}
Curve2D_remove_point :: (using self: *Curve2D, idx: int) {
}
Curve2D_clear_points :: (using self: *Curve2D) {
}
Curve2D_sample :: (using self: *Curve2D, idx: int, t: float) -> Vector2 {
}
Curve2D_samplef :: (using self: *Curve2D, fofs: float) -> Vector2 {
}
Curve2D_set_bake_interval :: (using self: *Curve2D, distance: float) {
}
Curve2D_get_bake_interval :: (using self: *Curve2D) -> float {
}
Curve2D_get_baked_length :: (using self: *Curve2D) -> float {
}
Curve2D_sample_baked :: (using self: *Curve2D, offset: float, cubic: bool) -> Vector2 {
}
Curve2D_sample_baked_with_rotation :: (using self: *Curve2D, offset: float, cubic: bool) -> Transform2D {
}
Curve2D_get_baked_points :: (using self: *Curve2D) -> PackedVector2Array {
}
Curve2D_get_closest_point :: (using self: *Curve2D, to_point: Vector2) -> Vector2 {
}
Curve2D_get_closest_offset :: (using self: *Curve2D, to_point: Vector2) -> float {
}
Curve2D_tessellate :: (using self: *Curve2D, max_stages: int, tolerance_degrees: float) -> PackedVector2Array {
}
Curve2D_tessellate_even_length :: (using self: *Curve2D, max_stages: int, tolerance_length: float) -> PackedVector2Array {
}

// Curve3D
Curve3D :: struct {
	__private: *void;
}

Curve3D_get_point_count :: (using self: *Curve3D) -> int {
}
Curve3D_set_point_count :: (using self: *Curve3D, count: int) {
}
Curve3D_add_point :: (using self: *Curve3D, position: Vector3, in: Vector3, out: Vector3, index: int) {
}
Curve3D_set_point_position :: (using self: *Curve3D, idx: int, position: Vector3) {
}
Curve3D_get_point_position :: (using self: *Curve3D, idx: int) -> Vector3 {
}
Curve3D_set_point_tilt :: (using self: *Curve3D, idx: int, tilt: float) {
}
Curve3D_get_point_tilt :: (using self: *Curve3D, idx: int) -> float {
}
Curve3D_set_point_in :: (using self: *Curve3D, idx: int, position: Vector3) {
}
Curve3D_get_point_in :: (using self: *Curve3D, idx: int) -> Vector3 {
}
Curve3D_set_point_out :: (using self: *Curve3D, idx: int, position: Vector3) {
}
Curve3D_get_point_out :: (using self: *Curve3D, idx: int) -> Vector3 {
}
Curve3D_remove_point :: (using self: *Curve3D, idx: int) {
}
Curve3D_clear_points :: (using self: *Curve3D) {
}
Curve3D_sample :: (using self: *Curve3D, idx: int, t: float) -> Vector3 {
}
Curve3D_samplef :: (using self: *Curve3D, fofs: float) -> Vector3 {
}
Curve3D_set_bake_interval :: (using self: *Curve3D, distance: float) {
}
Curve3D_get_bake_interval :: (using self: *Curve3D) -> float {
}
Curve3D_set_up_vector_enabled :: (using self: *Curve3D, enable: bool) {
}
Curve3D_is_up_vector_enabled :: (using self: *Curve3D) -> bool {
}
Curve3D_get_baked_length :: (using self: *Curve3D) -> float {
}
Curve3D_sample_baked :: (using self: *Curve3D, offset: float, cubic: bool) -> Vector3 {
}
Curve3D_sample_baked_with_rotation :: (using self: *Curve3D, offset: float, cubic: bool, apply_tilt: bool) -> Transform3D {
}
Curve3D_sample_baked_up_vector :: (using self: *Curve3D, offset: float, apply_tilt: bool) -> Vector3 {
}
Curve3D_get_baked_points :: (using self: *Curve3D) -> PackedVector3Array {
}
Curve3D_get_baked_tilts :: (using self: *Curve3D) -> PackedFloat32Array {
}
Curve3D_get_baked_up_vectors :: (using self: *Curve3D) -> PackedVector3Array {
}
Curve3D_get_closest_point :: (using self: *Curve3D, to_point: Vector3) -> Vector3 {
}
Curve3D_get_closest_offset :: (using self: *Curve3D, to_point: Vector3) -> float {
}
Curve3D_tessellate :: (using self: *Curve3D, max_stages: int, tolerance_degrees: float) -> PackedVector3Array {
}
Curve3D_tessellate_even_length :: (using self: *Curve3D, max_stages: int, tolerance_length: float) -> PackedVector3Array {
}

// CurveTexture
CurveTexture :: struct {
	__private: *void;

	TextureMode :: enum {
		TEXTURE_MODE_RGB :: 0;
		TEXTURE_MODE_RED :: 1;
	}
}

CurveTexture_set_width :: (using self: *CurveTexture, width: int) {
}
CurveTexture_set_curve :: (using self: *CurveTexture, curve: Curve) {
}
CurveTexture_get_curve :: (using self: *CurveTexture) -> Curve {
}
CurveTexture_set_texture_mode :: (using self: *CurveTexture, texture_mode: CurveTexture.TextureMode) {
}
CurveTexture_get_texture_mode :: (using self: *CurveTexture) -> CurveTexture.TextureMode {
}

// CurveXYZTexture
CurveXYZTexture :: struct {
	__private: *void;
}

CurveXYZTexture_set_width :: (using self: *CurveXYZTexture, width: int) {
}
CurveXYZTexture_set_curve_x :: (using self: *CurveXYZTexture, curve: Curve) {
}
CurveXYZTexture_get_curve_x :: (using self: *CurveXYZTexture) -> Curve {
}
CurveXYZTexture_set_curve_y :: (using self: *CurveXYZTexture, curve: Curve) {
}
CurveXYZTexture_get_curve_y :: (using self: *CurveXYZTexture) -> Curve {
}
CurveXYZTexture_set_curve_z :: (using self: *CurveXYZTexture, curve: Curve) {
}
CurveXYZTexture_get_curve_z :: (using self: *CurveXYZTexture) -> Curve {
}

// CylinderMesh
CylinderMesh :: struct {
	__private: *void;
}

CylinderMesh_set_top_radius :: (using self: *CylinderMesh, radius: float) {
}
CylinderMesh_get_top_radius :: (using self: *CylinderMesh) -> float {
}
CylinderMesh_set_bottom_radius :: (using self: *CylinderMesh, radius: float) {
}
CylinderMesh_get_bottom_radius :: (using self: *CylinderMesh) -> float {
}
CylinderMesh_set_height :: (using self: *CylinderMesh, height: float) {
}
CylinderMesh_get_height :: (using self: *CylinderMesh) -> float {
}
CylinderMesh_set_radial_segments :: (using self: *CylinderMesh, segments: int) {
}
CylinderMesh_get_radial_segments :: (using self: *CylinderMesh) -> int {
}
CylinderMesh_set_rings :: (using self: *CylinderMesh, rings: int) {
}
CylinderMesh_get_rings :: (using self: *CylinderMesh) -> int {
}
CylinderMesh_set_cap_top :: (using self: *CylinderMesh, cap_top: bool) {
}
CylinderMesh_is_cap_top :: (using self: *CylinderMesh) -> bool {
}
CylinderMesh_set_cap_bottom :: (using self: *CylinderMesh, cap_bottom: bool) {
}
CylinderMesh_is_cap_bottom :: (using self: *CylinderMesh) -> bool {
}

// CylinderShape3D
CylinderShape3D :: struct {
	__private: *void;
}

CylinderShape3D_set_radius :: (using self: *CylinderShape3D, radius: float) {
}
CylinderShape3D_get_radius :: (using self: *CylinderShape3D) -> float {
}
CylinderShape3D_set_height :: (using self: *CylinderShape3D, height: float) {
}
CylinderShape3D_get_height :: (using self: *CylinderShape3D) -> float {
}

// DTLSServer
DTLSServer :: struct {
	__private: *void;
}

DTLSServer_setup :: (using self: *DTLSServer, server_options: TLSOptions) -> Error {
}
DTLSServer_take_connection :: (using self: *DTLSServer, udp_peer: PacketPeerUDP) -> PacketPeerDTLS {
}

// DampedSpringJoint2D
DampedSpringJoint2D :: struct {
	__private: *void;
}

DampedSpringJoint2D_set_length :: (using self: *DampedSpringJoint2D, length: float) {
}
DampedSpringJoint2D_get_length :: (using self: *DampedSpringJoint2D) -> float {
}
DampedSpringJoint2D_set_rest_length :: (using self: *DampedSpringJoint2D, rest_length: float) {
}
DampedSpringJoint2D_get_rest_length :: (using self: *DampedSpringJoint2D) -> float {
}
DampedSpringJoint2D_set_stiffness :: (using self: *DampedSpringJoint2D, stiffness: float) {
}
DampedSpringJoint2D_get_stiffness :: (using self: *DampedSpringJoint2D) -> float {
}
DampedSpringJoint2D_set_damping :: (using self: *DampedSpringJoint2D, damping: float) {
}
DampedSpringJoint2D_get_damping :: (using self: *DampedSpringJoint2D) -> float {
}

// Decal
Decal :: struct {
	__private: *void;

	DecalTexture :: enum {
		TEXTURE_ALBEDO :: 0;
		TEXTURE_NORMAL :: 1;
		TEXTURE_ORM :: 2;
		TEXTURE_EMISSION :: 3;
		TEXTURE_MAX :: 4;
	}
}

Decal_set_size :: (using self: *Decal, size: Vector3) {
}
Decal_get_size :: (using self: *Decal) -> Vector3 {
}
Decal_set_texture :: (using self: *Decal, type: Decal.DecalTexture, texture: Texture2D) {
}
Decal_get_texture :: (using self: *Decal, type: Decal.DecalTexture) -> Texture2D {
}
Decal_set_emission_energy :: (using self: *Decal, energy: float) {
}
Decal_get_emission_energy :: (using self: *Decal) -> float {
}
Decal_set_albedo_mix :: (using self: *Decal, energy: float) {
}
Decal_get_albedo_mix :: (using self: *Decal) -> float {
}
Decal_set_modulate :: (using self: *Decal, color: Color) {
}
Decal_get_modulate :: (using self: *Decal) -> Color {
}
Decal_set_upper_fade :: (using self: *Decal, fade: float) {
}
Decal_get_upper_fade :: (using self: *Decal) -> float {
}
Decal_set_lower_fade :: (using self: *Decal, fade: float) {
}
Decal_get_lower_fade :: (using self: *Decal) -> float {
}
Decal_set_normal_fade :: (using self: *Decal, fade: float) {
}
Decal_get_normal_fade :: (using self: *Decal) -> float {
}
Decal_set_enable_distance_fade :: (using self: *Decal, enable: bool) {
}
Decal_is_distance_fade_enabled :: (using self: *Decal) -> bool {
}
Decal_set_distance_fade_begin :: (using self: *Decal, distance: float) {
}
Decal_get_distance_fade_begin :: (using self: *Decal) -> float {
}
Decal_set_distance_fade_length :: (using self: *Decal, distance: float) {
}
Decal_get_distance_fade_length :: (using self: *Decal) -> float {
}
Decal_set_cull_mask :: (using self: *Decal, mask: int) {
}
Decal_get_cull_mask :: (using self: *Decal) -> int {
}

// DirAccess
DirAccess :: struct {
	__private: *void;
}

DirAccess_open :: (using self: *DirAccess, path: String) -> DirAccess {
}
DirAccess_get_open_error :: (using self: *DirAccess) -> Error {
}
DirAccess_list_dir_begin :: (using self: *DirAccess) -> Error {
}
DirAccess_get_next :: (using self: *DirAccess) -> String {
}
DirAccess_current_is_dir :: (using self: *DirAccess) -> bool {
}
DirAccess_list_dir_end :: (using self: *DirAccess) {
}
DirAccess_get_files :: (using self: *DirAccess) -> PackedStringArray {
}
DirAccess_get_files_at :: (using self: *DirAccess, path: String) -> PackedStringArray {
}
DirAccess_get_directories :: (using self: *DirAccess) -> PackedStringArray {
}
DirAccess_get_directories_at :: (using self: *DirAccess, path: String) -> PackedStringArray {
}
DirAccess_get_drive_count :: (using self: *DirAccess) -> int {
}
DirAccess_get_drive_name :: (using self: *DirAccess, idx: int) -> String {
}
DirAccess_get_current_drive :: (using self: *DirAccess) -> int {
}
DirAccess_change_dir :: (using self: *DirAccess, to_dir: String) -> Error {
}
DirAccess_get_current_dir :: (using self: *DirAccess, include_drive: bool) -> String {
}
DirAccess_make_dir :: (using self: *DirAccess, path: String) -> Error {
}
DirAccess_make_dir_absolute :: (using self: *DirAccess, path: String) -> Error {
}
DirAccess_make_dir_recursive :: (using self: *DirAccess, path: String) -> Error {
}
DirAccess_make_dir_recursive_absolute :: (using self: *DirAccess, path: String) -> Error {
}
DirAccess_file_exists :: (using self: *DirAccess, path: String) -> bool {
}
DirAccess_dir_exists :: (using self: *DirAccess, path: String) -> bool {
}
DirAccess_dir_exists_absolute :: (using self: *DirAccess, path: String) -> bool {
}
DirAccess_get_space_left :: (using self: *DirAccess) -> int {
}
DirAccess_copy :: (using self: *DirAccess, from: String, to: String, chmod_flags: int) -> Error {
}
DirAccess_copy_absolute :: (using self: *DirAccess, from: String, to: String, chmod_flags: int) -> Error {
}
DirAccess_rename :: (using self: *DirAccess, from: String, to: String) -> Error {
}
DirAccess_rename_absolute :: (using self: *DirAccess, from: String, to: String) -> Error {
}
DirAccess__remove :: (using self: *DirAccess, path: String) -> Error {
}
DirAccess_remove_absolute :: (using self: *DirAccess, path: String) -> Error {
}
DirAccess_is_link :: (using self: *DirAccess, path: String) -> bool {
}
DirAccess_read_link :: (using self: *DirAccess, path: String) -> String {
}
DirAccess_create_link :: (using self: *DirAccess, source: String, target: String) -> Error {
}
DirAccess_set_include_navigational :: (using self: *DirAccess, enable: bool) {
}
DirAccess_get_include_navigational :: (using self: *DirAccess) -> bool {
}
DirAccess_set_include_hidden :: (using self: *DirAccess, enable: bool) {
}
DirAccess_get_include_hidden :: (using self: *DirAccess) -> bool {
}
DirAccess_is_case_sensitive :: (using self: *DirAccess, path: String) -> bool {
}

// DirectionalLight2D
DirectionalLight2D :: struct {
	__private: *void;
}

DirectionalLight2D_set_max_distance :: (using self: *DirectionalLight2D, pixels: float) {
}
DirectionalLight2D_get_max_distance :: (using self: *DirectionalLight2D) -> float {
}

// DirectionalLight3D
DirectionalLight3D :: struct {
	__private: *void;

	ShadowMode :: enum {
		SHADOW_ORTHOGONAL :: 0;
		SHADOW_PARALLEL_2_SPLITS :: 1;
		SHADOW_PARALLEL_4_SPLITS :: 2;
	}
	SkyMode :: enum {
		SKY_MODE_LIGHT_AND_SKY :: 0;
		SKY_MODE_LIGHT_ONLY :: 1;
		SKY_MODE_SKY_ONLY :: 2;
	}
}

DirectionalLight3D_set_shadow_mode :: (using self: *DirectionalLight3D, mode: DirectionalLight3D.ShadowMode) {
}
DirectionalLight3D_get_shadow_mode :: (using self: *DirectionalLight3D) -> DirectionalLight3D.ShadowMode {
}
DirectionalLight3D_set_blend_splits :: (using self: *DirectionalLight3D, enabled: bool) {
}
DirectionalLight3D_is_blend_splits_enabled :: (using self: *DirectionalLight3D) -> bool {
}
DirectionalLight3D_set_sky_mode :: (using self: *DirectionalLight3D, mode: DirectionalLight3D.SkyMode) {
}
DirectionalLight3D_get_sky_mode :: (using self: *DirectionalLight3D) -> DirectionalLight3D.SkyMode {
}

// DisplayServer
DisplayServer :: struct {
	__private: *void;

	SCREEN_WITH_MOUSE_FOCUS :: -4;
	SCREEN_WITH_KEYBOARD_FOCUS :: -3;
	SCREEN_PRIMARY :: -2;
	SCREEN_OF_MAIN_WINDOW :: -1;
	MAIN_WINDOW_ID :: 0;
	INVALID_WINDOW_ID :: -1;
	INVALID_INDICATOR_ID :: -1;

	Feature :: enum {
		FEATURE_GLOBAL_MENU :: 0;
		FEATURE_SUBWINDOWS :: 1;
		FEATURE_TOUCHSCREEN :: 2;
		FEATURE_MOUSE :: 3;
		FEATURE_MOUSE_WARP :: 4;
		FEATURE_CLIPBOARD :: 5;
		FEATURE_VIRTUAL_KEYBOARD :: 6;
		FEATURE_CURSOR_SHAPE :: 7;
		FEATURE_CUSTOM_CURSOR_SHAPE :: 8;
		FEATURE_NATIVE_DIALOG :: 9;
		FEATURE_IME :: 10;
		FEATURE_WINDOW_TRANSPARENCY :: 11;
		FEATURE_HIDPI :: 12;
		FEATURE_ICON :: 13;
		FEATURE_NATIVE_ICON :: 14;
		FEATURE_ORIENTATION :: 15;
		FEATURE_SWAP_BUFFERS :: 16;
		FEATURE_CLIPBOARD_PRIMARY :: 18;
		FEATURE_TEXT_TO_SPEECH :: 19;
		FEATURE_EXTEND_TO_TITLE :: 20;
		FEATURE_SCREEN_CAPTURE :: 21;
		FEATURE_STATUS_INDICATOR :: 22;
		FEATURE_NATIVE_HELP :: 23;
		FEATURE_NATIVE_DIALOG_INPUT :: 24;
		FEATURE_NATIVE_DIALOG_FILE :: 25;
	}
	MouseMode :: enum {
		MOUSE_MODE_VISIBLE :: 0;
		MOUSE_MODE_HIDDEN :: 1;
		MOUSE_MODE_CAPTURED :: 2;
		MOUSE_MODE_CONFINED :: 3;
		MOUSE_MODE_CONFINED_HIDDEN :: 4;
	}
	ScreenOrientation :: enum {
		SCREEN_LANDSCAPE :: 0;
		SCREEN_PORTRAIT :: 1;
		SCREEN_REVERSE_LANDSCAPE :: 2;
		SCREEN_REVERSE_PORTRAIT :: 3;
		SCREEN_SENSOR_LANDSCAPE :: 4;
		SCREEN_SENSOR_PORTRAIT :: 5;
		SCREEN_SENSOR :: 6;
	}
	VirtualKeyboardType :: enum {
		KEYBOARD_TYPE_DEFAULT :: 0;
		KEYBOARD_TYPE_MULTILINE :: 1;
		KEYBOARD_TYPE_NUMBER :: 2;
		KEYBOARD_TYPE_NUMBER_DECIMAL :: 3;
		KEYBOARD_TYPE_PHONE :: 4;
		KEYBOARD_TYPE_EMAIL_ADDRESS :: 5;
		KEYBOARD_TYPE_PASSWORD :: 6;
		KEYBOARD_TYPE_URL :: 7;
	}
	CursorShape :: enum {
		CURSOR_ARROW :: 0;
		CURSOR_IBEAM :: 1;
		CURSOR_POINTING_HAND :: 2;
		CURSOR_CROSS :: 3;
		CURSOR_WAIT :: 4;
		CURSOR_BUSY :: 5;
		CURSOR_DRAG :: 6;
		CURSOR_CAN_DROP :: 7;
		CURSOR_FORBIDDEN :: 8;
		CURSOR_VSIZE :: 9;
		CURSOR_HSIZE :: 10;
		CURSOR_BDIAGSIZE :: 11;
		CURSOR_FDIAGSIZE :: 12;
		CURSOR_MOVE :: 13;
		CURSOR_VSPLIT :: 14;
		CURSOR_HSPLIT :: 15;
		CURSOR_HELP :: 16;
		CURSOR_MAX :: 17;
	}
	FileDialogMode :: enum {
		FILE_DIALOG_MODE_OPEN_FILE :: 0;
		FILE_DIALOG_MODE_OPEN_FILES :: 1;
		FILE_DIALOG_MODE_OPEN_DIR :: 2;
		FILE_DIALOG_MODE_OPEN_ANY :: 3;
		FILE_DIALOG_MODE_SAVE_FILE :: 4;
	}
	WindowMode :: enum {
		WINDOW_MODE_WINDOWED :: 0;
		WINDOW_MODE_MINIMIZED :: 1;
		WINDOW_MODE_MAXIMIZED :: 2;
		WINDOW_MODE_FULLSCREEN :: 3;
		WINDOW_MODE_EXCLUSIVE_FULLSCREEN :: 4;
	}
	WindowFlags :: enum {
		WINDOW_FLAG_RESIZE_DISABLED :: 0;
		WINDOW_FLAG_BORDERLESS :: 1;
		WINDOW_FLAG_ALWAYS_ON_TOP :: 2;
		WINDOW_FLAG_TRANSPARENT :: 3;
		WINDOW_FLAG_NO_FOCUS :: 4;
		WINDOW_FLAG_POPUP :: 5;
		WINDOW_FLAG_EXTEND_TO_TITLE :: 6;
		WINDOW_FLAG_MOUSE_PASSTHROUGH :: 7;
		WINDOW_FLAG_MAX :: 8;
	}
	WindowEvent :: enum {
		WINDOW_EVENT_MOUSE_ENTER :: 0;
		WINDOW_EVENT_MOUSE_EXIT :: 1;
		WINDOW_EVENT_FOCUS_IN :: 2;
		WINDOW_EVENT_FOCUS_OUT :: 3;
		WINDOW_EVENT_CLOSE_REQUEST :: 4;
		WINDOW_EVENT_GO_BACK_REQUEST :: 5;
		WINDOW_EVENT_DPI_CHANGE :: 6;
		WINDOW_EVENT_TITLEBAR_CHANGE :: 7;
	}
	VSyncMode :: enum {
		VSYNC_DISABLED :: 0;
		VSYNC_ENABLED :: 1;
		VSYNC_ADAPTIVE :: 2;
		VSYNC_MAILBOX :: 3;
	}
	HandleType :: enum {
		DISPLAY_HANDLE :: 0;
		WINDOW_HANDLE :: 1;
		WINDOW_VIEW :: 2;
		OPENGL_CONTEXT :: 3;
	}
	TTSUtteranceEvent :: enum {
		TTS_UTTERANCE_STARTED :: 0;
		TTS_UTTERANCE_ENDED :: 1;
		TTS_UTTERANCE_CANCELED :: 2;
		TTS_UTTERANCE_BOUNDARY :: 3;
	}
}

DisplayServer_has_feature :: (using self: *DisplayServer, feature: DisplayServer.Feature) -> bool {
}
DisplayServer_get_name :: (using self: *DisplayServer) -> String {
}
DisplayServer_help_set_search_callbacks :: (using self: *DisplayServer, search_callback: Callable, action_callback: Callable) {
}
DisplayServer_global_menu_set_popup_callbacks :: (using self: *DisplayServer, menu_root: String, open_callback: Callable, close_callback: Callable) {
}
DisplayServer_global_menu_add_submenu_item :: (using self: *DisplayServer, menu_root: String, label: String, submenu: String, index: int) -> int {
}
DisplayServer_global_menu_add_item :: (using self: *DisplayServer, menu_root: String, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
DisplayServer_global_menu_add_check_item :: (using self: *DisplayServer, menu_root: String, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
DisplayServer_global_menu_add_icon_item :: (using self: *DisplayServer, menu_root: String, icon: Texture2D, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
DisplayServer_global_menu_add_icon_check_item :: (using self: *DisplayServer, menu_root: String, icon: Texture2D, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
DisplayServer_global_menu_add_radio_check_item :: (using self: *DisplayServer, menu_root: String, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
DisplayServer_global_menu_add_icon_radio_check_item :: (using self: *DisplayServer, menu_root: String, icon: Texture2D, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
DisplayServer_global_menu_add_multistate_item :: (using self: *DisplayServer, menu_root: String, label: String, max_states: int, default_state: int, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
DisplayServer_global_menu_add_separator :: (using self: *DisplayServer, menu_root: String, index: int) -> int {
}
DisplayServer_global_menu_get_item_index_from_text :: (using self: *DisplayServer, menu_root: String, text: String) -> int {
}
DisplayServer_global_menu_get_item_index_from_tag :: (using self: *DisplayServer, menu_root: String, tag: Variant) -> int {
}
DisplayServer_global_menu_is_item_checked :: (using self: *DisplayServer, menu_root: String, idx: int) -> bool {
}
DisplayServer_global_menu_is_item_checkable :: (using self: *DisplayServer, menu_root: String, idx: int) -> bool {
}
DisplayServer_global_menu_is_item_radio_checkable :: (using self: *DisplayServer, menu_root: String, idx: int) -> bool {
}
DisplayServer_global_menu_get_item_callback :: (using self: *DisplayServer, menu_root: String, idx: int) -> Callable {
}
DisplayServer_global_menu_get_item_key_callback :: (using self: *DisplayServer, menu_root: String, idx: int) -> Callable {
}
DisplayServer_global_menu_get_item_tag :: (using self: *DisplayServer, menu_root: String, idx: int) -> Variant {
}
DisplayServer_global_menu_get_item_text :: (using self: *DisplayServer, menu_root: String, idx: int) -> String {
}
DisplayServer_global_menu_get_item_submenu :: (using self: *DisplayServer, menu_root: String, idx: int) -> String {
}
DisplayServer_global_menu_get_item_accelerator :: (using self: *DisplayServer, menu_root: String, idx: int) -> Key {
}
DisplayServer_global_menu_is_item_disabled :: (using self: *DisplayServer, menu_root: String, idx: int) -> bool {
}
DisplayServer_global_menu_is_item_hidden :: (using self: *DisplayServer, menu_root: String, idx: int) -> bool {
}
DisplayServer_global_menu_get_item_tooltip :: (using self: *DisplayServer, menu_root: String, idx: int) -> String {
}
DisplayServer_global_menu_get_item_state :: (using self: *DisplayServer, menu_root: String, idx: int) -> int {
}
DisplayServer_global_menu_get_item_max_states :: (using self: *DisplayServer, menu_root: String, idx: int) -> int {
}
DisplayServer_global_menu_get_item_icon :: (using self: *DisplayServer, menu_root: String, idx: int) -> Texture2D {
}
DisplayServer_global_menu_get_item_indentation_level :: (using self: *DisplayServer, menu_root: String, idx: int) -> int {
}
DisplayServer_global_menu_set_item_checked :: (using self: *DisplayServer, menu_root: String, idx: int, checked: bool) {
}
DisplayServer_global_menu_set_item_checkable :: (using self: *DisplayServer, menu_root: String, idx: int, checkable: bool) {
}
DisplayServer_global_menu_set_item_radio_checkable :: (using self: *DisplayServer, menu_root: String, idx: int, checkable: bool) {
}
DisplayServer_global_menu_set_item_callback :: (using self: *DisplayServer, menu_root: String, idx: int, callback: Callable) {
}
DisplayServer_global_menu_set_item_hover_callbacks :: (using self: *DisplayServer, menu_root: String, idx: int, callback: Callable) {
}
DisplayServer_global_menu_set_item_key_callback :: (using self: *DisplayServer, menu_root: String, idx: int, key_callback: Callable) {
}
DisplayServer_global_menu_set_item_tag :: (using self: *DisplayServer, menu_root: String, idx: int, tag: Variant) {
}
DisplayServer_global_menu_set_item_text :: (using self: *DisplayServer, menu_root: String, idx: int, text: String) {
}
DisplayServer_global_menu_set_item_submenu :: (using self: *DisplayServer, menu_root: String, idx: int, submenu: String) {
}
DisplayServer_global_menu_set_item_accelerator :: (using self: *DisplayServer, menu_root: String, idx: int, keycode: Key) {
}
DisplayServer_global_menu_set_item_disabled :: (using self: *DisplayServer, menu_root: String, idx: int, disabled: bool) {
}
DisplayServer_global_menu_set_item_hidden :: (using self: *DisplayServer, menu_root: String, idx: int, hidden: bool) {
}
DisplayServer_global_menu_set_item_tooltip :: (using self: *DisplayServer, menu_root: String, idx: int, tooltip: String) {
}
DisplayServer_global_menu_set_item_state :: (using self: *DisplayServer, menu_root: String, idx: int, state: int) {
}
DisplayServer_global_menu_set_item_max_states :: (using self: *DisplayServer, menu_root: String, idx: int, max_states: int) {
}
DisplayServer_global_menu_set_item_icon :: (using self: *DisplayServer, menu_root: String, idx: int, icon: Texture2D) {
}
DisplayServer_global_menu_set_item_indentation_level :: (using self: *DisplayServer, menu_root: String, idx: int, level: int) {
}
DisplayServer_global_menu_get_item_count :: (using self: *DisplayServer, menu_root: String) -> int {
}
DisplayServer_global_menu_remove_item :: (using self: *DisplayServer, menu_root: String, idx: int) {
}
DisplayServer_global_menu_clear :: (using self: *DisplayServer, menu_root: String) {
}
DisplayServer_global_menu_get_system_menu_roots :: (using self: *DisplayServer) -> Dictionary {
}
DisplayServer_tts_is_speaking :: (using self: *DisplayServer) -> bool {
}
DisplayServer_tts_is_paused :: (using self: *DisplayServer) -> bool {
}
DisplayServer_tts_get_voices :: (using self: *DisplayServer) -> Dictionary {
}
DisplayServer_tts_get_voices_for_language :: (using self: *DisplayServer, language: String) -> PackedStringArray {
}
DisplayServer_tts_speak :: (using self: *DisplayServer, text: String, voice: String, volume: int, pitch: float, rate: float, utterance_id: int, interrupt: bool) {
}
DisplayServer_tts_pause :: (using self: *DisplayServer) {
}
DisplayServer_tts_resume :: (using self: *DisplayServer) {
}
DisplayServer_tts_stop :: (using self: *DisplayServer) {
}
DisplayServer_tts_set_utterance_callback :: (using self: *DisplayServer, event: DisplayServer.TTSUtteranceEvent, callable: Callable) {
}
DisplayServer_is_dark_mode_supported :: (using self: *DisplayServer) -> bool {
}
DisplayServer_is_dark_mode :: (using self: *DisplayServer) -> bool {
}
DisplayServer_get_accent_color :: (using self: *DisplayServer) -> Color {
}
DisplayServer_get_base_color :: (using self: *DisplayServer) -> Color {
}
DisplayServer_set_system_theme_change_callback :: (using self: *DisplayServer, callable: Callable) {
}
DisplayServer_mouse_set_mode :: (using self: *DisplayServer, mouse_mode: DisplayServer.MouseMode) {
}
DisplayServer_mouse_get_mode :: (using self: *DisplayServer) -> DisplayServer.MouseMode {
}
DisplayServer_warp_mouse :: (using self: *DisplayServer, position: Vector2i) {
}
DisplayServer_mouse_get_position :: (using self: *DisplayServer) -> Vector2i {
}
DisplayServer_mouse_get_button_state :: (using self: *DisplayServer) -> MouseButtonMask {
}
DisplayServer_clipboard_set :: (using self: *DisplayServer, clipboard: String) {
}
DisplayServer_clipboard_get :: (using self: *DisplayServer) -> String {
}
DisplayServer_clipboard_get_image :: (using self: *DisplayServer) -> Image {
}
DisplayServer_clipboard_has :: (using self: *DisplayServer) -> bool {
}
DisplayServer_clipboard_has_image :: (using self: *DisplayServer) -> bool {
}
DisplayServer_clipboard_set_primary :: (using self: *DisplayServer, clipboard_primary: String) {
}
DisplayServer_clipboard_get_primary :: (using self: *DisplayServer) -> String {
}
DisplayServer_get_display_cutouts :: (using self: *DisplayServer) -> Array {
}
DisplayServer_get_display_safe_area :: (using self: *DisplayServer) -> Rect2i {
}
DisplayServer_get_screen_count :: (using self: *DisplayServer) -> int {
}
DisplayServer_get_primary_screen :: (using self: *DisplayServer) -> int {
}
DisplayServer_get_keyboard_focus_screen :: (using self: *DisplayServer) -> int {
}
DisplayServer_get_screen_from_rect :: (using self: *DisplayServer, rect: Rect2) -> int {
}
DisplayServer_screen_get_position :: (using self: *DisplayServer, screen: int) -> Vector2i {
}
DisplayServer_screen_get_size :: (using self: *DisplayServer, screen: int) -> Vector2i {
}
DisplayServer_screen_get_usable_rect :: (using self: *DisplayServer, screen: int) -> Rect2i {
}
DisplayServer_screen_get_dpi :: (using self: *DisplayServer, screen: int) -> int {
}
DisplayServer_screen_get_scale :: (using self: *DisplayServer, screen: int) -> float {
}
DisplayServer_is_touchscreen_available :: (using self: *DisplayServer) -> bool {
}
DisplayServer_screen_get_max_scale :: (using self: *DisplayServer) -> float {
}
DisplayServer_screen_get_refresh_rate :: (using self: *DisplayServer, screen: int) -> float {
}
DisplayServer_screen_get_pixel :: (using self: *DisplayServer, position: Vector2i) -> Color {
}
DisplayServer_screen_get_image :: (using self: *DisplayServer, screen: int) -> Image {
}
DisplayServer_screen_set_orientation :: (using self: *DisplayServer, orientation: DisplayServer.ScreenOrientation, screen: int) {
}
DisplayServer_screen_get_orientation :: (using self: *DisplayServer, screen: int) -> DisplayServer.ScreenOrientation {
}
DisplayServer_screen_set_keep_on :: (using self: *DisplayServer, enable: bool) {
}
DisplayServer_screen_is_kept_on :: (using self: *DisplayServer) -> bool {
}
DisplayServer_get_window_list :: (using self: *DisplayServer) -> PackedInt32Array {
}
DisplayServer_get_window_at_screen_position :: (using self: *DisplayServer, position: Vector2i) -> int {
}
DisplayServer_window_get_native_handle :: (using self: *DisplayServer, handle_type: DisplayServer.HandleType, window_id: int) -> int {
}
DisplayServer_window_get_active_popup :: (using self: *DisplayServer) -> int {
}
DisplayServer_window_set_popup_safe_rect :: (using self: *DisplayServer, window: int, rect: Rect2i) {
}
DisplayServer_window_get_popup_safe_rect :: (using self: *DisplayServer, window: int) -> Rect2i {
}
DisplayServer_window_set_title :: (using self: *DisplayServer, title: String, window_id: int) {
}
DisplayServer_window_get_title_size :: (using self: *DisplayServer, title: String, window_id: int) -> Vector2i {
}
DisplayServer_window_set_mouse_passthrough :: (using self: *DisplayServer, region: PackedVector2Array, window_id: int) {
}
DisplayServer_window_get_current_screen :: (using self: *DisplayServer, window_id: int) -> int {
}
DisplayServer_window_set_current_screen :: (using self: *DisplayServer, screen: int, window_id: int) {
}
DisplayServer_window_get_position :: (using self: *DisplayServer, window_id: int) -> Vector2i {
}
DisplayServer_window_get_position_with_decorations :: (using self: *DisplayServer, window_id: int) -> Vector2i {
}
DisplayServer_window_set_position :: (using self: *DisplayServer, position: Vector2i, window_id: int) {
}
DisplayServer_window_get_size :: (using self: *DisplayServer, window_id: int) -> Vector2i {
}
DisplayServer_window_set_size :: (using self: *DisplayServer, size: Vector2i, window_id: int) {
}
DisplayServer_window_set_rect_changed_callback :: (using self: *DisplayServer, callback: Callable, window_id: int) {
}
DisplayServer_window_set_window_event_callback :: (using self: *DisplayServer, callback: Callable, window_id: int) {
}
DisplayServer_window_set_input_event_callback :: (using self: *DisplayServer, callback: Callable, window_id: int) {
}
DisplayServer_window_set_input_text_callback :: (using self: *DisplayServer, callback: Callable, window_id: int) {
}
DisplayServer_window_set_drop_files_callback :: (using self: *DisplayServer, callback: Callable, window_id: int) {
}
DisplayServer_window_get_attached_instance_id :: (using self: *DisplayServer, window_id: int) -> int {
}
DisplayServer_window_get_max_size :: (using self: *DisplayServer, window_id: int) -> Vector2i {
}
DisplayServer_window_set_max_size :: (using self: *DisplayServer, max_size: Vector2i, window_id: int) {
}
DisplayServer_window_get_min_size :: (using self: *DisplayServer, window_id: int) -> Vector2i {
}
DisplayServer_window_set_min_size :: (using self: *DisplayServer, min_size: Vector2i, window_id: int) {
}
DisplayServer_window_get_size_with_decorations :: (using self: *DisplayServer, window_id: int) -> Vector2i {
}
DisplayServer_window_get_mode :: (using self: *DisplayServer, window_id: int) -> DisplayServer.WindowMode {
}
DisplayServer_window_set_mode :: (using self: *DisplayServer, mode: DisplayServer.WindowMode, window_id: int) {
}
DisplayServer_window_set_flag :: (using self: *DisplayServer, flag: DisplayServer.WindowFlags, enabled: bool, window_id: int) {
}
DisplayServer_window_get_flag :: (using self: *DisplayServer, flag: DisplayServer.WindowFlags, window_id: int) -> bool {
}
DisplayServer_window_set_window_buttons_offset :: (using self: *DisplayServer, offset: Vector2i, window_id: int) {
}
DisplayServer_window_get_safe_title_margins :: (using self: *DisplayServer, window_id: int) -> Vector3i {
}
DisplayServer_window_request_attention :: (using self: *DisplayServer, window_id: int) {
}
DisplayServer_window_move_to_foreground :: (using self: *DisplayServer, window_id: int) {
}
DisplayServer_window_is_focused :: (using self: *DisplayServer, window_id: int) -> bool {
}
DisplayServer_window_can_draw :: (using self: *DisplayServer, window_id: int) -> bool {
}
DisplayServer_window_set_transient :: (using self: *DisplayServer, window_id: int, parent_window_id: int) {
}
DisplayServer_window_set_exclusive :: (using self: *DisplayServer, window_id: int, exclusive: bool) {
}
DisplayServer_window_set_ime_active :: (using self: *DisplayServer, active: bool, window_id: int) {
}
DisplayServer_window_set_ime_position :: (using self: *DisplayServer, position: Vector2i, window_id: int) {
}
DisplayServer_window_set_vsync_mode :: (using self: *DisplayServer, vsync_mode: DisplayServer.VSyncMode, window_id: int) {
}
DisplayServer_window_get_vsync_mode :: (using self: *DisplayServer, window_id: int) -> DisplayServer.VSyncMode {
}
DisplayServer_window_is_maximize_allowed :: (using self: *DisplayServer, window_id: int) -> bool {
}
DisplayServer_window_maximize_on_title_dbl_click :: (using self: *DisplayServer) -> bool {
}
DisplayServer_window_minimize_on_title_dbl_click :: (using self: *DisplayServer) -> bool {
}
DisplayServer_ime_get_selection :: (using self: *DisplayServer) -> Vector2i {
}
DisplayServer_ime_get_text :: (using self: *DisplayServer) -> String {
}
DisplayServer_virtual_keyboard_show :: (using self: *DisplayServer, existing_text: String, position: Rect2, type: DisplayServer.VirtualKeyboardType, max_length: int, cursor_start: int, cursor_end: int) {
}
DisplayServer_virtual_keyboard_hide :: (using self: *DisplayServer) {
}
DisplayServer_virtual_keyboard_get_height :: (using self: *DisplayServer) -> int {
}
DisplayServer_cursor_set_shape :: (using self: *DisplayServer, shape: DisplayServer.CursorShape) {
}
DisplayServer_cursor_get_shape :: (using self: *DisplayServer) -> DisplayServer.CursorShape {
}
DisplayServer_cursor_set_custom_image :: (using self: *DisplayServer, cursor: Resource, shape: DisplayServer.CursorShape, hotspot: Vector2) {
}
DisplayServer_get_swap_cancel_ok :: (using self: *DisplayServer) -> bool {
}
DisplayServer_enable_for_stealing_focus :: (using self: *DisplayServer, process_id: int) {
}
DisplayServer_dialog_show :: (using self: *DisplayServer, title: String, description: String, buttons: PackedStringArray, callback: Callable) -> Error {
}
DisplayServer_dialog_input_text :: (using self: *DisplayServer, title: String, description: String, existing_text: String, callback: Callable) -> Error {
}
DisplayServer_file_dialog_show :: (using self: *DisplayServer, title: String, current_directory: String, filename: String, show_hidden: bool, mode: DisplayServer.FileDialogMode, filters: PackedStringArray, callback: Callable) -> Error {
}
DisplayServer_file_dialog_with_options_show :: (using self: *DisplayServer, title: String, current_directory: String, root: String, filename: String, show_hidden: bool, mode: DisplayServer.FileDialogMode, filters: PackedStringArray, options: Dictionary, callback: Callable) -> Error {
}
DisplayServer_keyboard_get_layout_count :: (using self: *DisplayServer) -> int {
}
DisplayServer_keyboard_get_current_layout :: (using self: *DisplayServer) -> int {
}
DisplayServer_keyboard_set_current_layout :: (using self: *DisplayServer, index: int) {
}
DisplayServer_keyboard_get_layout_language :: (using self: *DisplayServer, index: int) -> String {
}
DisplayServer_keyboard_get_layout_name :: (using self: *DisplayServer, index: int) -> String {
}
DisplayServer_keyboard_get_keycode_from_physical :: (using self: *DisplayServer, keycode: Key) -> Key {
}
DisplayServer_keyboard_get_label_from_physical :: (using self: *DisplayServer, keycode: Key) -> Key {
}
DisplayServer_process_events :: (using self: *DisplayServer) {
}
DisplayServer_force_process_and_drop_events :: (using self: *DisplayServer) {
}
DisplayServer_set_native_icon :: (using self: *DisplayServer, filename: String) {
}
DisplayServer_set_icon :: (using self: *DisplayServer, image: Image) {
}
DisplayServer_create_status_indicator :: (using self: *DisplayServer, icon: Texture2D, tooltip: String, callback: Callable) -> int {
}
DisplayServer_status_indicator_set_icon :: (using self: *DisplayServer, id: int, icon: Texture2D) {
}
DisplayServer_status_indicator_set_tooltip :: (using self: *DisplayServer, id: int, tooltip: String) {
}
DisplayServer_status_indicator_set_menu :: (using self: *DisplayServer, id: int, menu_rid: RID) {
}
DisplayServer_status_indicator_set_callback :: (using self: *DisplayServer, id: int, callback: Callable) {
}
DisplayServer_status_indicator_get_rect :: (using self: *DisplayServer, id: int) -> Rect2 {
}
DisplayServer_delete_status_indicator :: (using self: *DisplayServer, id: int) {
}
DisplayServer_tablet_get_driver_count :: (using self: *DisplayServer) -> int {
}
DisplayServer_tablet_get_driver_name :: (using self: *DisplayServer, idx: int) -> String {
}
DisplayServer_tablet_get_current_driver :: (using self: *DisplayServer) -> String {
}
DisplayServer_tablet_set_current_driver :: (using self: *DisplayServer, name: String) {
}
DisplayServer_is_window_transparency_available :: (using self: *DisplayServer) -> bool {
}
DisplayServer_register_additional_output :: (using self: *DisplayServer, object: Object) {
}
DisplayServer_unregister_additional_output :: (using self: *DisplayServer, object: Object) {
}
DisplayServer_has_additional_outputs :: (using self: *DisplayServer) -> bool {
}

// ENetConnection
ENetConnection :: struct {
	__private: *void;

	CompressionMode :: enum {
		COMPRESS_NONE :: 0;
		COMPRESS_RANGE_CODER :: 1;
		COMPRESS_FASTLZ :: 2;
		COMPRESS_ZLIB :: 3;
		COMPRESS_ZSTD :: 4;
	}
	EventType :: enum {
		EVENT_ERROR :: -1;
		EVENT_NONE :: 0;
		EVENT_CONNECT :: 1;
		EVENT_DISCONNECT :: 2;
		EVENT_RECEIVE :: 3;
	}
	HostStatistic :: enum {
		HOST_TOTAL_SENT_DATA :: 0;
		HOST_TOTAL_SENT_PACKETS :: 1;
		HOST_TOTAL_RECEIVED_DATA :: 2;
		HOST_TOTAL_RECEIVED_PACKETS :: 3;
	}
}

ENetConnection_create_host_bound :: (using self: *ENetConnection, bind_address: String, bind_port: int, max_peers: int, max_channels: int, in_bandwidth: int, out_bandwidth: int) -> Error {
}
ENetConnection_create_host :: (using self: *ENetConnection, max_peers: int, max_channels: int, in_bandwidth: int, out_bandwidth: int) -> Error {
}
ENetConnection_destroy :: (using self: *ENetConnection) {
}
ENetConnection_connect_to_host :: (using self: *ENetConnection, address: String, port: int, channels: int, data: int) -> ENetPacketPeer {
}
ENetConnection_service :: (using self: *ENetConnection, timeout: int) -> Array {
}
ENetConnection_flush :: (using self: *ENetConnection) {
}
ENetConnection_bandwidth_limit :: (using self: *ENetConnection, in_bandwidth: int, out_bandwidth: int) {
}
ENetConnection_channel_limit :: (using self: *ENetConnection, limit: int) {
}
ENetConnection_broadcast :: (using self: *ENetConnection, channel: int, packet: PackedByteArray, flags: int) {
}
ENetConnection_compress :: (using self: *ENetConnection, mode: ENetConnection.CompressionMode) {
}
ENetConnection_dtls_server_setup :: (using self: *ENetConnection, server_options: TLSOptions) -> Error {
}
ENetConnection_dtls_client_setup :: (using self: *ENetConnection, hostname: String, client_options: TLSOptions) -> Error {
}
ENetConnection_refuse_new_connections :: (using self: *ENetConnection, refuse: bool) {
}
ENetConnection_pop_statistic :: (using self: *ENetConnection, statistic: ENetConnection.HostStatistic) -> float {
}
ENetConnection_get_max_channels :: (using self: *ENetConnection) -> int {
}
ENetConnection_get_local_port :: (using self: *ENetConnection) -> int {
}
ENetConnection_get_peers :: (using self: *ENetConnection) -> Array {
}
ENetConnection_socket_send :: (using self: *ENetConnection, destination_address: String, destination_port: int, packet: PackedByteArray) {
}

// ENetMultiplayerPeer
ENetMultiplayerPeer :: struct {
	__private: *void;
}

ENetMultiplayerPeer_create_server :: (using self: *ENetMultiplayerPeer, port: int, max_clients: int, max_channels: int, in_bandwidth: int, out_bandwidth: int) -> Error {
}
ENetMultiplayerPeer_create_client :: (using self: *ENetMultiplayerPeer, address: String, port: int, channel_count: int, in_bandwidth: int, out_bandwidth: int, local_port: int) -> Error {
}
ENetMultiplayerPeer_create_mesh :: (using self: *ENetMultiplayerPeer, unique_id: int) -> Error {
}
ENetMultiplayerPeer_add_mesh_peer :: (using self: *ENetMultiplayerPeer, peer_id: int, host: ENetConnection) -> Error {
}
ENetMultiplayerPeer_set_bind_ip :: (using self: *ENetMultiplayerPeer, ip: String) {
}
ENetMultiplayerPeer_get_host :: (using self: *ENetMultiplayerPeer) -> ENetConnection {
}
ENetMultiplayerPeer_get_peer :: (using self: *ENetMultiplayerPeer, id: int) -> ENetPacketPeer {
}

// ENetPacketPeer
ENetPacketPeer :: struct {
	__private: *void;

	PACKET_LOSS_SCALE :: 65536;
	PACKET_THROTTLE_SCALE :: 32;
	FLAG_RELIABLE :: 1;
	FLAG_UNSEQUENCED :: 2;
	FLAG_UNRELIABLE_FRAGMENT :: 8;

	PeerState :: enum {
		STATE_DISCONNECTED :: 0;
		STATE_CONNECTING :: 1;
		STATE_ACKNOWLEDGING_CONNECT :: 2;
		STATE_CONNECTION_PENDING :: 3;
		STATE_CONNECTION_SUCCEEDED :: 4;
		STATE_CONNECTED :: 5;
		STATE_DISCONNECT_LATER :: 6;
		STATE_DISCONNECTING :: 7;
		STATE_ACKNOWLEDGING_DISCONNECT :: 8;
		STATE_ZOMBIE :: 9;
	}
	PeerStatistic :: enum {
		PEER_PACKET_LOSS :: 0;
		PEER_PACKET_LOSS_VARIANCE :: 1;
		PEER_PACKET_LOSS_EPOCH :: 2;
		PEER_ROUND_TRIP_TIME :: 3;
		PEER_ROUND_TRIP_TIME_VARIANCE :: 4;
		PEER_LAST_ROUND_TRIP_TIME :: 5;
		PEER_LAST_ROUND_TRIP_TIME_VARIANCE :: 6;
		PEER_PACKET_THROTTLE :: 7;
		PEER_PACKET_THROTTLE_LIMIT :: 8;
		PEER_PACKET_THROTTLE_COUNTER :: 9;
		PEER_PACKET_THROTTLE_EPOCH :: 10;
		PEER_PACKET_THROTTLE_ACCELERATION :: 11;
		PEER_PACKET_THROTTLE_DECELERATION :: 12;
		PEER_PACKET_THROTTLE_INTERVAL :: 13;
	}
}

ENetPacketPeer_peer_disconnect :: (using self: *ENetPacketPeer, data: int) {
}
ENetPacketPeer_peer_disconnect_later :: (using self: *ENetPacketPeer, data: int) {
}
ENetPacketPeer_peer_disconnect_now :: (using self: *ENetPacketPeer, data: int) {
}
ENetPacketPeer_ping :: (using self: *ENetPacketPeer) {
}
ENetPacketPeer_ping_interval :: (using self: *ENetPacketPeer, ping_interval: int) {
}
ENetPacketPeer_reset :: (using self: *ENetPacketPeer) {
}
ENetPacketPeer_send :: (using self: *ENetPacketPeer, channel: int, packet: PackedByteArray, flags: int) -> Error {
}
ENetPacketPeer_throttle_configure :: (using self: *ENetPacketPeer, interval: int, acceleration: int, deceleration: int) {
}
ENetPacketPeer_set_timeout :: (using self: *ENetPacketPeer, timeout: int, timeout_min: int, timeout_max: int) {
}
ENetPacketPeer_get_remote_address :: (using self: *ENetPacketPeer) -> String {
}
ENetPacketPeer_get_remote_port :: (using self: *ENetPacketPeer) -> int {
}
ENetPacketPeer_get_statistic :: (using self: *ENetPacketPeer, statistic: ENetPacketPeer.PeerStatistic) -> float {
}
ENetPacketPeer_get_state :: (using self: *ENetPacketPeer) -> ENetPacketPeer.PeerState {
}
ENetPacketPeer_get_channels :: (using self: *ENetPacketPeer) -> int {
}
ENetPacketPeer_is_active :: (using self: *ENetPacketPeer) -> bool {
}

// EditorCommandPalette
EditorCommandPalette :: struct {
	__private: *void;
}

EditorCommandPalette_add_command :: (using self: *EditorCommandPalette, command_name: String, key_name: String, binded_callable: Callable, shortcut_text: String) {
}
EditorCommandPalette_remove_command :: (using self: *EditorCommandPalette, key_name: String) {
}

// EditorDebuggerPlugin
EditorDebuggerPlugin :: struct {
	__private: *void;
}

EditorDebuggerPlugin__setup_session :: (using self: *EditorDebuggerPlugin, session_id: int) {
}
EditorDebuggerPlugin__has_capture :: (using self: *EditorDebuggerPlugin, capture: String) -> bool {
}
EditorDebuggerPlugin__capture :: (using self: *EditorDebuggerPlugin, message: String, data: Array, session_id: int) -> bool {
}
EditorDebuggerPlugin__goto_script_line :: (using self: *EditorDebuggerPlugin, script: Script, line: int) {
}
EditorDebuggerPlugin__breakpoints_cleared_in_tree :: (using self: *EditorDebuggerPlugin) {
}
EditorDebuggerPlugin__breakpoint_set_in_tree :: (using self: *EditorDebuggerPlugin, script: Script, line: int, enabled: bool) {
}
EditorDebuggerPlugin_get_session :: (using self: *EditorDebuggerPlugin, id: int) -> EditorDebuggerSession {
}
EditorDebuggerPlugin_get_sessions :: (using self: *EditorDebuggerPlugin) -> Array {
}

// EditorDebuggerSession
EditorDebuggerSession :: struct {
	__private: *void;
}

EditorDebuggerSession_send_message :: (using self: *EditorDebuggerSession, message: String, data: Array) {
}
EditorDebuggerSession_toggle_profiler :: (using self: *EditorDebuggerSession, profiler: String, enable: bool, data: Array) {
}
EditorDebuggerSession_is_breaked :: (using self: *EditorDebuggerSession) -> bool {
}
EditorDebuggerSession_is_debuggable :: (using self: *EditorDebuggerSession) -> bool {
}
EditorDebuggerSession_is_active :: (using self: *EditorDebuggerSession) -> bool {
}
EditorDebuggerSession_add_session_tab :: (using self: *EditorDebuggerSession, control: Control) {
}
EditorDebuggerSession_remove_session_tab :: (using self: *EditorDebuggerSession, control: Control) {
}
EditorDebuggerSession_set_breakpoint :: (using self: *EditorDebuggerSession, path: String, line: int, enabled: bool) {
}

// EditorExportPlatform
EditorExportPlatform :: struct {
	__private: *void;
}

EditorExportPlatform_get_os_name :: (using self: *EditorExportPlatform) -> String {
}

// EditorExportPlatformAndroid
EditorExportPlatformAndroid :: struct {
	__private: *void;
}

// EditorExportPlatformIOS
EditorExportPlatformIOS :: struct {
	__private: *void;
}

// EditorExportPlatformLinuxBSD
EditorExportPlatformLinuxBSD :: struct {
	__private: *void;
}

// EditorExportPlatformMacOS
EditorExportPlatformMacOS :: struct {
	__private: *void;
}

// EditorExportPlatformPC
EditorExportPlatformPC :: struct {
	__private: *void;
}

// EditorExportPlatformWeb
EditorExportPlatformWeb :: struct {
	__private: *void;
}

// EditorExportPlatformWindows
EditorExportPlatformWindows :: struct {
	__private: *void;
}

// EditorExportPlugin
EditorExportPlugin :: struct {
	__private: *void;
}

EditorExportPlugin__export_file :: (using self: *EditorExportPlugin, path: String, type: String, features: PackedStringArray) {
}
EditorExportPlugin__export_begin :: (using self: *EditorExportPlugin, features: PackedStringArray, is_debug: bool, path: String, flags: int) {
}
EditorExportPlugin__export_end :: (using self: *EditorExportPlugin) {
}
EditorExportPlugin__begin_customize_resources :: (using self: *EditorExportPlugin, platform: EditorExportPlatform, features: PackedStringArray) -> bool {
}
EditorExportPlugin__customize_resource :: (using self: *EditorExportPlugin, resource: Resource, path: String) -> Resource {
}
EditorExportPlugin__begin_customize_scenes :: (using self: *EditorExportPlugin, platform: EditorExportPlatform, features: PackedStringArray) -> bool {
}
EditorExportPlugin__customize_scene :: (using self: *EditorExportPlugin, scene: Node, path: String) -> Node {
}
EditorExportPlugin__get_customization_configuration_hash :: (using self: *EditorExportPlugin) -> int {
}
EditorExportPlugin__end_customize_scenes :: (using self: *EditorExportPlugin) {
}
EditorExportPlugin__end_customize_resources :: (using self: *EditorExportPlugin) {
}
EditorExportPlugin__get_export_options :: (using self: *EditorExportPlugin, platform: EditorExportPlatform) -> Dictionary {
}
EditorExportPlugin__get_export_options_overrides :: (using self: *EditorExportPlugin, platform: EditorExportPlatform) -> Dictionary {
}
EditorExportPlugin__should_update_export_options :: (using self: *EditorExportPlugin, platform: EditorExportPlatform) -> bool {
}
EditorExportPlugin__get_export_option_warning :: (using self: *EditorExportPlugin, platform: EditorExportPlatform, option: String) -> String {
}
EditorExportPlugin__get_export_features :: (using self: *EditorExportPlugin, platform: EditorExportPlatform, debug: bool) -> PackedStringArray {
}
EditorExportPlugin__get_name :: (using self: *EditorExportPlugin) -> String {
}
EditorExportPlugin__supports_platform :: (using self: *EditorExportPlugin, platform: EditorExportPlatform) -> bool {
}
EditorExportPlugin__get_android_dependencies :: (using self: *EditorExportPlugin, platform: EditorExportPlatform, debug: bool) -> PackedStringArray {
}
EditorExportPlugin__get_android_dependencies_maven_repos :: (using self: *EditorExportPlugin, platform: EditorExportPlatform, debug: bool) -> PackedStringArray {
}
EditorExportPlugin__get_android_libraries :: (using self: *EditorExportPlugin, platform: EditorExportPlatform, debug: bool) -> PackedStringArray {
}
EditorExportPlugin__get_android_manifest_activity_element_contents :: (using self: *EditorExportPlugin, platform: EditorExportPlatform, debug: bool) -> String {
}
EditorExportPlugin__get_android_manifest_application_element_contents :: (using self: *EditorExportPlugin, platform: EditorExportPlatform, debug: bool) -> String {
}
EditorExportPlugin__get_android_manifest_element_contents :: (using self: *EditorExportPlugin, platform: EditorExportPlatform, debug: bool) -> String {
}
EditorExportPlugin_add_shared_object :: (using self: *EditorExportPlugin, path: String, tags: PackedStringArray, target: String) {
}
EditorExportPlugin_add_ios_project_static_lib :: (using self: *EditorExportPlugin, path: String) {
}
EditorExportPlugin_add_file :: (using self: *EditorExportPlugin, path: String, file: PackedByteArray, remap: bool) {
}
EditorExportPlugin_add_ios_framework :: (using self: *EditorExportPlugin, path: String) {
}
EditorExportPlugin_add_ios_embedded_framework :: (using self: *EditorExportPlugin, path: String) {
}
EditorExportPlugin_add_ios_plist_content :: (using self: *EditorExportPlugin, plist_content: String) {
}
EditorExportPlugin_add_ios_linker_flags :: (using self: *EditorExportPlugin, flags: String) {
}
EditorExportPlugin_add_ios_bundle_file :: (using self: *EditorExportPlugin, path: String) {
}
EditorExportPlugin_add_ios_cpp_code :: (using self: *EditorExportPlugin, code: String) {
}
EditorExportPlugin_add_macos_plugin_file :: (using self: *EditorExportPlugin, path: String) {
}
EditorExportPlugin_skip :: (using self: *EditorExportPlugin) {
}
EditorExportPlugin_get_option :: (using self: *EditorExportPlugin, name: StringName) -> Variant {
}

// EditorFeatureProfile
EditorFeatureProfile :: struct {
	__private: *void;

	Feature :: enum {
		FEATURE_3D :: 0;
		FEATURE_SCRIPT :: 1;
		FEATURE_ASSET_LIB :: 2;
		FEATURE_SCENE_TREE :: 3;
		FEATURE_NODE_DOCK :: 4;
		FEATURE_FILESYSTEM_DOCK :: 5;
		FEATURE_IMPORT_DOCK :: 6;
		FEATURE_HISTORY_DOCK :: 7;
		FEATURE_MAX :: 8;
	}
}

EditorFeatureProfile_set_disable_class :: (using self: *EditorFeatureProfile, class_name: StringName, disable: bool) {
}
EditorFeatureProfile_is_class_disabled :: (using self: *EditorFeatureProfile, class_name: StringName) -> bool {
}
EditorFeatureProfile_set_disable_class_editor :: (using self: *EditorFeatureProfile, class_name: StringName, disable: bool) {
}
EditorFeatureProfile_is_class_editor_disabled :: (using self: *EditorFeatureProfile, class_name: StringName) -> bool {
}
EditorFeatureProfile_set_disable_class_property :: (using self: *EditorFeatureProfile, class_name: StringName, property: StringName, disable: bool) {
}
EditorFeatureProfile_is_class_property_disabled :: (using self: *EditorFeatureProfile, class_name: StringName, property: StringName) -> bool {
}
EditorFeatureProfile_set_disable_feature :: (using self: *EditorFeatureProfile, feature: EditorFeatureProfile.Feature, disable: bool) {
}
EditorFeatureProfile_is_feature_disabled :: (using self: *EditorFeatureProfile, feature: EditorFeatureProfile.Feature) -> bool {
}
EditorFeatureProfile_get_feature_name :: (using self: *EditorFeatureProfile, feature: EditorFeatureProfile.Feature) -> String {
}
EditorFeatureProfile_save_to_file :: (using self: *EditorFeatureProfile, path: String) -> Error {
}
EditorFeatureProfile_load_from_file :: (using self: *EditorFeatureProfile, path: String) -> Error {
}

// EditorFileDialog
EditorFileDialog :: struct {
	__private: *void;

	FileMode :: enum {
		FILE_MODE_OPEN_FILE :: 0;
		FILE_MODE_OPEN_FILES :: 1;
		FILE_MODE_OPEN_DIR :: 2;
		FILE_MODE_OPEN_ANY :: 3;
		FILE_MODE_SAVE_FILE :: 4;
	}
	Access :: enum {
		ACCESS_RESOURCES :: 0;
		ACCESS_USERDATA :: 1;
		ACCESS_FILESYSTEM :: 2;
	}
	DisplayMode :: enum {
		DISPLAY_THUMBNAILS :: 0;
		DISPLAY_LIST :: 1;
	}
}

EditorFileDialog_clear_filters :: (using self: *EditorFileDialog) {
}
EditorFileDialog_add_filter :: (using self: *EditorFileDialog, filter: String, description: String) {
}
EditorFileDialog_set_filters :: (using self: *EditorFileDialog, filters: PackedStringArray) {
}
EditorFileDialog_get_filters :: (using self: *EditorFileDialog) -> PackedStringArray {
}
EditorFileDialog_get_option_name :: (using self: *EditorFileDialog, option: int) -> String {
}
EditorFileDialog_get_option_values :: (using self: *EditorFileDialog, option: int) -> PackedStringArray {
}
EditorFileDialog_get_option_default :: (using self: *EditorFileDialog, option: int) -> int {
}
EditorFileDialog_set_option_name :: (using self: *EditorFileDialog, option: int, name: String) {
}
EditorFileDialog_set_option_values :: (using self: *EditorFileDialog, option: int, values: PackedStringArray) {
}
EditorFileDialog_set_option_default :: (using self: *EditorFileDialog, option: int, default_value_index: int) {
}
EditorFileDialog_set_option_count :: (using self: *EditorFileDialog, count: int) {
}
EditorFileDialog_get_option_count :: (using self: *EditorFileDialog) -> int {
}
EditorFileDialog_add_option :: (using self: *EditorFileDialog, name: String, values: PackedStringArray, default_value_index: int) {
}
EditorFileDialog_get_selected_options :: (using self: *EditorFileDialog) -> Dictionary {
}
EditorFileDialog_get_current_dir :: (using self: *EditorFileDialog) -> String {
}
EditorFileDialog_get_current_file :: (using self: *EditorFileDialog) -> String {
}
EditorFileDialog_get_current_path :: (using self: *EditorFileDialog) -> String {
}
EditorFileDialog_set_current_dir :: (using self: *EditorFileDialog, dir: String) {
}
EditorFileDialog_set_current_file :: (using self: *EditorFileDialog, file: String) {
}
EditorFileDialog_set_current_path :: (using self: *EditorFileDialog, path: String) {
}
EditorFileDialog_set_file_mode :: (using self: *EditorFileDialog, mode: EditorFileDialog.FileMode) {
}
EditorFileDialog_get_file_mode :: (using self: *EditorFileDialog) -> EditorFileDialog.FileMode {
}
EditorFileDialog_get_vbox :: (using self: *EditorFileDialog) -> VBoxContainer {
}
EditorFileDialog_get_line_edit :: (using self: *EditorFileDialog) -> LineEdit {
}
EditorFileDialog_set_access :: (using self: *EditorFileDialog, access: EditorFileDialog.Access) {
}
EditorFileDialog_get_access :: (using self: *EditorFileDialog) -> EditorFileDialog.Access {
}
EditorFileDialog_set_show_hidden_files :: (using self: *EditorFileDialog, show: bool) {
}
EditorFileDialog_is_showing_hidden_files :: (using self: *EditorFileDialog) -> bool {
}
EditorFileDialog_set_display_mode :: (using self: *EditorFileDialog, mode: EditorFileDialog.DisplayMode) {
}
EditorFileDialog_get_display_mode :: (using self: *EditorFileDialog) -> EditorFileDialog.DisplayMode {
}
EditorFileDialog_set_disable_overwrite_warning :: (using self: *EditorFileDialog, disable: bool) {
}
EditorFileDialog_is_overwrite_warning_disabled :: (using self: *EditorFileDialog) -> bool {
}
EditorFileDialog_add_side_menu :: (using self: *EditorFileDialog, menu: Control, title: String) {
}
EditorFileDialog_popup_file_dialog :: (using self: *EditorFileDialog) {
}
EditorFileDialog_invalidate :: (using self: *EditorFileDialog) {
}

// EditorFileSystem
EditorFileSystem :: struct {
	__private: *void;
}

EditorFileSystem_get_filesystem :: (using self: *EditorFileSystem) -> EditorFileSystemDirectory {
}
EditorFileSystem_is_scanning :: (using self: *EditorFileSystem) -> bool {
}
EditorFileSystem_get_scanning_progress :: (using self: *EditorFileSystem) -> float {
}
EditorFileSystem_scan :: (using self: *EditorFileSystem) {
}
EditorFileSystem_scan_sources :: (using self: *EditorFileSystem) {
}
EditorFileSystem_update_file :: (using self: *EditorFileSystem, path: String) {
}
EditorFileSystem_get_filesystem_path :: (using self: *EditorFileSystem, path: String) -> EditorFileSystemDirectory {
}
EditorFileSystem_get_file_type :: (using self: *EditorFileSystem, path: String) -> String {
}
EditorFileSystem_reimport_files :: (using self: *EditorFileSystem, files: PackedStringArray) {
}

// EditorFileSystemDirectory
EditorFileSystemDirectory :: struct {
	__private: *void;
}

EditorFileSystemDirectory_get_subdir_count :: (using self: *EditorFileSystemDirectory) -> int {
}
EditorFileSystemDirectory_get_subdir :: (using self: *EditorFileSystemDirectory, idx: int) -> EditorFileSystemDirectory {
}
EditorFileSystemDirectory_get_file_count :: (using self: *EditorFileSystemDirectory) -> int {
}
EditorFileSystemDirectory_get_file :: (using self: *EditorFileSystemDirectory, idx: int) -> String {
}
EditorFileSystemDirectory_get_file_path :: (using self: *EditorFileSystemDirectory, idx: int) -> String {
}
EditorFileSystemDirectory_get_file_type :: (using self: *EditorFileSystemDirectory, idx: int) -> StringName {
}
EditorFileSystemDirectory_get_file_script_class_name :: (using self: *EditorFileSystemDirectory, idx: int) -> String {
}
EditorFileSystemDirectory_get_file_script_class_extends :: (using self: *EditorFileSystemDirectory, idx: int) -> String {
}
EditorFileSystemDirectory_get_file_import_is_valid :: (using self: *EditorFileSystemDirectory, idx: int) -> bool {
}
EditorFileSystemDirectory_get_name :: (using self: *EditorFileSystemDirectory) -> String {
}
EditorFileSystemDirectory_get_path :: (using self: *EditorFileSystemDirectory) -> String {
}
EditorFileSystemDirectory_get_parent :: (using self: *EditorFileSystemDirectory) -> EditorFileSystemDirectory {
}
EditorFileSystemDirectory_find_file_index :: (using self: *EditorFileSystemDirectory, name: String) -> int {
}
EditorFileSystemDirectory_find_dir_index :: (using self: *EditorFileSystemDirectory, name: String) -> int {
}

// EditorFileSystemImportFormatSupportQuery
EditorFileSystemImportFormatSupportQuery :: struct {
	__private: *void;
}

EditorFileSystemImportFormatSupportQuery__is_active :: (using self: *EditorFileSystemImportFormatSupportQuery) -> bool {
}
EditorFileSystemImportFormatSupportQuery__get_file_extensions :: (using self: *EditorFileSystemImportFormatSupportQuery) -> PackedStringArray {
}
EditorFileSystemImportFormatSupportQuery__query :: (using self: *EditorFileSystemImportFormatSupportQuery) -> bool {
}

// EditorImportPlugin
EditorImportPlugin :: struct {
	__private: *void;
}

EditorImportPlugin__get_importer_name :: (using self: *EditorImportPlugin) -> String {
}
EditorImportPlugin__get_visible_name :: (using self: *EditorImportPlugin) -> String {
}
EditorImportPlugin__get_preset_count :: (using self: *EditorImportPlugin) -> int {
}
EditorImportPlugin__get_preset_name :: (using self: *EditorImportPlugin, preset_index: int) -> String {
}
EditorImportPlugin__get_recognized_extensions :: (using self: *EditorImportPlugin) -> PackedStringArray {
}
EditorImportPlugin__get_import_options :: (using self: *EditorImportPlugin, path: String, preset_index: int) -> Dictionary {
}
EditorImportPlugin__get_save_extension :: (using self: *EditorImportPlugin) -> String {
}
EditorImportPlugin__get_resource_type :: (using self: *EditorImportPlugin) -> String {
}
EditorImportPlugin__get_priority :: (using self: *EditorImportPlugin) -> float {
}
EditorImportPlugin__get_import_order :: (using self: *EditorImportPlugin) -> int {
}
EditorImportPlugin__get_option_visibility :: (using self: *EditorImportPlugin, path: String, option_name: StringName, options: Dictionary) -> bool {
}
EditorImportPlugin__import :: (using self: *EditorImportPlugin, source_file: String, save_path: String, options: Dictionary, platform_variants: Array, gen_files: Array) -> Error {
}
EditorImportPlugin__can_import_threaded :: (using self: *EditorImportPlugin) -> bool {
}
EditorImportPlugin_append_import_external_resource :: (using self: *EditorImportPlugin, path: String, custom_options: Dictionary, custom_importer: String, generator_parameters: Variant) -> Error {
}

// EditorInspector
EditorInspector :: struct {
	__private: *void;
}

EditorInspector_get_selected_path :: (using self: *EditorInspector) -> String {
}
EditorInspector_get_edited_object :: (using self: *EditorInspector) -> Object {
}

// EditorInspectorPlugin
EditorInspectorPlugin :: struct {
	__private: *void;
}

EditorInspectorPlugin__can_handle :: (using self: *EditorInspectorPlugin, object: Object) -> bool {
}
EditorInspectorPlugin__parse_begin :: (using self: *EditorInspectorPlugin, object: Object) {
}
EditorInspectorPlugin__parse_category :: (using self: *EditorInspectorPlugin, object: Object, category: String) {
}
EditorInspectorPlugin__parse_group :: (using self: *EditorInspectorPlugin, object: Object, group: String) {
}
EditorInspectorPlugin__parse_property :: (using self: *EditorInspectorPlugin, object: Object, type: VariantType, name: String, hint_type: PropertyHint, hint_string: String, usage_flags: PropertyUsageFlags, wide: bool) -> bool {
}
EditorInspectorPlugin__parse_end :: (using self: *EditorInspectorPlugin, object: Object) {
}
EditorInspectorPlugin_add_custom_control :: (using self: *EditorInspectorPlugin, control: Control) {
}
EditorInspectorPlugin_add_property_editor :: (using self: *EditorInspectorPlugin, property: String, editor: Control, add_to_end: bool, label: String) {
}
EditorInspectorPlugin_add_property_editor_for_multiple_properties :: (using self: *EditorInspectorPlugin, label: String, properties: PackedStringArray, editor: Control) {
}

// EditorInterface
EditorInterface :: struct {
	__private: *void;
}

EditorInterface_restart_editor :: (using self: *EditorInterface, save: bool) {
}
EditorInterface_get_command_palette :: (using self: *EditorInterface) -> EditorCommandPalette {
}
EditorInterface_get_resource_filesystem :: (using self: *EditorInterface) -> EditorFileSystem {
}
EditorInterface_get_editor_paths :: (using self: *EditorInterface) -> EditorPaths {
}
EditorInterface_get_resource_previewer :: (using self: *EditorInterface) -> EditorResourcePreview {
}
EditorInterface_get_selection :: (using self: *EditorInterface) -> EditorSelection {
}
EditorInterface_get_editor_settings :: (using self: *EditorInterface) -> EditorSettings {
}
EditorInterface_make_mesh_previews :: (using self: *EditorInterface, meshes: Array, preview_size: int) -> Array {
}
EditorInterface_set_plugin_enabled :: (using self: *EditorInterface, plugin: String, enabled: bool) {
}
EditorInterface_is_plugin_enabled :: (using self: *EditorInterface, plugin: String) -> bool {
}
EditorInterface_get_editor_theme :: (using self: *EditorInterface) -> Theme {
}
EditorInterface_get_base_control :: (using self: *EditorInterface) -> Control {
}
EditorInterface_get_editor_main_screen :: (using self: *EditorInterface) -> VBoxContainer {
}
EditorInterface_get_script_editor :: (using self: *EditorInterface) -> ScriptEditor {
}
EditorInterface_get_editor_viewport_2d :: (using self: *EditorInterface) -> SubViewport {
}
EditorInterface_get_editor_viewport_3d :: (using self: *EditorInterface, idx: int) -> SubViewport {
}
EditorInterface_set_main_screen_editor :: (using self: *EditorInterface, name: String) {
}
EditorInterface_set_distraction_free_mode :: (using self: *EditorInterface, enter: bool) {
}
EditorInterface_is_distraction_free_mode_enabled :: (using self: *EditorInterface) -> bool {
}
EditorInterface_is_multi_window_enabled :: (using self: *EditorInterface) -> bool {
}
EditorInterface_get_editor_scale :: (using self: *EditorInterface) -> float {
}
EditorInterface_popup_dialog :: (using self: *EditorInterface, dialog: Window, rect: Rect2i) {
}
EditorInterface_popup_dialog_centered :: (using self: *EditorInterface, dialog: Window, minsize: Vector2i) {
}
EditorInterface_popup_dialog_centered_ratio :: (using self: *EditorInterface, dialog: Window, ratio: float) {
}
EditorInterface_popup_dialog_centered_clamped :: (using self: *EditorInterface, dialog: Window, minsize: Vector2i, fallback_ratio: float) {
}
EditorInterface_get_current_feature_profile :: (using self: *EditorInterface) -> String {
}
EditorInterface_set_current_feature_profile :: (using self: *EditorInterface, profile_name: String) {
}
EditorInterface_popup_node_selector :: (using self: *EditorInterface, callback: Callable, valid_types: Array) {
}
EditorInterface_popup_property_selector :: (using self: *EditorInterface, object: Object, callback: Callable, type_filter: PackedInt32Array) {
}
EditorInterface_get_file_system_dock :: (using self: *EditorInterface) -> FileSystemDock {
}
EditorInterface_select_file :: (using self: *EditorInterface, file: String) {
}
EditorInterface_get_selected_paths :: (using self: *EditorInterface) -> PackedStringArray {
}
EditorInterface_get_current_path :: (using self: *EditorInterface) -> String {
}
EditorInterface_get_current_directory :: (using self: *EditorInterface) -> String {
}
EditorInterface_get_inspector :: (using self: *EditorInterface) -> EditorInspector {
}
EditorInterface_inspect_object :: (using self: *EditorInterface, object: Object, for_property: String, inspector_only: bool) {
}
EditorInterface_edit_resource :: (using self: *EditorInterface, resource: Resource) {
}
EditorInterface_edit_node :: (using self: *EditorInterface, node: Node) {
}
EditorInterface_edit_script :: (using self: *EditorInterface, script: Script, line: int, column: int, grab_focus: bool) {
}
EditorInterface_open_scene_from_path :: (using self: *EditorInterface, scene_filepath: String) {
}
EditorInterface_reload_scene_from_path :: (using self: *EditorInterface, scene_filepath: String) {
}
EditorInterface_get_open_scenes :: (using self: *EditorInterface) -> PackedStringArray {
}
EditorInterface_get_edited_scene_root :: (using self: *EditorInterface) -> Node {
}
EditorInterface_save_scene :: (using self: *EditorInterface) -> Error {
}
EditorInterface_save_scene_as :: (using self: *EditorInterface, path: String, with_preview: bool) {
}
EditorInterface_save_all_scenes :: (using self: *EditorInterface) {
}
EditorInterface_mark_scene_as_unsaved :: (using self: *EditorInterface) {
}
EditorInterface_play_main_scene :: (using self: *EditorInterface) {
}
EditorInterface_play_current_scene :: (using self: *EditorInterface) {
}
EditorInterface_play_custom_scene :: (using self: *EditorInterface, scene_filepath: String) {
}
EditorInterface_stop_playing_scene :: (using self: *EditorInterface) {
}
EditorInterface_is_playing_scene :: (using self: *EditorInterface) -> bool {
}
EditorInterface_get_playing_scene :: (using self: *EditorInterface) -> String {
}
EditorInterface_set_movie_maker_enabled :: (using self: *EditorInterface, enabled: bool) {
}
EditorInterface_is_movie_maker_enabled :: (using self: *EditorInterface) -> bool {
}

// EditorNode3DGizmo
EditorNode3DGizmo :: struct {
	__private: *void;
}

EditorNode3DGizmo__redraw :: (using self: *EditorNode3DGizmo) {
}
EditorNode3DGizmo__get_handle_name :: (using self: *EditorNode3DGizmo, id: int, secondary: bool) -> String {
}
EditorNode3DGizmo__is_handle_highlighted :: (using self: *EditorNode3DGizmo, id: int, secondary: bool) -> bool {
}
EditorNode3DGizmo__get_handle_value :: (using self: *EditorNode3DGizmo, id: int, secondary: bool) -> Variant {
}
EditorNode3DGizmo__begin_handle_action :: (using self: *EditorNode3DGizmo, id: int, secondary: bool) {
}
EditorNode3DGizmo__set_handle :: (using self: *EditorNode3DGizmo, id: int, secondary: bool, camera: Camera3D, point: Vector2) {
}
EditorNode3DGizmo__commit_handle :: (using self: *EditorNode3DGizmo, id: int, secondary: bool, restore: Variant, cancel: bool) {
}
EditorNode3DGizmo__subgizmos_intersect_ray :: (using self: *EditorNode3DGizmo, camera: Camera3D, point: Vector2) -> int {
}
EditorNode3DGizmo__subgizmos_intersect_frustum :: (using self: *EditorNode3DGizmo, camera: Camera3D, frustum: Array) -> PackedInt32Array {
}
EditorNode3DGizmo__set_subgizmo_transform :: (using self: *EditorNode3DGizmo, id: int, transform: Transform3D) {
}
EditorNode3DGizmo__get_subgizmo_transform :: (using self: *EditorNode3DGizmo, id: int) -> Transform3D {
}
EditorNode3DGizmo__commit_subgizmos :: (using self: *EditorNode3DGizmo, ids: PackedInt32Array, restores: Array, cancel: bool) {
}
EditorNode3DGizmo_add_lines :: (using self: *EditorNode3DGizmo, lines: PackedVector3Array, material: Material, billboard: bool, modulate: Color) {
}
EditorNode3DGizmo_add_mesh :: (using self: *EditorNode3DGizmo, mesh: Mesh, material: Material, transform: Transform3D, skeleton: SkinReference) {
}
EditorNode3DGizmo_add_collision_segments :: (using self: *EditorNode3DGizmo, segments: PackedVector3Array) {
}
EditorNode3DGizmo_add_collision_triangles :: (using self: *EditorNode3DGizmo, triangles: TriangleMesh) {
}
EditorNode3DGizmo_add_unscaled_billboard :: (using self: *EditorNode3DGizmo, material: Material, default_scale: float, modulate: Color) {
}
EditorNode3DGizmo_add_handles :: (using self: *EditorNode3DGizmo, handles: PackedVector3Array, material: Material, ids: PackedInt32Array, billboard: bool, secondary: bool) {
}
EditorNode3DGizmo_set_node_3d :: (using self: *EditorNode3DGizmo, node: Node) {
}
EditorNode3DGizmo_get_node_3d :: (using self: *EditorNode3DGizmo) -> Node3D {
}
EditorNode3DGizmo_get_plugin :: (using self: *EditorNode3DGizmo) -> EditorNode3DGizmoPlugin {
}
EditorNode3DGizmo_clear :: (using self: *EditorNode3DGizmo) {
}
EditorNode3DGizmo_set_hidden :: (using self: *EditorNode3DGizmo, hidden: bool) {
}
EditorNode3DGizmo_is_subgizmo_selected :: (using self: *EditorNode3DGizmo, id: int) -> bool {
}
EditorNode3DGizmo_get_subgizmo_selection :: (using self: *EditorNode3DGizmo) -> PackedInt32Array {
}

// EditorNode3DGizmoPlugin
EditorNode3DGizmoPlugin :: struct {
	__private: *void;
}

EditorNode3DGizmoPlugin__has_gizmo :: (using self: *EditorNode3DGizmoPlugin, for_node_3d: Node3D) -> bool {
}
EditorNode3DGizmoPlugin__create_gizmo :: (using self: *EditorNode3DGizmoPlugin, for_node_3d: Node3D) -> EditorNode3DGizmo {
}
EditorNode3DGizmoPlugin__get_gizmo_name :: (using self: *EditorNode3DGizmoPlugin) -> String {
}
EditorNode3DGizmoPlugin__get_priority :: (using self: *EditorNode3DGizmoPlugin) -> int {
}
EditorNode3DGizmoPlugin__can_be_hidden :: (using self: *EditorNode3DGizmoPlugin) -> bool {
}
EditorNode3DGizmoPlugin__is_selectable_when_hidden :: (using self: *EditorNode3DGizmoPlugin) -> bool {
}
EditorNode3DGizmoPlugin__redraw :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo) {
}
EditorNode3DGizmoPlugin__get_handle_name :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo, handle_id: int, secondary: bool) -> String {
}
EditorNode3DGizmoPlugin__is_handle_highlighted :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo, handle_id: int, secondary: bool) -> bool {
}
EditorNode3DGizmoPlugin__get_handle_value :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo, handle_id: int, secondary: bool) -> Variant {
}
EditorNode3DGizmoPlugin__begin_handle_action :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo, handle_id: int, secondary: bool) {
}
EditorNode3DGizmoPlugin__set_handle :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo, handle_id: int, secondary: bool, camera: Camera3D, screen_pos: Vector2) {
}
EditorNode3DGizmoPlugin__commit_handle :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo, handle_id: int, secondary: bool, restore: Variant, cancel: bool) {
}
EditorNode3DGizmoPlugin__subgizmos_intersect_ray :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo, camera: Camera3D, screen_pos: Vector2) -> int {
}
EditorNode3DGizmoPlugin__subgizmos_intersect_frustum :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo, camera: Camera3D, frustum_planes: Array) -> PackedInt32Array {
}
EditorNode3DGizmoPlugin__get_subgizmo_transform :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo, subgizmo_id: int) -> Transform3D {
}
EditorNode3DGizmoPlugin__set_subgizmo_transform :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo, subgizmo_id: int, transform: Transform3D) {
}
EditorNode3DGizmoPlugin__commit_subgizmos :: (using self: *EditorNode3DGizmoPlugin, gizmo: EditorNode3DGizmo, ids: PackedInt32Array, restores: Array, cancel: bool) {
}
EditorNode3DGizmoPlugin_create_material :: (using self: *EditorNode3DGizmoPlugin, name: String, color: Color, billboard: bool, on_top: bool, use_vertex_color: bool) {
}
EditorNode3DGizmoPlugin_create_icon_material :: (using self: *EditorNode3DGizmoPlugin, name: String, texture: Texture2D, on_top: bool, color: Color) {
}
EditorNode3DGizmoPlugin_create_handle_material :: (using self: *EditorNode3DGizmoPlugin, name: String, billboard: bool, texture: Texture2D) {
}
EditorNode3DGizmoPlugin_add_material :: (using self: *EditorNode3DGizmoPlugin, name: String, material: StandardMaterial3D) {
}
EditorNode3DGizmoPlugin_get_material :: (using self: *EditorNode3DGizmoPlugin, name: String, gizmo: EditorNode3DGizmo) -> StandardMaterial3D {
}

// EditorPaths
EditorPaths :: struct {
	__private: *void;
}

EditorPaths_get_data_dir :: (using self: *EditorPaths) -> String {
}
EditorPaths_get_config_dir :: (using self: *EditorPaths) -> String {
}
EditorPaths_get_cache_dir :: (using self: *EditorPaths) -> String {
}
EditorPaths_is_self_contained :: (using self: *EditorPaths) -> bool {
}
EditorPaths_get_self_contained_file :: (using self: *EditorPaths) -> String {
}
EditorPaths_get_project_settings_dir :: (using self: *EditorPaths) -> String {
}

// EditorPlugin
EditorPlugin :: struct {
	__private: *void;

	CustomControlContainer :: enum {
		CONTAINER_TOOLBAR :: 0;
		CONTAINER_SPATIAL_EDITOR_MENU :: 1;
		CONTAINER_SPATIAL_EDITOR_SIDE_LEFT :: 2;
		CONTAINER_SPATIAL_EDITOR_SIDE_RIGHT :: 3;
		CONTAINER_SPATIAL_EDITOR_BOTTOM :: 4;
		CONTAINER_CANVAS_EDITOR_MENU :: 5;
		CONTAINER_CANVAS_EDITOR_SIDE_LEFT :: 6;
		CONTAINER_CANVAS_EDITOR_SIDE_RIGHT :: 7;
		CONTAINER_CANVAS_EDITOR_BOTTOM :: 8;
		CONTAINER_INSPECTOR_BOTTOM :: 9;
		CONTAINER_PROJECT_SETTING_TAB_LEFT :: 10;
		CONTAINER_PROJECT_SETTING_TAB_RIGHT :: 11;
	}
	DockSlot :: enum {
		DOCK_SLOT_LEFT_UL :: 0;
		DOCK_SLOT_LEFT_BL :: 1;
		DOCK_SLOT_LEFT_UR :: 2;
		DOCK_SLOT_LEFT_BR :: 3;
		DOCK_SLOT_RIGHT_UL :: 4;
		DOCK_SLOT_RIGHT_BL :: 5;
		DOCK_SLOT_RIGHT_UR :: 6;
		DOCK_SLOT_RIGHT_BR :: 7;
		DOCK_SLOT_MAX :: 8;
	}
	AfterGUIInput :: enum {
		AFTER_GUI_INPUT_PASS :: 0;
		AFTER_GUI_INPUT_STOP :: 1;
		AFTER_GUI_INPUT_CUSTOM :: 2;
	}
}

EditorPlugin__forward_canvas_gui_input :: (using self: *EditorPlugin, event: InputEvent) -> bool {
}
EditorPlugin__forward_canvas_draw_over_viewport :: (using self: *EditorPlugin, viewport_control: Control) {
}
EditorPlugin__forward_canvas_force_draw_over_viewport :: (using self: *EditorPlugin, viewport_control: Control) {
}
EditorPlugin__forward_3d_gui_input :: (using self: *EditorPlugin, viewport_camera: Camera3D, event: InputEvent) -> int {
}
EditorPlugin__forward_3d_draw_over_viewport :: (using self: *EditorPlugin, viewport_control: Control) {
}
EditorPlugin__forward_3d_force_draw_over_viewport :: (using self: *EditorPlugin, viewport_control: Control) {
}
EditorPlugin__get_plugin_name :: (using self: *EditorPlugin) -> String {
}
EditorPlugin__get_plugin_icon :: (using self: *EditorPlugin) -> Texture2D {
}
EditorPlugin__has_main_screen :: (using self: *EditorPlugin) -> bool {
}
EditorPlugin__make_visible :: (using self: *EditorPlugin, visible: bool) {
}
EditorPlugin__edit :: (using self: *EditorPlugin, object: Object) {
}
EditorPlugin__handles :: (using self: *EditorPlugin, object: Object) -> bool {
}
EditorPlugin__get_state :: (using self: *EditorPlugin) -> Dictionary {
}
EditorPlugin__set_state :: (using self: *EditorPlugin, state: Dictionary) {
}
EditorPlugin__clear :: (using self: *EditorPlugin) {
}
EditorPlugin__get_unsaved_status :: (using self: *EditorPlugin, for_scene: String) -> String {
}
EditorPlugin__save_external_data :: (using self: *EditorPlugin) {
}
EditorPlugin__apply_changes :: (using self: *EditorPlugin) {
}
EditorPlugin__get_breakpoints :: (using self: *EditorPlugin) -> PackedStringArray {
}
EditorPlugin__set_window_layout :: (using self: *EditorPlugin, configuration: ConfigFile) {
}
EditorPlugin__get_window_layout :: (using self: *EditorPlugin, configuration: ConfigFile) {
}
EditorPlugin__build :: (using self: *EditorPlugin) -> bool {
}
EditorPlugin__enable_plugin :: (using self: *EditorPlugin) {
}
EditorPlugin__disable_plugin :: (using self: *EditorPlugin) {
}
EditorPlugin_add_control_to_container :: (using self: *EditorPlugin, container: EditorPlugin.CustomControlContainer, control: Control) {
}
EditorPlugin_add_control_to_bottom_panel :: (using self: *EditorPlugin, control: Control, title: String, shortcut: Shortcut) -> Button {
}
EditorPlugin_add_control_to_dock :: (using self: *EditorPlugin, slot: EditorPlugin.DockSlot, control: Control, shortcut: Shortcut) {
}
EditorPlugin_remove_control_from_docks :: (using self: *EditorPlugin, control: Control) {
}
EditorPlugin_remove_control_from_bottom_panel :: (using self: *EditorPlugin, control: Control) {
}
EditorPlugin_remove_control_from_container :: (using self: *EditorPlugin, container: EditorPlugin.CustomControlContainer, control: Control) {
}
EditorPlugin_set_dock_tab_icon :: (using self: *EditorPlugin, control: Control, icon: Texture2D) {
}
EditorPlugin_add_tool_menu_item :: (using self: *EditorPlugin, name: String, callable: Callable) {
}
EditorPlugin_add_tool_submenu_item :: (using self: *EditorPlugin, name: String, submenu: PopupMenu) {
}
EditorPlugin_remove_tool_menu_item :: (using self: *EditorPlugin, name: String) {
}
EditorPlugin_get_export_as_menu :: (using self: *EditorPlugin) -> PopupMenu {
}
EditorPlugin_add_custom_type :: (using self: *EditorPlugin, type: String, base: String, script: Script, icon: Texture2D) {
}
EditorPlugin_remove_custom_type :: (using self: *EditorPlugin, type: String) {
}
EditorPlugin_add_autoload_singleton :: (using self: *EditorPlugin, name: String, path: String) {
}
EditorPlugin_remove_autoload_singleton :: (using self: *EditorPlugin, name: String) {
}
EditorPlugin_update_overlays :: (using self: *EditorPlugin) -> int {
}
EditorPlugin_make_bottom_panel_item_visible :: (using self: *EditorPlugin, item: Control) {
}
EditorPlugin_hide_bottom_panel :: (using self: *EditorPlugin) {
}
EditorPlugin_get_undo_redo :: (using self: *EditorPlugin) -> EditorUndoRedoManager {
}
EditorPlugin_add_undo_redo_inspector_hook_callback :: (using self: *EditorPlugin, callable: Callable) {
}
EditorPlugin_remove_undo_redo_inspector_hook_callback :: (using self: *EditorPlugin, callable: Callable) {
}
EditorPlugin_queue_save_layout :: (using self: *EditorPlugin) {
}
EditorPlugin_add_translation_parser_plugin :: (using self: *EditorPlugin, parser: EditorTranslationParserPlugin) {
}
EditorPlugin_remove_translation_parser_plugin :: (using self: *EditorPlugin, parser: EditorTranslationParserPlugin) {
}
EditorPlugin_add_import_plugin :: (using self: *EditorPlugin, importer: EditorImportPlugin, first_priority: bool) {
}
EditorPlugin_remove_import_plugin :: (using self: *EditorPlugin, importer: EditorImportPlugin) {
}
EditorPlugin_add_scene_format_importer_plugin :: (using self: *EditorPlugin, scene_format_importer: EditorSceneFormatImporter, first_priority: bool) {
}
EditorPlugin_remove_scene_format_importer_plugin :: (using self: *EditorPlugin, scene_format_importer: EditorSceneFormatImporter) {
}
EditorPlugin_add_scene_post_import_plugin :: (using self: *EditorPlugin, scene_import_plugin: EditorScenePostImportPlugin, first_priority: bool) {
}
EditorPlugin_remove_scene_post_import_plugin :: (using self: *EditorPlugin, scene_import_plugin: EditorScenePostImportPlugin) {
}
EditorPlugin_add_export_plugin :: (using self: *EditorPlugin, plugin: EditorExportPlugin) {
}
EditorPlugin_remove_export_plugin :: (using self: *EditorPlugin, plugin: EditorExportPlugin) {
}
EditorPlugin_add_node_3d_gizmo_plugin :: (using self: *EditorPlugin, plugin: EditorNode3DGizmoPlugin) {
}
EditorPlugin_remove_node_3d_gizmo_plugin :: (using self: *EditorPlugin, plugin: EditorNode3DGizmoPlugin) {
}
EditorPlugin_add_inspector_plugin :: (using self: *EditorPlugin, plugin: EditorInspectorPlugin) {
}
EditorPlugin_remove_inspector_plugin :: (using self: *EditorPlugin, plugin: EditorInspectorPlugin) {
}
EditorPlugin_add_resource_conversion_plugin :: (using self: *EditorPlugin, plugin: EditorResourceConversionPlugin) {
}
EditorPlugin_remove_resource_conversion_plugin :: (using self: *EditorPlugin, plugin: EditorResourceConversionPlugin) {
}
EditorPlugin_set_input_event_forwarding_always_enabled :: (using self: *EditorPlugin) {
}
EditorPlugin_set_force_draw_over_forwarding_enabled :: (using self: *EditorPlugin) {
}
EditorPlugin_get_editor_interface :: (using self: *EditorPlugin) -> EditorInterface {
}
EditorPlugin_get_script_create_dialog :: (using self: *EditorPlugin) -> ScriptCreateDialog {
}
EditorPlugin_add_debugger_plugin :: (using self: *EditorPlugin, script: EditorDebuggerPlugin) {
}
EditorPlugin_remove_debugger_plugin :: (using self: *EditorPlugin, script: EditorDebuggerPlugin) {
}
EditorPlugin_get_plugin_version :: (using self: *EditorPlugin) -> String {
}

// EditorProperty
EditorProperty :: struct {
	__private: *void;
}

EditorProperty__update_property :: (using self: *EditorProperty) {
}
EditorProperty__set_read_only :: (using self: *EditorProperty, read_only: bool) {
}
EditorProperty_set_label :: (using self: *EditorProperty, text: String) {
}
EditorProperty_get_label :: (using self: *EditorProperty) -> String {
}
EditorProperty_set_read_only :: (using self: *EditorProperty, read_only: bool) {
}
EditorProperty_is_read_only :: (using self: *EditorProperty) -> bool {
}
EditorProperty_set_checkable :: (using self: *EditorProperty, checkable: bool) {
}
EditorProperty_is_checkable :: (using self: *EditorProperty) -> bool {
}
EditorProperty_set_checked :: (using self: *EditorProperty, checked: bool) {
}
EditorProperty_is_checked :: (using self: *EditorProperty) -> bool {
}
EditorProperty_set_draw_warning :: (using self: *EditorProperty, draw_warning: bool) {
}
EditorProperty_is_draw_warning :: (using self: *EditorProperty) -> bool {
}
EditorProperty_set_keying :: (using self: *EditorProperty, keying: bool) {
}
EditorProperty_is_keying :: (using self: *EditorProperty) -> bool {
}
EditorProperty_set_deletable :: (using self: *EditorProperty, deletable: bool) {
}
EditorProperty_is_deletable :: (using self: *EditorProperty) -> bool {
}
EditorProperty_get_edited_property :: (using self: *EditorProperty) -> StringName {
}
EditorProperty_get_edited_object :: (using self: *EditorProperty) -> Object {
}
EditorProperty_update_property :: (using self: *EditorProperty) {
}
EditorProperty_add_focusable :: (using self: *EditorProperty, control: Control) {
}
EditorProperty_set_bottom_editor :: (using self: *EditorProperty, editor: Control) {
}
EditorProperty_emit_changed :: (using self: *EditorProperty, property: StringName, value: Variant, field: StringName, changing: bool) {
}

// EditorResourceConversionPlugin
EditorResourceConversionPlugin :: struct {
	__private: *void;
}

EditorResourceConversionPlugin__converts_to :: (using self: *EditorResourceConversionPlugin) -> String {
}
EditorResourceConversionPlugin__handles :: (using self: *EditorResourceConversionPlugin, resource: Resource) -> bool {
}
EditorResourceConversionPlugin__convert :: (using self: *EditorResourceConversionPlugin, resource: Resource) -> Resource {
}

// EditorResourcePicker
EditorResourcePicker :: struct {
	__private: *void;
}

EditorResourcePicker__set_create_options :: (using self: *EditorResourcePicker, menu_node: Object) {
}
EditorResourcePicker__handle_menu_selected :: (using self: *EditorResourcePicker, id: int) -> bool {
}
EditorResourcePicker_set_base_type :: (using self: *EditorResourcePicker, base_type: String) {
}
EditorResourcePicker_get_base_type :: (using self: *EditorResourcePicker) -> String {
}
EditorResourcePicker_get_allowed_types :: (using self: *EditorResourcePicker) -> PackedStringArray {
}
EditorResourcePicker_set_edited_resource :: (using self: *EditorResourcePicker, resource: Resource) {
}
EditorResourcePicker_get_edited_resource :: (using self: *EditorResourcePicker) -> Resource {
}
EditorResourcePicker_set_toggle_mode :: (using self: *EditorResourcePicker, enable: bool) {
}
EditorResourcePicker_is_toggle_mode :: (using self: *EditorResourcePicker) -> bool {
}
EditorResourcePicker_set_toggle_pressed :: (using self: *EditorResourcePicker, pressed: bool) {
}
EditorResourcePicker_set_editable :: (using self: *EditorResourcePicker, enable: bool) {
}
EditorResourcePicker_is_editable :: (using self: *EditorResourcePicker) -> bool {
}

// EditorResourcePreview
EditorResourcePreview :: struct {
	__private: *void;
}

EditorResourcePreview_queue_resource_preview :: (using self: *EditorResourcePreview, path: String, receiver: Object, receiver_func: StringName, userdata: Variant) {
}
EditorResourcePreview_queue_edited_resource_preview :: (using self: *EditorResourcePreview, resource: Resource, receiver: Object, receiver_func: StringName, userdata: Variant) {
}
EditorResourcePreview_add_preview_generator :: (using self: *EditorResourcePreview, generator: EditorResourcePreviewGenerator) {
}
EditorResourcePreview_remove_preview_generator :: (using self: *EditorResourcePreview, generator: EditorResourcePreviewGenerator) {
}
EditorResourcePreview_check_for_invalidation :: (using self: *EditorResourcePreview, path: String) {
}

// EditorResourcePreviewGenerator
EditorResourcePreviewGenerator :: struct {
	__private: *void;
}

EditorResourcePreviewGenerator__handles :: (using self: *EditorResourcePreviewGenerator, type: String) -> bool {
}
EditorResourcePreviewGenerator__generate :: (using self: *EditorResourcePreviewGenerator, resource: Resource, size: Vector2i, metadata: Dictionary) -> Texture2D {
}
EditorResourcePreviewGenerator__generate_from_path :: (using self: *EditorResourcePreviewGenerator, path: String, size: Vector2i, metadata: Dictionary) -> Texture2D {
}
EditorResourcePreviewGenerator__generate_small_preview_automatically :: (using self: *EditorResourcePreviewGenerator) -> bool {
}
EditorResourcePreviewGenerator__can_generate_small_preview :: (using self: *EditorResourcePreviewGenerator) -> bool {
}

// EditorResourceTooltipPlugin
EditorResourceTooltipPlugin :: struct {
	__private: *void;
}

EditorResourceTooltipPlugin__handles :: (using self: *EditorResourceTooltipPlugin, type: String) -> bool {
}
EditorResourceTooltipPlugin__make_tooltip_for_path :: (using self: *EditorResourceTooltipPlugin, path: String, metadata: Dictionary, base: Control) -> Control {
}
EditorResourceTooltipPlugin_request_thumbnail :: (using self: *EditorResourceTooltipPlugin, path: String, control: TextureRect) {
}

// EditorSceneFormatImporter
EditorSceneFormatImporter :: struct {
	__private: *void;

	IMPORT_SCENE :: 1;
	IMPORT_ANIMATION :: 2;
	IMPORT_FAIL_ON_MISSING_DEPENDENCIES :: 4;
	IMPORT_GENERATE_TANGENT_ARRAYS :: 8;
	IMPORT_USE_NAMED_SKIN_BINDS :: 16;
	IMPORT_DISCARD_MESHES_AND_MATERIALS :: 32;
	IMPORT_FORCE_DISABLE_MESH_COMPRESSION :: 64;
}

EditorSceneFormatImporter__get_import_flags :: (using self: *EditorSceneFormatImporter) -> int {
}
EditorSceneFormatImporter__get_extensions :: (using self: *EditorSceneFormatImporter) -> PackedStringArray {
}
EditorSceneFormatImporter__import_scene :: (using self: *EditorSceneFormatImporter, path: String, flags: int, options: Dictionary) -> Object {
}
EditorSceneFormatImporter__get_import_options :: (using self: *EditorSceneFormatImporter, path: String) {
}
EditorSceneFormatImporter__get_option_visibility :: (using self: *EditorSceneFormatImporter, path: String, for_animation: bool, option: String) -> Variant {
}

// EditorSceneFormatImporterBlend
EditorSceneFormatImporterBlend :: struct {
	__private: *void;
}

// EditorSceneFormatImporterFBX2GLTF
EditorSceneFormatImporterFBX2GLTF :: struct {
	__private: *void;
}

// EditorSceneFormatImporterGLTF
EditorSceneFormatImporterGLTF :: struct {
	__private: *void;
}

// EditorSceneFormatImporterUFBX
EditorSceneFormatImporterUFBX :: struct {
	__private: *void;
}

// EditorScenePostImport
EditorScenePostImport :: struct {
	__private: *void;
}

EditorScenePostImport__post_import :: (using self: *EditorScenePostImport, scene: Node) -> Object {
}
EditorScenePostImport_get_source_file :: (using self: *EditorScenePostImport) -> String {
}

// EditorScenePostImportPlugin
EditorScenePostImportPlugin :: struct {
	__private: *void;

	InternalImportCategory :: enum {
		INTERNAL_IMPORT_CATEGORY_NODE :: 0;
		INTERNAL_IMPORT_CATEGORY_MESH_3D_NODE :: 1;
		INTERNAL_IMPORT_CATEGORY_MESH :: 2;
		INTERNAL_IMPORT_CATEGORY_MATERIAL :: 3;
		INTERNAL_IMPORT_CATEGORY_ANIMATION :: 4;
		INTERNAL_IMPORT_CATEGORY_ANIMATION_NODE :: 5;
		INTERNAL_IMPORT_CATEGORY_SKELETON_3D_NODE :: 6;
		INTERNAL_IMPORT_CATEGORY_MAX :: 7;
	}
}

EditorScenePostImportPlugin__get_internal_import_options :: (using self: *EditorScenePostImportPlugin, category: int) {
}
EditorScenePostImportPlugin__get_internal_option_visibility :: (using self: *EditorScenePostImportPlugin, category: int, for_animation: bool, option: String) -> Variant {
}
EditorScenePostImportPlugin__get_internal_option_update_view_required :: (using self: *EditorScenePostImportPlugin, category: int, option: String) -> Variant {
}
EditorScenePostImportPlugin__internal_process :: (using self: *EditorScenePostImportPlugin, category: int, base_node: Node, node: Node, resource: Resource) {
}
EditorScenePostImportPlugin__get_import_options :: (using self: *EditorScenePostImportPlugin, path: String) {
}
EditorScenePostImportPlugin__get_option_visibility :: (using self: *EditorScenePostImportPlugin, path: String, for_animation: bool, option: String) -> Variant {
}
EditorScenePostImportPlugin__pre_process :: (using self: *EditorScenePostImportPlugin, scene: Node) {
}
EditorScenePostImportPlugin__post_process :: (using self: *EditorScenePostImportPlugin, scene: Node) {
}
EditorScenePostImportPlugin_get_option_value :: (using self: *EditorScenePostImportPlugin, name: StringName) -> Variant {
}
EditorScenePostImportPlugin_add_import_option :: (using self: *EditorScenePostImportPlugin, name: String, value: Variant) {
}
EditorScenePostImportPlugin_add_import_option_advanced :: (using self: *EditorScenePostImportPlugin, type: VariantType, name: String, default_value: Variant, hint: PropertyHint, hint_string: String, usage_flags: int) {
}

// EditorScript
EditorScript :: struct {
	__private: *void;
}

EditorScript__run :: (using self: *EditorScript) {
}
EditorScript_add_root_node :: (using self: *EditorScript, node: Node) {
}
EditorScript_get_scene :: (using self: *EditorScript) -> Node {
}
EditorScript_get_editor_interface :: (using self: *EditorScript) -> EditorInterface {
}

// EditorScriptPicker
EditorScriptPicker :: struct {
	__private: *void;
}

EditorScriptPicker_set_script_owner :: (using self: *EditorScriptPicker, owner_node: Node) {
}
EditorScriptPicker_get_script_owner :: (using self: *EditorScriptPicker) -> Node {
}

// EditorSelection
EditorSelection :: struct {
	__private: *void;
}

EditorSelection_clear :: (using self: *EditorSelection) {
}
EditorSelection_add_node :: (using self: *EditorSelection, node: Node) {
}
EditorSelection_remove_node :: (using self: *EditorSelection, node: Node) {
}
EditorSelection_get_selected_nodes :: (using self: *EditorSelection) -> Array {
}
EditorSelection_get_transformable_selected_nodes :: (using self: *EditorSelection) -> Array {
}

// EditorSettings
EditorSettings :: struct {
	__private: *void;

	NOTIFICATION_EDITOR_SETTINGS_CHANGED :: 10000;
}

EditorSettings_has_setting :: (using self: *EditorSettings, name: String) -> bool {
}
EditorSettings_set_setting :: (using self: *EditorSettings, name: String, value: Variant) {
}
EditorSettings_get_setting :: (using self: *EditorSettings, name: String) -> Variant {
}
EditorSettings_erase :: (using self: *EditorSettings, property: String) {
}
EditorSettings_set_initial_value :: (using self: *EditorSettings, name: StringName, value: Variant, update_current: bool) {
}
EditorSettings_add_property_info :: (using self: *EditorSettings, info: Dictionary) {
}
EditorSettings_set_project_metadata :: (using self: *EditorSettings, section: String, key: String, data: Variant) {
}
EditorSettings_get_project_metadata :: (using self: *EditorSettings, section: String, key: String, default: Variant) -> Variant {
}
EditorSettings_set_favorites :: (using self: *EditorSettings, dirs: PackedStringArray) {
}
EditorSettings_get_favorites :: (using self: *EditorSettings) -> PackedStringArray {
}
EditorSettings_set_recent_dirs :: (using self: *EditorSettings, dirs: PackedStringArray) {
}
EditorSettings_get_recent_dirs :: (using self: *EditorSettings) -> PackedStringArray {
}
EditorSettings_set_builtin_action_override :: (using self: *EditorSettings, name: String, actions_list: Array) {
}
EditorSettings_check_changed_settings_in_group :: (using self: *EditorSettings, setting_prefix: String) -> bool {
}
EditorSettings_get_changed_settings :: (using self: *EditorSettings) -> PackedStringArray {
}
EditorSettings_mark_setting_changed :: (using self: *EditorSettings, setting: String) {
}

// EditorSpinSlider
EditorSpinSlider :: struct {
	__private: *void;
}

EditorSpinSlider_set_label :: (using self: *EditorSpinSlider, label: String) {
}
EditorSpinSlider_get_label :: (using self: *EditorSpinSlider) -> String {
}
EditorSpinSlider_set_suffix :: (using self: *EditorSpinSlider, suffix: String) {
}
EditorSpinSlider_get_suffix :: (using self: *EditorSpinSlider) -> String {
}
EditorSpinSlider_set_read_only :: (using self: *EditorSpinSlider, read_only: bool) {
}
EditorSpinSlider_is_read_only :: (using self: *EditorSpinSlider) -> bool {
}
EditorSpinSlider_set_flat :: (using self: *EditorSpinSlider, flat: bool) {
}
EditorSpinSlider_is_flat :: (using self: *EditorSpinSlider) -> bool {
}
EditorSpinSlider_set_hide_slider :: (using self: *EditorSpinSlider, hide_slider: bool) {
}
EditorSpinSlider_is_hiding_slider :: (using self: *EditorSpinSlider) -> bool {
}

// EditorSyntaxHighlighter
EditorSyntaxHighlighter :: struct {
	__private: *void;
}

EditorSyntaxHighlighter__get_name :: (using self: *EditorSyntaxHighlighter) -> String {
}
EditorSyntaxHighlighter__get_supported_languages :: (using self: *EditorSyntaxHighlighter) -> PackedStringArray {
}

// EditorTranslationParserPlugin
EditorTranslationParserPlugin :: struct {
	__private: *void;
}

EditorTranslationParserPlugin__parse_file :: (using self: *EditorTranslationParserPlugin, path: String, msgids: Array, msgids_context_plural: Array) {
}
EditorTranslationParserPlugin__get_recognized_extensions :: (using self: *EditorTranslationParserPlugin) -> PackedStringArray {
}

// EditorUndoRedoManager
EditorUndoRedoManager :: struct {
	__private: *void;

	SpecialHistory :: enum {
		GLOBAL_HISTORY :: 0;
		REMOTE_HISTORY :: -9;
		INVALID_HISTORY :: -99;
	}
}

EditorUndoRedoManager_create_action :: (using self: *EditorUndoRedoManager, name: String, merge_mode: UndoRedo.MergeMode, custom_context: Object, backward_undo_ops: bool) {
}
EditorUndoRedoManager_commit_action :: (using self: *EditorUndoRedoManager, execute: bool) {
}
EditorUndoRedoManager_is_committing_action :: (using self: *EditorUndoRedoManager) -> bool {
}
EditorUndoRedoManager_force_fixed_history :: (using self: *EditorUndoRedoManager) {
}
EditorUndoRedoManager_add_do_method :: (using self: *EditorUndoRedoManager, object: Object, method: StringName) {
}
EditorUndoRedoManager_add_undo_method :: (using self: *EditorUndoRedoManager, object: Object, method: StringName) {
}
EditorUndoRedoManager_add_do_property :: (using self: *EditorUndoRedoManager, object: Object, property: StringName, value: Variant) {
}
EditorUndoRedoManager_add_undo_property :: (using self: *EditorUndoRedoManager, object: Object, property: StringName, value: Variant) {
}
EditorUndoRedoManager_add_do_reference :: (using self: *EditorUndoRedoManager, object: Object) {
}
EditorUndoRedoManager_add_undo_reference :: (using self: *EditorUndoRedoManager, object: Object) {
}
EditorUndoRedoManager_get_object_history_id :: (using self: *EditorUndoRedoManager, object: Object) -> int {
}
EditorUndoRedoManager_get_history_undo_redo :: (using self: *EditorUndoRedoManager, id: int) -> UndoRedo {
}

// EditorVCSInterface
EditorVCSInterface :: struct {
	__private: *void;

	ChangeType :: enum {
		CHANGE_TYPE_NEW :: 0;
		CHANGE_TYPE_MODIFIED :: 1;
		CHANGE_TYPE_RENAMED :: 2;
		CHANGE_TYPE_DELETED :: 3;
		CHANGE_TYPE_TYPECHANGE :: 4;
		CHANGE_TYPE_UNMERGED :: 5;
	}
	TreeArea :: enum {
		TREE_AREA_COMMIT :: 0;
		TREE_AREA_STAGED :: 1;
		TREE_AREA_UNSTAGED :: 2;
	}
}

EditorVCSInterface__initialize :: (using self: *EditorVCSInterface, project_path: String) -> bool {
}
EditorVCSInterface__set_credentials :: (using self: *EditorVCSInterface, username: String, password: String, ssh_public_key_path: String, ssh_private_key_path: String, ssh_passphrase: String) {
}
EditorVCSInterface__get_modified_files_data :: (using self: *EditorVCSInterface) -> Dictionary {
}
EditorVCSInterface__stage_file :: (using self: *EditorVCSInterface, file_path: String) {
}
EditorVCSInterface__unstage_file :: (using self: *EditorVCSInterface, file_path: String) {
}
EditorVCSInterface__discard_file :: (using self: *EditorVCSInterface, file_path: String) {
}
EditorVCSInterface__commit :: (using self: *EditorVCSInterface, msg: String) {
}
EditorVCSInterface__get_diff :: (using self: *EditorVCSInterface, identifier: String, area: int) -> Dictionary {
}
EditorVCSInterface__shut_down :: (using self: *EditorVCSInterface) -> bool {
}
EditorVCSInterface__get_vcs_name :: (using self: *EditorVCSInterface) -> String {
}
EditorVCSInterface__get_previous_commits :: (using self: *EditorVCSInterface, max_commits: int) -> Dictionary {
}
EditorVCSInterface__get_branch_list :: (using self: *EditorVCSInterface) -> Array {
}
EditorVCSInterface__get_remotes :: (using self: *EditorVCSInterface) -> Array {
}
EditorVCSInterface__create_branch :: (using self: *EditorVCSInterface, branch_name: String) {
}
EditorVCSInterface__remove_branch :: (using self: *EditorVCSInterface, branch_name: String) {
}
EditorVCSInterface__create_remote :: (using self: *EditorVCSInterface, remote_name: String, remote_url: String) {
}
EditorVCSInterface__remove_remote :: (using self: *EditorVCSInterface, remote_name: String) {
}
EditorVCSInterface__get_current_branch_name :: (using self: *EditorVCSInterface) -> String {
}
EditorVCSInterface__checkout_branch :: (using self: *EditorVCSInterface, branch_name: String) -> bool {
}
EditorVCSInterface__pull :: (using self: *EditorVCSInterface, remote: String) {
}
EditorVCSInterface__push :: (using self: *EditorVCSInterface, remote: String, force: bool) {
}
EditorVCSInterface__fetch :: (using self: *EditorVCSInterface, remote: String) {
}
EditorVCSInterface__get_line_diff :: (using self: *EditorVCSInterface, file_path: String, text: String) -> Dictionary {
}
EditorVCSInterface_create_diff_line :: (using self: *EditorVCSInterface, new_line_no: int, old_line_no: int, content: String, status: String) -> Dictionary {
}
EditorVCSInterface_create_diff_hunk :: (using self: *EditorVCSInterface, old_start: int, new_start: int, old_lines: int, new_lines: int) -> Dictionary {
}
EditorVCSInterface_create_diff_file :: (using self: *EditorVCSInterface, new_file: String, old_file: String) -> Dictionary {
}
EditorVCSInterface_create_commit :: (using self: *EditorVCSInterface, msg: String, author: String, id: String, unix_timestamp: int, offset_minutes: int) -> Dictionary {
}
EditorVCSInterface_create_status_file :: (using self: *EditorVCSInterface, file_path: String, change_type: EditorVCSInterface.ChangeType, area: EditorVCSInterface.TreeArea) -> Dictionary {
}
EditorVCSInterface_add_diff_hunks_into_diff_file :: (using self: *EditorVCSInterface, diff_file: Dictionary, diff_hunks: Dictionary) -> Dictionary {
}
EditorVCSInterface_add_line_diffs_into_diff_hunk :: (using self: *EditorVCSInterface, diff_hunk: Dictionary, line_diffs: Dictionary) -> Dictionary {
}
EditorVCSInterface_popup_error :: (using self: *EditorVCSInterface, msg: String) {
}

// EncodedObjectAsID
EncodedObjectAsID :: struct {
	__private: *void;
}

EncodedObjectAsID_set_object_id :: (using self: *EncodedObjectAsID, id: int) {
}
EncodedObjectAsID_get_object_id :: (using self: *EncodedObjectAsID) -> int {
}

// Engine
Engine :: struct {
	__private: *void;
}

Engine_set_physics_ticks_per_second :: (using self: *Engine, physics_ticks_per_second: int) {
}
Engine_get_physics_ticks_per_second :: (using self: *Engine) -> int {
}
Engine_set_max_physics_steps_per_frame :: (using self: *Engine, max_physics_steps: int) {
}
Engine_get_max_physics_steps_per_frame :: (using self: *Engine) -> int {
}
Engine_set_physics_jitter_fix :: (using self: *Engine, physics_jitter_fix: float) {
}
Engine_get_physics_jitter_fix :: (using self: *Engine) -> float {
}
Engine_get_physics_interpolation_fraction :: (using self: *Engine) -> float {
}
Engine_set_max_fps :: (using self: *Engine, max_fps: int) {
}
Engine_get_max_fps :: (using self: *Engine) -> int {
}
Engine_set_time_scale :: (using self: *Engine, time_scale: float) {
}
Engine_get_time_scale :: (using self: *Engine) -> float {
}
Engine_get_frames_drawn :: (using self: *Engine) -> int {
}
Engine_get_frames_per_second :: (using self: *Engine) -> float {
}
Engine_get_physics_frames :: (using self: *Engine) -> int {
}
Engine_get_process_frames :: (using self: *Engine) -> int {
}
Engine_get_main_loop :: (using self: *Engine) -> MainLoop {
}
Engine_get_version_info :: (using self: *Engine) -> Dictionary {
}
Engine_get_author_info :: (using self: *Engine) -> Dictionary {
}
Engine_get_copyright_info :: (using self: *Engine) -> Dictionary {
}
Engine_get_donor_info :: (using self: *Engine) -> Dictionary {
}
Engine_get_license_info :: (using self: *Engine) -> Dictionary {
}
Engine_get_license_text :: (using self: *Engine) -> String {
}
Engine_get_architecture_name :: (using self: *Engine) -> String {
}
Engine_is_in_physics_frame :: (using self: *Engine) -> bool {
}
Engine_has_singleton :: (using self: *Engine, name: StringName) -> bool {
}
Engine_get_singleton :: (using self: *Engine, name: StringName) -> Object {
}
Engine_register_singleton :: (using self: *Engine, name: StringName, instance: Object) {
}
Engine_unregister_singleton :: (using self: *Engine, name: StringName) {
}
Engine_get_singleton_list :: (using self: *Engine) -> PackedStringArray {
}
Engine_register_script_language :: (using self: *Engine, language: ScriptLanguage) -> Error {
}
Engine_unregister_script_language :: (using self: *Engine, language: ScriptLanguage) -> Error {
}
Engine_get_script_language_count :: (using self: *Engine) -> int {
}
Engine_get_script_language :: (using self: *Engine, index: int) -> ScriptLanguage {
}
Engine_is_editor_hint :: (using self: *Engine) -> bool {
}
Engine_get_write_movie_path :: (using self: *Engine) -> String {
}
Engine_set_print_error_messages :: (using self: *Engine, enabled: bool) {
}
Engine_is_printing_error_messages :: (using self: *Engine) -> bool {
}

// EngineDebugger
EngineDebugger :: struct {
	__private: *void;
}

EngineDebugger_is_active :: (using self: *EngineDebugger) -> bool {
}
EngineDebugger_register_profiler :: (using self: *EngineDebugger, name: StringName, profiler: EngineProfiler) {
}
EngineDebugger_unregister_profiler :: (using self: *EngineDebugger, name: StringName) {
}
EngineDebugger_is_profiling :: (using self: *EngineDebugger, name: StringName) -> bool {
}
EngineDebugger_has_profiler :: (using self: *EngineDebugger, name: StringName) -> bool {
}
EngineDebugger_profiler_add_frame_data :: (using self: *EngineDebugger, name: StringName, data: Array) {
}
EngineDebugger_profiler_enable :: (using self: *EngineDebugger, name: StringName, enable: bool, arguments: Array) {
}
EngineDebugger_register_message_capture :: (using self: *EngineDebugger, name: StringName, callable: Callable) {
}
EngineDebugger_unregister_message_capture :: (using self: *EngineDebugger, name: StringName) {
}
EngineDebugger_has_capture :: (using self: *EngineDebugger, name: StringName) -> bool {
}
EngineDebugger_line_poll :: (using self: *EngineDebugger) {
}
EngineDebugger_send_message :: (using self: *EngineDebugger, message: String, data: Array) {
}
EngineDebugger_debug :: (using self: *EngineDebugger, can_continue: bool, is_error_breakpoint: bool) {
}
EngineDebugger_script_debug :: (using self: *EngineDebugger, language: ScriptLanguage, can_continue: bool, is_error_breakpoint: bool) {
}
EngineDebugger_set_lines_left :: (using self: *EngineDebugger, lines: int) {
}
EngineDebugger_get_lines_left :: (using self: *EngineDebugger) -> int {
}
EngineDebugger_set_depth :: (using self: *EngineDebugger, depth: int) {
}
EngineDebugger_get_depth :: (using self: *EngineDebugger) -> int {
}
EngineDebugger_is_breakpoint :: (using self: *EngineDebugger, line: int, source: StringName) -> bool {
}
EngineDebugger_is_skipping_breakpoints :: (using self: *EngineDebugger) -> bool {
}
EngineDebugger_insert_breakpoint :: (using self: *EngineDebugger, line: int, source: StringName) {
}
EngineDebugger_remove_breakpoint :: (using self: *EngineDebugger, line: int, source: StringName) {
}
EngineDebugger_clear_breakpoints :: (using self: *EngineDebugger) {
}

// EngineProfiler
EngineProfiler :: struct {
	__private: *void;
}

EngineProfiler__toggle :: (using self: *EngineProfiler, enable: bool, options: Array) {
}
EngineProfiler__add_frame :: (using self: *EngineProfiler, data: Array) {
}
EngineProfiler__tick :: (using self: *EngineProfiler, frame_time: float, process_time: float, physics_time: float, physics_frame_time: float) {
}

// Environment
Environment :: struct {
	__private: *void;

	BGMode :: enum {
		BG_CLEAR_COLOR :: 0;
		BG_COLOR :: 1;
		BG_SKY :: 2;
		BG_CANVAS :: 3;
		BG_KEEP :: 4;
		BG_CAMERA_FEED :: 5;
		BG_MAX :: 6;
	}
	AmbientSource :: enum {
		AMBIENT_SOURCE_BG :: 0;
		AMBIENT_SOURCE_DISABLED :: 1;
		AMBIENT_SOURCE_COLOR :: 2;
		AMBIENT_SOURCE_SKY :: 3;
	}
	ReflectionSource :: enum {
		REFLECTION_SOURCE_BG :: 0;
		REFLECTION_SOURCE_DISABLED :: 1;
		REFLECTION_SOURCE_SKY :: 2;
	}
	ToneMapper :: enum {
		TONE_MAPPER_LINEAR :: 0;
		TONE_MAPPER_REINHARDT :: 1;
		TONE_MAPPER_FILMIC :: 2;
		TONE_MAPPER_ACES :: 3;
	}
	GlowBlendMode :: enum {
		GLOW_BLEND_MODE_ADDITIVE :: 0;
		GLOW_BLEND_MODE_SCREEN :: 1;
		GLOW_BLEND_MODE_SOFTLIGHT :: 2;
		GLOW_BLEND_MODE_REPLACE :: 3;
		GLOW_BLEND_MODE_MIX :: 4;
	}
	FogMode :: enum {
		FOG_MODE_EXPONENTIAL :: 0;
		FOG_MODE_DEPTH :: 1;
	}
	SDFGIYScale :: enum {
		SDFGI_Y_SCALE_50_PERCENT :: 0;
		SDFGI_Y_SCALE_75_PERCENT :: 1;
		SDFGI_Y_SCALE_100_PERCENT :: 2;
	}
}

Environment_set_background :: (using self: *Environment, mode: Environment.BGMode) {
}
Environment_get_background :: (using self: *Environment) -> Environment.BGMode {
}
Environment_set_sky :: (using self: *Environment, sky: Sky) {
}
Environment_get_sky :: (using self: *Environment) -> Sky {
}
Environment_set_sky_custom_fov :: (using self: *Environment, scale: float) {
}
Environment_get_sky_custom_fov :: (using self: *Environment) -> float {
}
Environment_set_sky_rotation :: (using self: *Environment, euler_radians: Vector3) {
}
Environment_get_sky_rotation :: (using self: *Environment) -> Vector3 {
}
Environment_set_bg_color :: (using self: *Environment, color: Color) {
}
Environment_get_bg_color :: (using self: *Environment) -> Color {
}
Environment_set_bg_energy_multiplier :: (using self: *Environment, energy: float) {
}
Environment_get_bg_energy_multiplier :: (using self: *Environment) -> float {
}
Environment_set_bg_intensity :: (using self: *Environment, energy: float) {
}
Environment_get_bg_intensity :: (using self: *Environment) -> float {
}
Environment_set_canvas_max_layer :: (using self: *Environment, layer: int) {
}
Environment_get_canvas_max_layer :: (using self: *Environment) -> int {
}
Environment_set_camera_feed_id :: (using self: *Environment, id: int) {
}
Environment_get_camera_feed_id :: (using self: *Environment) -> int {
}
Environment_set_ambient_light_color :: (using self: *Environment, color: Color) {
}
Environment_get_ambient_light_color :: (using self: *Environment) -> Color {
}
Environment_set_ambient_source :: (using self: *Environment, source: Environment.AmbientSource) {
}
Environment_get_ambient_source :: (using self: *Environment) -> Environment.AmbientSource {
}
Environment_set_ambient_light_energy :: (using self: *Environment, energy: float) {
}
Environment_get_ambient_light_energy :: (using self: *Environment) -> float {
}
Environment_set_ambient_light_sky_contribution :: (using self: *Environment, ratio: float) {
}
Environment_get_ambient_light_sky_contribution :: (using self: *Environment) -> float {
}
Environment_set_reflection_source :: (using self: *Environment, source: Environment.ReflectionSource) {
}
Environment_get_reflection_source :: (using self: *Environment) -> Environment.ReflectionSource {
}
Environment_set_tonemapper :: (using self: *Environment, mode: Environment.ToneMapper) {
}
Environment_get_tonemapper :: (using self: *Environment) -> Environment.ToneMapper {
}
Environment_set_tonemap_exposure :: (using self: *Environment, exposure: float) {
}
Environment_get_tonemap_exposure :: (using self: *Environment) -> float {
}
Environment_set_tonemap_white :: (using self: *Environment, white: float) {
}
Environment_get_tonemap_white :: (using self: *Environment) -> float {
}
Environment_set_ssr_enabled :: (using self: *Environment, enabled: bool) {
}
Environment_is_ssr_enabled :: (using self: *Environment) -> bool {
}
Environment_set_ssr_max_steps :: (using self: *Environment, max_steps: int) {
}
Environment_get_ssr_max_steps :: (using self: *Environment) -> int {
}
Environment_set_ssr_fade_in :: (using self: *Environment, fade_in: float) {
}
Environment_get_ssr_fade_in :: (using self: *Environment) -> float {
}
Environment_set_ssr_fade_out :: (using self: *Environment, fade_out: float) {
}
Environment_get_ssr_fade_out :: (using self: *Environment) -> float {
}
Environment_set_ssr_depth_tolerance :: (using self: *Environment, depth_tolerance: float) {
}
Environment_get_ssr_depth_tolerance :: (using self: *Environment) -> float {
}
Environment_set_ssao_enabled :: (using self: *Environment, enabled: bool) {
}
Environment_is_ssao_enabled :: (using self: *Environment) -> bool {
}
Environment_set_ssao_radius :: (using self: *Environment, radius: float) {
}
Environment_get_ssao_radius :: (using self: *Environment) -> float {
}
Environment_set_ssao_intensity :: (using self: *Environment, intensity: float) {
}
Environment_get_ssao_intensity :: (using self: *Environment) -> float {
}
Environment_set_ssao_power :: (using self: *Environment, power: float) {
}
Environment_get_ssao_power :: (using self: *Environment) -> float {
}
Environment_set_ssao_detail :: (using self: *Environment, detail: float) {
}
Environment_get_ssao_detail :: (using self: *Environment) -> float {
}
Environment_set_ssao_horizon :: (using self: *Environment, horizon: float) {
}
Environment_get_ssao_horizon :: (using self: *Environment) -> float {
}
Environment_set_ssao_sharpness :: (using self: *Environment, sharpness: float) {
}
Environment_get_ssao_sharpness :: (using self: *Environment) -> float {
}
Environment_set_ssao_direct_light_affect :: (using self: *Environment, amount: float) {
}
Environment_get_ssao_direct_light_affect :: (using self: *Environment) -> float {
}
Environment_set_ssao_ao_channel_affect :: (using self: *Environment, amount: float) {
}
Environment_get_ssao_ao_channel_affect :: (using self: *Environment) -> float {
}
Environment_set_ssil_enabled :: (using self: *Environment, enabled: bool) {
}
Environment_is_ssil_enabled :: (using self: *Environment) -> bool {
}
Environment_set_ssil_radius :: (using self: *Environment, radius: float) {
}
Environment_get_ssil_radius :: (using self: *Environment) -> float {
}
Environment_set_ssil_intensity :: (using self: *Environment, intensity: float) {
}
Environment_get_ssil_intensity :: (using self: *Environment) -> float {
}
Environment_set_ssil_sharpness :: (using self: *Environment, sharpness: float) {
}
Environment_get_ssil_sharpness :: (using self: *Environment) -> float {
}
Environment_set_ssil_normal_rejection :: (using self: *Environment, normal_rejection: float) {
}
Environment_get_ssil_normal_rejection :: (using self: *Environment) -> float {
}
Environment_set_sdfgi_enabled :: (using self: *Environment, enabled: bool) {
}
Environment_is_sdfgi_enabled :: (using self: *Environment) -> bool {
}
Environment_set_sdfgi_cascades :: (using self: *Environment, amount: int) {
}
Environment_get_sdfgi_cascades :: (using self: *Environment) -> int {
}
Environment_set_sdfgi_min_cell_size :: (using self: *Environment, size: float) {
}
Environment_get_sdfgi_min_cell_size :: (using self: *Environment) -> float {
}
Environment_set_sdfgi_max_distance :: (using self: *Environment, distance: float) {
}
Environment_get_sdfgi_max_distance :: (using self: *Environment) -> float {
}
Environment_set_sdfgi_cascade0_distance :: (using self: *Environment, distance: float) {
}
Environment_get_sdfgi_cascade0_distance :: (using self: *Environment) -> float {
}
Environment_set_sdfgi_y_scale :: (using self: *Environment, scale: Environment.SDFGIYScale) {
}
Environment_get_sdfgi_y_scale :: (using self: *Environment) -> Environment.SDFGIYScale {
}
Environment_set_sdfgi_use_occlusion :: (using self: *Environment, enable: bool) {
}
Environment_is_sdfgi_using_occlusion :: (using self: *Environment) -> bool {
}
Environment_set_sdfgi_bounce_feedback :: (using self: *Environment, amount: float) {
}
Environment_get_sdfgi_bounce_feedback :: (using self: *Environment) -> float {
}
Environment_set_sdfgi_read_sky_light :: (using self: *Environment, enable: bool) {
}
Environment_is_sdfgi_reading_sky_light :: (using self: *Environment) -> bool {
}
Environment_set_sdfgi_energy :: (using self: *Environment, amount: float) {
}
Environment_get_sdfgi_energy :: (using self: *Environment) -> float {
}
Environment_set_sdfgi_normal_bias :: (using self: *Environment, bias: float) {
}
Environment_get_sdfgi_normal_bias :: (using self: *Environment) -> float {
}
Environment_set_sdfgi_probe_bias :: (using self: *Environment, bias: float) {
}
Environment_get_sdfgi_probe_bias :: (using self: *Environment) -> float {
}
Environment_set_glow_enabled :: (using self: *Environment, enabled: bool) {
}
Environment_is_glow_enabled :: (using self: *Environment) -> bool {
}
Environment_set_glow_level :: (using self: *Environment, idx: int, intensity: float) {
}
Environment_get_glow_level :: (using self: *Environment, idx: int) -> float {
}
Environment_set_glow_normalized :: (using self: *Environment, normalize: bool) {
}
Environment_is_glow_normalized :: (using self: *Environment) -> bool {
}
Environment_set_glow_intensity :: (using self: *Environment, intensity: float) {
}
Environment_get_glow_intensity :: (using self: *Environment) -> float {
}
Environment_set_glow_strength :: (using self: *Environment, strength: float) {
}
Environment_get_glow_strength :: (using self: *Environment) -> float {
}
Environment_set_glow_mix :: (using self: *Environment, mix: float) {
}
Environment_get_glow_mix :: (using self: *Environment) -> float {
}
Environment_set_glow_bloom :: (using self: *Environment, amount: float) {
}
Environment_get_glow_bloom :: (using self: *Environment) -> float {
}
Environment_set_glow_blend_mode :: (using self: *Environment, mode: Environment.GlowBlendMode) {
}
Environment_get_glow_blend_mode :: (using self: *Environment) -> Environment.GlowBlendMode {
}
Environment_set_glow_hdr_bleed_threshold :: (using self: *Environment, threshold: float) {
}
Environment_get_glow_hdr_bleed_threshold :: (using self: *Environment) -> float {
}
Environment_set_glow_hdr_bleed_scale :: (using self: *Environment, scale: float) {
}
Environment_get_glow_hdr_bleed_scale :: (using self: *Environment) -> float {
}
Environment_set_glow_hdr_luminance_cap :: (using self: *Environment, amount: float) {
}
Environment_get_glow_hdr_luminance_cap :: (using self: *Environment) -> float {
}
Environment_set_glow_map_strength :: (using self: *Environment, strength: float) {
}
Environment_get_glow_map_strength :: (using self: *Environment) -> float {
}
Environment_set_glow_map :: (using self: *Environment, mode: Texture) {
}
Environment_get_glow_map :: (using self: *Environment) -> Texture {
}
Environment_set_fog_enabled :: (using self: *Environment, enabled: bool) {
}
Environment_is_fog_enabled :: (using self: *Environment) -> bool {
}
Environment_set_fog_mode :: (using self: *Environment, mode: Environment.FogMode) {
}
Environment_get_fog_mode :: (using self: *Environment) -> Environment.FogMode {
}
Environment_set_fog_light_color :: (using self: *Environment, light_color: Color) {
}
Environment_get_fog_light_color :: (using self: *Environment) -> Color {
}
Environment_set_fog_light_energy :: (using self: *Environment, light_energy: float) {
}
Environment_get_fog_light_energy :: (using self: *Environment) -> float {
}
Environment_set_fog_sun_scatter :: (using self: *Environment, sun_scatter: float) {
}
Environment_get_fog_sun_scatter :: (using self: *Environment) -> float {
}
Environment_set_fog_density :: (using self: *Environment, density: float) {
}
Environment_get_fog_density :: (using self: *Environment) -> float {
}
Environment_set_fog_height :: (using self: *Environment, height: float) {
}
Environment_get_fog_height :: (using self: *Environment) -> float {
}
Environment_set_fog_height_density :: (using self: *Environment, height_density: float) {
}
Environment_get_fog_height_density :: (using self: *Environment) -> float {
}
Environment_set_fog_aerial_perspective :: (using self: *Environment, aerial_perspective: float) {
}
Environment_get_fog_aerial_perspective :: (using self: *Environment) -> float {
}
Environment_set_fog_sky_affect :: (using self: *Environment, sky_affect: float) {
}
Environment_get_fog_sky_affect :: (using self: *Environment) -> float {
}
Environment_set_fog_depth_curve :: (using self: *Environment, curve: float) {
}
Environment_get_fog_depth_curve :: (using self: *Environment) -> float {
}
Environment_set_fog_depth_begin :: (using self: *Environment, begin: float) {
}
Environment_get_fog_depth_begin :: (using self: *Environment) -> float {
}
Environment_set_fog_depth_end :: (using self: *Environment, end: float) {
}
Environment_get_fog_depth_end :: (using self: *Environment) -> float {
}
Environment_set_volumetric_fog_enabled :: (using self: *Environment, enabled: bool) {
}
Environment_is_volumetric_fog_enabled :: (using self: *Environment) -> bool {
}
Environment_set_volumetric_fog_emission :: (using self: *Environment, color: Color) {
}
Environment_get_volumetric_fog_emission :: (using self: *Environment) -> Color {
}
Environment_set_volumetric_fog_albedo :: (using self: *Environment, color: Color) {
}
Environment_get_volumetric_fog_albedo :: (using self: *Environment) -> Color {
}
Environment_set_volumetric_fog_density :: (using self: *Environment, density: float) {
}
Environment_get_volumetric_fog_density :: (using self: *Environment) -> float {
}
Environment_set_volumetric_fog_emission_energy :: (using self: *Environment, begin: float) {
}
Environment_get_volumetric_fog_emission_energy :: (using self: *Environment) -> float {
}
Environment_set_volumetric_fog_anisotropy :: (using self: *Environment, anisotropy: float) {
}
Environment_get_volumetric_fog_anisotropy :: (using self: *Environment) -> float {
}
Environment_set_volumetric_fog_length :: (using self: *Environment, length: float) {
}
Environment_get_volumetric_fog_length :: (using self: *Environment) -> float {
}
Environment_set_volumetric_fog_detail_spread :: (using self: *Environment, detail_spread: float) {
}
Environment_get_volumetric_fog_detail_spread :: (using self: *Environment) -> float {
}
Environment_set_volumetric_fog_gi_inject :: (using self: *Environment, gi_inject: float) {
}
Environment_get_volumetric_fog_gi_inject :: (using self: *Environment) -> float {
}
Environment_set_volumetric_fog_ambient_inject :: (using self: *Environment, enabled: float) {
}
Environment_get_volumetric_fog_ambient_inject :: (using self: *Environment) -> float {
}
Environment_set_volumetric_fog_sky_affect :: (using self: *Environment, sky_affect: float) {
}
Environment_get_volumetric_fog_sky_affect :: (using self: *Environment) -> float {
}
Environment_set_volumetric_fog_temporal_reprojection_enabled :: (using self: *Environment, enabled: bool) {
}
Environment_is_volumetric_fog_temporal_reprojection_enabled :: (using self: *Environment) -> bool {
}
Environment_set_volumetric_fog_temporal_reprojection_amount :: (using self: *Environment, temporal_reprojection_amount: float) {
}
Environment_get_volumetric_fog_temporal_reprojection_amount :: (using self: *Environment) -> float {
}
Environment_set_adjustment_enabled :: (using self: *Environment, enabled: bool) {
}
Environment_is_adjustment_enabled :: (using self: *Environment) -> bool {
}
Environment_set_adjustment_brightness :: (using self: *Environment, brightness: float) {
}
Environment_get_adjustment_brightness :: (using self: *Environment) -> float {
}
Environment_set_adjustment_contrast :: (using self: *Environment, contrast: float) {
}
Environment_get_adjustment_contrast :: (using self: *Environment) -> float {
}
Environment_set_adjustment_saturation :: (using self: *Environment, saturation: float) {
}
Environment_get_adjustment_saturation :: (using self: *Environment) -> float {
}
Environment_set_adjustment_color_correction :: (using self: *Environment, color_correction: Texture) {
}
Environment_get_adjustment_color_correction :: (using self: *Environment) -> Texture {
}

// Expression
Expression :: struct {
	__private: *void;
}

Expression_parse :: (using self: *Expression, expression: String, input_names: PackedStringArray) -> Error {
}
Expression_execute :: (using self: *Expression, inputs: Array, base_instance: Object, show_error: bool, const_calls_only: bool) -> Variant {
}
Expression_has_execute_failed :: (using self: *Expression) -> bool {
}
Expression_get_error_text :: (using self: *Expression) -> String {
}

// FBXDocument
FBXDocument :: struct {
	__private: *void;
}

// FBXState
FBXState :: struct {
	__private: *void;
}

FBXState_get_allow_geometry_helper_nodes :: (using self: *FBXState) -> bool {
}
FBXState_set_allow_geometry_helper_nodes :: (using self: *FBXState, allow: bool) {
}

// FastNoiseLite
FastNoiseLite :: struct {
	__private: *void;

	NoiseType :: enum {
		TYPE_VALUE :: 5;
		TYPE_VALUE_CUBIC :: 4;
		TYPE_PERLIN :: 3;
		TYPE_CELLULAR :: 2;
		TYPE_SIMPLEX :: 0;
		TYPE_SIMPLEX_SMOOTH :: 1;
	}
	FractalType :: enum {
		FRACTAL_NONE :: 0;
		FRACTAL_FBM :: 1;
		FRACTAL_RIDGED :: 2;
		FRACTAL_PING_PONG :: 3;
	}
	CellularDistanceFunction :: enum {
		DISTANCE_EUCLIDEAN :: 0;
		DISTANCE_EUCLIDEAN_SQUARED :: 1;
		DISTANCE_MANHATTAN :: 2;
		DISTANCE_HYBRID :: 3;
	}
	CellularReturnType :: enum {
		RETURN_CELL_VALUE :: 0;
		RETURN_DISTANCE :: 1;
		RETURN_DISTANCE2 :: 2;
		RETURN_DISTANCE2_ADD :: 3;
		RETURN_DISTANCE2_SUB :: 4;
		RETURN_DISTANCE2_MUL :: 5;
		RETURN_DISTANCE2_DIV :: 6;
	}
	DomainWarpType :: enum {
		DOMAIN_WARP_SIMPLEX :: 0;
		DOMAIN_WARP_SIMPLEX_REDUCED :: 1;
		DOMAIN_WARP_BASIC_GRID :: 2;
	}
	DomainWarpFractalType :: enum {
		DOMAIN_WARP_FRACTAL_NONE :: 0;
		DOMAIN_WARP_FRACTAL_PROGRESSIVE :: 1;
		DOMAIN_WARP_FRACTAL_INDEPENDENT :: 2;
	}
}

FastNoiseLite_set_noise_type :: (using self: *FastNoiseLite, type: FastNoiseLite.NoiseType) {
}
FastNoiseLite_get_noise_type :: (using self: *FastNoiseLite) -> FastNoiseLite.NoiseType {
}
FastNoiseLite_set_seed :: (using self: *FastNoiseLite, seed: int) {
}
FastNoiseLite_get_seed :: (using self: *FastNoiseLite) -> int {
}
FastNoiseLite_set_frequency :: (using self: *FastNoiseLite, freq: float) {
}
FastNoiseLite_get_frequency :: (using self: *FastNoiseLite) -> float {
}
FastNoiseLite_set_offset :: (using self: *FastNoiseLite, offset: Vector3) {
}
FastNoiseLite_get_offset :: (using self: *FastNoiseLite) -> Vector3 {
}
FastNoiseLite_set_fractal_type :: (using self: *FastNoiseLite, type: FastNoiseLite.FractalType) {
}
FastNoiseLite_get_fractal_type :: (using self: *FastNoiseLite) -> FastNoiseLite.FractalType {
}
FastNoiseLite_set_fractal_octaves :: (using self: *FastNoiseLite, octave_count: int) {
}
FastNoiseLite_get_fractal_octaves :: (using self: *FastNoiseLite) -> int {
}
FastNoiseLite_set_fractal_lacunarity :: (using self: *FastNoiseLite, lacunarity: float) {
}
FastNoiseLite_get_fractal_lacunarity :: (using self: *FastNoiseLite) -> float {
}
FastNoiseLite_set_fractal_gain :: (using self: *FastNoiseLite, gain: float) {
}
FastNoiseLite_get_fractal_gain :: (using self: *FastNoiseLite) -> float {
}
FastNoiseLite_set_fractal_weighted_strength :: (using self: *FastNoiseLite, weighted_strength: float) {
}
FastNoiseLite_get_fractal_weighted_strength :: (using self: *FastNoiseLite) -> float {
}
FastNoiseLite_set_fractal_ping_pong_strength :: (using self: *FastNoiseLite, ping_pong_strength: float) {
}
FastNoiseLite_get_fractal_ping_pong_strength :: (using self: *FastNoiseLite) -> float {
}
FastNoiseLite_set_cellular_distance_function :: (using self: *FastNoiseLite, func: FastNoiseLite.CellularDistanceFunction) {
}
FastNoiseLite_get_cellular_distance_function :: (using self: *FastNoiseLite) -> FastNoiseLite.CellularDistanceFunction {
}
FastNoiseLite_set_cellular_jitter :: (using self: *FastNoiseLite, jitter: float) {
}
FastNoiseLite_get_cellular_jitter :: (using self: *FastNoiseLite) -> float {
}
FastNoiseLite_set_cellular_return_type :: (using self: *FastNoiseLite, ret: FastNoiseLite.CellularReturnType) {
}
FastNoiseLite_get_cellular_return_type :: (using self: *FastNoiseLite) -> FastNoiseLite.CellularReturnType {
}
FastNoiseLite_set_domain_warp_enabled :: (using self: *FastNoiseLite, domain_warp_enabled: bool) {
}
FastNoiseLite_is_domain_warp_enabled :: (using self: *FastNoiseLite) -> bool {
}
FastNoiseLite_set_domain_warp_type :: (using self: *FastNoiseLite, domain_warp_type: FastNoiseLite.DomainWarpType) {
}
FastNoiseLite_get_domain_warp_type :: (using self: *FastNoiseLite) -> FastNoiseLite.DomainWarpType {
}
FastNoiseLite_set_domain_warp_amplitude :: (using self: *FastNoiseLite, domain_warp_amplitude: float) {
}
FastNoiseLite_get_domain_warp_amplitude :: (using self: *FastNoiseLite) -> float {
}
FastNoiseLite_set_domain_warp_frequency :: (using self: *FastNoiseLite, domain_warp_frequency: float) {
}
FastNoiseLite_get_domain_warp_frequency :: (using self: *FastNoiseLite) -> float {
}
FastNoiseLite_set_domain_warp_fractal_type :: (using self: *FastNoiseLite, domain_warp_fractal_type: FastNoiseLite.DomainWarpFractalType) {
}
FastNoiseLite_get_domain_warp_fractal_type :: (using self: *FastNoiseLite) -> FastNoiseLite.DomainWarpFractalType {
}
FastNoiseLite_set_domain_warp_fractal_octaves :: (using self: *FastNoiseLite, domain_warp_octave_count: int) {
}
FastNoiseLite_get_domain_warp_fractal_octaves :: (using self: *FastNoiseLite) -> int {
}
FastNoiseLite_set_domain_warp_fractal_lacunarity :: (using self: *FastNoiseLite, domain_warp_lacunarity: float) {
}
FastNoiseLite_get_domain_warp_fractal_lacunarity :: (using self: *FastNoiseLite) -> float {
}
FastNoiseLite_set_domain_warp_fractal_gain :: (using self: *FastNoiseLite, domain_warp_gain: float) {
}
FastNoiseLite_get_domain_warp_fractal_gain :: (using self: *FastNoiseLite) -> float {
}

// FileAccess
FileAccess :: struct {
	__private: *void;

	ModeFlags :: enum {
		READ :: 1;
		WRITE :: 2;
		READ_WRITE :: 3;
		WRITE_READ :: 7;
	}
	CompressionMode :: enum {
		COMPRESSION_FASTLZ :: 0;
		COMPRESSION_DEFLATE :: 1;
		COMPRESSION_ZSTD :: 2;
		COMPRESSION_GZIP :: 3;
		COMPRESSION_BROTLI :: 4;
	}
	UnixPermissionFlags :: enum_flags {
		UNIX_READ_OWNER :: 256;
		UNIX_WRITE_OWNER :: 128;
		UNIX_EXECUTE_OWNER :: 64;
		UNIX_READ_GROUP :: 32;
		UNIX_WRITE_GROUP :: 16;
		UNIX_EXECUTE_GROUP :: 8;
		UNIX_READ_OTHER :: 4;
		UNIX_WRITE_OTHER :: 2;
		UNIX_EXECUTE_OTHER :: 1;
		UNIX_SET_USER_ID :: 2048;
		UNIX_SET_GROUP_ID :: 1024;
		UNIX_RESTRICTED_DELETE :: 512;
	}
}

FileAccess_open :: (using self: *FileAccess, path: String, flags: FileAccess.ModeFlags) -> FileAccess {
}
FileAccess_open_encrypted :: (using self: *FileAccess, path: String, mode_flags: FileAccess.ModeFlags, key: PackedByteArray) -> FileAccess {
}
FileAccess_open_encrypted_with_pass :: (using self: *FileAccess, path: String, mode_flags: FileAccess.ModeFlags, pass: String) -> FileAccess {
}
FileAccess_open_compressed :: (using self: *FileAccess, path: String, mode_flags: FileAccess.ModeFlags, compression_mode: FileAccess.CompressionMode) -> FileAccess {
}
FileAccess_get_open_error :: (using self: *FileAccess) -> Error {
}
FileAccess_get_file_as_bytes :: (using self: *FileAccess, path: String) -> PackedByteArray {
}
FileAccess_get_file_as_string :: (using self: *FileAccess, path: String) -> String {
}
FileAccess_resize :: (using self: *FileAccess, length: int) -> Error {
}
FileAccess_flush :: (using self: *FileAccess) {
}
FileAccess_get_path :: (using self: *FileAccess) -> String {
}
FileAccess_get_path_absolute :: (using self: *FileAccess) -> String {
}
FileAccess_is_open :: (using self: *FileAccess) -> bool {
}
FileAccess_seek :: (using self: *FileAccess, position: int) {
}
FileAccess_seek_end :: (using self: *FileAccess, position: int) {
}
FileAccess_get_position :: (using self: *FileAccess) -> int {
}
FileAccess_get_length :: (using self: *FileAccess) -> int {
}
FileAccess_eof_reached :: (using self: *FileAccess) -> bool {
}
FileAccess_get_8 :: (using self: *FileAccess) -> int {
}
FileAccess_get_16 :: (using self: *FileAccess) -> int {
}
FileAccess_get_32 :: (using self: *FileAccess) -> int {
}
FileAccess_get_64 :: (using self: *FileAccess) -> int {
}
FileAccess_get_float :: (using self: *FileAccess) -> float {
}
FileAccess_get_double :: (using self: *FileAccess) -> float {
}
FileAccess_get_real :: (using self: *FileAccess) -> float {
}
FileAccess_get_buffer :: (using self: *FileAccess, length: int) -> PackedByteArray {
}
FileAccess_get_line :: (using self: *FileAccess) -> String {
}
FileAccess_get_csv_line :: (using self: *FileAccess, delim: String) -> PackedStringArray {
}
FileAccess_get_as_text :: (using self: *FileAccess, skip_cr: bool) -> String {
}
FileAccess_get_md5 :: (using self: *FileAccess, path: String) -> String {
}
FileAccess_get_sha256 :: (using self: *FileAccess, path: String) -> String {
}
FileAccess_is_big_endian :: (using self: *FileAccess) -> bool {
}
FileAccess_set_big_endian :: (using self: *FileAccess, big_endian: bool) {
}
FileAccess_get_error :: (using self: *FileAccess) -> Error {
}
FileAccess_get_var :: (using self: *FileAccess, allow_objects: bool) -> Variant {
}
FileAccess_store_8 :: (using self: *FileAccess, value: int) {
}
FileAccess_store_16 :: (using self: *FileAccess, value: int) {
}
FileAccess_store_32 :: (using self: *FileAccess, value: int) {
}
FileAccess_store_64 :: (using self: *FileAccess, value: int) {
}
FileAccess_store_float :: (using self: *FileAccess, value: float) {
}
FileAccess_store_double :: (using self: *FileAccess, value: float) {
}
FileAccess_store_real :: (using self: *FileAccess, value: float) {
}
FileAccess_store_buffer :: (using self: *FileAccess, buffer: PackedByteArray) {
}
FileAccess_store_line :: (using self: *FileAccess, line: String) {
}
FileAccess_store_csv_line :: (using self: *FileAccess, values: PackedStringArray, delim: String) {
}
FileAccess_store_string :: (using self: *FileAccess, _string: String) {
}
FileAccess_store_var :: (using self: *FileAccess, value: Variant, full_objects: bool) {
}
FileAccess_store_pascal_string :: (using self: *FileAccess, _string: String) {
}
FileAccess_get_pascal_string :: (using self: *FileAccess) -> String {
}
FileAccess_close :: (using self: *FileAccess) {
}
FileAccess_file_exists :: (using self: *FileAccess, path: String) -> bool {
}
FileAccess_get_modified_time :: (using self: *FileAccess, file: String) -> int {
}
FileAccess_get_unix_permissions :: (using self: *FileAccess, file: String) -> FileAccess.UnixPermissionFlags {
}
FileAccess_set_unix_permissions :: (using self: *FileAccess, file: String, permissions: FileAccess.UnixPermissionFlags) -> Error {
}
FileAccess_get_hidden_attribute :: (using self: *FileAccess, file: String) -> bool {
}
FileAccess_set_hidden_attribute :: (using self: *FileAccess, file: String, hidden: bool) -> Error {
}
FileAccess_set_read_only_attribute :: (using self: *FileAccess, file: String, ro: bool) -> Error {
}
FileAccess_get_read_only_attribute :: (using self: *FileAccess, file: String) -> bool {
}

// FileDialog
FileDialog :: struct {
	__private: *void;

	FileMode :: enum {
		FILE_MODE_OPEN_FILE :: 0;
		FILE_MODE_OPEN_FILES :: 1;
		FILE_MODE_OPEN_DIR :: 2;
		FILE_MODE_OPEN_ANY :: 3;
		FILE_MODE_SAVE_FILE :: 4;
	}
	Access :: enum {
		ACCESS_RESOURCES :: 0;
		ACCESS_USERDATA :: 1;
		ACCESS_FILESYSTEM :: 2;
	}
}

FileDialog_clear_filters :: (using self: *FileDialog) {
}
FileDialog_add_filter :: (using self: *FileDialog, filter: String, description: String) {
}
FileDialog_set_filters :: (using self: *FileDialog, filters: PackedStringArray) {
}
FileDialog_get_filters :: (using self: *FileDialog) -> PackedStringArray {
}
FileDialog_get_option_name :: (using self: *FileDialog, option: int) -> String {
}
FileDialog_get_option_values :: (using self: *FileDialog, option: int) -> PackedStringArray {
}
FileDialog_get_option_default :: (using self: *FileDialog, option: int) -> int {
}
FileDialog_set_option_name :: (using self: *FileDialog, option: int, name: String) {
}
FileDialog_set_option_values :: (using self: *FileDialog, option: int, values: PackedStringArray) {
}
FileDialog_set_option_default :: (using self: *FileDialog, option: int, default_value_index: int) {
}
FileDialog_set_option_count :: (using self: *FileDialog, count: int) {
}
FileDialog_get_option_count :: (using self: *FileDialog) -> int {
}
FileDialog_add_option :: (using self: *FileDialog, name: String, values: PackedStringArray, default_value_index: int) {
}
FileDialog_get_selected_options :: (using self: *FileDialog) -> Dictionary {
}
FileDialog_get_current_dir :: (using self: *FileDialog) -> String {
}
FileDialog_get_current_file :: (using self: *FileDialog) -> String {
}
FileDialog_get_current_path :: (using self: *FileDialog) -> String {
}
FileDialog_set_current_dir :: (using self: *FileDialog, dir: String) {
}
FileDialog_set_current_file :: (using self: *FileDialog, file: String) {
}
FileDialog_set_current_path :: (using self: *FileDialog, path: String) {
}
FileDialog_set_mode_overrides_title :: (using self: *FileDialog, override: bool) {
}
FileDialog_is_mode_overriding_title :: (using self: *FileDialog) -> bool {
}
FileDialog_set_file_mode :: (using self: *FileDialog, mode: FileDialog.FileMode) {
}
FileDialog_get_file_mode :: (using self: *FileDialog) -> FileDialog.FileMode {
}
FileDialog_get_vbox :: (using self: *FileDialog) -> VBoxContainer {
}
FileDialog_get_line_edit :: (using self: *FileDialog) -> LineEdit {
}
FileDialog_set_access :: (using self: *FileDialog, access: FileDialog.Access) {
}
FileDialog_get_access :: (using self: *FileDialog) -> FileDialog.Access {
}
FileDialog_set_root_subfolder :: (using self: *FileDialog, dir: String) {
}
FileDialog_get_root_subfolder :: (using self: *FileDialog) -> String {
}
FileDialog_set_show_hidden_files :: (using self: *FileDialog, show: bool) {
}
FileDialog_is_showing_hidden_files :: (using self: *FileDialog) -> bool {
}
FileDialog_set_use_native_dialog :: (using self: *FileDialog, native: bool) {
}
FileDialog_get_use_native_dialog :: (using self: *FileDialog) -> bool {
}
FileDialog_deselect_all :: (using self: *FileDialog) {
}
FileDialog_invalidate :: (using self: *FileDialog) {
}

// FileSystemDock
FileSystemDock :: struct {
	__private: *void;
}

FileSystemDock_navigate_to_path :: (using self: *FileSystemDock, path: String) {
}
FileSystemDock_add_resource_tooltip_plugin :: (using self: *FileSystemDock, plugin: EditorResourceTooltipPlugin) {
}
FileSystemDock_remove_resource_tooltip_plugin :: (using self: *FileSystemDock, plugin: EditorResourceTooltipPlugin) {
}

// FlowContainer
FlowContainer :: struct {
	__private: *void;

	AlignmentMode :: enum {
		ALIGNMENT_BEGIN :: 0;
		ALIGNMENT_CENTER :: 1;
		ALIGNMENT_END :: 2;
	}
	LastWrapAlignmentMode :: enum {
		LAST_WRAP_ALIGNMENT_INHERIT :: 0;
		LAST_WRAP_ALIGNMENT_BEGIN :: 1;
		LAST_WRAP_ALIGNMENT_CENTER :: 2;
		LAST_WRAP_ALIGNMENT_END :: 3;
	}
}

FlowContainer_get_line_count :: (using self: *FlowContainer) -> int {
}
FlowContainer_set_alignment :: (using self: *FlowContainer, alignment: FlowContainer.AlignmentMode) {
}
FlowContainer_get_alignment :: (using self: *FlowContainer) -> FlowContainer.AlignmentMode {
}
FlowContainer_set_last_wrap_alignment :: (using self: *FlowContainer, last_wrap_alignment: FlowContainer.LastWrapAlignmentMode) {
}
FlowContainer_get_last_wrap_alignment :: (using self: *FlowContainer) -> FlowContainer.LastWrapAlignmentMode {
}
FlowContainer_set_vertical :: (using self: *FlowContainer, vertical: bool) {
}
FlowContainer_is_vertical :: (using self: *FlowContainer) -> bool {
}
FlowContainer_set_reverse_fill :: (using self: *FlowContainer, reverse_fill: bool) {
}
FlowContainer_is_reverse_fill :: (using self: *FlowContainer) -> bool {
}

// FogMaterial
FogMaterial :: struct {
	__private: *void;
}

FogMaterial_set_density :: (using self: *FogMaterial, density: float) {
}
FogMaterial_get_density :: (using self: *FogMaterial) -> float {
}
FogMaterial_set_albedo :: (using self: *FogMaterial, albedo: Color) {
}
FogMaterial_get_albedo :: (using self: *FogMaterial) -> Color {
}
FogMaterial_set_emission :: (using self: *FogMaterial, emission: Color) {
}
FogMaterial_get_emission :: (using self: *FogMaterial) -> Color {
}
FogMaterial_set_height_falloff :: (using self: *FogMaterial, height_falloff: float) {
}
FogMaterial_get_height_falloff :: (using self: *FogMaterial) -> float {
}
FogMaterial_set_edge_fade :: (using self: *FogMaterial, edge_fade: float) {
}
FogMaterial_get_edge_fade :: (using self: *FogMaterial) -> float {
}
FogMaterial_set_density_texture :: (using self: *FogMaterial, density_texture: Texture3D) {
}
FogMaterial_get_density_texture :: (using self: *FogMaterial) -> Texture3D {
}

// FogVolume
FogVolume :: struct {
	__private: *void;
}

FogVolume_set_size :: (using self: *FogVolume, size: Vector3) {
}
FogVolume_get_size :: (using self: *FogVolume) -> Vector3 {
}
FogVolume_set_shape :: (using self: *FogVolume, shape: RenderingServer.FogVolumeShape) {
}
FogVolume_get_shape :: (using self: *FogVolume) -> RenderingServer.FogVolumeShape {
}
FogVolume_set_material :: (using self: *FogVolume, material: Material) {
}
FogVolume_get_material :: (using self: *FogVolume) -> Material {
}

// Font
Font :: struct {
	__private: *void;
}

Font_set_fallbacks :: (using self: *Font, fallbacks: Array) {
}
Font_get_fallbacks :: (using self: *Font) -> Array {
}
Font_find_variation :: (using self: *Font, variation_coordinates: Dictionary, face_index: int, strength: float, transform: Transform2D, spacing_top: int, spacing_bottom: int, spacing_space: int, spacing_glyph: int, baseline_offset: float) -> RID {
}
Font_get_rids :: (using self: *Font) -> Array {
}
Font_get_height :: (using self: *Font, font_size: int) -> float {
}
Font_get_ascent :: (using self: *Font, font_size: int) -> float {
}
Font_get_descent :: (using self: *Font, font_size: int) -> float {
}
Font_get_underline_position :: (using self: *Font, font_size: int) -> float {
}
Font_get_underline_thickness :: (using self: *Font, font_size: int) -> float {
}
Font_get_font_name :: (using self: *Font) -> String {
}
Font_get_font_style_name :: (using self: *Font) -> String {
}
Font_get_ot_name_strings :: (using self: *Font) -> Dictionary {
}
Font_get_font_style :: (using self: *Font) -> TextServer.FontStyle {
}
Font_get_font_weight :: (using self: *Font) -> int {
}
Font_get_font_stretch :: (using self: *Font) -> int {
}
Font_get_spacing :: (using self: *Font, spacing: TextServer.SpacingType) -> int {
}
Font_get_opentype_features :: (using self: *Font) -> Dictionary {
}
Font_set_cache_capacity :: (using self: *Font, single_line: int, multi_line: int) {
}
Font_get_string_size :: (using self: *Font, text: String, alignment: HorizontalAlignment, width: float, font_size: int, justification_flags: TextServer.JustificationFlag, direction: TextServer.Direction, orientation: TextServer.Orientation) -> Vector2 {
}
Font_get_multiline_string_size :: (using self: *Font, text: String, alignment: HorizontalAlignment, width: float, font_size: int, max_lines: int, brk_flags: TextServer.LineBreakFlag, justification_flags: TextServer.JustificationFlag, direction: TextServer.Direction, orientation: TextServer.Orientation) -> Vector2 {
}
Font_draw_string :: (using self: *Font, canvas_item: RID, pos: Vector2, text: String, alignment: HorizontalAlignment, width: float, font_size: int, modulate: Color, justification_flags: TextServer.JustificationFlag, direction: TextServer.Direction, orientation: TextServer.Orientation) {
}
Font_draw_multiline_string :: (using self: *Font, canvas_item: RID, pos: Vector2, text: String, alignment: HorizontalAlignment, width: float, font_size: int, max_lines: int, modulate: Color, brk_flags: TextServer.LineBreakFlag, justification_flags: TextServer.JustificationFlag, direction: TextServer.Direction, orientation: TextServer.Orientation) {
}
Font_draw_string_outline :: (using self: *Font, canvas_item: RID, pos: Vector2, text: String, alignment: HorizontalAlignment, width: float, font_size: int, size: int, modulate: Color, justification_flags: TextServer.JustificationFlag, direction: TextServer.Direction, orientation: TextServer.Orientation) {
}
Font_draw_multiline_string_outline :: (using self: *Font, canvas_item: RID, pos: Vector2, text: String, alignment: HorizontalAlignment, width: float, font_size: int, max_lines: int, size: int, modulate: Color, brk_flags: TextServer.LineBreakFlag, justification_flags: TextServer.JustificationFlag, direction: TextServer.Direction, orientation: TextServer.Orientation) {
}
Font_get_char_size :: (using self: *Font, char: int, font_size: int) -> Vector2 {
}
Font_draw_char :: (using self: *Font, canvas_item: RID, pos: Vector2, char: int, font_size: int, modulate: Color) -> float {
}
Font_draw_char_outline :: (using self: *Font, canvas_item: RID, pos: Vector2, char: int, font_size: int, size: int, modulate: Color) -> float {
}
Font_has_char :: (using self: *Font, char: int) -> bool {
}
Font_get_supported_chars :: (using self: *Font) -> String {
}
Font_is_language_supported :: (using self: *Font, language: String) -> bool {
}
Font_is_script_supported :: (using self: *Font, script: String) -> bool {
}
Font_get_supported_feature_list :: (using self: *Font) -> Dictionary {
}
Font_get_supported_variation_list :: (using self: *Font) -> Dictionary {
}
Font_get_face_count :: (using self: *Font) -> int {
}

// FontFile
FontFile :: struct {
	__private: *void;
}

FontFile_load_bitmap_font :: (using self: *FontFile, path: String) -> Error {
}
FontFile_load_dynamic_font :: (using self: *FontFile, path: String) -> Error {
}
FontFile_set_data :: (using self: *FontFile, data: PackedByteArray) {
}
FontFile_get_data :: (using self: *FontFile) -> PackedByteArray {
}
FontFile_set_font_name :: (using self: *FontFile, name: String) {
}
FontFile_set_font_style_name :: (using self: *FontFile, name: String) {
}
FontFile_set_font_style :: (using self: *FontFile, style: TextServer.FontStyle) {
}
FontFile_set_font_weight :: (using self: *FontFile, weight: int) {
}
FontFile_set_font_stretch :: (using self: *FontFile, stretch: int) {
}
FontFile_set_antialiasing :: (using self: *FontFile, antialiasing: TextServer.FontAntialiasing) {
}
FontFile_get_antialiasing :: (using self: *FontFile) -> TextServer.FontAntialiasing {
}
FontFile_set_disable_embedded_bitmaps :: (using self: *FontFile, disable_embedded_bitmaps: bool) {
}
FontFile_get_disable_embedded_bitmaps :: (using self: *FontFile) -> bool {
}
FontFile_set_generate_mipmaps :: (using self: *FontFile, generate_mipmaps: bool) {
}
FontFile_get_generate_mipmaps :: (using self: *FontFile) -> bool {
}
FontFile_set_multichannel_signed_distance_field :: (using self: *FontFile, msdf: bool) {
}
FontFile_is_multichannel_signed_distance_field :: (using self: *FontFile) -> bool {
}
FontFile_set_msdf_pixel_range :: (using self: *FontFile, msdf_pixel_range: int) {
}
FontFile_get_msdf_pixel_range :: (using self: *FontFile) -> int {
}
FontFile_set_msdf_size :: (using self: *FontFile, msdf_size: int) {
}
FontFile_get_msdf_size :: (using self: *FontFile) -> int {
}
FontFile_set_fixed_size :: (using self: *FontFile, fixed_size: int) {
}
FontFile_get_fixed_size :: (using self: *FontFile) -> int {
}
FontFile_set_fixed_size_scale_mode :: (using self: *FontFile, fixed_size_scale_mode: TextServer.FixedSizeScaleMode) {
}
FontFile_get_fixed_size_scale_mode :: (using self: *FontFile) -> TextServer.FixedSizeScaleMode {
}
FontFile_set_allow_system_fallback :: (using self: *FontFile, allow_system_fallback: bool) {
}
FontFile_is_allow_system_fallback :: (using self: *FontFile) -> bool {
}
FontFile_set_force_autohinter :: (using self: *FontFile, force_autohinter: bool) {
}
FontFile_is_force_autohinter :: (using self: *FontFile) -> bool {
}
FontFile_set_hinting :: (using self: *FontFile, hinting: TextServer.Hinting) {
}
FontFile_get_hinting :: (using self: *FontFile) -> TextServer.Hinting {
}
FontFile_set_subpixel_positioning :: (using self: *FontFile, subpixel_positioning: TextServer.SubpixelPositioning) {
}
FontFile_get_subpixel_positioning :: (using self: *FontFile) -> TextServer.SubpixelPositioning {
}
FontFile_set_oversampling :: (using self: *FontFile, oversampling: float) {
}
FontFile_get_oversampling :: (using self: *FontFile) -> float {
}
FontFile_get_cache_count :: (using self: *FontFile) -> int {
}
FontFile_clear_cache :: (using self: *FontFile) {
}
FontFile_remove_cache :: (using self: *FontFile, cache_index: int) {
}
FontFile_get_size_cache_list :: (using self: *FontFile, cache_index: int) -> Array {
}
FontFile_clear_size_cache :: (using self: *FontFile, cache_index: int) {
}
FontFile_remove_size_cache :: (using self: *FontFile, cache_index: int, size: Vector2i) {
}
FontFile_set_variation_coordinates :: (using self: *FontFile, cache_index: int, variation_coordinates: Dictionary) {
}
FontFile_get_variation_coordinates :: (using self: *FontFile, cache_index: int) -> Dictionary {
}
FontFile_set_embolden :: (using self: *FontFile, cache_index: int, strength: float) {
}
FontFile_get_embolden :: (using self: *FontFile, cache_index: int) -> float {
}
FontFile_set_transform :: (using self: *FontFile, cache_index: int, transform: Transform2D) {
}
FontFile_get_transform :: (using self: *FontFile, cache_index: int) -> Transform2D {
}
FontFile_set_extra_spacing :: (using self: *FontFile, cache_index: int, spacing: TextServer.SpacingType, value: int) {
}
FontFile_get_extra_spacing :: (using self: *FontFile, cache_index: int, spacing: TextServer.SpacingType) -> int {
}
FontFile_set_extra_baseline_offset :: (using self: *FontFile, cache_index: int, baseline_offset: float) {
}
FontFile_get_extra_baseline_offset :: (using self: *FontFile, cache_index: int) -> float {
}
FontFile_set_face_index :: (using self: *FontFile, cache_index: int, face_index: int) {
}
FontFile_get_face_index :: (using self: *FontFile, cache_index: int) -> int {
}
FontFile_set_cache_ascent :: (using self: *FontFile, cache_index: int, size: int, ascent: float) {
}
FontFile_get_cache_ascent :: (using self: *FontFile, cache_index: int, size: int) -> float {
}
FontFile_set_cache_descent :: (using self: *FontFile, cache_index: int, size: int, descent: float) {
}
FontFile_get_cache_descent :: (using self: *FontFile, cache_index: int, size: int) -> float {
}
FontFile_set_cache_underline_position :: (using self: *FontFile, cache_index: int, size: int, underline_position: float) {
}
FontFile_get_cache_underline_position :: (using self: *FontFile, cache_index: int, size: int) -> float {
}
FontFile_set_cache_underline_thickness :: (using self: *FontFile, cache_index: int, size: int, underline_thickness: float) {
}
FontFile_get_cache_underline_thickness :: (using self: *FontFile, cache_index: int, size: int) -> float {
}
FontFile_set_cache_scale :: (using self: *FontFile, cache_index: int, size: int, scale: float) {
}
FontFile_get_cache_scale :: (using self: *FontFile, cache_index: int, size: int) -> float {
}
FontFile_get_texture_count :: (using self: *FontFile, cache_index: int, size: Vector2i) -> int {
}
FontFile_clear_textures :: (using self: *FontFile, cache_index: int, size: Vector2i) {
}
FontFile_remove_texture :: (using self: *FontFile, cache_index: int, size: Vector2i, texture_index: int) {
}
FontFile_set_texture_image :: (using self: *FontFile, cache_index: int, size: Vector2i, texture_index: int, image: Image) {
}
FontFile_get_texture_image :: (using self: *FontFile, cache_index: int, size: Vector2i, texture_index: int) -> Image {
}
FontFile_set_texture_offsets :: (using self: *FontFile, cache_index: int, size: Vector2i, texture_index: int, offset: PackedInt32Array) {
}
FontFile_get_texture_offsets :: (using self: *FontFile, cache_index: int, size: Vector2i, texture_index: int) -> PackedInt32Array {
}
FontFile_get_glyph_list :: (using self: *FontFile, cache_index: int, size: Vector2i) -> PackedInt32Array {
}
FontFile_clear_glyphs :: (using self: *FontFile, cache_index: int, size: Vector2i) {
}
FontFile_remove_glyph :: (using self: *FontFile, cache_index: int, size: Vector2i, glyph: int) {
}
FontFile_set_glyph_advance :: (using self: *FontFile, cache_index: int, size: int, glyph: int, advance: Vector2) {
}
FontFile_get_glyph_advance :: (using self: *FontFile, cache_index: int, size: int, glyph: int) -> Vector2 {
}
FontFile_set_glyph_offset :: (using self: *FontFile, cache_index: int, size: Vector2i, glyph: int, offset: Vector2) {
}
FontFile_get_glyph_offset :: (using self: *FontFile, cache_index: int, size: Vector2i, glyph: int) -> Vector2 {
}
FontFile_set_glyph_size :: (using self: *FontFile, cache_index: int, size: Vector2i, glyph: int, gl_size: Vector2) {
}
FontFile_get_glyph_size :: (using self: *FontFile, cache_index: int, size: Vector2i, glyph: int) -> Vector2 {
}
FontFile_set_glyph_uv_rect :: (using self: *FontFile, cache_index: int, size: Vector2i, glyph: int, uv_rect: Rect2) {
}
FontFile_get_glyph_uv_rect :: (using self: *FontFile, cache_index: int, size: Vector2i, glyph: int) -> Rect2 {
}
FontFile_set_glyph_texture_idx :: (using self: *FontFile, cache_index: int, size: Vector2i, glyph: int, texture_idx: int) {
}
FontFile_get_glyph_texture_idx :: (using self: *FontFile, cache_index: int, size: Vector2i, glyph: int) -> int {
}
FontFile_get_kerning_list :: (using self: *FontFile, cache_index: int, size: int) -> Array {
}
FontFile_clear_kerning_map :: (using self: *FontFile, cache_index: int, size: int) {
}
FontFile_remove_kerning :: (using self: *FontFile, cache_index: int, size: int, glyph_pair: Vector2i) {
}
FontFile_set_kerning :: (using self: *FontFile, cache_index: int, size: int, glyph_pair: Vector2i, kerning: Vector2) {
}
FontFile_get_kerning :: (using self: *FontFile, cache_index: int, size: int, glyph_pair: Vector2i) -> Vector2 {
}
FontFile_render_range :: (using self: *FontFile, cache_index: int, size: Vector2i, start: int, end: int) {
}
FontFile_render_glyph :: (using self: *FontFile, cache_index: int, size: Vector2i, index: int) {
}
FontFile_set_language_support_override :: (using self: *FontFile, language: String, supported: bool) {
}
FontFile_get_language_support_override :: (using self: *FontFile, language: String) -> bool {
}
FontFile_remove_language_support_override :: (using self: *FontFile, language: String) {
}
FontFile_get_language_support_overrides :: (using self: *FontFile) -> PackedStringArray {
}
FontFile_set_script_support_override :: (using self: *FontFile, script: String, supported: bool) {
}
FontFile_get_script_support_override :: (using self: *FontFile, script: String) -> bool {
}
FontFile_remove_script_support_override :: (using self: *FontFile, script: String) {
}
FontFile_get_script_support_overrides :: (using self: *FontFile) -> PackedStringArray {
}
FontFile_set_opentype_feature_overrides :: (using self: *FontFile, overrides: Dictionary) {
}
FontFile_get_opentype_feature_overrides :: (using self: *FontFile) -> Dictionary {
}
FontFile_get_glyph_index :: (using self: *FontFile, size: int, char: int, variation_selector: int) -> int {
}
FontFile_get_char_from_glyph_index :: (using self: *FontFile, size: int, glyph_index: int) -> int {
}

// FontVariation
FontVariation :: struct {
	__private: *void;
}

FontVariation_set_base_font :: (using self: *FontVariation, font: Font) {
}
FontVariation_get_base_font :: (using self: *FontVariation) -> Font {
}
FontVariation_set_variation_opentype :: (using self: *FontVariation, coords: Dictionary) {
}
FontVariation_get_variation_opentype :: (using self: *FontVariation) -> Dictionary {
}
FontVariation_set_variation_embolden :: (using self: *FontVariation, strength: float) {
}
FontVariation_get_variation_embolden :: (using self: *FontVariation) -> float {
}
FontVariation_set_variation_face_index :: (using self: *FontVariation, face_index: int) {
}
FontVariation_get_variation_face_index :: (using self: *FontVariation) -> int {
}
FontVariation_set_variation_transform :: (using self: *FontVariation, transform: Transform2D) {
}
FontVariation_get_variation_transform :: (using self: *FontVariation) -> Transform2D {
}
FontVariation_set_opentype_features :: (using self: *FontVariation, features: Dictionary) {
}
FontVariation_set_spacing :: (using self: *FontVariation, spacing: TextServer.SpacingType, value: int) {
}
FontVariation_set_baseline_offset :: (using self: *FontVariation, baseline_offset: float) {
}
FontVariation_get_baseline_offset :: (using self: *FontVariation) -> float {
}

// FramebufferCacheRD
FramebufferCacheRD :: struct {
	__private: *void;
}

FramebufferCacheRD_get_cache_multipass :: (using self: *FramebufferCacheRD, textures: Array, passes: Array, views: int) -> RID {
}

// GDExtension
GDExtension :: struct {
	__private: *void;

	InitializationLevel :: enum {
		INITIALIZATION_LEVEL_CORE :: 0;
		INITIALIZATION_LEVEL_SERVERS :: 1;
		INITIALIZATION_LEVEL_SCENE :: 2;
		INITIALIZATION_LEVEL_EDITOR :: 3;
	}
}

GDExtension_is_library_open :: (using self: *GDExtension) -> bool {
}
GDExtension_get_minimum_library_initialization_level :: (using self: *GDExtension) -> GDExtension.InitializationLevel {
}

// GDExtensionManager
GDExtensionManager :: struct {
	__private: *void;

	LoadStatus :: enum {
		LOAD_STATUS_OK :: 0;
		LOAD_STATUS_FAILED :: 1;
		LOAD_STATUS_ALREADY_LOADED :: 2;
		LOAD_STATUS_NOT_LOADED :: 3;
		LOAD_STATUS_NEEDS_RESTART :: 4;
	}
}

GDExtensionManager_load_extension :: (using self: *GDExtensionManager, path: String) -> GDExtensionManager.LoadStatus {
}
GDExtensionManager_reload_extension :: (using self: *GDExtensionManager, path: String) -> GDExtensionManager.LoadStatus {
}
GDExtensionManager_unload_extension :: (using self: *GDExtensionManager, path: String) -> GDExtensionManager.LoadStatus {
}
GDExtensionManager_is_extension_loaded :: (using self: *GDExtensionManager, path: String) -> bool {
}
GDExtensionManager_get_loaded_extensions :: (using self: *GDExtensionManager) -> PackedStringArray {
}
GDExtensionManager_get_extension :: (using self: *GDExtensionManager, path: String) -> GDExtension {
}

// GDScript
GDScript :: struct {
	__private: *void;
}

GDScript_new :: (using self: *GDScript) -> Variant {
}

// GLTFAccessor
GLTFAccessor :: struct {
	__private: *void;

	GLTFAccessorType :: enum {
		TYPE_SCALAR :: 0;
		TYPE_VEC2 :: 1;
		TYPE_VEC3 :: 2;
		TYPE_VEC4 :: 3;
		TYPE_MAT2 :: 4;
		TYPE_MAT3 :: 5;
		TYPE_MAT4 :: 6;
	}
}

GLTFAccessor_get_buffer_view :: (using self: *GLTFAccessor) -> int {
}
GLTFAccessor_set_buffer_view :: (using self: *GLTFAccessor, buffer_view: int) {
}
GLTFAccessor_get_byte_offset :: (using self: *GLTFAccessor) -> int {
}
GLTFAccessor_set_byte_offset :: (using self: *GLTFAccessor, byte_offset: int) {
}
GLTFAccessor_get_component_type :: (using self: *GLTFAccessor) -> int {
}
GLTFAccessor_set_component_type :: (using self: *GLTFAccessor, component_type: int) {
}
GLTFAccessor_get_normalized :: (using self: *GLTFAccessor) -> bool {
}
GLTFAccessor_set_normalized :: (using self: *GLTFAccessor, normalized: bool) {
}
GLTFAccessor_get_count :: (using self: *GLTFAccessor) -> int {
}
GLTFAccessor_set_count :: (using self: *GLTFAccessor, count: int) {
}
GLTFAccessor_get_accessor_type :: (using self: *GLTFAccessor) -> GLTFAccessor.GLTFAccessorType {
}
GLTFAccessor_set_accessor_type :: (using self: *GLTFAccessor, accessor_type: GLTFAccessor.GLTFAccessorType) {
}
GLTFAccessor_get_type :: (using self: *GLTFAccessor) -> int {
}
GLTFAccessor_set_type :: (using self: *GLTFAccessor, type: int) {
}
GLTFAccessor_get_min :: (using self: *GLTFAccessor) -> PackedFloat64Array {
}
GLTFAccessor_set_min :: (using self: *GLTFAccessor, min: PackedFloat64Array) {
}
GLTFAccessor_get_max :: (using self: *GLTFAccessor) -> PackedFloat64Array {
}
GLTFAccessor_set_max :: (using self: *GLTFAccessor, max: PackedFloat64Array) {
}
GLTFAccessor_get_sparse_count :: (using self: *GLTFAccessor) -> int {
}
GLTFAccessor_set_sparse_count :: (using self: *GLTFAccessor, sparse_count: int) {
}
GLTFAccessor_get_sparse_indices_buffer_view :: (using self: *GLTFAccessor) -> int {
}
GLTFAccessor_set_sparse_indices_buffer_view :: (using self: *GLTFAccessor, sparse_indices_buffer_view: int) {
}
GLTFAccessor_get_sparse_indices_byte_offset :: (using self: *GLTFAccessor) -> int {
}
GLTFAccessor_set_sparse_indices_byte_offset :: (using self: *GLTFAccessor, sparse_indices_byte_offset: int) {
}
GLTFAccessor_get_sparse_indices_component_type :: (using self: *GLTFAccessor) -> int {
}
GLTFAccessor_set_sparse_indices_component_type :: (using self: *GLTFAccessor, sparse_indices_component_type: int) {
}
GLTFAccessor_get_sparse_values_buffer_view :: (using self: *GLTFAccessor) -> int {
}
GLTFAccessor_set_sparse_values_buffer_view :: (using self: *GLTFAccessor, sparse_values_buffer_view: int) {
}
GLTFAccessor_get_sparse_values_byte_offset :: (using self: *GLTFAccessor) -> int {
}
GLTFAccessor_set_sparse_values_byte_offset :: (using self: *GLTFAccessor, sparse_values_byte_offset: int) {
}

// GLTFAnimation
GLTFAnimation :: struct {
	__private: *void;
}

GLTFAnimation_get_original_name :: (using self: *GLTFAnimation) -> String {
}
GLTFAnimation_set_original_name :: (using self: *GLTFAnimation, original_name: String) {
}
GLTFAnimation_get_loop :: (using self: *GLTFAnimation) -> bool {
}
GLTFAnimation_set_loop :: (using self: *GLTFAnimation, loop: bool) {
}
GLTFAnimation_get_additional_data :: (using self: *GLTFAnimation, extension_name: StringName) -> Variant {
}
GLTFAnimation_set_additional_data :: (using self: *GLTFAnimation, extension_name: StringName, additional_data: Variant) {
}

// GLTFBufferView
GLTFBufferView :: struct {
	__private: *void;
}

GLTFBufferView_load_buffer_view_data :: (using self: *GLTFBufferView, state: GLTFState) -> PackedByteArray {
}
GLTFBufferView_get_buffer :: (using self: *GLTFBufferView) -> int {
}
GLTFBufferView_set_buffer :: (using self: *GLTFBufferView, buffer: int) {
}
GLTFBufferView_get_byte_offset :: (using self: *GLTFBufferView) -> int {
}
GLTFBufferView_set_byte_offset :: (using self: *GLTFBufferView, byte_offset: int) {
}
GLTFBufferView_get_byte_length :: (using self: *GLTFBufferView) -> int {
}
GLTFBufferView_set_byte_length :: (using self: *GLTFBufferView, byte_length: int) {
}
GLTFBufferView_get_byte_stride :: (using self: *GLTFBufferView) -> int {
}
GLTFBufferView_set_byte_stride :: (using self: *GLTFBufferView, byte_stride: int) {
}
GLTFBufferView_get_indices :: (using self: *GLTFBufferView) -> bool {
}
GLTFBufferView_set_indices :: (using self: *GLTFBufferView, indices: bool) {
}
GLTFBufferView_get_vertex_attributes :: (using self: *GLTFBufferView) -> bool {
}
GLTFBufferView_set_vertex_attributes :: (using self: *GLTFBufferView, is_attributes: bool) {
}

// GLTFCamera
GLTFCamera :: struct {
	__private: *void;
}

GLTFCamera_from_node :: (using self: *GLTFCamera, camera_node: Camera3D) -> GLTFCamera {
}
GLTFCamera_to_node :: (using self: *GLTFCamera) -> Camera3D {
}
GLTFCamera_from_dictionary :: (using self: *GLTFCamera, dictionary: Dictionary) -> GLTFCamera {
}
GLTFCamera_to_dictionary :: (using self: *GLTFCamera) -> Dictionary {
}
GLTFCamera_get_perspective :: (using self: *GLTFCamera) -> bool {
}
GLTFCamera_set_perspective :: (using self: *GLTFCamera, perspective: bool) {
}
GLTFCamera_get_fov :: (using self: *GLTFCamera) -> float {
}
GLTFCamera_set_fov :: (using self: *GLTFCamera, fov: float) {
}
GLTFCamera_get_size_mag :: (using self: *GLTFCamera) -> float {
}
GLTFCamera_set_size_mag :: (using self: *GLTFCamera, size_mag: float) {
}
GLTFCamera_get_depth_far :: (using self: *GLTFCamera) -> float {
}
GLTFCamera_set_depth_far :: (using self: *GLTFCamera, zdepth_far: float) {
}
GLTFCamera_get_depth_near :: (using self: *GLTFCamera) -> float {
}
GLTFCamera_set_depth_near :: (using self: *GLTFCamera, zdepth_near: float) {
}

// GLTFDocument
GLTFDocument :: struct {
	__private: *void;

	RootNodeMode :: enum {
		ROOT_NODE_MODE_SINGLE_ROOT :: 0;
		ROOT_NODE_MODE_KEEP_ROOT :: 1;
		ROOT_NODE_MODE_MULTI_ROOT :: 2;
	}
}

GLTFDocument_set_image_format :: (using self: *GLTFDocument, image_format: String) {
}
GLTFDocument_get_image_format :: (using self: *GLTFDocument) -> String {
}
GLTFDocument_set_lossy_quality :: (using self: *GLTFDocument, lossy_quality: float) {
}
GLTFDocument_get_lossy_quality :: (using self: *GLTFDocument) -> float {
}
GLTFDocument_set_root_node_mode :: (using self: *GLTFDocument, root_node_mode: GLTFDocument.RootNodeMode) {
}
GLTFDocument_get_root_node_mode :: (using self: *GLTFDocument) -> GLTFDocument.RootNodeMode {
}
GLTFDocument_append_from_file :: (using self: *GLTFDocument, path: String, state: GLTFState, flags: int, base_path: String) -> Error {
}
GLTFDocument_append_from_buffer :: (using self: *GLTFDocument, bytes: PackedByteArray, base_path: String, state: GLTFState, flags: int) -> Error {
}
GLTFDocument_append_from_scene :: (using self: *GLTFDocument, node: Node, state: GLTFState, flags: int) -> Error {
}
GLTFDocument_generate_scene :: (using self: *GLTFDocument, state: GLTFState, bake_fps: float, trimming: bool, remove_immutable_tracks: bool) -> Node {
}
GLTFDocument_generate_buffer :: (using self: *GLTFDocument, state: GLTFState) -> PackedByteArray {
}
GLTFDocument_write_to_filesystem :: (using self: *GLTFDocument, state: GLTFState, path: String) -> Error {
}
GLTFDocument_register_gltf_document_extension :: (using self: *GLTFDocument, extension: GLTFDocumentExtension, first_priority: bool) {
}
GLTFDocument_unregister_gltf_document_extension :: (using self: *GLTFDocument, extension: GLTFDocumentExtension) {
}

// GLTFDocumentExtension
GLTFDocumentExtension :: struct {
	__private: *void;
}

GLTFDocumentExtension__import_preflight :: (using self: *GLTFDocumentExtension, state: GLTFState, extensions: PackedStringArray) -> Error {
}
GLTFDocumentExtension__get_supported_extensions :: (using self: *GLTFDocumentExtension) -> PackedStringArray {
}
GLTFDocumentExtension__parse_node_extensions :: (using self: *GLTFDocumentExtension, state: GLTFState, gltf_node: GLTFNode, extensions: Dictionary) -> Error {
}
GLTFDocumentExtension__parse_image_data :: (using self: *GLTFDocumentExtension, state: GLTFState, image_data: PackedByteArray, mime_type: String, ret_image: Image) -> Error {
}
GLTFDocumentExtension__get_image_file_extension :: (using self: *GLTFDocumentExtension) -> String {
}
GLTFDocumentExtension__parse_texture_json :: (using self: *GLTFDocumentExtension, state: GLTFState, texture_json: Dictionary, ret_gltf_texture: GLTFTexture) -> Error {
}
GLTFDocumentExtension__generate_scene_node :: (using self: *GLTFDocumentExtension, state: GLTFState, gltf_node: GLTFNode, scene_parent: Node) -> Node3D {
}
GLTFDocumentExtension__import_post_parse :: (using self: *GLTFDocumentExtension, state: GLTFState) -> Error {
}
GLTFDocumentExtension__import_node :: (using self: *GLTFDocumentExtension, state: GLTFState, gltf_node: GLTFNode, json: Dictionary, node: Node) -> Error {
}
GLTFDocumentExtension__import_post :: (using self: *GLTFDocumentExtension, state: GLTFState, root: Node) -> Error {
}
GLTFDocumentExtension__export_preflight :: (using self: *GLTFDocumentExtension, state: GLTFState, root: Node) -> Error {
}
GLTFDocumentExtension__convert_scene_node :: (using self: *GLTFDocumentExtension, state: GLTFState, gltf_node: GLTFNode, scene_node: Node) {
}
GLTFDocumentExtension__export_preserialize :: (using self: *GLTFDocumentExtension, state: GLTFState) -> Error {
}
GLTFDocumentExtension__get_saveable_image_formats :: (using self: *GLTFDocumentExtension) -> PackedStringArray {
}
GLTFDocumentExtension__serialize_image_to_bytes :: (using self: *GLTFDocumentExtension, state: GLTFState, image: Image, image_dict: Dictionary, image_format: String, lossy_quality: float) -> PackedByteArray {
}
GLTFDocumentExtension__save_image_at_path :: (using self: *GLTFDocumentExtension, state: GLTFState, image: Image, file_path: String, image_format: String, lossy_quality: float) -> Error {
}
GLTFDocumentExtension__serialize_texture_json :: (using self: *GLTFDocumentExtension, state: GLTFState, texture_json: Dictionary, gltf_texture: GLTFTexture, image_format: String) -> Error {
}
GLTFDocumentExtension__export_node :: (using self: *GLTFDocumentExtension, state: GLTFState, gltf_node: GLTFNode, json: Dictionary, node: Node) -> Error {
}
GLTFDocumentExtension__export_post :: (using self: *GLTFDocumentExtension, state: GLTFState) -> Error {
}

// GLTFDocumentExtensionConvertImporterMesh
GLTFDocumentExtensionConvertImporterMesh :: struct {
	__private: *void;
}

// GLTFLight
GLTFLight :: struct {
	__private: *void;
}

GLTFLight_from_node :: (using self: *GLTFLight, light_node: Light3D) -> GLTFLight {
}
GLTFLight_to_node :: (using self: *GLTFLight) -> Light3D {
}
GLTFLight_from_dictionary :: (using self: *GLTFLight, dictionary: Dictionary) -> GLTFLight {
}
GLTFLight_to_dictionary :: (using self: *GLTFLight) -> Dictionary {
}
GLTFLight_get_color :: (using self: *GLTFLight) -> Color {
}
GLTFLight_set_color :: (using self: *GLTFLight, color: Color) {
}
GLTFLight_get_intensity :: (using self: *GLTFLight) -> float {
}
GLTFLight_set_intensity :: (using self: *GLTFLight, intensity: float) {
}
GLTFLight_get_light_type :: (using self: *GLTFLight) -> String {
}
GLTFLight_set_light_type :: (using self: *GLTFLight, light_type: String) {
}
GLTFLight_get_range :: (using self: *GLTFLight) -> float {
}
GLTFLight_set_range :: (using self: *GLTFLight, range: float) {
}
GLTFLight_get_inner_cone_angle :: (using self: *GLTFLight) -> float {
}
GLTFLight_set_inner_cone_angle :: (using self: *GLTFLight, inner_cone_angle: float) {
}
GLTFLight_get_outer_cone_angle :: (using self: *GLTFLight) -> float {
}
GLTFLight_set_outer_cone_angle :: (using self: *GLTFLight, outer_cone_angle: float) {
}
GLTFLight_get_additional_data :: (using self: *GLTFLight, extension_name: StringName) -> Variant {
}
GLTFLight_set_additional_data :: (using self: *GLTFLight, extension_name: StringName, additional_data: Variant) {
}

// GLTFMesh
GLTFMesh :: struct {
	__private: *void;
}

GLTFMesh_get_original_name :: (using self: *GLTFMesh) -> String {
}
GLTFMesh_set_original_name :: (using self: *GLTFMesh, original_name: String) {
}
GLTFMesh_get_mesh :: (using self: *GLTFMesh) -> ImporterMesh {
}
GLTFMesh_set_mesh :: (using self: *GLTFMesh, mesh: ImporterMesh) {
}
GLTFMesh_get_blend_weights :: (using self: *GLTFMesh) -> PackedFloat32Array {
}
GLTFMesh_set_blend_weights :: (using self: *GLTFMesh, blend_weights: PackedFloat32Array) {
}
GLTFMesh_get_instance_materials :: (using self: *GLTFMesh) -> Array {
}
GLTFMesh_set_instance_materials :: (using self: *GLTFMesh, instance_materials: Array) {
}
GLTFMesh_get_additional_data :: (using self: *GLTFMesh, extension_name: StringName) -> Variant {
}
GLTFMesh_set_additional_data :: (using self: *GLTFMesh, extension_name: StringName, additional_data: Variant) {
}

// GLTFNode
GLTFNode :: struct {
	__private: *void;
}

GLTFNode_get_original_name :: (using self: *GLTFNode) -> String {
}
GLTFNode_set_original_name :: (using self: *GLTFNode, original_name: String) {
}
GLTFNode_get_parent :: (using self: *GLTFNode) -> int {
}
GLTFNode_set_parent :: (using self: *GLTFNode, parent: int) {
}
GLTFNode_get_height :: (using self: *GLTFNode) -> int {
}
GLTFNode_set_height :: (using self: *GLTFNode, height: int) {
}
GLTFNode_get_xform :: (using self: *GLTFNode) -> Transform3D {
}
GLTFNode_set_xform :: (using self: *GLTFNode, xform: Transform3D) {
}
GLTFNode_get_mesh :: (using self: *GLTFNode) -> int {
}
GLTFNode_set_mesh :: (using self: *GLTFNode, mesh: int) {
}
GLTFNode_get_camera :: (using self: *GLTFNode) -> int {
}
GLTFNode_set_camera :: (using self: *GLTFNode, camera: int) {
}
GLTFNode_get_skin :: (using self: *GLTFNode) -> int {
}
GLTFNode_set_skin :: (using self: *GLTFNode, skin: int) {
}
GLTFNode_get_skeleton :: (using self: *GLTFNode) -> int {
}
GLTFNode_set_skeleton :: (using self: *GLTFNode, skeleton: int) {
}
GLTFNode_get_position :: (using self: *GLTFNode) -> Vector3 {
}
GLTFNode_set_position :: (using self: *GLTFNode, position: Vector3) {
}
GLTFNode_get_rotation :: (using self: *GLTFNode) -> Quaternion {
}
GLTFNode_set_rotation :: (using self: *GLTFNode, rotation: Quaternion) {
}
GLTFNode_get_scale :: (using self: *GLTFNode) -> Vector3 {
}
GLTFNode_set_scale :: (using self: *GLTFNode, scale: Vector3) {
}
GLTFNode_get_children :: (using self: *GLTFNode) -> PackedInt32Array {
}
GLTFNode_set_children :: (using self: *GLTFNode, children: PackedInt32Array) {
}
GLTFNode_get_light :: (using self: *GLTFNode) -> int {
}
GLTFNode_set_light :: (using self: *GLTFNode, light: int) {
}
GLTFNode_get_additional_data :: (using self: *GLTFNode, extension_name: StringName) -> Variant {
}
GLTFNode_set_additional_data :: (using self: *GLTFNode, extension_name: StringName, additional_data: Variant) {
}

// GLTFPhysicsBody
GLTFPhysicsBody :: struct {
	__private: *void;
}

GLTFPhysicsBody_from_node :: (using self: *GLTFPhysicsBody, body_node: CollisionObject3D) -> GLTFPhysicsBody {
}
GLTFPhysicsBody_to_node :: (using self: *GLTFPhysicsBody) -> CollisionObject3D {
}
GLTFPhysicsBody_from_dictionary :: (using self: *GLTFPhysicsBody, dictionary: Dictionary) -> GLTFPhysicsBody {
}
GLTFPhysicsBody_to_dictionary :: (using self: *GLTFPhysicsBody) -> Dictionary {
}
GLTFPhysicsBody_get_body_type :: (using self: *GLTFPhysicsBody) -> String {
}
GLTFPhysicsBody_set_body_type :: (using self: *GLTFPhysicsBody, body_type: String) {
}
GLTFPhysicsBody_get_mass :: (using self: *GLTFPhysicsBody) -> float {
}
GLTFPhysicsBody_set_mass :: (using self: *GLTFPhysicsBody, mass: float) {
}
GLTFPhysicsBody_get_linear_velocity :: (using self: *GLTFPhysicsBody) -> Vector3 {
}
GLTFPhysicsBody_set_linear_velocity :: (using self: *GLTFPhysicsBody, linear_velocity: Vector3) {
}
GLTFPhysicsBody_get_angular_velocity :: (using self: *GLTFPhysicsBody) -> Vector3 {
}
GLTFPhysicsBody_set_angular_velocity :: (using self: *GLTFPhysicsBody, angular_velocity: Vector3) {
}
GLTFPhysicsBody_get_center_of_mass :: (using self: *GLTFPhysicsBody) -> Vector3 {
}
GLTFPhysicsBody_set_center_of_mass :: (using self: *GLTFPhysicsBody, center_of_mass: Vector3) {
}
GLTFPhysicsBody_get_inertia_diagonal :: (using self: *GLTFPhysicsBody) -> Vector3 {
}
GLTFPhysicsBody_set_inertia_diagonal :: (using self: *GLTFPhysicsBody, inertia_diagonal: Vector3) {
}
GLTFPhysicsBody_get_inertia_orientation :: (using self: *GLTFPhysicsBody) -> Quaternion {
}
GLTFPhysicsBody_set_inertia_orientation :: (using self: *GLTFPhysicsBody, inertia_orientation: Quaternion) {
}
GLTFPhysicsBody_get_inertia_tensor :: (using self: *GLTFPhysicsBody) -> Basis {
}
GLTFPhysicsBody_set_inertia_tensor :: (using self: *GLTFPhysicsBody, inertia_tensor: Basis) {
}

// GLTFPhysicsShape
GLTFPhysicsShape :: struct {
	__private: *void;
}

GLTFPhysicsShape_from_node :: (using self: *GLTFPhysicsShape, shape_node: CollisionShape3D) -> GLTFPhysicsShape {
}
GLTFPhysicsShape_to_node :: (using self: *GLTFPhysicsShape, cache_shapes: bool) -> CollisionShape3D {
}
GLTFPhysicsShape_from_resource :: (using self: *GLTFPhysicsShape, shape_resource: Shape3D) -> GLTFPhysicsShape {
}
GLTFPhysicsShape_to_resource :: (using self: *GLTFPhysicsShape, cache_shapes: bool) -> Shape3D {
}
GLTFPhysicsShape_from_dictionary :: (using self: *GLTFPhysicsShape, dictionary: Dictionary) -> GLTFPhysicsShape {
}
GLTFPhysicsShape_to_dictionary :: (using self: *GLTFPhysicsShape) -> Dictionary {
}
GLTFPhysicsShape_get_shape_type :: (using self: *GLTFPhysicsShape) -> String {
}
GLTFPhysicsShape_set_shape_type :: (using self: *GLTFPhysicsShape, shape_type: String) {
}
GLTFPhysicsShape_get_size :: (using self: *GLTFPhysicsShape) -> Vector3 {
}
GLTFPhysicsShape_set_size :: (using self: *GLTFPhysicsShape, size: Vector3) {
}
GLTFPhysicsShape_get_radius :: (using self: *GLTFPhysicsShape) -> float {
}
GLTFPhysicsShape_set_radius :: (using self: *GLTFPhysicsShape, radius: float) {
}
GLTFPhysicsShape_get_height :: (using self: *GLTFPhysicsShape) -> float {
}
GLTFPhysicsShape_set_height :: (using self: *GLTFPhysicsShape, height: float) {
}
GLTFPhysicsShape_get_is_trigger :: (using self: *GLTFPhysicsShape) -> bool {
}
GLTFPhysicsShape_set_is_trigger :: (using self: *GLTFPhysicsShape, is_trigger: bool) {
}
GLTFPhysicsShape_get_mesh_index :: (using self: *GLTFPhysicsShape) -> int {
}
GLTFPhysicsShape_set_mesh_index :: (using self: *GLTFPhysicsShape, mesh_index: int) {
}
GLTFPhysicsShape_get_importer_mesh :: (using self: *GLTFPhysicsShape) -> ImporterMesh {
}
GLTFPhysicsShape_set_importer_mesh :: (using self: *GLTFPhysicsShape, importer_mesh: ImporterMesh) {
}

// GLTFSkeleton
GLTFSkeleton :: struct {
	__private: *void;
}

GLTFSkeleton_get_joints :: (using self: *GLTFSkeleton) -> PackedInt32Array {
}
GLTFSkeleton_set_joints :: (using self: *GLTFSkeleton, joints: PackedInt32Array) {
}
GLTFSkeleton_get_roots :: (using self: *GLTFSkeleton) -> PackedInt32Array {
}
GLTFSkeleton_set_roots :: (using self: *GLTFSkeleton, roots: PackedInt32Array) {
}
GLTFSkeleton_get_godot_skeleton :: (using self: *GLTFSkeleton) -> Skeleton3D {
}
GLTFSkeleton_get_unique_names :: (using self: *GLTFSkeleton) -> Array {
}
GLTFSkeleton_set_unique_names :: (using self: *GLTFSkeleton, unique_names: Array) {
}
GLTFSkeleton_get_godot_bone_node :: (using self: *GLTFSkeleton) -> Dictionary {
}
GLTFSkeleton_set_godot_bone_node :: (using self: *GLTFSkeleton, godot_bone_node: Dictionary) {
}
GLTFSkeleton_get_bone_attachment_count :: (using self: *GLTFSkeleton) -> int {
}
GLTFSkeleton_get_bone_attachment :: (using self: *GLTFSkeleton, idx: int) -> BoneAttachment3D {
}

// GLTFSkin
GLTFSkin :: struct {
	__private: *void;
}

GLTFSkin_get_skin_root :: (using self: *GLTFSkin) -> int {
}
GLTFSkin_set_skin_root :: (using self: *GLTFSkin, skin_root: int) {
}
GLTFSkin_get_joints_original :: (using self: *GLTFSkin) -> PackedInt32Array {
}
GLTFSkin_set_joints_original :: (using self: *GLTFSkin, joints_original: PackedInt32Array) {
}
GLTFSkin_get_inverse_binds :: (using self: *GLTFSkin) -> Array {
}
GLTFSkin_set_inverse_binds :: (using self: *GLTFSkin, inverse_binds: Array) {
}
GLTFSkin_get_joints :: (using self: *GLTFSkin) -> PackedInt32Array {
}
GLTFSkin_set_joints :: (using self: *GLTFSkin, joints: PackedInt32Array) {
}
GLTFSkin_get_non_joints :: (using self: *GLTFSkin) -> PackedInt32Array {
}
GLTFSkin_set_non_joints :: (using self: *GLTFSkin, non_joints: PackedInt32Array) {
}
GLTFSkin_get_roots :: (using self: *GLTFSkin) -> PackedInt32Array {
}
GLTFSkin_set_roots :: (using self: *GLTFSkin, roots: PackedInt32Array) {
}
GLTFSkin_get_skeleton :: (using self: *GLTFSkin) -> int {
}
GLTFSkin_set_skeleton :: (using self: *GLTFSkin, skeleton: int) {
}
GLTFSkin_get_joint_i_to_bone_i :: (using self: *GLTFSkin) -> Dictionary {
}
GLTFSkin_set_joint_i_to_bone_i :: (using self: *GLTFSkin, joint_i_to_bone_i: Dictionary) {
}
GLTFSkin_get_joint_i_to_name :: (using self: *GLTFSkin) -> Dictionary {
}
GLTFSkin_set_joint_i_to_name :: (using self: *GLTFSkin, joint_i_to_name: Dictionary) {
}
GLTFSkin_get_godot_skin :: (using self: *GLTFSkin) -> Skin {
}
GLTFSkin_set_godot_skin :: (using self: *GLTFSkin, godot_skin: Skin) {
}

// GLTFSpecGloss
GLTFSpecGloss :: struct {
	__private: *void;
}

GLTFSpecGloss_get_diffuse_img :: (using self: *GLTFSpecGloss) -> Image {
}
GLTFSpecGloss_set_diffuse_img :: (using self: *GLTFSpecGloss, diffuse_img: Image) {
}
GLTFSpecGloss_get_diffuse_factor :: (using self: *GLTFSpecGloss) -> Color {
}
GLTFSpecGloss_set_diffuse_factor :: (using self: *GLTFSpecGloss, diffuse_factor: Color) {
}
GLTFSpecGloss_get_gloss_factor :: (using self: *GLTFSpecGloss) -> float {
}
GLTFSpecGloss_set_gloss_factor :: (using self: *GLTFSpecGloss, gloss_factor: float) {
}
GLTFSpecGloss_get_specular_factor :: (using self: *GLTFSpecGloss) -> Color {
}
GLTFSpecGloss_set_specular_factor :: (using self: *GLTFSpecGloss, specular_factor: Color) {
}
GLTFSpecGloss_get_spec_gloss_img :: (using self: *GLTFSpecGloss) -> Image {
}
GLTFSpecGloss_set_spec_gloss_img :: (using self: *GLTFSpecGloss, spec_gloss_img: Image) {
}

// GLTFState
GLTFState :: struct {
	__private: *void;

	HANDLE_BINARY_DISCARD_TEXTURES :: 0;
	HANDLE_BINARY_EXTRACT_TEXTURES :: 1;
	HANDLE_BINARY_EMBED_AS_BASISU :: 2;
	HANDLE_BINARY_EMBED_AS_UNCOMPRESSED :: 3;
}

GLTFState_add_used_extension :: (using self: *GLTFState, extension_name: String, required: bool) {
}
GLTFState_append_data_to_buffers :: (using self: *GLTFState, data: PackedByteArray, deduplication: bool) -> int {
}
GLTFState_get_json :: (using self: *GLTFState) -> Dictionary {
}
GLTFState_set_json :: (using self: *GLTFState, json: Dictionary) {
}
GLTFState_get_major_version :: (using self: *GLTFState) -> int {
}
GLTFState_set_major_version :: (using self: *GLTFState, major_version: int) {
}
GLTFState_get_minor_version :: (using self: *GLTFState) -> int {
}
GLTFState_set_minor_version :: (using self: *GLTFState, minor_version: int) {
}
GLTFState_get_copyright :: (using self: *GLTFState) -> String {
}
GLTFState_set_copyright :: (using self: *GLTFState, copyright: String) {
}
GLTFState_get_glb_data :: (using self: *GLTFState) -> PackedByteArray {
}
GLTFState_set_glb_data :: (using self: *GLTFState, glb_data: PackedByteArray) {
}
GLTFState_get_use_named_skin_binds :: (using self: *GLTFState) -> bool {
}
GLTFState_set_use_named_skin_binds :: (using self: *GLTFState, use_named_skin_binds: bool) {
}
GLTFState_get_nodes :: (using self: *GLTFState) -> Array {
}
GLTFState_set_nodes :: (using self: *GLTFState, nodes: Array) {
}
GLTFState_get_buffers :: (using self: *GLTFState) -> Array {
}
GLTFState_set_buffers :: (using self: *GLTFState, buffers: Array) {
}
GLTFState_get_buffer_views :: (using self: *GLTFState) -> Array {
}
GLTFState_set_buffer_views :: (using self: *GLTFState, buffer_views: Array) {
}
GLTFState_get_accessors :: (using self: *GLTFState) -> Array {
}
GLTFState_set_accessors :: (using self: *GLTFState, accessors: Array) {
}
GLTFState_get_meshes :: (using self: *GLTFState) -> Array {
}
GLTFState_set_meshes :: (using self: *GLTFState, meshes: Array) {
}
GLTFState_get_animation_players_count :: (using self: *GLTFState, idx: int) -> int {
}
GLTFState_get_animation_player :: (using self: *GLTFState, idx: int) -> AnimationPlayer {
}
GLTFState_get_materials :: (using self: *GLTFState) -> Array {
}
GLTFState_set_materials :: (using self: *GLTFState, materials: Array) {
}
GLTFState_get_scene_name :: (using self: *GLTFState) -> String {
}
GLTFState_set_scene_name :: (using self: *GLTFState, scene_name: String) {
}
GLTFState_get_base_path :: (using self: *GLTFState) -> String {
}
GLTFState_set_base_path :: (using self: *GLTFState, base_path: String) {
}
GLTFState_get_filename :: (using self: *GLTFState) -> String {
}
GLTFState_set_filename :: (using self: *GLTFState, filename: String) {
}
GLTFState_get_root_nodes :: (using self: *GLTFState) -> PackedInt32Array {
}
GLTFState_set_root_nodes :: (using self: *GLTFState, root_nodes: PackedInt32Array) {
}
GLTFState_get_textures :: (using self: *GLTFState) -> Array {
}
GLTFState_set_textures :: (using self: *GLTFState, textures: Array) {
}
GLTFState_get_texture_samplers :: (using self: *GLTFState) -> Array {
}
GLTFState_set_texture_samplers :: (using self: *GLTFState, texture_samplers: Array) {
}
GLTFState_get_images :: (using self: *GLTFState) -> Array {
}
GLTFState_set_images :: (using self: *GLTFState, images: Array) {
}
GLTFState_get_skins :: (using self: *GLTFState) -> Array {
}
GLTFState_set_skins :: (using self: *GLTFState, skins: Array) {
}
GLTFState_get_cameras :: (using self: *GLTFState) -> Array {
}
GLTFState_set_cameras :: (using self: *GLTFState, cameras: Array) {
}
GLTFState_get_lights :: (using self: *GLTFState) -> Array {
}
GLTFState_set_lights :: (using self: *GLTFState, lights: Array) {
}
GLTFState_get_unique_names :: (using self: *GLTFState) -> Array {
}
GLTFState_set_unique_names :: (using self: *GLTFState, unique_names: Array) {
}
GLTFState_get_unique_animation_names :: (using self: *GLTFState) -> Array {
}
GLTFState_set_unique_animation_names :: (using self: *GLTFState, unique_animation_names: Array) {
}
GLTFState_get_skeletons :: (using self: *GLTFState) -> Array {
}
GLTFState_set_skeletons :: (using self: *GLTFState, skeletons: Array) {
}
GLTFState_get_create_animations :: (using self: *GLTFState) -> bool {
}
GLTFState_set_create_animations :: (using self: *GLTFState, create_animations: bool) {
}
GLTFState_get_import_as_skeleton_bones :: (using self: *GLTFState) -> bool {
}
GLTFState_set_import_as_skeleton_bones :: (using self: *GLTFState, import_as_skeleton_bones: bool) {
}
GLTFState_get_animations :: (using self: *GLTFState) -> Array {
}
GLTFState_set_animations :: (using self: *GLTFState, animations: Array) {
}
GLTFState_get_scene_node :: (using self: *GLTFState, idx: int) -> Node {
}
GLTFState_get_node_index :: (using self: *GLTFState, scene_node: Node) -> int {
}
GLTFState_get_additional_data :: (using self: *GLTFState, extension_name: StringName) -> Variant {
}
GLTFState_set_additional_data :: (using self: *GLTFState, extension_name: StringName, additional_data: Variant) {
}
GLTFState_get_handle_binary_image :: (using self: *GLTFState) -> int {
}
GLTFState_set_handle_binary_image :: (using self: *GLTFState, method: int) {
}
GLTFState_set_bake_fps :: (using self: *GLTFState, value: float) {
}
GLTFState_get_bake_fps :: (using self: *GLTFState) -> float {
}

// GLTFTexture
GLTFTexture :: struct {
	__private: *void;
}

GLTFTexture_get_src_image :: (using self: *GLTFTexture) -> int {
}
GLTFTexture_set_src_image :: (using self: *GLTFTexture, src_image: int) {
}
GLTFTexture_get_sampler :: (using self: *GLTFTexture) -> int {
}
GLTFTexture_set_sampler :: (using self: *GLTFTexture, sampler: int) {
}

// GLTFTextureSampler
GLTFTextureSampler :: struct {
	__private: *void;
}

GLTFTextureSampler_get_mag_filter :: (using self: *GLTFTextureSampler) -> int {
}
GLTFTextureSampler_set_mag_filter :: (using self: *GLTFTextureSampler, filter_mode: int) {
}
GLTFTextureSampler_get_min_filter :: (using self: *GLTFTextureSampler) -> int {
}
GLTFTextureSampler_set_min_filter :: (using self: *GLTFTextureSampler, filter_mode: int) {
}
GLTFTextureSampler_get_wrap_s :: (using self: *GLTFTextureSampler) -> int {
}
GLTFTextureSampler_set_wrap_s :: (using self: *GLTFTextureSampler, wrap_mode: int) {
}
GLTFTextureSampler_get_wrap_t :: (using self: *GLTFTextureSampler) -> int {
}
GLTFTextureSampler_set_wrap_t :: (using self: *GLTFTextureSampler, wrap_mode: int) {
}

// GPUParticles2D
GPUParticles2D :: struct {
	__private: *void;

	DrawOrder :: enum {
		DRAW_ORDER_INDEX :: 0;
		DRAW_ORDER_LIFETIME :: 1;
		DRAW_ORDER_REVERSE_LIFETIME :: 2;
	}
	EmitFlags :: enum {
		EMIT_FLAG_POSITION :: 1;
		EMIT_FLAG_ROTATION_SCALE :: 2;
		EMIT_FLAG_VELOCITY :: 4;
		EMIT_FLAG_COLOR :: 8;
		EMIT_FLAG_CUSTOM :: 16;
	}
}

GPUParticles2D_set_emitting :: (using self: *GPUParticles2D, emitting: bool) {
}
GPUParticles2D_set_amount :: (using self: *GPUParticles2D, amount: int) {
}
GPUParticles2D_set_lifetime :: (using self: *GPUParticles2D, secs: float) {
}
GPUParticles2D_set_one_shot :: (using self: *GPUParticles2D, secs: bool) {
}
GPUParticles2D_set_pre_process_time :: (using self: *GPUParticles2D, secs: float) {
}
GPUParticles2D_set_explosiveness_ratio :: (using self: *GPUParticles2D, ratio: float) {
}
GPUParticles2D_set_randomness_ratio :: (using self: *GPUParticles2D, ratio: float) {
}
GPUParticles2D_set_visibility_rect :: (using self: *GPUParticles2D, visibility_rect: Rect2) {
}
GPUParticles2D_set_use_local_coordinates :: (using self: *GPUParticles2D, enable: bool) {
}
GPUParticles2D_set_fixed_fps :: (using self: *GPUParticles2D, fps: int) {
}
GPUParticles2D_set_fractional_delta :: (using self: *GPUParticles2D, enable: bool) {
}
GPUParticles2D_set_interpolate :: (using self: *GPUParticles2D, enable: bool) {
}
GPUParticles2D_set_process_material :: (using self: *GPUParticles2D, material: Material) {
}
GPUParticles2D_set_speed_scale :: (using self: *GPUParticles2D, scale: float) {
}
GPUParticles2D_set_collision_base_size :: (using self: *GPUParticles2D, size: float) {
}
GPUParticles2D_set_interp_to_end :: (using self: *GPUParticles2D, interp: float) {
}
GPUParticles2D_is_emitting :: (using self: *GPUParticles2D) -> bool {
}
GPUParticles2D_get_amount :: (using self: *GPUParticles2D) -> int {
}
GPUParticles2D_get_lifetime :: (using self: *GPUParticles2D) -> float {
}
GPUParticles2D_get_one_shot :: (using self: *GPUParticles2D) -> bool {
}
GPUParticles2D_get_pre_process_time :: (using self: *GPUParticles2D) -> float {
}
GPUParticles2D_get_explosiveness_ratio :: (using self: *GPUParticles2D) -> float {
}
GPUParticles2D_get_randomness_ratio :: (using self: *GPUParticles2D) -> float {
}
GPUParticles2D_get_visibility_rect :: (using self: *GPUParticles2D) -> Rect2 {
}
GPUParticles2D_get_use_local_coordinates :: (using self: *GPUParticles2D) -> bool {
}
GPUParticles2D_get_fixed_fps :: (using self: *GPUParticles2D) -> int {
}
GPUParticles2D_get_fractional_delta :: (using self: *GPUParticles2D) -> bool {
}
GPUParticles2D_get_interpolate :: (using self: *GPUParticles2D) -> bool {
}
GPUParticles2D_get_process_material :: (using self: *GPUParticles2D) -> Material {
}
GPUParticles2D_get_speed_scale :: (using self: *GPUParticles2D) -> float {
}
GPUParticles2D_get_collision_base_size :: (using self: *GPUParticles2D) -> float {
}
GPUParticles2D_get_interp_to_end :: (using self: *GPUParticles2D) -> float {
}
GPUParticles2D_set_draw_order :: (using self: *GPUParticles2D, order: GPUParticles2D.DrawOrder) {
}
GPUParticles2D_get_draw_order :: (using self: *GPUParticles2D) -> GPUParticles2D.DrawOrder {
}
GPUParticles2D_set_texture :: (using self: *GPUParticles2D, texture: Texture2D) {
}
GPUParticles2D_get_texture :: (using self: *GPUParticles2D) -> Texture2D {
}
GPUParticles2D_capture_rect :: (using self: *GPUParticles2D) -> Rect2 {
}
GPUParticles2D_restart :: (using self: *GPUParticles2D) {
}
GPUParticles2D_set_sub_emitter :: (using self: *GPUParticles2D, path: NodePath) {
}
GPUParticles2D_get_sub_emitter :: (using self: *GPUParticles2D) -> NodePath {
}
GPUParticles2D_emit_particle :: (using self: *GPUParticles2D, xform: Transform2D, velocity: Vector2, color: Color, custom: Color, flags: int) {
}
GPUParticles2D_set_trail_enabled :: (using self: *GPUParticles2D, enabled: bool) {
}
GPUParticles2D_set_trail_lifetime :: (using self: *GPUParticles2D, secs: float) {
}
GPUParticles2D_is_trail_enabled :: (using self: *GPUParticles2D) -> bool {
}
GPUParticles2D_get_trail_lifetime :: (using self: *GPUParticles2D) -> float {
}
GPUParticles2D_set_trail_sections :: (using self: *GPUParticles2D, sections: int) {
}
GPUParticles2D_get_trail_sections :: (using self: *GPUParticles2D) -> int {
}
GPUParticles2D_set_trail_section_subdivisions :: (using self: *GPUParticles2D, subdivisions: int) {
}
GPUParticles2D_get_trail_section_subdivisions :: (using self: *GPUParticles2D) -> int {
}
GPUParticles2D_convert_from_particles :: (using self: *GPUParticles2D, particles: Node) {
}
GPUParticles2D_set_amount_ratio :: (using self: *GPUParticles2D, ratio: float) {
}
GPUParticles2D_get_amount_ratio :: (using self: *GPUParticles2D) -> float {
}

// GPUParticles3D
GPUParticles3D :: struct {
	__private: *void;

	MAX_DRAW_PASSES :: 4;

	DrawOrder :: enum {
		DRAW_ORDER_INDEX :: 0;
		DRAW_ORDER_LIFETIME :: 1;
		DRAW_ORDER_REVERSE_LIFETIME :: 2;
		DRAW_ORDER_VIEW_DEPTH :: 3;
	}
	EmitFlags :: enum {
		EMIT_FLAG_POSITION :: 1;
		EMIT_FLAG_ROTATION_SCALE :: 2;
		EMIT_FLAG_VELOCITY :: 4;
		EMIT_FLAG_COLOR :: 8;
		EMIT_FLAG_CUSTOM :: 16;
	}
	TransformAlign :: enum {
		TRANSFORM_ALIGN_DISABLED :: 0;
		TRANSFORM_ALIGN_Z_BILLBOARD :: 1;
		TRANSFORM_ALIGN_Y_TO_VELOCITY :: 2;
		TRANSFORM_ALIGN_Z_BILLBOARD_Y_TO_VELOCITY :: 3;
	}
}

GPUParticles3D_set_emitting :: (using self: *GPUParticles3D, emitting: bool) {
}
GPUParticles3D_set_amount :: (using self: *GPUParticles3D, amount: int) {
}
GPUParticles3D_set_lifetime :: (using self: *GPUParticles3D, secs: float) {
}
GPUParticles3D_set_one_shot :: (using self: *GPUParticles3D, enable: bool) {
}
GPUParticles3D_set_pre_process_time :: (using self: *GPUParticles3D, secs: float) {
}
GPUParticles3D_set_explosiveness_ratio :: (using self: *GPUParticles3D, ratio: float) {
}
GPUParticles3D_set_randomness_ratio :: (using self: *GPUParticles3D, ratio: float) {
}
GPUParticles3D_set_visibility_aabb :: (using self: *GPUParticles3D, aabb: AABB) {
}
GPUParticles3D_set_use_local_coordinates :: (using self: *GPUParticles3D, enable: bool) {
}
GPUParticles3D_set_fixed_fps :: (using self: *GPUParticles3D, fps: int) {
}
GPUParticles3D_set_fractional_delta :: (using self: *GPUParticles3D, enable: bool) {
}
GPUParticles3D_set_interpolate :: (using self: *GPUParticles3D, enable: bool) {
}
GPUParticles3D_set_process_material :: (using self: *GPUParticles3D, material: Material) {
}
GPUParticles3D_set_speed_scale :: (using self: *GPUParticles3D, scale: float) {
}
GPUParticles3D_set_collision_base_size :: (using self: *GPUParticles3D, size: float) {
}
GPUParticles3D_set_interp_to_end :: (using self: *GPUParticles3D, interp: float) {
}
GPUParticles3D_is_emitting :: (using self: *GPUParticles3D) -> bool {
}
GPUParticles3D_get_amount :: (using self: *GPUParticles3D) -> int {
}
GPUParticles3D_get_lifetime :: (using self: *GPUParticles3D) -> float {
}
GPUParticles3D_get_one_shot :: (using self: *GPUParticles3D) -> bool {
}
GPUParticles3D_get_pre_process_time :: (using self: *GPUParticles3D) -> float {
}
GPUParticles3D_get_explosiveness_ratio :: (using self: *GPUParticles3D) -> float {
}
GPUParticles3D_get_randomness_ratio :: (using self: *GPUParticles3D) -> float {
}
GPUParticles3D_get_visibility_aabb :: (using self: *GPUParticles3D) -> AABB {
}
GPUParticles3D_get_use_local_coordinates :: (using self: *GPUParticles3D) -> bool {
}
GPUParticles3D_get_fixed_fps :: (using self: *GPUParticles3D) -> int {
}
GPUParticles3D_get_fractional_delta :: (using self: *GPUParticles3D) -> bool {
}
GPUParticles3D_get_interpolate :: (using self: *GPUParticles3D) -> bool {
}
GPUParticles3D_get_process_material :: (using self: *GPUParticles3D) -> Material {
}
GPUParticles3D_get_speed_scale :: (using self: *GPUParticles3D) -> float {
}
GPUParticles3D_get_collision_base_size :: (using self: *GPUParticles3D) -> float {
}
GPUParticles3D_get_interp_to_end :: (using self: *GPUParticles3D) -> float {
}
GPUParticles3D_set_draw_order :: (using self: *GPUParticles3D, order: GPUParticles3D.DrawOrder) {
}
GPUParticles3D_get_draw_order :: (using self: *GPUParticles3D) -> GPUParticles3D.DrawOrder {
}
GPUParticles3D_set_draw_passes :: (using self: *GPUParticles3D, passes: int) {
}
GPUParticles3D_set_draw_pass_mesh :: (using self: *GPUParticles3D, pass: int, mesh: Mesh) {
}
GPUParticles3D_get_draw_passes :: (using self: *GPUParticles3D) -> int {
}
GPUParticles3D_get_draw_pass_mesh :: (using self: *GPUParticles3D, pass: int) -> Mesh {
}
GPUParticles3D_set_skin :: (using self: *GPUParticles3D, skin: Skin) {
}
GPUParticles3D_get_skin :: (using self: *GPUParticles3D) -> Skin {
}
GPUParticles3D_restart :: (using self: *GPUParticles3D) {
}
GPUParticles3D_capture_aabb :: (using self: *GPUParticles3D) -> AABB {
}
GPUParticles3D_set_sub_emitter :: (using self: *GPUParticles3D, path: NodePath) {
}
GPUParticles3D_get_sub_emitter :: (using self: *GPUParticles3D) -> NodePath {
}
GPUParticles3D_emit_particle :: (using self: *GPUParticles3D, xform: Transform3D, velocity: Vector3, color: Color, custom: Color, flags: int) {
}
GPUParticles3D_set_trail_enabled :: (using self: *GPUParticles3D, enabled: bool) {
}
GPUParticles3D_set_trail_lifetime :: (using self: *GPUParticles3D, secs: float) {
}
GPUParticles3D_is_trail_enabled :: (using self: *GPUParticles3D) -> bool {
}
GPUParticles3D_get_trail_lifetime :: (using self: *GPUParticles3D) -> float {
}
GPUParticles3D_set_transform_align :: (using self: *GPUParticles3D, align: GPUParticles3D.TransformAlign) {
}
GPUParticles3D_get_transform_align :: (using self: *GPUParticles3D) -> GPUParticles3D.TransformAlign {
}
GPUParticles3D_convert_from_particles :: (using self: *GPUParticles3D, particles: Node) {
}
GPUParticles3D_set_amount_ratio :: (using self: *GPUParticles3D, ratio: float) {
}
GPUParticles3D_get_amount_ratio :: (using self: *GPUParticles3D) -> float {
}

// GPUParticlesAttractor3D
GPUParticlesAttractor3D :: struct {
	__private: *void;
}

GPUParticlesAttractor3D_set_cull_mask :: (using self: *GPUParticlesAttractor3D, mask: int) {
}
GPUParticlesAttractor3D_get_cull_mask :: (using self: *GPUParticlesAttractor3D) -> int {
}
GPUParticlesAttractor3D_set_strength :: (using self: *GPUParticlesAttractor3D, strength: float) {
}
GPUParticlesAttractor3D_get_strength :: (using self: *GPUParticlesAttractor3D) -> float {
}
GPUParticlesAttractor3D_set_attenuation :: (using self: *GPUParticlesAttractor3D, attenuation: float) {
}
GPUParticlesAttractor3D_get_attenuation :: (using self: *GPUParticlesAttractor3D) -> float {
}
GPUParticlesAttractor3D_set_directionality :: (using self: *GPUParticlesAttractor3D, amount: float) {
}
GPUParticlesAttractor3D_get_directionality :: (using self: *GPUParticlesAttractor3D) -> float {
}

// GPUParticlesAttractorBox3D
GPUParticlesAttractorBox3D :: struct {
	__private: *void;
}

GPUParticlesAttractorBox3D_set_size :: (using self: *GPUParticlesAttractorBox3D, size: Vector3) {
}
GPUParticlesAttractorBox3D_get_size :: (using self: *GPUParticlesAttractorBox3D) -> Vector3 {
}

// GPUParticlesAttractorSphere3D
GPUParticlesAttractorSphere3D :: struct {
	__private: *void;
}

GPUParticlesAttractorSphere3D_set_radius :: (using self: *GPUParticlesAttractorSphere3D, radius: float) {
}
GPUParticlesAttractorSphere3D_get_radius :: (using self: *GPUParticlesAttractorSphere3D) -> float {
}

// GPUParticlesAttractorVectorField3D
GPUParticlesAttractorVectorField3D :: struct {
	__private: *void;
}

GPUParticlesAttractorVectorField3D_set_size :: (using self: *GPUParticlesAttractorVectorField3D, size: Vector3) {
}
GPUParticlesAttractorVectorField3D_get_size :: (using self: *GPUParticlesAttractorVectorField3D) -> Vector3 {
}
GPUParticlesAttractorVectorField3D_set_texture :: (using self: *GPUParticlesAttractorVectorField3D, texture: Texture3D) {
}
GPUParticlesAttractorVectorField3D_get_texture :: (using self: *GPUParticlesAttractorVectorField3D) -> Texture3D {
}

// GPUParticlesCollision3D
GPUParticlesCollision3D :: struct {
	__private: *void;
}

GPUParticlesCollision3D_set_cull_mask :: (using self: *GPUParticlesCollision3D, mask: int) {
}
GPUParticlesCollision3D_get_cull_mask :: (using self: *GPUParticlesCollision3D) -> int {
}

// GPUParticlesCollisionBox3D
GPUParticlesCollisionBox3D :: struct {
	__private: *void;
}

GPUParticlesCollisionBox3D_set_size :: (using self: *GPUParticlesCollisionBox3D, size: Vector3) {
}
GPUParticlesCollisionBox3D_get_size :: (using self: *GPUParticlesCollisionBox3D) -> Vector3 {
}

// GPUParticlesCollisionHeightField3D
GPUParticlesCollisionHeightField3D :: struct {
	__private: *void;

	Resolution :: enum {
		RESOLUTION_256 :: 0;
		RESOLUTION_512 :: 1;
		RESOLUTION_1024 :: 2;
		RESOLUTION_2048 :: 3;
		RESOLUTION_4096 :: 4;
		RESOLUTION_8192 :: 5;
		RESOLUTION_MAX :: 6;
	}
	UpdateMode :: enum {
		UPDATE_MODE_WHEN_MOVED :: 0;
		UPDATE_MODE_ALWAYS :: 1;
	}
}

GPUParticlesCollisionHeightField3D_set_size :: (using self: *GPUParticlesCollisionHeightField3D, size: Vector3) {
}
GPUParticlesCollisionHeightField3D_get_size :: (using self: *GPUParticlesCollisionHeightField3D) -> Vector3 {
}
GPUParticlesCollisionHeightField3D_set_resolution :: (using self: *GPUParticlesCollisionHeightField3D, resolution: GPUParticlesCollisionHeightField3D.Resolution) {
}
GPUParticlesCollisionHeightField3D_get_resolution :: (using self: *GPUParticlesCollisionHeightField3D) -> GPUParticlesCollisionHeightField3D.Resolution {
}
GPUParticlesCollisionHeightField3D_set_update_mode :: (using self: *GPUParticlesCollisionHeightField3D, update_mode: GPUParticlesCollisionHeightField3D.UpdateMode) {
}
GPUParticlesCollisionHeightField3D_get_update_mode :: (using self: *GPUParticlesCollisionHeightField3D) -> GPUParticlesCollisionHeightField3D.UpdateMode {
}
GPUParticlesCollisionHeightField3D_set_follow_camera_enabled :: (using self: *GPUParticlesCollisionHeightField3D, enabled: bool) {
}
GPUParticlesCollisionHeightField3D_is_follow_camera_enabled :: (using self: *GPUParticlesCollisionHeightField3D) -> bool {
}

// GPUParticlesCollisionSDF3D
GPUParticlesCollisionSDF3D :: struct {
	__private: *void;

	Resolution :: enum {
		RESOLUTION_16 :: 0;
		RESOLUTION_32 :: 1;
		RESOLUTION_64 :: 2;
		RESOLUTION_128 :: 3;
		RESOLUTION_256 :: 4;
		RESOLUTION_512 :: 5;
		RESOLUTION_MAX :: 6;
	}
}

GPUParticlesCollisionSDF3D_set_size :: (using self: *GPUParticlesCollisionSDF3D, size: Vector3) {
}
GPUParticlesCollisionSDF3D_get_size :: (using self: *GPUParticlesCollisionSDF3D) -> Vector3 {
}
GPUParticlesCollisionSDF3D_set_resolution :: (using self: *GPUParticlesCollisionSDF3D, resolution: GPUParticlesCollisionSDF3D.Resolution) {
}
GPUParticlesCollisionSDF3D_get_resolution :: (using self: *GPUParticlesCollisionSDF3D) -> GPUParticlesCollisionSDF3D.Resolution {
}
GPUParticlesCollisionSDF3D_set_texture :: (using self: *GPUParticlesCollisionSDF3D, texture: Texture3D) {
}
GPUParticlesCollisionSDF3D_get_texture :: (using self: *GPUParticlesCollisionSDF3D) -> Texture3D {
}
GPUParticlesCollisionSDF3D_set_thickness :: (using self: *GPUParticlesCollisionSDF3D, thickness: float) {
}
GPUParticlesCollisionSDF3D_get_thickness :: (using self: *GPUParticlesCollisionSDF3D) -> float {
}
GPUParticlesCollisionSDF3D_set_bake_mask :: (using self: *GPUParticlesCollisionSDF3D, mask: int) {
}
GPUParticlesCollisionSDF3D_get_bake_mask :: (using self: *GPUParticlesCollisionSDF3D) -> int {
}
GPUParticlesCollisionSDF3D_set_bake_mask_value :: (using self: *GPUParticlesCollisionSDF3D, layer_number: int, value: bool) {
}
GPUParticlesCollisionSDF3D_get_bake_mask_value :: (using self: *GPUParticlesCollisionSDF3D, layer_number: int) -> bool {
}

// GPUParticlesCollisionSphere3D
GPUParticlesCollisionSphere3D :: struct {
	__private: *void;
}

GPUParticlesCollisionSphere3D_set_radius :: (using self: *GPUParticlesCollisionSphere3D, radius: float) {
}
GPUParticlesCollisionSphere3D_get_radius :: (using self: *GPUParticlesCollisionSphere3D) -> float {
}

// Generic6DOFJoint3D
Generic6DOFJoint3D :: struct {
	__private: *void;

	Param :: enum {
		PARAM_LINEAR_LOWER_LIMIT :: 0;
		PARAM_LINEAR_UPPER_LIMIT :: 1;
		PARAM_LINEAR_LIMIT_SOFTNESS :: 2;
		PARAM_LINEAR_RESTITUTION :: 3;
		PARAM_LINEAR_DAMPING :: 4;
		PARAM_LINEAR_MOTOR_TARGET_VELOCITY :: 5;
		PARAM_LINEAR_MOTOR_FORCE_LIMIT :: 6;
		PARAM_LINEAR_SPRING_STIFFNESS :: 7;
		PARAM_LINEAR_SPRING_DAMPING :: 8;
		PARAM_LINEAR_SPRING_EQUILIBRIUM_POINT :: 9;
		PARAM_ANGULAR_LOWER_LIMIT :: 10;
		PARAM_ANGULAR_UPPER_LIMIT :: 11;
		PARAM_ANGULAR_LIMIT_SOFTNESS :: 12;
		PARAM_ANGULAR_DAMPING :: 13;
		PARAM_ANGULAR_RESTITUTION :: 14;
		PARAM_ANGULAR_FORCE_LIMIT :: 15;
		PARAM_ANGULAR_ERP :: 16;
		PARAM_ANGULAR_MOTOR_TARGET_VELOCITY :: 17;
		PARAM_ANGULAR_MOTOR_FORCE_LIMIT :: 18;
		PARAM_ANGULAR_SPRING_STIFFNESS :: 19;
		PARAM_ANGULAR_SPRING_DAMPING :: 20;
		PARAM_ANGULAR_SPRING_EQUILIBRIUM_POINT :: 21;
		PARAM_MAX :: 22;
	}
	Flag :: enum {
		FLAG_ENABLE_LINEAR_LIMIT :: 0;
		FLAG_ENABLE_ANGULAR_LIMIT :: 1;
		FLAG_ENABLE_LINEAR_SPRING :: 3;
		FLAG_ENABLE_ANGULAR_SPRING :: 2;
		FLAG_ENABLE_MOTOR :: 4;
		FLAG_ENABLE_LINEAR_MOTOR :: 5;
		FLAG_MAX :: 6;
	}
}

Generic6DOFJoint3D_set_param_x :: (using self: *Generic6DOFJoint3D, param: Generic6DOFJoint3D.Param, value: float) {
}
Generic6DOFJoint3D_get_param_x :: (using self: *Generic6DOFJoint3D, param: Generic6DOFJoint3D.Param) -> float {
}
Generic6DOFJoint3D_set_param_y :: (using self: *Generic6DOFJoint3D, param: Generic6DOFJoint3D.Param, value: float) {
}
Generic6DOFJoint3D_get_param_y :: (using self: *Generic6DOFJoint3D, param: Generic6DOFJoint3D.Param) -> float {
}
Generic6DOFJoint3D_set_param_z :: (using self: *Generic6DOFJoint3D, param: Generic6DOFJoint3D.Param, value: float) {
}
Generic6DOFJoint3D_get_param_z :: (using self: *Generic6DOFJoint3D, param: Generic6DOFJoint3D.Param) -> float {
}
Generic6DOFJoint3D_set_flag_x :: (using self: *Generic6DOFJoint3D, flag: Generic6DOFJoint3D.Flag, value: bool) {
}
Generic6DOFJoint3D_get_flag_x :: (using self: *Generic6DOFJoint3D, flag: Generic6DOFJoint3D.Flag) -> bool {
}
Generic6DOFJoint3D_set_flag_y :: (using self: *Generic6DOFJoint3D, flag: Generic6DOFJoint3D.Flag, value: bool) {
}
Generic6DOFJoint3D_get_flag_y :: (using self: *Generic6DOFJoint3D, flag: Generic6DOFJoint3D.Flag) -> bool {
}
Generic6DOFJoint3D_set_flag_z :: (using self: *Generic6DOFJoint3D, flag: Generic6DOFJoint3D.Flag, value: bool) {
}
Generic6DOFJoint3D_get_flag_z :: (using self: *Generic6DOFJoint3D, flag: Generic6DOFJoint3D.Flag) -> bool {
}

// Geometry2D
Geometry2D :: struct {
	__private: *void;

	PolyBooleanOperation :: enum {
		OPERATION_UNION :: 0;
		OPERATION_DIFFERENCE :: 1;
		OPERATION_INTERSECTION :: 2;
		OPERATION_XOR :: 3;
	}
	PolyJoinType :: enum {
		JOIN_SQUARE :: 0;
		JOIN_ROUND :: 1;
		JOIN_MITER :: 2;
	}
	PolyEndType :: enum {
		END_POLYGON :: 0;
		END_JOINED :: 1;
		END_BUTT :: 2;
		END_SQUARE :: 3;
		END_ROUND :: 4;
	}
}

Geometry2D_is_point_in_circle :: (using self: *Geometry2D, point: Vector2, circle_position: Vector2, circle_radius: float) -> bool {
}
Geometry2D_segment_intersects_circle :: (using self: *Geometry2D, segment_from: Vector2, segment_to: Vector2, circle_position: Vector2, circle_radius: float) -> float {
}
Geometry2D_segment_intersects_segment :: (using self: *Geometry2D, from_a: Vector2, to_a: Vector2, from_b: Vector2, to_b: Vector2) -> Variant {
}
Geometry2D_line_intersects_line :: (using self: *Geometry2D, from_a: Vector2, dir_a: Vector2, from_b: Vector2, dir_b: Vector2) -> Variant {
}
Geometry2D_get_closest_points_between_segments :: (using self: *Geometry2D, p1: Vector2, q1: Vector2, p2: Vector2, q2: Vector2) -> PackedVector2Array {
}
Geometry2D_get_closest_point_to_segment :: (using self: *Geometry2D, point: Vector2, s1: Vector2, s2: Vector2) -> Vector2 {
}
Geometry2D_get_closest_point_to_segment_uncapped :: (using self: *Geometry2D, point: Vector2, s1: Vector2, s2: Vector2) -> Vector2 {
}
Geometry2D_point_is_inside_triangle :: (using self: *Geometry2D, point: Vector2, a: Vector2, b: Vector2, c: Vector2) -> bool {
}
Geometry2D_is_polygon_clockwise :: (using self: *Geometry2D, polygon: PackedVector2Array) -> bool {
}
Geometry2D_is_point_in_polygon :: (using self: *Geometry2D, point: Vector2, polygon: PackedVector2Array) -> bool {
}
Geometry2D_triangulate_polygon :: (using self: *Geometry2D, polygon: PackedVector2Array) -> PackedInt32Array {
}
Geometry2D_triangulate_delaunay :: (using self: *Geometry2D, points: PackedVector2Array) -> PackedInt32Array {
}
Geometry2D_convex_hull :: (using self: *Geometry2D, points: PackedVector2Array) -> PackedVector2Array {
}
Geometry2D_decompose_polygon_in_convex :: (using self: *Geometry2D, polygon: PackedVector2Array) -> Array {
}
Geometry2D_merge_polygons :: (using self: *Geometry2D, polygon_a: PackedVector2Array, polygon_b: PackedVector2Array) -> Array {
}
Geometry2D_clip_polygons :: (using self: *Geometry2D, polygon_a: PackedVector2Array, polygon_b: PackedVector2Array) -> Array {
}
Geometry2D_intersect_polygons :: (using self: *Geometry2D, polygon_a: PackedVector2Array, polygon_b: PackedVector2Array) -> Array {
}
Geometry2D_exclude_polygons :: (using self: *Geometry2D, polygon_a: PackedVector2Array, polygon_b: PackedVector2Array) -> Array {
}
Geometry2D_clip_polyline_with_polygon :: (using self: *Geometry2D, polyline: PackedVector2Array, polygon: PackedVector2Array) -> Array {
}
Geometry2D_intersect_polyline_with_polygon :: (using self: *Geometry2D, polyline: PackedVector2Array, polygon: PackedVector2Array) -> Array {
}
Geometry2D_offset_polygon :: (using self: *Geometry2D, polygon: PackedVector2Array, delta: float, join_type: Geometry2D.PolyJoinType) -> Array {
}
Geometry2D_offset_polyline :: (using self: *Geometry2D, polyline: PackedVector2Array, delta: float, join_type: Geometry2D.PolyJoinType, end_type: Geometry2D.PolyEndType) -> Array {
}
Geometry2D_make_atlas :: (using self: *Geometry2D, sizes: PackedVector2Array) -> Dictionary {
}

// Geometry3D
Geometry3D :: struct {
	__private: *void;
}

Geometry3D_compute_convex_mesh_points :: (using self: *Geometry3D, planes: Array) -> PackedVector3Array {
}
Geometry3D_build_box_planes :: (using self: *Geometry3D, extents: Vector3) -> Array {
}
Geometry3D_build_cylinder_planes :: (using self: *Geometry3D, radius: float, height: float, sides: int, axis: Vector3.Axis) -> Array {
}
Geometry3D_build_capsule_planes :: (using self: *Geometry3D, radius: float, height: float, sides: int, lats: int, axis: Vector3.Axis) -> Array {
}
Geometry3D_get_closest_points_between_segments :: (using self: *Geometry3D, p1: Vector3, p2: Vector3, q1: Vector3, q2: Vector3) -> PackedVector3Array {
}
Geometry3D_get_closest_point_to_segment :: (using self: *Geometry3D, point: Vector3, s1: Vector3, s2: Vector3) -> Vector3 {
}
Geometry3D_get_closest_point_to_segment_uncapped :: (using self: *Geometry3D, point: Vector3, s1: Vector3, s2: Vector3) -> Vector3 {
}
Geometry3D_get_triangle_barycentric_coords :: (using self: *Geometry3D, point: Vector3, a: Vector3, b: Vector3, c: Vector3) -> Vector3 {
}
Geometry3D_ray_intersects_triangle :: (using self: *Geometry3D, from: Vector3, dir: Vector3, a: Vector3, b: Vector3, c: Vector3) -> Variant {
}
Geometry3D_segment_intersects_triangle :: (using self: *Geometry3D, from: Vector3, to: Vector3, a: Vector3, b: Vector3, c: Vector3) -> Variant {
}
Geometry3D_segment_intersects_sphere :: (using self: *Geometry3D, from: Vector3, to: Vector3, sphere_position: Vector3, sphere_radius: float) -> PackedVector3Array {
}
Geometry3D_segment_intersects_cylinder :: (using self: *Geometry3D, from: Vector3, to: Vector3, height: float, radius: float) -> PackedVector3Array {
}
Geometry3D_segment_intersects_convex :: (using self: *Geometry3D, from: Vector3, to: Vector3, planes: Array) -> PackedVector3Array {
}
Geometry3D_clip_polygon :: (using self: *Geometry3D, points: PackedVector3Array, plane: Plane) -> PackedVector3Array {
}
Geometry3D_tetrahedralize_delaunay :: (using self: *Geometry3D, points: PackedVector3Array) -> PackedInt32Array {
}

// GeometryInstance3D
GeometryInstance3D :: struct {
	__private: *void;

	ShadowCastingSetting :: enum {
		SHADOW_CASTING_SETTING_OFF :: 0;
		SHADOW_CASTING_SETTING_ON :: 1;
		SHADOW_CASTING_SETTING_DOUBLE_SIDED :: 2;
		SHADOW_CASTING_SETTING_SHADOWS_ONLY :: 3;
	}
	GIMode :: enum {
		GI_MODE_DISABLED :: 0;
		GI_MODE_STATIC :: 1;
		GI_MODE_DYNAMIC :: 2;
	}
	LightmapScale :: enum {
		LIGHTMAP_SCALE_1X :: 0;
		LIGHTMAP_SCALE_2X :: 1;
		LIGHTMAP_SCALE_4X :: 2;
		LIGHTMAP_SCALE_8X :: 3;
		LIGHTMAP_SCALE_MAX :: 4;
	}
	VisibilityRangeFadeMode :: enum {
		VISIBILITY_RANGE_FADE_DISABLED :: 0;
		VISIBILITY_RANGE_FADE_SELF :: 1;
		VISIBILITY_RANGE_FADE_DEPENDENCIES :: 2;
	}
}

GeometryInstance3D_set_material_override :: (using self: *GeometryInstance3D, material: Material) {
}
GeometryInstance3D_get_material_override :: (using self: *GeometryInstance3D) -> Material {
}
GeometryInstance3D_set_material_overlay :: (using self: *GeometryInstance3D, material: Material) {
}
GeometryInstance3D_get_material_overlay :: (using self: *GeometryInstance3D) -> Material {
}
GeometryInstance3D_set_cast_shadows_setting :: (using self: *GeometryInstance3D, shadow_casting_setting: GeometryInstance3D.ShadowCastingSetting) {
}
GeometryInstance3D_get_cast_shadows_setting :: (using self: *GeometryInstance3D) -> GeometryInstance3D.ShadowCastingSetting {
}
GeometryInstance3D_set_lod_bias :: (using self: *GeometryInstance3D, bias: float) {
}
GeometryInstance3D_get_lod_bias :: (using self: *GeometryInstance3D) -> float {
}
GeometryInstance3D_set_transparency :: (using self: *GeometryInstance3D, transparency: float) {
}
GeometryInstance3D_get_transparency :: (using self: *GeometryInstance3D) -> float {
}
GeometryInstance3D_set_visibility_range_end_margin :: (using self: *GeometryInstance3D, distance: float) {
}
GeometryInstance3D_get_visibility_range_end_margin :: (using self: *GeometryInstance3D) -> float {
}
GeometryInstance3D_set_visibility_range_end :: (using self: *GeometryInstance3D, distance: float) {
}
GeometryInstance3D_get_visibility_range_end :: (using self: *GeometryInstance3D) -> float {
}
GeometryInstance3D_set_visibility_range_begin_margin :: (using self: *GeometryInstance3D, distance: float) {
}
GeometryInstance3D_get_visibility_range_begin_margin :: (using self: *GeometryInstance3D) -> float {
}
GeometryInstance3D_set_visibility_range_begin :: (using self: *GeometryInstance3D, distance: float) {
}
GeometryInstance3D_get_visibility_range_begin :: (using self: *GeometryInstance3D) -> float {
}
GeometryInstance3D_set_visibility_range_fade_mode :: (using self: *GeometryInstance3D, mode: GeometryInstance3D.VisibilityRangeFadeMode) {
}
GeometryInstance3D_get_visibility_range_fade_mode :: (using self: *GeometryInstance3D) -> GeometryInstance3D.VisibilityRangeFadeMode {
}
GeometryInstance3D_set_instance_shader_parameter :: (using self: *GeometryInstance3D, name: StringName, value: Variant) {
}
GeometryInstance3D_get_instance_shader_parameter :: (using self: *GeometryInstance3D, name: StringName) -> Variant {
}
GeometryInstance3D_set_extra_cull_margin :: (using self: *GeometryInstance3D, margin: float) {
}
GeometryInstance3D_get_extra_cull_margin :: (using self: *GeometryInstance3D) -> float {
}
GeometryInstance3D_set_lightmap_scale :: (using self: *GeometryInstance3D, scale: GeometryInstance3D.LightmapScale) {
}
GeometryInstance3D_get_lightmap_scale :: (using self: *GeometryInstance3D) -> GeometryInstance3D.LightmapScale {
}
GeometryInstance3D_set_gi_mode :: (using self: *GeometryInstance3D, mode: GeometryInstance3D.GIMode) {
}
GeometryInstance3D_get_gi_mode :: (using self: *GeometryInstance3D) -> GeometryInstance3D.GIMode {
}
GeometryInstance3D_set_ignore_occlusion_culling :: (using self: *GeometryInstance3D, ignore_culling: bool) {
}
GeometryInstance3D_is_ignoring_occlusion_culling :: (using self: *GeometryInstance3D) -> bool {
}
GeometryInstance3D_set_custom_aabb :: (using self: *GeometryInstance3D, aabb: AABB) {
}
GeometryInstance3D_get_custom_aabb :: (using self: *GeometryInstance3D) -> AABB {
}

// Gradient
Gradient :: struct {
	__private: *void;

	InterpolationMode :: enum {
		GRADIENT_INTERPOLATE_LINEAR :: 0;
		GRADIENT_INTERPOLATE_CONSTANT :: 1;
		GRADIENT_INTERPOLATE_CUBIC :: 2;
	}
	ColorSpace :: enum {
		GRADIENT_COLOR_SPACE_SRGB :: 0;
		GRADIENT_COLOR_SPACE_LINEAR_SRGB :: 1;
		GRADIENT_COLOR_SPACE_OKLAB :: 2;
	}
}

Gradient_add_point :: (using self: *Gradient, offset: float, color: Color) {
}
Gradient_remove_point :: (using self: *Gradient, point: int) {
}
Gradient_set_offset :: (using self: *Gradient, point: int, offset: float) {
}
Gradient_get_offset :: (using self: *Gradient, point: int) -> float {
}
Gradient_reverse :: (using self: *Gradient) {
}
Gradient_set_color :: (using self: *Gradient, point: int, color: Color) {
}
Gradient_get_color :: (using self: *Gradient, point: int) -> Color {
}
Gradient_sample :: (using self: *Gradient, offset: float) -> Color {
}
Gradient_get_point_count :: (using self: *Gradient) -> int {
}
Gradient_set_offsets :: (using self: *Gradient, offsets: PackedFloat32Array) {
}
Gradient_get_offsets :: (using self: *Gradient) -> PackedFloat32Array {
}
Gradient_set_colors :: (using self: *Gradient, colors: PackedColorArray) {
}
Gradient_get_colors :: (using self: *Gradient) -> PackedColorArray {
}
Gradient_set_interpolation_mode :: (using self: *Gradient, interpolation_mode: Gradient.InterpolationMode) {
}
Gradient_get_interpolation_mode :: (using self: *Gradient) -> Gradient.InterpolationMode {
}
Gradient_set_interpolation_color_space :: (using self: *Gradient, interpolation_color_space: Gradient.ColorSpace) {
}
Gradient_get_interpolation_color_space :: (using self: *Gradient) -> Gradient.ColorSpace {
}

// GradientTexture1D
GradientTexture1D :: struct {
	__private: *void;
}

GradientTexture1D_set_gradient :: (using self: *GradientTexture1D, gradient: Gradient) {
}
GradientTexture1D_get_gradient :: (using self: *GradientTexture1D) -> Gradient {
}
GradientTexture1D_set_width :: (using self: *GradientTexture1D, width: int) {
}
GradientTexture1D_set_use_hdr :: (using self: *GradientTexture1D, enabled: bool) {
}
GradientTexture1D_is_using_hdr :: (using self: *GradientTexture1D) -> bool {
}

// GradientTexture2D
GradientTexture2D :: struct {
	__private: *void;

	Fill :: enum {
		FILL_LINEAR :: 0;
		FILL_RADIAL :: 1;
		FILL_SQUARE :: 2;
	}
	Repeat :: enum {
		REPEAT_NONE :: 0;
		REPEAT :: 1;
		REPEAT_MIRROR :: 2;
	}
}

GradientTexture2D_set_gradient :: (using self: *GradientTexture2D, gradient: Gradient) {
}
GradientTexture2D_get_gradient :: (using self: *GradientTexture2D) -> Gradient {
}
GradientTexture2D_set_width :: (using self: *GradientTexture2D, width: int) {
}
GradientTexture2D_set_height :: (using self: *GradientTexture2D, height: int) {
}
GradientTexture2D_set_use_hdr :: (using self: *GradientTexture2D, enabled: bool) {
}
GradientTexture2D_is_using_hdr :: (using self: *GradientTexture2D) -> bool {
}
GradientTexture2D_set_fill :: (using self: *GradientTexture2D, fill: GradientTexture2D.Fill) {
}
GradientTexture2D_get_fill :: (using self: *GradientTexture2D) -> GradientTexture2D.Fill {
}
GradientTexture2D_set_fill_from :: (using self: *GradientTexture2D, fill_from: Vector2) {
}
GradientTexture2D_get_fill_from :: (using self: *GradientTexture2D) -> Vector2 {
}
GradientTexture2D_set_fill_to :: (using self: *GradientTexture2D, fill_to: Vector2) {
}
GradientTexture2D_get_fill_to :: (using self: *GradientTexture2D) -> Vector2 {
}
GradientTexture2D_set_repeat :: (using self: *GradientTexture2D, repeat: GradientTexture2D.Repeat) {
}
GradientTexture2D_get_repeat :: (using self: *GradientTexture2D) -> GradientTexture2D.Repeat {
}

// GraphEdit
GraphEdit :: struct {
	__private: *void;

	PanningScheme :: enum {
		SCROLL_ZOOMS :: 0;
		SCROLL_PANS :: 1;
	}
	GridPattern :: enum {
		GRID_PATTERN_LINES :: 0;
		GRID_PATTERN_DOTS :: 1;
	}
}

GraphEdit__is_in_input_hotzone :: (using self: *GraphEdit, in_node: Object, in_port: int, mouse_position: Vector2) -> bool {
}
GraphEdit__is_in_output_hotzone :: (using self: *GraphEdit, in_node: Object, in_port: int, mouse_position: Vector2) -> bool {
}
GraphEdit__get_connection_line :: (using self: *GraphEdit, from_position: Vector2, to_position: Vector2) -> PackedVector2Array {
}
GraphEdit__is_node_hover_valid :: (using self: *GraphEdit, from_node: StringName, from_port: int, to_node: StringName, to_port: int) -> bool {
}
GraphEdit_connect_node :: (using self: *GraphEdit, from_node: StringName, from_port: int, to_node: StringName, to_port: int) -> Error {
}
GraphEdit_is_node_connected :: (using self: *GraphEdit, from_node: StringName, from_port: int, to_node: StringName, to_port: int) -> bool {
}
GraphEdit_disconnect_node :: (using self: *GraphEdit, from_node: StringName, from_port: int, to_node: StringName, to_port: int) {
}
GraphEdit_set_connection_activity :: (using self: *GraphEdit, from_node: StringName, from_port: int, to_node: StringName, to_port: int, amount: float) {
}
GraphEdit_get_connection_list :: (using self: *GraphEdit) -> Dictionary {
}
GraphEdit_get_closest_connection_at_point :: (using self: *GraphEdit, point: Vector2, max_distance: float) -> Dictionary {
}
GraphEdit_get_connections_intersecting_with_rect :: (using self: *GraphEdit, rect: Rect2) -> Dictionary {
}
GraphEdit_clear_connections :: (using self: *GraphEdit) {
}
GraphEdit_force_connection_drag_end :: (using self: *GraphEdit) {
}
GraphEdit_get_scroll_offset :: (using self: *GraphEdit) -> Vector2 {
}
GraphEdit_set_scroll_offset :: (using self: *GraphEdit, offset: Vector2) {
}
GraphEdit_add_valid_right_disconnect_type :: (using self: *GraphEdit, type: int) {
}
GraphEdit_remove_valid_right_disconnect_type :: (using self: *GraphEdit, type: int) {
}
GraphEdit_add_valid_left_disconnect_type :: (using self: *GraphEdit, type: int) {
}
GraphEdit_remove_valid_left_disconnect_type :: (using self: *GraphEdit, type: int) {
}
GraphEdit_add_valid_connection_type :: (using self: *GraphEdit, from_type: int, to_type: int) {
}
GraphEdit_remove_valid_connection_type :: (using self: *GraphEdit, from_type: int, to_type: int) {
}
GraphEdit_is_valid_connection_type :: (using self: *GraphEdit, from_type: int, to_type: int) -> bool {
}
GraphEdit_get_connection_line :: (using self: *GraphEdit, from_node: Vector2, to_node: Vector2) -> PackedVector2Array {
}
GraphEdit_attach_graph_element_to_frame :: (using self: *GraphEdit, element: StringName, frame: StringName) {
}
GraphEdit_detach_graph_element_from_frame :: (using self: *GraphEdit, element: StringName) {
}
GraphEdit_get_element_frame :: (using self: *GraphEdit, element: StringName) -> GraphFrame {
}
GraphEdit_get_attached_nodes_of_frame :: (using self: *GraphEdit, frame: StringName) -> Array {
}
GraphEdit_set_panning_scheme :: (using self: *GraphEdit, scheme: GraphEdit.PanningScheme) {
}
GraphEdit_get_panning_scheme :: (using self: *GraphEdit) -> GraphEdit.PanningScheme {
}
GraphEdit_set_zoom :: (using self: *GraphEdit, zoom: float) {
}
GraphEdit_get_zoom :: (using self: *GraphEdit) -> float {
}
GraphEdit_set_zoom_min :: (using self: *GraphEdit, zoom_min: float) {
}
GraphEdit_get_zoom_min :: (using self: *GraphEdit) -> float {
}
GraphEdit_set_zoom_max :: (using self: *GraphEdit, zoom_max: float) {
}
GraphEdit_get_zoom_max :: (using self: *GraphEdit) -> float {
}
GraphEdit_set_zoom_step :: (using self: *GraphEdit, zoom_step: float) {
}
GraphEdit_get_zoom_step :: (using self: *GraphEdit) -> float {
}
GraphEdit_set_show_grid :: (using self: *GraphEdit, enable: bool) {
}
GraphEdit_is_showing_grid :: (using self: *GraphEdit) -> bool {
}
GraphEdit_set_grid_pattern :: (using self: *GraphEdit, pattern: GraphEdit.GridPattern) {
}
GraphEdit_get_grid_pattern :: (using self: *GraphEdit) -> GraphEdit.GridPattern {
}
GraphEdit_set_snapping_enabled :: (using self: *GraphEdit, enable: bool) {
}
GraphEdit_is_snapping_enabled :: (using self: *GraphEdit) -> bool {
}
GraphEdit_set_snapping_distance :: (using self: *GraphEdit, pixels: int) {
}
GraphEdit_get_snapping_distance :: (using self: *GraphEdit) -> int {
}
GraphEdit_set_connection_lines_curvature :: (using self: *GraphEdit, curvature: float) {
}
GraphEdit_get_connection_lines_curvature :: (using self: *GraphEdit) -> float {
}
GraphEdit_set_connection_lines_thickness :: (using self: *GraphEdit, pixels: float) {
}
GraphEdit_get_connection_lines_thickness :: (using self: *GraphEdit) -> float {
}
GraphEdit_set_connection_lines_antialiased :: (using self: *GraphEdit, pixels: bool) {
}
GraphEdit_is_connection_lines_antialiased :: (using self: *GraphEdit) -> bool {
}
GraphEdit_set_minimap_size :: (using self: *GraphEdit, size: Vector2) {
}
GraphEdit_get_minimap_size :: (using self: *GraphEdit) -> Vector2 {
}
GraphEdit_set_minimap_opacity :: (using self: *GraphEdit, opacity: float) {
}
GraphEdit_get_minimap_opacity :: (using self: *GraphEdit) -> float {
}
GraphEdit_set_minimap_enabled :: (using self: *GraphEdit, enable: bool) {
}
GraphEdit_is_minimap_enabled :: (using self: *GraphEdit) -> bool {
}
GraphEdit_set_show_menu :: (using self: *GraphEdit, hidden: bool) {
}
GraphEdit_is_showing_menu :: (using self: *GraphEdit) -> bool {
}
GraphEdit_set_show_zoom_label :: (using self: *GraphEdit, enable: bool) {
}
GraphEdit_is_showing_zoom_label :: (using self: *GraphEdit) -> bool {
}
GraphEdit_set_show_grid_buttons :: (using self: *GraphEdit, hidden: bool) {
}
GraphEdit_is_showing_grid_buttons :: (using self: *GraphEdit) -> bool {
}
GraphEdit_set_show_zoom_buttons :: (using self: *GraphEdit, hidden: bool) {
}
GraphEdit_is_showing_zoom_buttons :: (using self: *GraphEdit) -> bool {
}
GraphEdit_set_show_minimap_button :: (using self: *GraphEdit, hidden: bool) {
}
GraphEdit_is_showing_minimap_button :: (using self: *GraphEdit) -> bool {
}
GraphEdit_set_show_arrange_button :: (using self: *GraphEdit, hidden: bool) {
}
GraphEdit_is_showing_arrange_button :: (using self: *GraphEdit) -> bool {
}
GraphEdit_set_right_disconnects :: (using self: *GraphEdit, enable: bool) {
}
GraphEdit_is_right_disconnects_enabled :: (using self: *GraphEdit) -> bool {
}
GraphEdit_get_menu_hbox :: (using self: *GraphEdit) -> HBoxContainer {
}
GraphEdit_arrange_nodes :: (using self: *GraphEdit) {
}
GraphEdit_set_selected :: (using self: *GraphEdit, node: Node) {
}

// GraphElement
GraphElement :: struct {
	__private: *void;
}

GraphElement_set_resizable :: (using self: *GraphElement, resizable: bool) {
}
GraphElement_is_resizable :: (using self: *GraphElement) -> bool {
}
GraphElement_set_draggable :: (using self: *GraphElement, draggable: bool) {
}
GraphElement_is_draggable :: (using self: *GraphElement) -> bool {
}
GraphElement_set_selectable :: (using self: *GraphElement, selectable: bool) {
}
GraphElement_is_selectable :: (using self: *GraphElement) -> bool {
}
GraphElement_set_selected :: (using self: *GraphElement, selected: bool) {
}
GraphElement_is_selected :: (using self: *GraphElement) -> bool {
}
GraphElement_set_position_offset :: (using self: *GraphElement, offset: Vector2) {
}
GraphElement_get_position_offset :: (using self: *GraphElement) -> Vector2 {
}

// GraphFrame
GraphFrame :: struct {
	__private: *void;
}

GraphFrame_set_title :: (using self: *GraphFrame, title: String) {
}
GraphFrame_get_title :: (using self: *GraphFrame) -> String {
}
GraphFrame_get_titlebar_hbox :: (using self: *GraphFrame) -> HBoxContainer {
}
GraphFrame_set_autoshrink_enabled :: (using self: *GraphFrame, shrink: bool) {
}
GraphFrame_is_autoshrink_enabled :: (using self: *GraphFrame) -> bool {
}
GraphFrame_set_autoshrink_margin :: (using self: *GraphFrame, autoshrink_margin: int) {
}
GraphFrame_get_autoshrink_margin :: (using self: *GraphFrame) -> int {
}
GraphFrame_set_drag_margin :: (using self: *GraphFrame, drag_margin: int) {
}
GraphFrame_get_drag_margin :: (using self: *GraphFrame) -> int {
}
GraphFrame_set_tint_color_enabled :: (using self: *GraphFrame, enable: bool) {
}
GraphFrame_is_tint_color_enabled :: (using self: *GraphFrame) -> bool {
}
GraphFrame_set_tint_color :: (using self: *GraphFrame, color: Color) {
}
GraphFrame_get_tint_color :: (using self: *GraphFrame) -> Color {
}

// GraphNode
GraphNode :: struct {
	__private: *void;
}

GraphNode__draw_port :: (using self: *GraphNode, slot_index: int, position: Vector2i, left: bool, color: Color) {
}
GraphNode_set_title :: (using self: *GraphNode, title: String) {
}
GraphNode_get_title :: (using self: *GraphNode) -> String {
}
GraphNode_get_titlebar_hbox :: (using self: *GraphNode) -> HBoxContainer {
}
GraphNode_set_slot :: (using self: *GraphNode, slot_index: int, enable_left_port: bool, type_left: int, color_left: Color, enable_right_port: bool, type_right: int, color_right: Color, custom_icon_left: Texture2D, custom_icon_right: Texture2D, draw_stylebox: bool) {
}
GraphNode_clear_slot :: (using self: *GraphNode, slot_index: int) {
}
GraphNode_clear_all_slots :: (using self: *GraphNode) {
}
GraphNode_is_slot_enabled_left :: (using self: *GraphNode, slot_index: int) -> bool {
}
GraphNode_set_slot_enabled_left :: (using self: *GraphNode, slot_index: int, enable: bool) {
}
GraphNode_set_slot_type_left :: (using self: *GraphNode, slot_index: int, type: int) {
}
GraphNode_get_slot_type_left :: (using self: *GraphNode, slot_index: int) -> int {
}
GraphNode_set_slot_color_left :: (using self: *GraphNode, slot_index: int, color: Color) {
}
GraphNode_get_slot_color_left :: (using self: *GraphNode, slot_index: int) -> Color {
}
GraphNode_set_slot_custom_icon_left :: (using self: *GraphNode, slot_index: int, custom_icon: Texture2D) {
}
GraphNode_get_slot_custom_icon_left :: (using self: *GraphNode, slot_index: int) -> Texture2D {
}
GraphNode_is_slot_enabled_right :: (using self: *GraphNode, slot_index: int) -> bool {
}
GraphNode_set_slot_enabled_right :: (using self: *GraphNode, slot_index: int, enable: bool) {
}
GraphNode_set_slot_type_right :: (using self: *GraphNode, slot_index: int, type: int) {
}
GraphNode_get_slot_type_right :: (using self: *GraphNode, slot_index: int) -> int {
}
GraphNode_set_slot_color_right :: (using self: *GraphNode, slot_index: int, color: Color) {
}
GraphNode_get_slot_color_right :: (using self: *GraphNode, slot_index: int) -> Color {
}
GraphNode_set_slot_custom_icon_right :: (using self: *GraphNode, slot_index: int, custom_icon: Texture2D) {
}
GraphNode_get_slot_custom_icon_right :: (using self: *GraphNode, slot_index: int) -> Texture2D {
}
GraphNode_is_slot_draw_stylebox :: (using self: *GraphNode, slot_index: int) -> bool {
}
GraphNode_set_slot_draw_stylebox :: (using self: *GraphNode, slot_index: int, enable: bool) {
}
GraphNode_set_ignore_invalid_connection_type :: (using self: *GraphNode, ignore: bool) {
}
GraphNode_is_ignoring_valid_connection_type :: (using self: *GraphNode) -> bool {
}
GraphNode_get_input_port_count :: (using self: *GraphNode) -> int {
}
GraphNode_get_input_port_position :: (using self: *GraphNode, port_idx: int) -> Vector2 {
}
GraphNode_get_input_port_type :: (using self: *GraphNode, port_idx: int) -> int {
}
GraphNode_get_input_port_color :: (using self: *GraphNode, port_idx: int) -> Color {
}
GraphNode_get_input_port_slot :: (using self: *GraphNode, port_idx: int) -> int {
}
GraphNode_get_output_port_count :: (using self: *GraphNode) -> int {
}
GraphNode_get_output_port_position :: (using self: *GraphNode, port_idx: int) -> Vector2 {
}
GraphNode_get_output_port_type :: (using self: *GraphNode, port_idx: int) -> int {
}
GraphNode_get_output_port_color :: (using self: *GraphNode, port_idx: int) -> Color {
}
GraphNode_get_output_port_slot :: (using self: *GraphNode, port_idx: int) -> int {
}

// GridContainer
GridContainer :: struct {
	__private: *void;
}

GridContainer_set_columns :: (using self: *GridContainer, columns: int) {
}
GridContainer_get_columns :: (using self: *GridContainer) -> int {
}

// GridMap
GridMap :: struct {
	__private: *void;

	INVALID_CELL_ITEM :: -1;
}

GridMap_set_collision_layer :: (using self: *GridMap, layer: int) {
}
GridMap_get_collision_layer :: (using self: *GridMap) -> int {
}
GridMap_set_collision_mask :: (using self: *GridMap, mask: int) {
}
GridMap_get_collision_mask :: (using self: *GridMap) -> int {
}
GridMap_set_collision_mask_value :: (using self: *GridMap, layer_number: int, value: bool) {
}
GridMap_get_collision_mask_value :: (using self: *GridMap, layer_number: int) -> bool {
}
GridMap_set_collision_layer_value :: (using self: *GridMap, layer_number: int, value: bool) {
}
GridMap_get_collision_layer_value :: (using self: *GridMap, layer_number: int) -> bool {
}
GridMap_set_collision_priority :: (using self: *GridMap, priority: float) {
}
GridMap_get_collision_priority :: (using self: *GridMap) -> float {
}
GridMap_set_physics_material :: (using self: *GridMap, material: PhysicsMaterial) {
}
GridMap_get_physics_material :: (using self: *GridMap) -> PhysicsMaterial {
}
GridMap_set_bake_navigation :: (using self: *GridMap, bake_navigation: bool) {
}
GridMap_is_baking_navigation :: (using self: *GridMap) -> bool {
}
GridMap_set_navigation_map :: (using self: *GridMap, navigation_map: RID) {
}
GridMap_get_navigation_map :: (using self: *GridMap) -> RID {
}
GridMap_set_mesh_library :: (using self: *GridMap, mesh_library: MeshLibrary) {
}
GridMap_get_mesh_library :: (using self: *GridMap) -> MeshLibrary {
}
GridMap_set_cell_size :: (using self: *GridMap, size: Vector3) {
}
GridMap_get_cell_size :: (using self: *GridMap) -> Vector3 {
}
GridMap_set_cell_scale :: (using self: *GridMap, scale: float) {
}
GridMap_get_cell_scale :: (using self: *GridMap) -> float {
}
GridMap_set_octant_size :: (using self: *GridMap, size: int) {
}
GridMap_get_octant_size :: (using self: *GridMap) -> int {
}
GridMap_set_cell_item :: (using self: *GridMap, position: Vector3i, item: int, orientation: int) {
}
GridMap_get_cell_item :: (using self: *GridMap, position: Vector3i) -> int {
}
GridMap_get_cell_item_orientation :: (using self: *GridMap, position: Vector3i) -> int {
}
GridMap_get_cell_item_basis :: (using self: *GridMap, position: Vector3i) -> Basis {
}
GridMap_get_basis_with_orthogonal_index :: (using self: *GridMap, index: int) -> Basis {
}
GridMap_get_orthogonal_index_from_basis :: (using self: *GridMap, basis: Basis) -> int {
}
GridMap_local_to_map :: (using self: *GridMap, local_position: Vector3) -> Vector3i {
}
GridMap_map_to_local :: (using self: *GridMap, map_position: Vector3i) -> Vector3 {
}
GridMap_resource_changed :: (using self: *GridMap, resource: Resource) {
}
GridMap_set_center_x :: (using self: *GridMap, enable: bool) {
}
GridMap_get_center_x :: (using self: *GridMap) -> bool {
}
GridMap_set_center_y :: (using self: *GridMap, enable: bool) {
}
GridMap_get_center_y :: (using self: *GridMap) -> bool {
}
GridMap_set_center_z :: (using self: *GridMap, enable: bool) {
}
GridMap_get_center_z :: (using self: *GridMap) -> bool {
}
GridMap_clear :: (using self: *GridMap) {
}
GridMap_get_used_cells :: (using self: *GridMap) -> Array {
}
GridMap_get_used_cells_by_item :: (using self: *GridMap, item: int) -> Array {
}
GridMap_get_meshes :: (using self: *GridMap) -> Array {
}
GridMap_get_bake_meshes :: (using self: *GridMap) -> Array {
}
GridMap_get_bake_mesh_instance :: (using self: *GridMap, idx: int) -> RID {
}
GridMap_clear_baked_meshes :: (using self: *GridMap) {
}
GridMap_make_baked_meshes :: (using self: *GridMap, gen_lightmap_uv: bool, lightmap_uv_texel_size: float) {
}

// GrooveJoint2D
GrooveJoint2D :: struct {
	__private: *void;
}

GrooveJoint2D_set_length :: (using self: *GrooveJoint2D, length: float) {
}
GrooveJoint2D_get_length :: (using self: *GrooveJoint2D) -> float {
}
GrooveJoint2D_set_initial_offset :: (using self: *GrooveJoint2D, offset: float) {
}
GrooveJoint2D_get_initial_offset :: (using self: *GrooveJoint2D) -> float {
}

// HBoxContainer
HBoxContainer :: struct {
	__private: *void;
}

// HFlowContainer
HFlowContainer :: struct {
	__private: *void;
}

// HMACContext
HMACContext :: struct {
	__private: *void;
}

HMACContext_start :: (using self: *HMACContext, hash_type: HashingContext.HashType, key: PackedByteArray) -> Error {
}
HMACContext_update :: (using self: *HMACContext, data: PackedByteArray) -> Error {
}
HMACContext_finish :: (using self: *HMACContext) -> PackedByteArray {
}

// HScrollBar
HScrollBar :: struct {
	__private: *void;
}

// HSeparator
HSeparator :: struct {
	__private: *void;
}

// HSlider
HSlider :: struct {
	__private: *void;
}

// HSplitContainer
HSplitContainer :: struct {
	__private: *void;
}

// HTTPClient
HTTPClient :: struct {
	__private: *void;

	Method :: enum {
		METHOD_GET :: 0;
		METHOD_HEAD :: 1;
		METHOD_POST :: 2;
		METHOD_PUT :: 3;
		METHOD_DELETE :: 4;
		METHOD_OPTIONS :: 5;
		METHOD_TRACE :: 6;
		METHOD_CONNECT :: 7;
		METHOD_PATCH :: 8;
		METHOD_MAX :: 9;
	}
	Status :: enum {
		STATUS_DISCONNECTED :: 0;
		STATUS_RESOLVING :: 1;
		STATUS_CANT_RESOLVE :: 2;
		STATUS_CONNECTING :: 3;
		STATUS_CANT_CONNECT :: 4;
		STATUS_CONNECTED :: 5;
		STATUS_REQUESTING :: 6;
		STATUS_BODY :: 7;
		STATUS_CONNECTION_ERROR :: 8;
		STATUS_TLS_HANDSHAKE_ERROR :: 9;
	}
	ResponseCode :: enum {
		RESPONSE_CONTINUE :: 100;
		RESPONSE_SWITCHING_PROTOCOLS :: 101;
		RESPONSE_PROCESSING :: 102;
		RESPONSE_OK :: 200;
		RESPONSE_CREATED :: 201;
		RESPONSE_ACCEPTED :: 202;
		RESPONSE_NON_AUTHORITATIVE_INFORMATION :: 203;
		RESPONSE_NO_CONTENT :: 204;
		RESPONSE_RESET_CONTENT :: 205;
		RESPONSE_PARTIAL_CONTENT :: 206;
		RESPONSE_MULTI_STATUS :: 207;
		RESPONSE_ALREADY_REPORTED :: 208;
		RESPONSE_IM_USED :: 226;
		RESPONSE_MULTIPLE_CHOICES :: 300;
		RESPONSE_MOVED_PERMANENTLY :: 301;
		RESPONSE_FOUND :: 302;
		RESPONSE_SEE_OTHER :: 303;
		RESPONSE_NOT_MODIFIED :: 304;
		RESPONSE_USE_PROXY :: 305;
		RESPONSE_SWITCH_PROXY :: 306;
		RESPONSE_TEMPORARY_REDIRECT :: 307;
		RESPONSE_PERMANENT_REDIRECT :: 308;
		RESPONSE_BAD_REQUEST :: 400;
		RESPONSE_UNAUTHORIZED :: 401;
		RESPONSE_PAYMENT_REQUIRED :: 402;
		RESPONSE_FORBIDDEN :: 403;
		RESPONSE_NOT_FOUND :: 404;
		RESPONSE_METHOD_NOT_ALLOWED :: 405;
		RESPONSE_NOT_ACCEPTABLE :: 406;
		RESPONSE_PROXY_AUTHENTICATION_REQUIRED :: 407;
		RESPONSE_REQUEST_TIMEOUT :: 408;
		RESPONSE_CONFLICT :: 409;
		RESPONSE_GONE :: 410;
		RESPONSE_LENGTH_REQUIRED :: 411;
		RESPONSE_PRECONDITION_FAILED :: 412;
		RESPONSE_REQUEST_ENTITY_TOO_LARGE :: 413;
		RESPONSE_REQUEST_URI_TOO_LONG :: 414;
		RESPONSE_UNSUPPORTED_MEDIA_TYPE :: 415;
		RESPONSE_REQUESTED_RANGE_NOT_SATISFIABLE :: 416;
		RESPONSE_EXPECTATION_FAILED :: 417;
		RESPONSE_IM_A_TEAPOT :: 418;
		RESPONSE_MISDIRECTED_REQUEST :: 421;
		RESPONSE_UNPROCESSABLE_ENTITY :: 422;
		RESPONSE_LOCKED :: 423;
		RESPONSE_FAILED_DEPENDENCY :: 424;
		RESPONSE_UPGRADE_REQUIRED :: 426;
		RESPONSE_PRECONDITION_REQUIRED :: 428;
		RESPONSE_TOO_MANY_REQUESTS :: 429;
		RESPONSE_REQUEST_HEADER_FIELDS_TOO_LARGE :: 431;
		RESPONSE_UNAVAILABLE_FOR_LEGAL_REASONS :: 451;
		RESPONSE_INTERNAL_SERVER_ERROR :: 500;
		RESPONSE_NOT_IMPLEMENTED :: 501;
		RESPONSE_BAD_GATEWAY :: 502;
		RESPONSE_SERVICE_UNAVAILABLE :: 503;
		RESPONSE_GATEWAY_TIMEOUT :: 504;
		RESPONSE_HTTP_VERSION_NOT_SUPPORTED :: 505;
		RESPONSE_VARIANT_ALSO_NEGOTIATES :: 506;
		RESPONSE_INSUFFICIENT_STORAGE :: 507;
		RESPONSE_LOOP_DETECTED :: 508;
		RESPONSE_NOT_EXTENDED :: 510;
		RESPONSE_NETWORK_AUTH_REQUIRED :: 511;
	}
}

HTTPClient_connect_to_host :: (using self: *HTTPClient, host: String, port: int, tls_options: TLSOptions) -> Error {
}
HTTPClient_set_connection :: (using self: *HTTPClient, connection: StreamPeer) {
}
HTTPClient_get_connection :: (using self: *HTTPClient) -> StreamPeer {
}
HTTPClient_request_raw :: (using self: *HTTPClient, method: HTTPClient.Method, url: String, headers: PackedStringArray, body: PackedByteArray) -> Error {
}
HTTPClient_request :: (using self: *HTTPClient, method: HTTPClient.Method, url: String, headers: PackedStringArray, body: String) -> Error {
}
HTTPClient_close :: (using self: *HTTPClient) {
}
HTTPClient_has_response :: (using self: *HTTPClient) -> bool {
}
HTTPClient_is_response_chunked :: (using self: *HTTPClient) -> bool {
}
HTTPClient_get_response_code :: (using self: *HTTPClient) -> int {
}
HTTPClient_get_response_headers :: (using self: *HTTPClient) -> PackedStringArray {
}
HTTPClient_get_response_headers_as_dictionary :: (using self: *HTTPClient) -> Dictionary {
}
HTTPClient_get_response_body_length :: (using self: *HTTPClient) -> int {
}
HTTPClient_read_response_body_chunk :: (using self: *HTTPClient) -> PackedByteArray {
}
HTTPClient_set_read_chunk_size :: (using self: *HTTPClient, bytes: int) {
}
HTTPClient_get_read_chunk_size :: (using self: *HTTPClient) -> int {
}
HTTPClient_set_blocking_mode :: (using self: *HTTPClient, enabled: bool) {
}
HTTPClient_is_blocking_mode_enabled :: (using self: *HTTPClient) -> bool {
}
HTTPClient_get_status :: (using self: *HTTPClient) -> HTTPClient.Status {
}
HTTPClient_poll :: (using self: *HTTPClient) -> Error {
}
HTTPClient_set_http_proxy :: (using self: *HTTPClient, host: String, port: int) {
}
HTTPClient_set_https_proxy :: (using self: *HTTPClient, host: String, port: int) {
}
HTTPClient_query_string_from_dict :: (using self: *HTTPClient, fields: Dictionary) -> String {
}

// HTTPRequest
HTTPRequest :: struct {
	__private: *void;

	Result :: enum {
		RESULT_SUCCESS :: 0;
		RESULT_CHUNKED_BODY_SIZE_MISMATCH :: 1;
		RESULT_CANT_CONNECT :: 2;
		RESULT_CANT_RESOLVE :: 3;
		RESULT_CONNECTION_ERROR :: 4;
		RESULT_TLS_HANDSHAKE_ERROR :: 5;
		RESULT_NO_RESPONSE :: 6;
		RESULT_BODY_SIZE_LIMIT_EXCEEDED :: 7;
		RESULT_BODY_DECOMPRESS_FAILED :: 8;
		RESULT_REQUEST_FAILED :: 9;
		RESULT_DOWNLOAD_FILE_CANT_OPEN :: 10;
		RESULT_DOWNLOAD_FILE_WRITE_ERROR :: 11;
		RESULT_REDIRECT_LIMIT_REACHED :: 12;
		RESULT_TIMEOUT :: 13;
	}
}

HTTPRequest_request :: (using self: *HTTPRequest, url: String, custom_headers: PackedStringArray, method: HTTPClient.Method, request_data: String) -> Error {
}
HTTPRequest_request_raw :: (using self: *HTTPRequest, url: String, custom_headers: PackedStringArray, method: HTTPClient.Method, request_data_raw: PackedByteArray) -> Error {
}
HTTPRequest_cancel_request :: (using self: *HTTPRequest) {
}
HTTPRequest_set_tls_options :: (using self: *HTTPRequest, client_options: TLSOptions) {
}
HTTPRequest_get_http_client_status :: (using self: *HTTPRequest) -> HTTPClient.Status {
}
HTTPRequest_set_use_threads :: (using self: *HTTPRequest, enable: bool) {
}
HTTPRequest_is_using_threads :: (using self: *HTTPRequest) -> bool {
}
HTTPRequest_set_accept_gzip :: (using self: *HTTPRequest, enable: bool) {
}
HTTPRequest_is_accepting_gzip :: (using self: *HTTPRequest) -> bool {
}
HTTPRequest_set_body_size_limit :: (using self: *HTTPRequest, bytes: int) {
}
HTTPRequest_get_body_size_limit :: (using self: *HTTPRequest) -> int {
}
HTTPRequest_set_max_redirects :: (using self: *HTTPRequest, amount: int) {
}
HTTPRequest_get_max_redirects :: (using self: *HTTPRequest) -> int {
}
HTTPRequest_set_download_file :: (using self: *HTTPRequest, path: String) {
}
HTTPRequest_get_download_file :: (using self: *HTTPRequest) -> String {
}
HTTPRequest_get_downloaded_bytes :: (using self: *HTTPRequest) -> int {
}
HTTPRequest_get_body_size :: (using self: *HTTPRequest) -> int {
}
HTTPRequest_set_timeout :: (using self: *HTTPRequest, timeout: float) {
}
HTTPRequest_get_timeout :: (using self: *HTTPRequest) -> float {
}
HTTPRequest_set_download_chunk_size :: (using self: *HTTPRequest, chunk_size: int) {
}
HTTPRequest_get_download_chunk_size :: (using self: *HTTPRequest) -> int {
}
HTTPRequest_set_http_proxy :: (using self: *HTTPRequest, host: String, port: int) {
}
HTTPRequest_set_https_proxy :: (using self: *HTTPRequest, host: String, port: int) {
}

// HashingContext
HashingContext :: struct {
	__private: *void;

	HashType :: enum {
		HASH_MD5 :: 0;
		HASH_SHA1 :: 1;
		HASH_SHA256 :: 2;
	}
}

HashingContext_start :: (using self: *HashingContext, type: HashingContext.HashType) -> Error {
}
HashingContext_update :: (using self: *HashingContext, chunk: PackedByteArray) -> Error {
}
HashingContext_finish :: (using self: *HashingContext) -> PackedByteArray {
}

// HeightMapShape3D
HeightMapShape3D :: struct {
	__private: *void;
}

HeightMapShape3D_set_map_width :: (using self: *HeightMapShape3D, width: int) {
}
HeightMapShape3D_get_map_width :: (using self: *HeightMapShape3D) -> int {
}
HeightMapShape3D_set_map_depth :: (using self: *HeightMapShape3D, height: int) {
}
HeightMapShape3D_get_map_depth :: (using self: *HeightMapShape3D) -> int {
}
HeightMapShape3D_set_map_data :: (using self: *HeightMapShape3D, data: PackedFloat32Array) {
}
HeightMapShape3D_get_map_data :: (using self: *HeightMapShape3D) -> PackedFloat32Array {
}
HeightMapShape3D_get_min_height :: (using self: *HeightMapShape3D) -> float {
}
HeightMapShape3D_get_max_height :: (using self: *HeightMapShape3D) -> float {
}
HeightMapShape3D_update_map_data_from_image :: (using self: *HeightMapShape3D, image: Image, height_min: float, height_max: float) {
}

// HingeJoint3D
HingeJoint3D :: struct {
	__private: *void;

	Param :: enum {
		PARAM_BIAS :: 0;
		PARAM_LIMIT_UPPER :: 1;
		PARAM_LIMIT_LOWER :: 2;
		PARAM_LIMIT_BIAS :: 3;
		PARAM_LIMIT_SOFTNESS :: 4;
		PARAM_LIMIT_RELAXATION :: 5;
		PARAM_MOTOR_TARGET_VELOCITY :: 6;
		PARAM_MOTOR_MAX_IMPULSE :: 7;
		PARAM_MAX :: 8;
	}
	Flag :: enum {
		FLAG_USE_LIMIT :: 0;
		FLAG_ENABLE_MOTOR :: 1;
		FLAG_MAX :: 2;
	}
}

HingeJoint3D_set_param :: (using self: *HingeJoint3D, param: HingeJoint3D.Param, value: float) {
}
HingeJoint3D_get_param :: (using self: *HingeJoint3D, param: HingeJoint3D.Param) -> float {
}
HingeJoint3D_set_flag :: (using self: *HingeJoint3D, flag: HingeJoint3D.Flag, enabled: bool) {
}
HingeJoint3D_get_flag :: (using self: *HingeJoint3D, flag: HingeJoint3D.Flag) -> bool {
}

// IP
IP :: struct {
	__private: *void;

	RESOLVER_MAX_QUERIES :: 256;
	RESOLVER_INVALID_ID :: -1;

	ResolverStatus :: enum {
		RESOLVER_STATUS_NONE :: 0;
		RESOLVER_STATUS_WAITING :: 1;
		RESOLVER_STATUS_DONE :: 2;
		RESOLVER_STATUS_ERROR :: 3;
	}
	Type :: enum {
		TYPE_NONE :: 0;
		TYPE_IPV4 :: 1;
		TYPE_IPV6 :: 2;
		TYPE_ANY :: 3;
	}
}

IP_resolve_hostname :: (using self: *IP, host: String, ip_type: IP.Type) -> String {
}
IP_resolve_hostname_addresses :: (using self: *IP, host: String, ip_type: IP.Type) -> PackedStringArray {
}
IP_resolve_hostname_queue_item :: (using self: *IP, host: String, ip_type: IP.Type) -> int {
}
IP_get_resolve_item_status :: (using self: *IP, id: int) -> IP.ResolverStatus {
}
IP_get_resolve_item_address :: (using self: *IP, id: int) -> String {
}
IP_get_resolve_item_addresses :: (using self: *IP, id: int) -> Array {
}
IP_erase_resolve_item :: (using self: *IP, id: int) {
}
IP_get_local_addresses :: (using self: *IP) -> PackedStringArray {
}
IP_get_local_interfaces :: (using self: *IP) -> Dictionary {
}
IP_clear_cache :: (using self: *IP, hostname: String) {
}

// Image
Image :: struct {
	__private: *void;

	MAX_WIDTH :: 16777216;
	MAX_HEIGHT :: 16777216;

	Format :: enum {
		FORMAT_L8 :: 0;
		FORMAT_LA8 :: 1;
		FORMAT_R8 :: 2;
		FORMAT_RG8 :: 3;
		FORMAT_RGB8 :: 4;
		FORMAT_RGBA8 :: 5;
		FORMAT_RGBA4444 :: 6;
		FORMAT_RGB565 :: 7;
		FORMAT_RF :: 8;
		FORMAT_RGF :: 9;
		FORMAT_RGBF :: 10;
		FORMAT_RGBAF :: 11;
		FORMAT_RH :: 12;
		FORMAT_RGH :: 13;
		FORMAT_RGBH :: 14;
		FORMAT_RGBAH :: 15;
		FORMAT_RGBE9995 :: 16;
		FORMAT_DXT1 :: 17;
		FORMAT_DXT3 :: 18;
		FORMAT_DXT5 :: 19;
		FORMAT_RGTC_R :: 20;
		FORMAT_RGTC_RG :: 21;
		FORMAT_BPTC_RGBA :: 22;
		FORMAT_BPTC_RGBF :: 23;
		FORMAT_BPTC_RGBFU :: 24;
		FORMAT_ETC :: 25;
		FORMAT_ETC2_R11 :: 26;
		FORMAT_ETC2_R11S :: 27;
		FORMAT_ETC2_RG11 :: 28;
		FORMAT_ETC2_RG11S :: 29;
		FORMAT_ETC2_RGB8 :: 30;
		FORMAT_ETC2_RGBA8 :: 31;
		FORMAT_ETC2_RGB8A1 :: 32;
		FORMAT_ETC2_RA_AS_RG :: 33;
		FORMAT_DXT5_RA_AS_RG :: 34;
		FORMAT_ASTC_4x4 :: 35;
		FORMAT_ASTC_4x4_HDR :: 36;
		FORMAT_ASTC_8x8 :: 37;
		FORMAT_ASTC_8x8_HDR :: 38;
		FORMAT_MAX :: 39;
	}
	Interpolation :: enum {
		INTERPOLATE_NEAREST :: 0;
		INTERPOLATE_BILINEAR :: 1;
		INTERPOLATE_CUBIC :: 2;
		INTERPOLATE_TRILINEAR :: 3;
		INTERPOLATE_LANCZOS :: 4;
	}
	AlphaMode :: enum {
		ALPHA_NONE :: 0;
		ALPHA_BIT :: 1;
		ALPHA_BLEND :: 2;
	}
	CompressMode :: enum {
		COMPRESS_S3TC :: 0;
		COMPRESS_ETC :: 1;
		COMPRESS_ETC2 :: 2;
		COMPRESS_BPTC :: 3;
		COMPRESS_ASTC :: 4;
		COMPRESS_MAX :: 5;
	}
	UsedChannels :: enum {
		USED_CHANNELS_L :: 0;
		USED_CHANNELS_LA :: 1;
		USED_CHANNELS_R :: 2;
		USED_CHANNELS_RG :: 3;
		USED_CHANNELS_RGB :: 4;
		USED_CHANNELS_RGBA :: 5;
	}
	CompressSource :: enum {
		COMPRESS_SOURCE_GENERIC :: 0;
		COMPRESS_SOURCE_SRGB :: 1;
		COMPRESS_SOURCE_NORMAL :: 2;
	}
	ASTCFormat :: enum {
		ASTC_FORMAT_4x4 :: 0;
		ASTC_FORMAT_8x8 :: 1;
	}
}

Image_get_width :: (using self: *Image) -> int {
}
Image_get_height :: (using self: *Image) -> int {
}
Image_get_size :: (using self: *Image) -> Vector2i {
}
Image_has_mipmaps :: (using self: *Image) -> bool {
}
Image_get_format :: (using self: *Image) -> Image.Format {
}
Image_get_data :: (using self: *Image) -> PackedByteArray {
}
Image_get_data_size :: (using self: *Image) -> int {
}
Image_convert :: (using self: *Image, format: Image.Format) {
}
Image_get_mipmap_count :: (using self: *Image) -> int {
}
Image_get_mipmap_offset :: (using self: *Image, mipmap: int) -> int {
}
Image_resize_to_po2 :: (using self: *Image, square: bool, interpolation: Image.Interpolation) {
}
Image_resize :: (using self: *Image, width: int, height: int, interpolation: Image.Interpolation) {
}
Image_shrink_x2 :: (using self: *Image) {
}
Image_crop :: (using self: *Image, width: int, height: int) {
}
Image_flip_x :: (using self: *Image) {
}
Image_flip_y :: (using self: *Image) {
}
Image_generate_mipmaps :: (using self: *Image, renormalize: bool) -> Error {
}
Image_clear_mipmaps :: (using self: *Image) {
}
Image_create :: (using self: *Image, width: int, height: int, use_mipmaps: bool, format: Image.Format) -> Image {
}
Image_create_empty :: (using self: *Image, width: int, height: int, use_mipmaps: bool, format: Image.Format) -> Image {
}
Image_create_from_data :: (using self: *Image, width: int, height: int, use_mipmaps: bool, format: Image.Format, data: PackedByteArray) -> Image {
}
Image_set_data :: (using self: *Image, width: int, height: int, use_mipmaps: bool, format: Image.Format, data: PackedByteArray) {
}
Image_is_empty :: (using self: *Image) -> bool {
}
Image_load :: (using self: *Image, path: String) -> Error {
}
Image_load_from_file :: (using self: *Image, path: String) -> Image {
}
Image_save_png :: (using self: *Image, path: String) -> Error {
}
Image_save_png_to_buffer :: (using self: *Image) -> PackedByteArray {
}
Image_save_jpg :: (using self: *Image, path: String, quality: float) -> Error {
}
Image_save_jpg_to_buffer :: (using self: *Image, quality: float) -> PackedByteArray {
}
Image_save_exr :: (using self: *Image, path: String, grayscale: bool) -> Error {
}
Image_save_exr_to_buffer :: (using self: *Image, grayscale: bool) -> PackedByteArray {
}
Image_save_webp :: (using self: *Image, path: String, lossy: bool, quality: float) -> Error {
}
Image_save_webp_to_buffer :: (using self: *Image, lossy: bool, quality: float) -> PackedByteArray {
}
Image_detect_alpha :: (using self: *Image) -> Image.AlphaMode {
}
Image_is_invisible :: (using self: *Image) -> bool {
}
Image_detect_used_channels :: (using self: *Image, source: Image.CompressSource) -> Image.UsedChannels {
}
Image_compress :: (using self: *Image, mode: Image.CompressMode, source: Image.CompressSource, astc_format: Image.ASTCFormat) -> Error {
}
Image_compress_from_channels :: (using self: *Image, mode: Image.CompressMode, channels: Image.UsedChannels, astc_format: Image.ASTCFormat) -> Error {
}
Image_decompress :: (using self: *Image) -> Error {
}
Image_is_compressed :: (using self: *Image) -> bool {
}
Image_rotate_90 :: (using self: *Image, direction: ClockDirection) {
}
Image_rotate_180 :: (using self: *Image) {
}
Image_fix_alpha_edges :: (using self: *Image) {
}
Image_premultiply_alpha :: (using self: *Image) {
}
Image_srgb_to_linear :: (using self: *Image) {
}
Image_normal_map_to_xy :: (using self: *Image) {
}
Image_rgbe_to_srgb :: (using self: *Image) -> Image {
}
Image_bump_map_to_normal_map :: (using self: *Image, bump_scale: float) {
}
Image_compute_image_metrics :: (using self: *Image, compared_image: Image, use_luma: bool) -> Dictionary {
}
Image_blit_rect :: (using self: *Image, src: Image, src_rect: Rect2i, dst: Vector2i) {
}
Image_blit_rect_mask :: (using self: *Image, src: Image, mask: Image, src_rect: Rect2i, dst: Vector2i) {
}
Image_blend_rect :: (using self: *Image, src: Image, src_rect: Rect2i, dst: Vector2i) {
}
Image_blend_rect_mask :: (using self: *Image, src: Image, mask: Image, src_rect: Rect2i, dst: Vector2i) {
}
Image_fill :: (using self: *Image, color: Color) {
}
Image_fill_rect :: (using self: *Image, rect: Rect2i, color: Color) {
}
Image_get_used_rect :: (using self: *Image) -> Rect2i {
}
Image_get_region :: (using self: *Image, region: Rect2i) -> Image {
}
Image_copy_from :: (using self: *Image, src: Image) {
}
Image_get_pixelv :: (using self: *Image, point: Vector2i) -> Color {
}
Image_get_pixel :: (using self: *Image, x: int, y: int) -> Color {
}
Image_set_pixelv :: (using self: *Image, point: Vector2i, color: Color) {
}
Image_set_pixel :: (using self: *Image, x: int, y: int, color: Color) {
}
Image_adjust_bcs :: (using self: *Image, brightness: float, contrast: float, saturation: float) {
}
Image_load_png_from_buffer :: (using self: *Image, buffer: PackedByteArray) -> Error {
}
Image_load_jpg_from_buffer :: (using self: *Image, buffer: PackedByteArray) -> Error {
}
Image_load_webp_from_buffer :: (using self: *Image, buffer: PackedByteArray) -> Error {
}
Image_load_tga_from_buffer :: (using self: *Image, buffer: PackedByteArray) -> Error {
}
Image_load_bmp_from_buffer :: (using self: *Image, buffer: PackedByteArray) -> Error {
}
Image_load_ktx_from_buffer :: (using self: *Image, buffer: PackedByteArray) -> Error {
}
Image_load_svg_from_buffer :: (using self: *Image, buffer: PackedByteArray, scale: float) -> Error {
}
Image_load_svg_from_string :: (using self: *Image, svg_str: String, scale: float) -> Error {
}

// ImageFormatLoader
ImageFormatLoader :: struct {
	__private: *void;

	LoaderFlags :: enum_flags {
		FLAG_NONE :: 0;
		FLAG_FORCE_LINEAR :: 1;
		FLAG_CONVERT_COLORS :: 2;
	}
}

// ImageFormatLoaderExtension
ImageFormatLoaderExtension :: struct {
	__private: *void;
}

ImageFormatLoaderExtension__get_recognized_extensions :: (using self: *ImageFormatLoaderExtension) -> PackedStringArray {
}
ImageFormatLoaderExtension__load_image :: (using self: *ImageFormatLoaderExtension, image: Image, fileaccess: FileAccess, flags: ImageFormatLoader.LoaderFlags, scale: float) -> Error {
}
ImageFormatLoaderExtension_add_format_loader :: (using self: *ImageFormatLoaderExtension) {
}
ImageFormatLoaderExtension_remove_format_loader :: (using self: *ImageFormatLoaderExtension) {
}

// ImageTexture
ImageTexture :: struct {
	__private: *void;
}

ImageTexture_create_from_image :: (using self: *ImageTexture, image: Image) -> ImageTexture {
}
ImageTexture_get_format :: (using self: *ImageTexture) -> Image.Format {
}
ImageTexture_set_image :: (using self: *ImageTexture, image: Image) {
}
ImageTexture_update :: (using self: *ImageTexture, image: Image) {
}
ImageTexture_set_size_override :: (using self: *ImageTexture, size: Vector2i) {
}

// ImageTexture3D
ImageTexture3D :: struct {
	__private: *void;
}

ImageTexture3D_create :: (using self: *ImageTexture3D, format: Image.Format, width: int, height: int, depth: int, use_mipmaps: bool, data: Array) -> Error {
}
ImageTexture3D_update :: (using self: *ImageTexture3D, data: Array) {
}

// ImageTextureLayered
ImageTextureLayered :: struct {
	__private: *void;
}

ImageTextureLayered_create_from_images :: (using self: *ImageTextureLayered, images: Array) -> Error {
}
ImageTextureLayered_update_layer :: (using self: *ImageTextureLayered, image: Image, layer: int) {
}

// ImmediateMesh
ImmediateMesh :: struct {
	__private: *void;
}

ImmediateMesh_surface_begin :: (using self: *ImmediateMesh, primitive: Mesh.PrimitiveType, material: Material) {
}
ImmediateMesh_surface_set_color :: (using self: *ImmediateMesh, color: Color) {
}
ImmediateMesh_surface_set_normal :: (using self: *ImmediateMesh, normal: Vector3) {
}
ImmediateMesh_surface_set_tangent :: (using self: *ImmediateMesh, tangent: Plane) {
}
ImmediateMesh_surface_set_uv :: (using self: *ImmediateMesh, uv: Vector2) {
}
ImmediateMesh_surface_set_uv2 :: (using self: *ImmediateMesh, uv2: Vector2) {
}
ImmediateMesh_surface_add_vertex :: (using self: *ImmediateMesh, vertex: Vector3) {
}
ImmediateMesh_surface_add_vertex_2d :: (using self: *ImmediateMesh, vertex: Vector2) {
}
ImmediateMesh_surface_end :: (using self: *ImmediateMesh) {
}
ImmediateMesh_clear_surfaces :: (using self: *ImmediateMesh) {
}

// ImporterMesh
ImporterMesh :: struct {
	__private: *void;
}

ImporterMesh_add_blend_shape :: (using self: *ImporterMesh, name: String) {
}
ImporterMesh_get_blend_shape_count :: (using self: *ImporterMesh) -> int {
}
ImporterMesh_get_blend_shape_name :: (using self: *ImporterMesh, blend_shape_idx: int) -> String {
}
ImporterMesh_set_blend_shape_mode :: (using self: *ImporterMesh, mode: Mesh.BlendShapeMode) {
}
ImporterMesh_get_blend_shape_mode :: (using self: *ImporterMesh) -> Mesh.BlendShapeMode {
}
ImporterMesh_add_surface :: (using self: *ImporterMesh, primitive: Mesh.PrimitiveType, arrays: Array, blend_shapes: Array, lods: Dictionary, material: Material, name: String, flags: int) {
}
ImporterMesh_get_surface_count :: (using self: *ImporterMesh) -> int {
}
ImporterMesh_get_surface_primitive_type :: (using self: *ImporterMesh, surface_idx: int) -> Mesh.PrimitiveType {
}
ImporterMesh_get_surface_name :: (using self: *ImporterMesh, surface_idx: int) -> String {
}
ImporterMesh_get_surface_arrays :: (using self: *ImporterMesh, surface_idx: int) -> Array {
}
ImporterMesh_get_surface_blend_shape_arrays :: (using self: *ImporterMesh, surface_idx: int, blend_shape_idx: int) -> Array {
}
ImporterMesh_get_surface_lod_count :: (using self: *ImporterMesh, surface_idx: int) -> int {
}
ImporterMesh_get_surface_lod_size :: (using self: *ImporterMesh, surface_idx: int, lod_idx: int) -> float {
}
ImporterMesh_get_surface_lod_indices :: (using self: *ImporterMesh, surface_idx: int, lod_idx: int) -> PackedInt32Array {
}
ImporterMesh_get_surface_material :: (using self: *ImporterMesh, surface_idx: int) -> Material {
}
ImporterMesh_get_surface_format :: (using self: *ImporterMesh, surface_idx: int) -> int {
}
ImporterMesh_set_surface_name :: (using self: *ImporterMesh, surface_idx: int, name: String) {
}
ImporterMesh_set_surface_material :: (using self: *ImporterMesh, surface_idx: int, material: Material) {
}
ImporterMesh_generate_lods :: (using self: *ImporterMesh, normal_merge_angle: float, normal_split_angle: float, bone_transform_array: Array) {
}
ImporterMesh_get_mesh :: (using self: *ImporterMesh, base_mesh: ArrayMesh) -> ArrayMesh {
}
ImporterMesh_clear :: (using self: *ImporterMesh) {
}
ImporterMesh_set_lightmap_size_hint :: (using self: *ImporterMesh, size: Vector2i) {
}
ImporterMesh_get_lightmap_size_hint :: (using self: *ImporterMesh) -> Vector2i {
}

// ImporterMeshInstance3D
ImporterMeshInstance3D :: struct {
	__private: *void;
}

ImporterMeshInstance3D_set_mesh :: (using self: *ImporterMeshInstance3D, mesh: ImporterMesh) {
}
ImporterMeshInstance3D_get_mesh :: (using self: *ImporterMeshInstance3D) -> ImporterMesh {
}
ImporterMeshInstance3D_set_skin :: (using self: *ImporterMeshInstance3D, skin: Skin) {
}
ImporterMeshInstance3D_get_skin :: (using self: *ImporterMeshInstance3D) -> Skin {
}
ImporterMeshInstance3D_set_skeleton_path :: (using self: *ImporterMeshInstance3D, skeleton_path: NodePath) {
}
ImporterMeshInstance3D_get_skeleton_path :: (using self: *ImporterMeshInstance3D) -> NodePath {
}
ImporterMeshInstance3D_set_layer_mask :: (using self: *ImporterMeshInstance3D, layer_mask: int) {
}
ImporterMeshInstance3D_get_layer_mask :: (using self: *ImporterMeshInstance3D) -> int {
}
ImporterMeshInstance3D_set_cast_shadows_setting :: (using self: *ImporterMeshInstance3D, shadow_casting_setting: GeometryInstance3D.ShadowCastingSetting) {
}
ImporterMeshInstance3D_get_cast_shadows_setting :: (using self: *ImporterMeshInstance3D) -> GeometryInstance3D.ShadowCastingSetting {
}
ImporterMeshInstance3D_set_visibility_range_end_margin :: (using self: *ImporterMeshInstance3D, distance: float) {
}
ImporterMeshInstance3D_get_visibility_range_end_margin :: (using self: *ImporterMeshInstance3D) -> float {
}
ImporterMeshInstance3D_set_visibility_range_end :: (using self: *ImporterMeshInstance3D, distance: float) {
}
ImporterMeshInstance3D_get_visibility_range_end :: (using self: *ImporterMeshInstance3D) -> float {
}
ImporterMeshInstance3D_set_visibility_range_begin_margin :: (using self: *ImporterMeshInstance3D, distance: float) {
}
ImporterMeshInstance3D_get_visibility_range_begin_margin :: (using self: *ImporterMeshInstance3D) -> float {
}
ImporterMeshInstance3D_set_visibility_range_begin :: (using self: *ImporterMeshInstance3D, distance: float) {
}
ImporterMeshInstance3D_get_visibility_range_begin :: (using self: *ImporterMeshInstance3D) -> float {
}
ImporterMeshInstance3D_set_visibility_range_fade_mode :: (using self: *ImporterMeshInstance3D, mode: GeometryInstance3D.VisibilityRangeFadeMode) {
}
ImporterMeshInstance3D_get_visibility_range_fade_mode :: (using self: *ImporterMeshInstance3D) -> GeometryInstance3D.VisibilityRangeFadeMode {
}

// Input
Input :: struct {
	__private: *void;

	MouseMode :: enum {
		MOUSE_MODE_VISIBLE :: 0;
		MOUSE_MODE_HIDDEN :: 1;
		MOUSE_MODE_CAPTURED :: 2;
		MOUSE_MODE_CONFINED :: 3;
		MOUSE_MODE_CONFINED_HIDDEN :: 4;
	}
	CursorShape :: enum {
		CURSOR_ARROW :: 0;
		CURSOR_IBEAM :: 1;
		CURSOR_POINTING_HAND :: 2;
		CURSOR_CROSS :: 3;
		CURSOR_WAIT :: 4;
		CURSOR_BUSY :: 5;
		CURSOR_DRAG :: 6;
		CURSOR_CAN_DROP :: 7;
		CURSOR_FORBIDDEN :: 8;
		CURSOR_VSIZE :: 9;
		CURSOR_HSIZE :: 10;
		CURSOR_BDIAGSIZE :: 11;
		CURSOR_FDIAGSIZE :: 12;
		CURSOR_MOVE :: 13;
		CURSOR_VSPLIT :: 14;
		CURSOR_HSPLIT :: 15;
		CURSOR_HELP :: 16;
	}
}

Input_is_anything_pressed :: (using self: *Input) -> bool {
}
Input_is_key_pressed :: (using self: *Input, keycode: Key) -> bool {
}
Input_is_physical_key_pressed :: (using self: *Input, keycode: Key) -> bool {
}
Input_is_key_label_pressed :: (using self: *Input, keycode: Key) -> bool {
}
Input_is_mouse_button_pressed :: (using self: *Input, button: MouseButton) -> bool {
}
Input_is_joy_button_pressed :: (using self: *Input, device: int, button: JoyButton) -> bool {
}
Input_is_action_pressed :: (using self: *Input, action: StringName, exact_match: bool) -> bool {
}
Input_is_action_just_pressed :: (using self: *Input, action: StringName, exact_match: bool) -> bool {
}
Input_is_action_just_released :: (using self: *Input, action: StringName, exact_match: bool) -> bool {
}
Input_get_action_strength :: (using self: *Input, action: StringName, exact_match: bool) -> float {
}
Input_get_action_raw_strength :: (using self: *Input, action: StringName, exact_match: bool) -> float {
}
Input_get_axis :: (using self: *Input, negative_action: StringName, positive_action: StringName) -> float {
}
Input_get_vector :: (using self: *Input, negative_x: StringName, positive_x: StringName, negative_y: StringName, positive_y: StringName, deadzone: float) -> Vector2 {
}
Input_add_joy_mapping :: (using self: *Input, mapping: String, update_existing: bool) {
}
Input_remove_joy_mapping :: (using self: *Input, guid: String) {
}
Input_is_joy_known :: (using self: *Input, device: int) -> bool {
}
Input_get_joy_axis :: (using self: *Input, device: int, axis: JoyAxis) -> float {
}
Input_get_joy_name :: (using self: *Input, device: int) -> String {
}
Input_get_joy_guid :: (using self: *Input, device: int) -> String {
}
Input_get_joy_info :: (using self: *Input, device: int) -> Dictionary {
}
Input_should_ignore_device :: (using self: *Input, vendor_id: int, product_id: int) -> bool {
}
Input_get_connected_joypads :: (using self: *Input) -> Array {
}
Input_get_joy_vibration_strength :: (using self: *Input, device: int) -> Vector2 {
}
Input_get_joy_vibration_duration :: (using self: *Input, device: int) -> float {
}
Input_start_joy_vibration :: (using self: *Input, device: int, weak_magnitude: float, strong_magnitude: float, duration: float) {
}
Input_stop_joy_vibration :: (using self: *Input, device: int) {
}
Input_vibrate_handheld :: (using self: *Input, duration_ms: int, amplitude: float) {
}
Input_get_gravity :: (using self: *Input) -> Vector3 {
}
Input_get_accelerometer :: (using self: *Input) -> Vector3 {
}
Input_get_magnetometer :: (using self: *Input) -> Vector3 {
}
Input_get_gyroscope :: (using self: *Input) -> Vector3 {
}
Input_set_gravity :: (using self: *Input, value: Vector3) {
}
Input_set_accelerometer :: (using self: *Input, value: Vector3) {
}
Input_set_magnetometer :: (using self: *Input, value: Vector3) {
}
Input_set_gyroscope :: (using self: *Input, value: Vector3) {
}
Input_get_last_mouse_velocity :: (using self: *Input) -> Vector2 {
}
Input_get_last_mouse_screen_velocity :: (using self: *Input) -> Vector2 {
}
Input_get_mouse_button_mask :: (using self: *Input) -> MouseButtonMask {
}
Input_set_mouse_mode :: (using self: *Input, mode: Input.MouseMode) {
}
Input_get_mouse_mode :: (using self: *Input) -> Input.MouseMode {
}
Input_warp_mouse :: (using self: *Input, position: Vector2) {
}
Input_action_press :: (using self: *Input, action: StringName, strength: float) {
}
Input_action_release :: (using self: *Input, action: StringName) {
}
Input_set_default_cursor_shape :: (using self: *Input, shape: Input.CursorShape) {
}
Input_get_current_cursor_shape :: (using self: *Input) -> Input.CursorShape {
}
Input_set_custom_mouse_cursor :: (using self: *Input, image: Resource, shape: Input.CursorShape, hotspot: Vector2) {
}
Input_parse_input_event :: (using self: *Input, event: InputEvent) {
}
Input_set_use_accumulated_input :: (using self: *Input, enable: bool) {
}
Input_is_using_accumulated_input :: (using self: *Input) -> bool {
}
Input_flush_buffered_events :: (using self: *Input) {
}
Input_set_emulate_mouse_from_touch :: (using self: *Input, enable: bool) {
}
Input_is_emulating_mouse_from_touch :: (using self: *Input) -> bool {
}
Input_set_emulate_touch_from_mouse :: (using self: *Input, enable: bool) {
}
Input_is_emulating_touch_from_mouse :: (using self: *Input) -> bool {
}

// InputEvent
InputEvent :: struct {
	__private: *void;

	DEVICE_ID_EMULATION :: -1;
}

InputEvent_set_device :: (using self: *InputEvent, device: int) {
}
InputEvent_get_device :: (using self: *InputEvent) -> int {
}
InputEvent_is_action :: (using self: *InputEvent, action: StringName, exact_match: bool) -> bool {
}
InputEvent_is_action_pressed :: (using self: *InputEvent, action: StringName, allow_echo: bool, exact_match: bool) -> bool {
}
InputEvent_is_action_released :: (using self: *InputEvent, action: StringName, exact_match: bool) -> bool {
}
InputEvent_get_action_strength :: (using self: *InputEvent, action: StringName, exact_match: bool) -> float {
}
InputEvent_is_canceled :: (using self: *InputEvent) -> bool {
}
InputEvent_is_pressed :: (using self: *InputEvent) -> bool {
}
InputEvent_is_released :: (using self: *InputEvent) -> bool {
}
InputEvent_is_echo :: (using self: *InputEvent) -> bool {
}
InputEvent_as_text :: (using self: *InputEvent) -> String {
}
InputEvent_is_match :: (using self: *InputEvent, event: InputEvent, exact_match: bool) -> bool {
}
InputEvent_is_action_type :: (using self: *InputEvent) -> bool {
}
InputEvent_accumulate :: (using self: *InputEvent, with_event: InputEvent) -> bool {
}
InputEvent_xformed_by :: (using self: *InputEvent, xform: Transform2D, local_ofs: Vector2) -> InputEvent {
}

// InputEventAction
InputEventAction :: struct {
	__private: *void;
}

InputEventAction_set_action :: (using self: *InputEventAction, action: StringName) {
}
InputEventAction_get_action :: (using self: *InputEventAction) -> StringName {
}
InputEventAction_set_pressed :: (using self: *InputEventAction, pressed: bool) {
}
InputEventAction_set_strength :: (using self: *InputEventAction, strength: float) {
}
InputEventAction_get_strength :: (using self: *InputEventAction) -> float {
}
InputEventAction_set_event_index :: (using self: *InputEventAction, index: int) {
}
InputEventAction_get_event_index :: (using self: *InputEventAction) -> int {
}

// InputEventFromWindow
InputEventFromWindow :: struct {
	__private: *void;
}

InputEventFromWindow_set_window_id :: (using self: *InputEventFromWindow, id: int) {
}
InputEventFromWindow_get_window_id :: (using self: *InputEventFromWindow) -> int {
}

// InputEventGesture
InputEventGesture :: struct {
	__private: *void;
}

InputEventGesture_set_position :: (using self: *InputEventGesture, position: Vector2) {
}
InputEventGesture_get_position :: (using self: *InputEventGesture) -> Vector2 {
}

// InputEventJoypadButton
InputEventJoypadButton :: struct {
	__private: *void;
}

InputEventJoypadButton_set_button_index :: (using self: *InputEventJoypadButton, button_index: JoyButton) {
}
InputEventJoypadButton_get_button_index :: (using self: *InputEventJoypadButton) -> JoyButton {
}
InputEventJoypadButton_set_pressure :: (using self: *InputEventJoypadButton, pressure: float) {
}
InputEventJoypadButton_get_pressure :: (using self: *InputEventJoypadButton) -> float {
}
InputEventJoypadButton_set_pressed :: (using self: *InputEventJoypadButton, pressed: bool) {
}

// InputEventJoypadMotion
InputEventJoypadMotion :: struct {
	__private: *void;
}

InputEventJoypadMotion_set_axis :: (using self: *InputEventJoypadMotion, axis: JoyAxis) {
}
InputEventJoypadMotion_get_axis :: (using self: *InputEventJoypadMotion) -> JoyAxis {
}
InputEventJoypadMotion_set_axis_value :: (using self: *InputEventJoypadMotion, axis_value: float) {
}
InputEventJoypadMotion_get_axis_value :: (using self: *InputEventJoypadMotion) -> float {
}

// InputEventKey
InputEventKey :: struct {
	__private: *void;
}

InputEventKey_set_pressed :: (using self: *InputEventKey, pressed: bool) {
}
InputEventKey_set_keycode :: (using self: *InputEventKey, keycode: Key) {
}
InputEventKey_get_keycode :: (using self: *InputEventKey) -> Key {
}
InputEventKey_set_physical_keycode :: (using self: *InputEventKey, physical_keycode: Key) {
}
InputEventKey_get_physical_keycode :: (using self: *InputEventKey) -> Key {
}
InputEventKey_set_key_label :: (using self: *InputEventKey, key_label: Key) {
}
InputEventKey_get_key_label :: (using self: *InputEventKey) -> Key {
}
InputEventKey_set_unicode :: (using self: *InputEventKey, unicode: int) {
}
InputEventKey_get_unicode :: (using self: *InputEventKey) -> int {
}
InputEventKey_set_location :: (using self: *InputEventKey, location: KeyLocation) {
}
InputEventKey_get_location :: (using self: *InputEventKey) -> KeyLocation {
}
InputEventKey_set_echo :: (using self: *InputEventKey, echo: bool) {
}
InputEventKey_get_keycode_with_modifiers :: (using self: *InputEventKey) -> Key {
}
InputEventKey_get_physical_keycode_with_modifiers :: (using self: *InputEventKey) -> Key {
}
InputEventKey_get_key_label_with_modifiers :: (using self: *InputEventKey) -> Key {
}
InputEventKey_as_text_keycode :: (using self: *InputEventKey) -> String {
}
InputEventKey_as_text_physical_keycode :: (using self: *InputEventKey) -> String {
}
InputEventKey_as_text_key_label :: (using self: *InputEventKey) -> String {
}
InputEventKey_as_text_location :: (using self: *InputEventKey) -> String {
}

// InputEventMIDI
InputEventMIDI :: struct {
	__private: *void;
}

InputEventMIDI_set_channel :: (using self: *InputEventMIDI, channel: int) {
}
InputEventMIDI_get_channel :: (using self: *InputEventMIDI) -> int {
}
InputEventMIDI_set_message :: (using self: *InputEventMIDI, message: MIDIMessage) {
}
InputEventMIDI_get_message :: (using self: *InputEventMIDI) -> MIDIMessage {
}
InputEventMIDI_set_pitch :: (using self: *InputEventMIDI, pitch: int) {
}
InputEventMIDI_get_pitch :: (using self: *InputEventMIDI) -> int {
}
InputEventMIDI_set_velocity :: (using self: *InputEventMIDI, velocity: int) {
}
InputEventMIDI_get_velocity :: (using self: *InputEventMIDI) -> int {
}
InputEventMIDI_set_instrument :: (using self: *InputEventMIDI, instrument: int) {
}
InputEventMIDI_get_instrument :: (using self: *InputEventMIDI) -> int {
}
InputEventMIDI_set_pressure :: (using self: *InputEventMIDI, pressure: int) {
}
InputEventMIDI_get_pressure :: (using self: *InputEventMIDI) -> int {
}
InputEventMIDI_set_controller_number :: (using self: *InputEventMIDI, controller_number: int) {
}
InputEventMIDI_get_controller_number :: (using self: *InputEventMIDI) -> int {
}
InputEventMIDI_set_controller_value :: (using self: *InputEventMIDI, controller_value: int) {
}
InputEventMIDI_get_controller_value :: (using self: *InputEventMIDI) -> int {
}

// InputEventMagnifyGesture
InputEventMagnifyGesture :: struct {
	__private: *void;
}

InputEventMagnifyGesture_set_factor :: (using self: *InputEventMagnifyGesture, factor: float) {
}
InputEventMagnifyGesture_get_factor :: (using self: *InputEventMagnifyGesture) -> float {
}

// InputEventMouse
InputEventMouse :: struct {
	__private: *void;
}

InputEventMouse_set_button_mask :: (using self: *InputEventMouse, button_mask: MouseButtonMask) {
}
InputEventMouse_get_button_mask :: (using self: *InputEventMouse) -> MouseButtonMask {
}
InputEventMouse_set_position :: (using self: *InputEventMouse, position: Vector2) {
}
InputEventMouse_get_position :: (using self: *InputEventMouse) -> Vector2 {
}
InputEventMouse_set_global_position :: (using self: *InputEventMouse, global_position: Vector2) {
}
InputEventMouse_get_global_position :: (using self: *InputEventMouse) -> Vector2 {
}

// InputEventMouseButton
InputEventMouseButton :: struct {
	__private: *void;
}

InputEventMouseButton_set_factor :: (using self: *InputEventMouseButton, factor: float) {
}
InputEventMouseButton_get_factor :: (using self: *InputEventMouseButton) -> float {
}
InputEventMouseButton_set_button_index :: (using self: *InputEventMouseButton, button_index: MouseButton) {
}
InputEventMouseButton_get_button_index :: (using self: *InputEventMouseButton) -> MouseButton {
}
InputEventMouseButton_set_pressed :: (using self: *InputEventMouseButton, pressed: bool) {
}
InputEventMouseButton_set_canceled :: (using self: *InputEventMouseButton, canceled: bool) {
}
InputEventMouseButton_set_double_click :: (using self: *InputEventMouseButton, double_click: bool) {
}
InputEventMouseButton_is_double_click :: (using self: *InputEventMouseButton) -> bool {
}

// InputEventMouseMotion
InputEventMouseMotion :: struct {
	__private: *void;
}

InputEventMouseMotion_set_tilt :: (using self: *InputEventMouseMotion, tilt: Vector2) {
}
InputEventMouseMotion_get_tilt :: (using self: *InputEventMouseMotion) -> Vector2 {
}
InputEventMouseMotion_set_pressure :: (using self: *InputEventMouseMotion, pressure: float) {
}
InputEventMouseMotion_get_pressure :: (using self: *InputEventMouseMotion) -> float {
}
InputEventMouseMotion_set_pen_inverted :: (using self: *InputEventMouseMotion, pen_inverted: bool) {
}
InputEventMouseMotion_get_pen_inverted :: (using self: *InputEventMouseMotion) -> bool {
}
InputEventMouseMotion_set_relative :: (using self: *InputEventMouseMotion, relative: Vector2) {
}
InputEventMouseMotion_get_relative :: (using self: *InputEventMouseMotion) -> Vector2 {
}
InputEventMouseMotion_set_screen_relative :: (using self: *InputEventMouseMotion, relative: Vector2) {
}
InputEventMouseMotion_get_screen_relative :: (using self: *InputEventMouseMotion) -> Vector2 {
}
InputEventMouseMotion_set_velocity :: (using self: *InputEventMouseMotion, velocity: Vector2) {
}
InputEventMouseMotion_get_velocity :: (using self: *InputEventMouseMotion) -> Vector2 {
}
InputEventMouseMotion_set_screen_velocity :: (using self: *InputEventMouseMotion, velocity: Vector2) {
}
InputEventMouseMotion_get_screen_velocity :: (using self: *InputEventMouseMotion) -> Vector2 {
}

// InputEventPanGesture
InputEventPanGesture :: struct {
	__private: *void;
}

InputEventPanGesture_set_delta :: (using self: *InputEventPanGesture, delta: Vector2) {
}
InputEventPanGesture_get_delta :: (using self: *InputEventPanGesture) -> Vector2 {
}

// InputEventScreenDrag
InputEventScreenDrag :: struct {
	__private: *void;
}

InputEventScreenDrag_set_index :: (using self: *InputEventScreenDrag, index: int) {
}
InputEventScreenDrag_get_index :: (using self: *InputEventScreenDrag) -> int {
}
InputEventScreenDrag_set_tilt :: (using self: *InputEventScreenDrag, tilt: Vector2) {
}
InputEventScreenDrag_get_tilt :: (using self: *InputEventScreenDrag) -> Vector2 {
}
InputEventScreenDrag_set_pressure :: (using self: *InputEventScreenDrag, pressure: float) {
}
InputEventScreenDrag_get_pressure :: (using self: *InputEventScreenDrag) -> float {
}
InputEventScreenDrag_set_pen_inverted :: (using self: *InputEventScreenDrag, pen_inverted: bool) {
}
InputEventScreenDrag_get_pen_inverted :: (using self: *InputEventScreenDrag) -> bool {
}
InputEventScreenDrag_set_position :: (using self: *InputEventScreenDrag, position: Vector2) {
}
InputEventScreenDrag_get_position :: (using self: *InputEventScreenDrag) -> Vector2 {
}
InputEventScreenDrag_set_relative :: (using self: *InputEventScreenDrag, relative: Vector2) {
}
InputEventScreenDrag_get_relative :: (using self: *InputEventScreenDrag) -> Vector2 {
}
InputEventScreenDrag_set_screen_relative :: (using self: *InputEventScreenDrag, relative: Vector2) {
}
InputEventScreenDrag_get_screen_relative :: (using self: *InputEventScreenDrag) -> Vector2 {
}
InputEventScreenDrag_set_velocity :: (using self: *InputEventScreenDrag, velocity: Vector2) {
}
InputEventScreenDrag_get_velocity :: (using self: *InputEventScreenDrag) -> Vector2 {
}
InputEventScreenDrag_set_screen_velocity :: (using self: *InputEventScreenDrag, velocity: Vector2) {
}
InputEventScreenDrag_get_screen_velocity :: (using self: *InputEventScreenDrag) -> Vector2 {
}

// InputEventScreenTouch
InputEventScreenTouch :: struct {
	__private: *void;
}

InputEventScreenTouch_set_index :: (using self: *InputEventScreenTouch, index: int) {
}
InputEventScreenTouch_get_index :: (using self: *InputEventScreenTouch) -> int {
}
InputEventScreenTouch_set_position :: (using self: *InputEventScreenTouch, position: Vector2) {
}
InputEventScreenTouch_get_position :: (using self: *InputEventScreenTouch) -> Vector2 {
}
InputEventScreenTouch_set_pressed :: (using self: *InputEventScreenTouch, pressed: bool) {
}
InputEventScreenTouch_set_canceled :: (using self: *InputEventScreenTouch, canceled: bool) {
}
InputEventScreenTouch_set_double_tap :: (using self: *InputEventScreenTouch, double_tap: bool) {
}
InputEventScreenTouch_is_double_tap :: (using self: *InputEventScreenTouch) -> bool {
}

// InputEventShortcut
InputEventShortcut :: struct {
	__private: *void;
}

InputEventShortcut_set_shortcut :: (using self: *InputEventShortcut, shortcut: Shortcut) {
}
InputEventShortcut_get_shortcut :: (using self: *InputEventShortcut) -> Shortcut {
}

// InputEventWithModifiers
InputEventWithModifiers :: struct {
	__private: *void;
}

InputEventWithModifiers_set_command_or_control_autoremap :: (using self: *InputEventWithModifiers, enable: bool) {
}
InputEventWithModifiers_is_command_or_control_autoremap :: (using self: *InputEventWithModifiers) -> bool {
}
InputEventWithModifiers_is_command_or_control_pressed :: (using self: *InputEventWithModifiers) -> bool {
}
InputEventWithModifiers_set_alt_pressed :: (using self: *InputEventWithModifiers, pressed: bool) {
}
InputEventWithModifiers_is_alt_pressed :: (using self: *InputEventWithModifiers) -> bool {
}
InputEventWithModifiers_set_shift_pressed :: (using self: *InputEventWithModifiers, pressed: bool) {
}
InputEventWithModifiers_is_shift_pressed :: (using self: *InputEventWithModifiers) -> bool {
}
InputEventWithModifiers_set_ctrl_pressed :: (using self: *InputEventWithModifiers, pressed: bool) {
}
InputEventWithModifiers_is_ctrl_pressed :: (using self: *InputEventWithModifiers) -> bool {
}
InputEventWithModifiers_set_meta_pressed :: (using self: *InputEventWithModifiers, pressed: bool) {
}
InputEventWithModifiers_is_meta_pressed :: (using self: *InputEventWithModifiers) -> bool {
}
InputEventWithModifiers_get_modifiers_mask :: (using self: *InputEventWithModifiers) -> KeyModifierMask {
}

// InputMap
InputMap :: struct {
	__private: *void;
}

InputMap_has_action :: (using self: *InputMap, action: StringName) -> bool {
}
InputMap_get_actions :: (using self: *InputMap) -> Array {
}
InputMap_add_action :: (using self: *InputMap, action: StringName, deadzone: float) {
}
InputMap_erase_action :: (using self: *InputMap, action: StringName) {
}
InputMap_action_set_deadzone :: (using self: *InputMap, action: StringName, deadzone: float) {
}
InputMap_action_get_deadzone :: (using self: *InputMap, action: StringName) -> float {
}
InputMap_action_add_event :: (using self: *InputMap, action: StringName, event: InputEvent) {
}
InputMap_action_has_event :: (using self: *InputMap, action: StringName, event: InputEvent) -> bool {
}
InputMap_action_erase_event :: (using self: *InputMap, action: StringName, event: InputEvent) {
}
InputMap_action_erase_events :: (using self: *InputMap, action: StringName) {
}
InputMap_action_get_events :: (using self: *InputMap, action: StringName) -> Array {
}
InputMap_event_is_action :: (using self: *InputMap, event: InputEvent, action: StringName, exact_match: bool) -> bool {
}
InputMap_load_from_project_settings :: (using self: *InputMap) {
}

// InstancePlaceholder
InstancePlaceholder :: struct {
	__private: *void;
}

InstancePlaceholder_get_stored_values :: (using self: *InstancePlaceholder, with_order: bool) -> Dictionary {
}
InstancePlaceholder_create_instance :: (using self: *InstancePlaceholder, replace: bool, custom_scene: PackedScene) -> Node {
}
InstancePlaceholder_get_instance_path :: (using self: *InstancePlaceholder) -> String {
}

// IntervalTweener
IntervalTweener :: struct {
	__private: *void;
}

// ItemList
ItemList :: struct {
	__private: *void;

	IconMode :: enum {
		ICON_MODE_TOP :: 0;
		ICON_MODE_LEFT :: 1;
	}
	SelectMode :: enum {
		SELECT_SINGLE :: 0;
		SELECT_MULTI :: 1;
	}
}

ItemList_add_item :: (using self: *ItemList, text: String, icon: Texture2D, selectable: bool) -> int {
}
ItemList_add_icon_item :: (using self: *ItemList, icon: Texture2D, selectable: bool) -> int {
}
ItemList_set_item_text :: (using self: *ItemList, idx: int, text: String) {
}
ItemList_get_item_text :: (using self: *ItemList, idx: int) -> String {
}
ItemList_set_item_icon :: (using self: *ItemList, idx: int, icon: Texture2D) {
}
ItemList_get_item_icon :: (using self: *ItemList, idx: int) -> Texture2D {
}
ItemList_set_item_text_direction :: (using self: *ItemList, idx: int, direction: Control.TextDirection) {
}
ItemList_get_item_text_direction :: (using self: *ItemList, idx: int) -> Control.TextDirection {
}
ItemList_set_item_language :: (using self: *ItemList, idx: int, language: String) {
}
ItemList_get_item_language :: (using self: *ItemList, idx: int) -> String {
}
ItemList_set_item_icon_transposed :: (using self: *ItemList, idx: int, transposed: bool) {
}
ItemList_is_item_icon_transposed :: (using self: *ItemList, idx: int) -> bool {
}
ItemList_set_item_icon_region :: (using self: *ItemList, idx: int, rect: Rect2) {
}
ItemList_get_item_icon_region :: (using self: *ItemList, idx: int) -> Rect2 {
}
ItemList_set_item_icon_modulate :: (using self: *ItemList, idx: int, modulate: Color) {
}
ItemList_get_item_icon_modulate :: (using self: *ItemList, idx: int) -> Color {
}
ItemList_set_item_selectable :: (using self: *ItemList, idx: int, selectable: bool) {
}
ItemList_is_item_selectable :: (using self: *ItemList, idx: int) -> bool {
}
ItemList_set_item_disabled :: (using self: *ItemList, idx: int, disabled: bool) {
}
ItemList_is_item_disabled :: (using self: *ItemList, idx: int) -> bool {
}
ItemList_set_item_metadata :: (using self: *ItemList, idx: int, metadata: Variant) {
}
ItemList_get_item_metadata :: (using self: *ItemList, idx: int) -> Variant {
}
ItemList_set_item_custom_bg_color :: (using self: *ItemList, idx: int, custom_bg_color: Color) {
}
ItemList_get_item_custom_bg_color :: (using self: *ItemList, idx: int) -> Color {
}
ItemList_set_item_custom_fg_color :: (using self: *ItemList, idx: int, custom_fg_color: Color) {
}
ItemList_get_item_custom_fg_color :: (using self: *ItemList, idx: int) -> Color {
}
ItemList_get_item_rect :: (using self: *ItemList, idx: int, expand: bool) -> Rect2 {
}
ItemList_set_item_tooltip_enabled :: (using self: *ItemList, idx: int, enable: bool) {
}
ItemList_is_item_tooltip_enabled :: (using self: *ItemList, idx: int) -> bool {
}
ItemList_set_item_tooltip :: (using self: *ItemList, idx: int, tooltip: String) {
}
ItemList_get_item_tooltip :: (using self: *ItemList, idx: int) -> String {
}
ItemList_select :: (using self: *ItemList, idx: int, single: bool) {
}
ItemList_deselect :: (using self: *ItemList, idx: int) {
}
ItemList_deselect_all :: (using self: *ItemList) {
}
ItemList_is_selected :: (using self: *ItemList, idx: int) -> bool {
}
ItemList_get_selected_items :: (using self: *ItemList) -> PackedInt32Array {
}
ItemList_move_item :: (using self: *ItemList, from_idx: int, to_idx: int) {
}
ItemList_set_item_count :: (using self: *ItemList, count: int) {
}
ItemList_get_item_count :: (using self: *ItemList) -> int {
}
ItemList_remove_item :: (using self: *ItemList, idx: int) {
}
ItemList_clear :: (using self: *ItemList) {
}
ItemList_sort_items_by_text :: (using self: *ItemList) {
}
ItemList_set_fixed_column_width :: (using self: *ItemList, width: int) {
}
ItemList_get_fixed_column_width :: (using self: *ItemList) -> int {
}
ItemList_set_same_column_width :: (using self: *ItemList, enable: bool) {
}
ItemList_is_same_column_width :: (using self: *ItemList) -> bool {
}
ItemList_set_max_text_lines :: (using self: *ItemList, lines: int) {
}
ItemList_get_max_text_lines :: (using self: *ItemList) -> int {
}
ItemList_set_max_columns :: (using self: *ItemList, amount: int) {
}
ItemList_get_max_columns :: (using self: *ItemList) -> int {
}
ItemList_set_select_mode :: (using self: *ItemList, mode: ItemList.SelectMode) {
}
ItemList_get_select_mode :: (using self: *ItemList) -> ItemList.SelectMode {
}
ItemList_set_icon_mode :: (using self: *ItemList, mode: ItemList.IconMode) {
}
ItemList_get_icon_mode :: (using self: *ItemList) -> ItemList.IconMode {
}
ItemList_set_fixed_icon_size :: (using self: *ItemList, size: Vector2i) {
}
ItemList_get_fixed_icon_size :: (using self: *ItemList) -> Vector2i {
}
ItemList_set_icon_scale :: (using self: *ItemList, scale: float) {
}
ItemList_get_icon_scale :: (using self: *ItemList) -> float {
}
ItemList_set_allow_rmb_select :: (using self: *ItemList, allow: bool) {
}
ItemList_get_allow_rmb_select :: (using self: *ItemList) -> bool {
}
ItemList_set_allow_reselect :: (using self: *ItemList, allow: bool) {
}
ItemList_get_allow_reselect :: (using self: *ItemList) -> bool {
}
ItemList_set_allow_search :: (using self: *ItemList, allow: bool) {
}
ItemList_get_allow_search :: (using self: *ItemList) -> bool {
}
ItemList_set_auto_height :: (using self: *ItemList, enable: bool) {
}
ItemList_has_auto_height :: (using self: *ItemList) -> bool {
}
ItemList_is_anything_selected :: (using self: *ItemList) -> bool {
}
ItemList_get_item_at_position :: (using self: *ItemList, position: Vector2, exact: bool) -> int {
}
ItemList_ensure_current_is_visible :: (using self: *ItemList) {
}
ItemList_get_v_scroll_bar :: (using self: *ItemList) -> VScrollBar {
}
ItemList_set_text_overrun_behavior :: (using self: *ItemList, overrun_behavior: TextServer.OverrunBehavior) {
}
ItemList_get_text_overrun_behavior :: (using self: *ItemList) -> TextServer.OverrunBehavior {
}
ItemList_force_update_list_size :: (using self: *ItemList) {
}

// JNISingleton
JNISingleton :: struct {
	__private: *void;
}

// JSON
JSON :: struct {
	__private: *void;
}

JSON_stringify :: (using self: *JSON, data: Variant, indent: String, sort_keys: bool, full_precision: bool) -> String {
}
JSON_parse_string :: (using self: *JSON, json_string: String) -> Variant {
}
JSON_parse :: (using self: *JSON, json_text: String, keep_text: bool) -> Error {
}
JSON_get_data :: (using self: *JSON) -> Variant {
}
JSON_set_data :: (using self: *JSON, data: Variant) {
}
JSON_get_parsed_text :: (using self: *JSON) -> String {
}
JSON_get_error_line :: (using self: *JSON) -> int {
}
JSON_get_error_message :: (using self: *JSON) -> String {
}

// JSONRPC
JSONRPC :: struct {
	__private: *void;

	ErrorCode :: enum {
		PARSE_ERROR :: -32700;
		INVALID_REQUEST :: -32600;
		METHOD_NOT_FOUND :: -32601;
		INVALID_PARAMS :: -32602;
		INTERNAL_ERROR :: -32603;
	}
}

JSONRPC_set_scope :: (using self: *JSONRPC, scope: String, target: Object) {
}
JSONRPC_process_action :: (using self: *JSONRPC, action: Variant, recurse: bool) -> Variant {
}
JSONRPC_process_string :: (using self: *JSONRPC, action: String) -> String {
}
JSONRPC_make_request :: (using self: *JSONRPC, method: String, params: Variant, id: Variant) -> Dictionary {
}
JSONRPC_make_response :: (using self: *JSONRPC, result: Variant, id: Variant) -> Dictionary {
}
JSONRPC_make_notification :: (using self: *JSONRPC, method: String, params: Variant) -> Dictionary {
}
JSONRPC_make_response_error :: (using self: *JSONRPC, code: int, message: String, id: Variant) -> Dictionary {
}

// JavaClass
JavaClass :: struct {
	__private: *void;
}

// JavaClassWrapper
JavaClassWrapper :: struct {
	__private: *void;
}

JavaClassWrapper_wrap :: (using self: *JavaClassWrapper, name: String) -> JavaClass {
}

// JavaScriptBridge
JavaScriptBridge :: struct {
	__private: *void;
}

JavaScriptBridge_eval :: (using self: *JavaScriptBridge, code: String, use_global_execution_context: bool) -> Variant {
}
JavaScriptBridge_get_interface :: (using self: *JavaScriptBridge, _interface: String) -> JavaScriptObject {
}
JavaScriptBridge_create_callback :: (using self: *JavaScriptBridge, callable: Callable) -> JavaScriptObject {
}
JavaScriptBridge_create_object :: (using self: *JavaScriptBridge, object: String) -> Variant {
}
JavaScriptBridge_download_buffer :: (using self: *JavaScriptBridge, buffer: PackedByteArray, name: String, mime: String) {
}
JavaScriptBridge_pwa_needs_update :: (using self: *JavaScriptBridge) -> bool {
}
JavaScriptBridge_pwa_update :: (using self: *JavaScriptBridge) -> Error {
}
JavaScriptBridge_force_fs_sync :: (using self: *JavaScriptBridge) {
}

// JavaScriptObject
JavaScriptObject :: struct {
	__private: *void;
}

// Joint2D
Joint2D :: struct {
	__private: *void;
}

Joint2D_set_node_a :: (using self: *Joint2D, node: NodePath) {
}
Joint2D_get_node_a :: (using self: *Joint2D) -> NodePath {
}
Joint2D_set_node_b :: (using self: *Joint2D, node: NodePath) {
}
Joint2D_get_node_b :: (using self: *Joint2D) -> NodePath {
}
Joint2D_set_bias :: (using self: *Joint2D, bias: float) {
}
Joint2D_get_bias :: (using self: *Joint2D) -> float {
}
Joint2D_set_exclude_nodes_from_collision :: (using self: *Joint2D, enable: bool) {
}
Joint2D_get_exclude_nodes_from_collision :: (using self: *Joint2D) -> bool {
}
Joint2D_get_rid :: (using self: *Joint2D) -> RID {
}

// Joint3D
Joint3D :: struct {
	__private: *void;
}

Joint3D_set_node_a :: (using self: *Joint3D, node: NodePath) {
}
Joint3D_get_node_a :: (using self: *Joint3D) -> NodePath {
}
Joint3D_set_node_b :: (using self: *Joint3D, node: NodePath) {
}
Joint3D_get_node_b :: (using self: *Joint3D) -> NodePath {
}
Joint3D_set_solver_priority :: (using self: *Joint3D, priority: int) {
}
Joint3D_get_solver_priority :: (using self: *Joint3D) -> int {
}
Joint3D_set_exclude_nodes_from_collision :: (using self: *Joint3D, enable: bool) {
}
Joint3D_get_exclude_nodes_from_collision :: (using self: *Joint3D) -> bool {
}
Joint3D_get_rid :: (using self: *Joint3D) -> RID {
}

// KinematicCollision2D
KinematicCollision2D :: struct {
	__private: *void;
}

KinematicCollision2D_get_position :: (using self: *KinematicCollision2D) -> Vector2 {
}
KinematicCollision2D_get_normal :: (using self: *KinematicCollision2D) -> Vector2 {
}
KinematicCollision2D_get_travel :: (using self: *KinematicCollision2D) -> Vector2 {
}
KinematicCollision2D_get_remainder :: (using self: *KinematicCollision2D) -> Vector2 {
}
KinematicCollision2D_get_angle :: (using self: *KinematicCollision2D, up_direction: Vector2) -> float {
}
KinematicCollision2D_get_depth :: (using self: *KinematicCollision2D) -> float {
}
KinematicCollision2D_get_local_shape :: (using self: *KinematicCollision2D) -> Object {
}
KinematicCollision2D_get_collider :: (using self: *KinematicCollision2D) -> Object {
}
KinematicCollision2D_get_collider_id :: (using self: *KinematicCollision2D) -> int {
}
KinematicCollision2D_get_collider_rid :: (using self: *KinematicCollision2D) -> RID {
}
KinematicCollision2D_get_collider_shape :: (using self: *KinematicCollision2D) -> Object {
}
KinematicCollision2D_get_collider_shape_index :: (using self: *KinematicCollision2D) -> int {
}
KinematicCollision2D_get_collider_velocity :: (using self: *KinematicCollision2D) -> Vector2 {
}

// KinematicCollision3D
KinematicCollision3D :: struct {
	__private: *void;
}

KinematicCollision3D_get_travel :: (using self: *KinematicCollision3D) -> Vector3 {
}
KinematicCollision3D_get_remainder :: (using self: *KinematicCollision3D) -> Vector3 {
}
KinematicCollision3D_get_depth :: (using self: *KinematicCollision3D) -> float {
}
KinematicCollision3D_get_collision_count :: (using self: *KinematicCollision3D) -> int {
}
KinematicCollision3D_get_position :: (using self: *KinematicCollision3D, collision_index: int) -> Vector3 {
}
KinematicCollision3D_get_normal :: (using self: *KinematicCollision3D, collision_index: int) -> Vector3 {
}
KinematicCollision3D_get_angle :: (using self: *KinematicCollision3D, collision_index: int, up_direction: Vector3) -> float {
}
KinematicCollision3D_get_local_shape :: (using self: *KinematicCollision3D, collision_index: int) -> Object {
}
KinematicCollision3D_get_collider :: (using self: *KinematicCollision3D, collision_index: int) -> Object {
}
KinematicCollision3D_get_collider_id :: (using self: *KinematicCollision3D, collision_index: int) -> int {
}
KinematicCollision3D_get_collider_rid :: (using self: *KinematicCollision3D, collision_index: int) -> RID {
}
KinematicCollision3D_get_collider_shape :: (using self: *KinematicCollision3D, collision_index: int) -> Object {
}
KinematicCollision3D_get_collider_shape_index :: (using self: *KinematicCollision3D, collision_index: int) -> int {
}
KinematicCollision3D_get_collider_velocity :: (using self: *KinematicCollision3D, collision_index: int) -> Vector3 {
}

// Label
Label :: struct {
	__private: *void;
}

Label_set_horizontal_alignment :: (using self: *Label, alignment: HorizontalAlignment) {
}
Label_get_horizontal_alignment :: (using self: *Label) -> HorizontalAlignment {
}
Label_set_vertical_alignment :: (using self: *Label, alignment: VerticalAlignment) {
}
Label_get_vertical_alignment :: (using self: *Label) -> VerticalAlignment {
}
Label_set_text :: (using self: *Label, text: String) {
}
Label_get_text :: (using self: *Label) -> String {
}
Label_set_label_settings :: (using self: *Label, settings: LabelSettings) {
}
Label_get_label_settings :: (using self: *Label) -> LabelSettings {
}
Label_set_text_direction :: (using self: *Label, direction: Control.TextDirection) {
}
Label_get_text_direction :: (using self: *Label) -> Control.TextDirection {
}
Label_set_language :: (using self: *Label, language: String) {
}
Label_get_language :: (using self: *Label) -> String {
}
Label_set_autowrap_mode :: (using self: *Label, autowrap_mode: TextServer.AutowrapMode) {
}
Label_get_autowrap_mode :: (using self: *Label) -> TextServer.AutowrapMode {
}
Label_set_justification_flags :: (using self: *Label, justification_flags: TextServer.JustificationFlag) {
}
Label_get_justification_flags :: (using self: *Label) -> TextServer.JustificationFlag {
}
Label_set_clip_text :: (using self: *Label, enable: bool) {
}
Label_is_clipping_text :: (using self: *Label) -> bool {
}
Label_set_tab_stops :: (using self: *Label, tab_stops: PackedFloat32Array) {
}
Label_get_tab_stops :: (using self: *Label) -> PackedFloat32Array {
}
Label_set_text_overrun_behavior :: (using self: *Label, overrun_behavior: TextServer.OverrunBehavior) {
}
Label_get_text_overrun_behavior :: (using self: *Label) -> TextServer.OverrunBehavior {
}
Label_set_ellipsis_char :: (using self: *Label, char: String) {
}
Label_get_ellipsis_char :: (using self: *Label) -> String {
}
Label_set_uppercase :: (using self: *Label, enable: bool) {
}
Label_is_uppercase :: (using self: *Label) -> bool {
}
Label_get_line_height :: (using self: *Label, line: int) -> int {
}
Label_get_line_count :: (using self: *Label) -> int {
}
Label_get_visible_line_count :: (using self: *Label) -> int {
}
Label_get_total_character_count :: (using self: *Label) -> int {
}
Label_set_visible_characters :: (using self: *Label, amount: int) {
}
Label_get_visible_characters :: (using self: *Label) -> int {
}
Label_get_visible_characters_behavior :: (using self: *Label) -> TextServer.VisibleCharactersBehavior {
}
Label_set_visible_characters_behavior :: (using self: *Label, behavior: TextServer.VisibleCharactersBehavior) {
}
Label_set_visible_ratio :: (using self: *Label, ratio: float) {
}
Label_get_visible_ratio :: (using self: *Label) -> float {
}
Label_set_lines_skipped :: (using self: *Label, lines_skipped: int) {
}
Label_get_lines_skipped :: (using self: *Label) -> int {
}
Label_set_max_lines_visible :: (using self: *Label, lines_visible: int) {
}
Label_get_max_lines_visible :: (using self: *Label) -> int {
}
Label_set_structured_text_bidi_override :: (using self: *Label, parser: TextServer.StructuredTextParser) {
}
Label_get_structured_text_bidi_override :: (using self: *Label) -> TextServer.StructuredTextParser {
}
Label_set_structured_text_bidi_override_options :: (using self: *Label, args: Array) {
}
Label_get_structured_text_bidi_override_options :: (using self: *Label) -> Array {
}
Label_get_character_bounds :: (using self: *Label, pos: int) -> Rect2 {
}

// Label3D
Label3D :: struct {
	__private: *void;

	DrawFlags :: enum {
		FLAG_SHADED :: 0;
		FLAG_DOUBLE_SIDED :: 1;
		FLAG_DISABLE_DEPTH_TEST :: 2;
		FLAG_FIXED_SIZE :: 3;
		FLAG_MAX :: 4;
	}
	AlphaCutMode :: enum {
		ALPHA_CUT_DISABLED :: 0;
		ALPHA_CUT_DISCARD :: 1;
		ALPHA_CUT_OPAQUE_PREPASS :: 2;
		ALPHA_CUT_HASH :: 3;
	}
}

Label3D_set_horizontal_alignment :: (using self: *Label3D, alignment: HorizontalAlignment) {
}
Label3D_get_horizontal_alignment :: (using self: *Label3D) -> HorizontalAlignment {
}
Label3D_set_vertical_alignment :: (using self: *Label3D, alignment: VerticalAlignment) {
}
Label3D_get_vertical_alignment :: (using self: *Label3D) -> VerticalAlignment {
}
Label3D_set_modulate :: (using self: *Label3D, modulate: Color) {
}
Label3D_get_modulate :: (using self: *Label3D) -> Color {
}
Label3D_set_outline_modulate :: (using self: *Label3D, modulate: Color) {
}
Label3D_get_outline_modulate :: (using self: *Label3D) -> Color {
}
Label3D_set_text :: (using self: *Label3D, text: String) {
}
Label3D_get_text :: (using self: *Label3D) -> String {
}
Label3D_set_text_direction :: (using self: *Label3D, direction: TextServer.Direction) {
}
Label3D_get_text_direction :: (using self: *Label3D) -> TextServer.Direction {
}
Label3D_set_language :: (using self: *Label3D, language: String) {
}
Label3D_get_language :: (using self: *Label3D) -> String {
}
Label3D_set_structured_text_bidi_override :: (using self: *Label3D, parser: TextServer.StructuredTextParser) {
}
Label3D_get_structured_text_bidi_override :: (using self: *Label3D) -> TextServer.StructuredTextParser {
}
Label3D_set_structured_text_bidi_override_options :: (using self: *Label3D, args: Array) {
}
Label3D_get_structured_text_bidi_override_options :: (using self: *Label3D) -> Array {
}
Label3D_set_uppercase :: (using self: *Label3D, enable: bool) {
}
Label3D_is_uppercase :: (using self: *Label3D) -> bool {
}
Label3D_set_render_priority :: (using self: *Label3D, priority: int) {
}
Label3D_get_render_priority :: (using self: *Label3D) -> int {
}
Label3D_set_outline_render_priority :: (using self: *Label3D, priority: int) {
}
Label3D_get_outline_render_priority :: (using self: *Label3D) -> int {
}
Label3D_set_font :: (using self: *Label3D, font: Font) {
}
Label3D_get_font :: (using self: *Label3D) -> Font {
}
Label3D_set_font_size :: (using self: *Label3D, size: int) {
}
Label3D_get_font_size :: (using self: *Label3D) -> int {
}
Label3D_set_outline_size :: (using self: *Label3D, outline_size: int) {
}
Label3D_get_outline_size :: (using self: *Label3D) -> int {
}
Label3D_set_line_spacing :: (using self: *Label3D, line_spacing: float) {
}
Label3D_get_line_spacing :: (using self: *Label3D) -> float {
}
Label3D_set_autowrap_mode :: (using self: *Label3D, autowrap_mode: TextServer.AutowrapMode) {
}
Label3D_get_autowrap_mode :: (using self: *Label3D) -> TextServer.AutowrapMode {
}
Label3D_set_justification_flags :: (using self: *Label3D, justification_flags: TextServer.JustificationFlag) {
}
Label3D_get_justification_flags :: (using self: *Label3D) -> TextServer.JustificationFlag {
}
Label3D_set_width :: (using self: *Label3D, width: float) {
}
Label3D_get_width :: (using self: *Label3D) -> float {
}
Label3D_set_pixel_size :: (using self: *Label3D, pixel_size: float) {
}
Label3D_get_pixel_size :: (using self: *Label3D) -> float {
}
Label3D_set_offset :: (using self: *Label3D, offset: Vector2) {
}
Label3D_get_offset :: (using self: *Label3D) -> Vector2 {
}
Label3D_set_draw_flag :: (using self: *Label3D, flag: Label3D.DrawFlags, enabled: bool) {
}
Label3D_get_draw_flag :: (using self: *Label3D, flag: Label3D.DrawFlags) -> bool {
}
Label3D_set_billboard_mode :: (using self: *Label3D, mode: BaseMaterial3D.BillboardMode) {
}
Label3D_get_billboard_mode :: (using self: *Label3D) -> BaseMaterial3D.BillboardMode {
}
Label3D_set_alpha_cut_mode :: (using self: *Label3D, mode: Label3D.AlphaCutMode) {
}
Label3D_get_alpha_cut_mode :: (using self: *Label3D) -> Label3D.AlphaCutMode {
}
Label3D_set_alpha_scissor_threshold :: (using self: *Label3D, threshold: float) {
}
Label3D_get_alpha_scissor_threshold :: (using self: *Label3D) -> float {
}
Label3D_set_alpha_hash_scale :: (using self: *Label3D, threshold: float) {
}
Label3D_get_alpha_hash_scale :: (using self: *Label3D) -> float {
}
Label3D_set_alpha_antialiasing :: (using self: *Label3D, alpha_aa: BaseMaterial3D.AlphaAntiAliasing) {
}
Label3D_get_alpha_antialiasing :: (using self: *Label3D) -> BaseMaterial3D.AlphaAntiAliasing {
}
Label3D_set_alpha_antialiasing_edge :: (using self: *Label3D, edge: float) {
}
Label3D_get_alpha_antialiasing_edge :: (using self: *Label3D) -> float {
}
Label3D_set_texture_filter :: (using self: *Label3D, mode: BaseMaterial3D.TextureFilter) {
}
Label3D_get_texture_filter :: (using self: *Label3D) -> BaseMaterial3D.TextureFilter {
}
Label3D_generate_triangle_mesh :: (using self: *Label3D) -> TriangleMesh {
}

// LabelSettings
LabelSettings :: struct {
	__private: *void;
}

LabelSettings_set_line_spacing :: (using self: *LabelSettings, spacing: float) {
}
LabelSettings_get_line_spacing :: (using self: *LabelSettings) -> float {
}
LabelSettings_set_font :: (using self: *LabelSettings, font: Font) {
}
LabelSettings_get_font :: (using self: *LabelSettings) -> Font {
}
LabelSettings_set_font_size :: (using self: *LabelSettings, size: int) {
}
LabelSettings_get_font_size :: (using self: *LabelSettings) -> int {
}
LabelSettings_set_font_color :: (using self: *LabelSettings, color: Color) {
}
LabelSettings_get_font_color :: (using self: *LabelSettings) -> Color {
}
LabelSettings_set_outline_size :: (using self: *LabelSettings, size: int) {
}
LabelSettings_get_outline_size :: (using self: *LabelSettings) -> int {
}
LabelSettings_set_outline_color :: (using self: *LabelSettings, color: Color) {
}
LabelSettings_get_outline_color :: (using self: *LabelSettings) -> Color {
}
LabelSettings_set_shadow_size :: (using self: *LabelSettings, size: int) {
}
LabelSettings_get_shadow_size :: (using self: *LabelSettings) -> int {
}
LabelSettings_set_shadow_color :: (using self: *LabelSettings, color: Color) {
}
LabelSettings_get_shadow_color :: (using self: *LabelSettings) -> Color {
}
LabelSettings_set_shadow_offset :: (using self: *LabelSettings, offset: Vector2) {
}
LabelSettings_get_shadow_offset :: (using self: *LabelSettings) -> Vector2 {
}

// Light2D
Light2D :: struct {
	__private: *void;

	ShadowFilter :: enum {
		SHADOW_FILTER_NONE :: 0;
		SHADOW_FILTER_PCF5 :: 1;
		SHADOW_FILTER_PCF13 :: 2;
	}
	BlendMode :: enum {
		BLEND_MODE_ADD :: 0;
		BLEND_MODE_SUB :: 1;
		BLEND_MODE_MIX :: 2;
	}
}

Light2D_set_enabled :: (using self: *Light2D, enabled: bool) {
}
Light2D_is_enabled :: (using self: *Light2D) -> bool {
}
Light2D_set_editor_only :: (using self: *Light2D, editor_only: bool) {
}
Light2D_is_editor_only :: (using self: *Light2D) -> bool {
}
Light2D_set_color :: (using self: *Light2D, color: Color) {
}
Light2D_get_color :: (using self: *Light2D) -> Color {
}
Light2D_set_energy :: (using self: *Light2D, energy: float) {
}
Light2D_get_energy :: (using self: *Light2D) -> float {
}
Light2D_set_z_range_min :: (using self: *Light2D, z: int) {
}
Light2D_get_z_range_min :: (using self: *Light2D) -> int {
}
Light2D_set_z_range_max :: (using self: *Light2D, z: int) {
}
Light2D_get_z_range_max :: (using self: *Light2D) -> int {
}
Light2D_set_layer_range_min :: (using self: *Light2D, layer: int) {
}
Light2D_get_layer_range_min :: (using self: *Light2D) -> int {
}
Light2D_set_layer_range_max :: (using self: *Light2D, layer: int) {
}
Light2D_get_layer_range_max :: (using self: *Light2D) -> int {
}
Light2D_set_item_cull_mask :: (using self: *Light2D, item_cull_mask: int) {
}
Light2D_get_item_cull_mask :: (using self: *Light2D) -> int {
}
Light2D_set_item_shadow_cull_mask :: (using self: *Light2D, item_shadow_cull_mask: int) {
}
Light2D_get_item_shadow_cull_mask :: (using self: *Light2D) -> int {
}
Light2D_set_shadow_enabled :: (using self: *Light2D, enabled: bool) {
}
Light2D_is_shadow_enabled :: (using self: *Light2D) -> bool {
}
Light2D_set_shadow_smooth :: (using self: *Light2D, smooth: float) {
}
Light2D_get_shadow_smooth :: (using self: *Light2D) -> float {
}
Light2D_set_shadow_filter :: (using self: *Light2D, filter: Light2D.ShadowFilter) {
}
Light2D_get_shadow_filter :: (using self: *Light2D) -> Light2D.ShadowFilter {
}
Light2D_set_shadow_color :: (using self: *Light2D, shadow_color: Color) {
}
Light2D_get_shadow_color :: (using self: *Light2D) -> Color {
}
Light2D_set_blend_mode :: (using self: *Light2D, mode: Light2D.BlendMode) {
}
Light2D_get_blend_mode :: (using self: *Light2D) -> Light2D.BlendMode {
}
Light2D_set_height :: (using self: *Light2D, height: float) {
}
Light2D_get_height :: (using self: *Light2D) -> float {
}

// Light3D
Light3D :: struct {
	__private: *void;

	Param :: enum {
		PARAM_ENERGY :: 0;
		PARAM_INDIRECT_ENERGY :: 1;
		PARAM_VOLUMETRIC_FOG_ENERGY :: 2;
		PARAM_SPECULAR :: 3;
		PARAM_RANGE :: 4;
		PARAM_SIZE :: 5;
		PARAM_ATTENUATION :: 6;
		PARAM_SPOT_ANGLE :: 7;
		PARAM_SPOT_ATTENUATION :: 8;
		PARAM_SHADOW_MAX_DISTANCE :: 9;
		PARAM_SHADOW_SPLIT_1_OFFSET :: 10;
		PARAM_SHADOW_SPLIT_2_OFFSET :: 11;
		PARAM_SHADOW_SPLIT_3_OFFSET :: 12;
		PARAM_SHADOW_FADE_START :: 13;
		PARAM_SHADOW_NORMAL_BIAS :: 14;
		PARAM_SHADOW_BIAS :: 15;
		PARAM_SHADOW_PANCAKE_SIZE :: 16;
		PARAM_SHADOW_OPACITY :: 17;
		PARAM_SHADOW_BLUR :: 18;
		PARAM_TRANSMITTANCE_BIAS :: 19;
		PARAM_INTENSITY :: 20;
		PARAM_MAX :: 21;
	}
	BakeMode :: enum {
		BAKE_DISABLED :: 0;
		BAKE_STATIC :: 1;
		BAKE_DYNAMIC :: 2;
	}
}

Light3D_set_editor_only :: (using self: *Light3D, editor_only: bool) {
}
Light3D_is_editor_only :: (using self: *Light3D) -> bool {
}
Light3D_set_param :: (using self: *Light3D, param: Light3D.Param, value: float) {
}
Light3D_get_param :: (using self: *Light3D, param: Light3D.Param) -> float {
}
Light3D_set_shadow :: (using self: *Light3D, enabled: bool) {
}
Light3D_has_shadow :: (using self: *Light3D) -> bool {
}
Light3D_set_negative :: (using self: *Light3D, enabled: bool) {
}
Light3D_is_negative :: (using self: *Light3D) -> bool {
}
Light3D_set_cull_mask :: (using self: *Light3D, cull_mask: int) {
}
Light3D_get_cull_mask :: (using self: *Light3D) -> int {
}
Light3D_set_enable_distance_fade :: (using self: *Light3D, enable: bool) {
}
Light3D_is_distance_fade_enabled :: (using self: *Light3D) -> bool {
}
Light3D_set_distance_fade_begin :: (using self: *Light3D, distance: float) {
}
Light3D_get_distance_fade_begin :: (using self: *Light3D) -> float {
}
Light3D_set_distance_fade_shadow :: (using self: *Light3D, distance: float) {
}
Light3D_get_distance_fade_shadow :: (using self: *Light3D) -> float {
}
Light3D_set_distance_fade_length :: (using self: *Light3D, distance: float) {
}
Light3D_get_distance_fade_length :: (using self: *Light3D) -> float {
}
Light3D_set_color :: (using self: *Light3D, color: Color) {
}
Light3D_get_color :: (using self: *Light3D) -> Color {
}
Light3D_set_shadow_reverse_cull_face :: (using self: *Light3D, enable: bool) {
}
Light3D_get_shadow_reverse_cull_face :: (using self: *Light3D) -> bool {
}
Light3D_set_bake_mode :: (using self: *Light3D, bake_mode: Light3D.BakeMode) {
}
Light3D_get_bake_mode :: (using self: *Light3D) -> Light3D.BakeMode {
}
Light3D_set_projector :: (using self: *Light3D, projector: Texture2D) {
}
Light3D_get_projector :: (using self: *Light3D) -> Texture2D {
}
Light3D_set_temperature :: (using self: *Light3D, temperature: float) {
}
Light3D_get_temperature :: (using self: *Light3D) -> float {
}
Light3D_get_correlated_color :: (using self: *Light3D) -> Color {
}

// LightOccluder2D
LightOccluder2D :: struct {
	__private: *void;
}

LightOccluder2D_set_occluder_polygon :: (using self: *LightOccluder2D, polygon: OccluderPolygon2D) {
}
LightOccluder2D_get_occluder_polygon :: (using self: *LightOccluder2D) -> OccluderPolygon2D {
}
LightOccluder2D_set_occluder_light_mask :: (using self: *LightOccluder2D, mask: int) {
}
LightOccluder2D_get_occluder_light_mask :: (using self: *LightOccluder2D) -> int {
}
LightOccluder2D_set_as_sdf_collision :: (using self: *LightOccluder2D, enable: bool) {
}
LightOccluder2D_is_set_as_sdf_collision :: (using self: *LightOccluder2D) -> bool {
}

// LightmapGI
LightmapGI :: struct {
	__private: *void;

	BakeQuality :: enum {
		BAKE_QUALITY_LOW :: 0;
		BAKE_QUALITY_MEDIUM :: 1;
		BAKE_QUALITY_HIGH :: 2;
		BAKE_QUALITY_ULTRA :: 3;
	}
	GenerateProbes :: enum {
		GENERATE_PROBES_DISABLED :: 0;
		GENERATE_PROBES_SUBDIV_4 :: 1;
		GENERATE_PROBES_SUBDIV_8 :: 2;
		GENERATE_PROBES_SUBDIV_16 :: 3;
		GENERATE_PROBES_SUBDIV_32 :: 4;
	}
	BakeError :: enum {
		BAKE_ERROR_OK :: 0;
		BAKE_ERROR_NO_SCENE_ROOT :: 1;
		BAKE_ERROR_FOREIGN_DATA :: 2;
		BAKE_ERROR_NO_LIGHTMAPPER :: 3;
		BAKE_ERROR_NO_SAVE_PATH :: 4;
		BAKE_ERROR_NO_MESHES :: 5;
		BAKE_ERROR_MESHES_INVALID :: 6;
		BAKE_ERROR_CANT_CREATE_IMAGE :: 7;
		BAKE_ERROR_USER_ABORTED :: 8;
		BAKE_ERROR_TEXTURE_SIZE_TOO_SMALL :: 9;
		BAKE_ERROR_LIGHTMAP_TOO_SMALL :: 10;
		BAKE_ERROR_ATLAS_TOO_SMALL :: 11;
	}
	EnvironmentMode :: enum {
		ENVIRONMENT_MODE_DISABLED :: 0;
		ENVIRONMENT_MODE_SCENE :: 1;
		ENVIRONMENT_MODE_CUSTOM_SKY :: 2;
		ENVIRONMENT_MODE_CUSTOM_COLOR :: 3;
	}
}

LightmapGI_set_light_data :: (using self: *LightmapGI, data: LightmapGIData) {
}
LightmapGI_get_light_data :: (using self: *LightmapGI) -> LightmapGIData {
}
LightmapGI_set_bake_quality :: (using self: *LightmapGI, bake_quality: LightmapGI.BakeQuality) {
}
LightmapGI_get_bake_quality :: (using self: *LightmapGI) -> LightmapGI.BakeQuality {
}
LightmapGI_set_bounces :: (using self: *LightmapGI, bounces: int) {
}
LightmapGI_get_bounces :: (using self: *LightmapGI) -> int {
}
LightmapGI_set_bounce_indirect_energy :: (using self: *LightmapGI, bounce_indirect_energy: float) {
}
LightmapGI_get_bounce_indirect_energy :: (using self: *LightmapGI) -> float {
}
LightmapGI_set_generate_probes :: (using self: *LightmapGI, subdivision: LightmapGI.GenerateProbes) {
}
LightmapGI_get_generate_probes :: (using self: *LightmapGI) -> LightmapGI.GenerateProbes {
}
LightmapGI_set_bias :: (using self: *LightmapGI, bias: float) {
}
LightmapGI_get_bias :: (using self: *LightmapGI) -> float {
}
LightmapGI_set_environment_mode :: (using self: *LightmapGI, mode: LightmapGI.EnvironmentMode) {
}
LightmapGI_get_environment_mode :: (using self: *LightmapGI) -> LightmapGI.EnvironmentMode {
}
LightmapGI_set_environment_custom_sky :: (using self: *LightmapGI, sky: Sky) {
}
LightmapGI_get_environment_custom_sky :: (using self: *LightmapGI) -> Sky {
}
LightmapGI_set_environment_custom_color :: (using self: *LightmapGI, color: Color) {
}
LightmapGI_get_environment_custom_color :: (using self: *LightmapGI) -> Color {
}
LightmapGI_set_environment_custom_energy :: (using self: *LightmapGI, energy: float) {
}
LightmapGI_get_environment_custom_energy :: (using self: *LightmapGI) -> float {
}
LightmapGI_set_texel_scale :: (using self: *LightmapGI, texel_scale: float) {
}
LightmapGI_get_texel_scale :: (using self: *LightmapGI) -> float {
}
LightmapGI_set_max_texture_size :: (using self: *LightmapGI, max_texture_size: int) {
}
LightmapGI_get_max_texture_size :: (using self: *LightmapGI) -> int {
}
LightmapGI_set_use_denoiser :: (using self: *LightmapGI, use_denoiser: bool) {
}
LightmapGI_is_using_denoiser :: (using self: *LightmapGI) -> bool {
}
LightmapGI_set_denoiser_strength :: (using self: *LightmapGI, denoiser_strength: float) {
}
LightmapGI_get_denoiser_strength :: (using self: *LightmapGI) -> float {
}
LightmapGI_set_denoiser_range :: (using self: *LightmapGI, denoiser_range: int) {
}
LightmapGI_get_denoiser_range :: (using self: *LightmapGI) -> int {
}
LightmapGI_set_interior :: (using self: *LightmapGI, enable: bool) {
}
LightmapGI_is_interior :: (using self: *LightmapGI) -> bool {
}
LightmapGI_set_directional :: (using self: *LightmapGI, directional: bool) {
}
LightmapGI_is_directional :: (using self: *LightmapGI) -> bool {
}
LightmapGI_set_use_texture_for_bounces :: (using self: *LightmapGI, use_texture_for_bounces: bool) {
}
LightmapGI_is_using_texture_for_bounces :: (using self: *LightmapGI) -> bool {
}
LightmapGI_set_camera_attributes :: (using self: *LightmapGI, camera_attributes: CameraAttributes) {
}
LightmapGI_get_camera_attributes :: (using self: *LightmapGI) -> CameraAttributes {
}

// LightmapGIData
LightmapGIData :: struct {
	__private: *void;
}

LightmapGIData_set_lightmap_textures :: (using self: *LightmapGIData, light_textures: Array) {
}
LightmapGIData_get_lightmap_textures :: (using self: *LightmapGIData) -> Array {
}
LightmapGIData_set_uses_spherical_harmonics :: (using self: *LightmapGIData, uses_spherical_harmonics: bool) {
}
LightmapGIData_is_using_spherical_harmonics :: (using self: *LightmapGIData) -> bool {
}
LightmapGIData_add_user :: (using self: *LightmapGIData, path: NodePath, uv_scale: Rect2, slice_index: int, sub_instance: int) {
}
LightmapGIData_get_user_count :: (using self: *LightmapGIData) -> int {
}
LightmapGIData_get_user_path :: (using self: *LightmapGIData, user_idx: int) -> NodePath {
}
LightmapGIData_clear_users :: (using self: *LightmapGIData) {
}
LightmapGIData_set_light_texture :: (using self: *LightmapGIData, light_texture: TextureLayered) {
}
LightmapGIData_get_light_texture :: (using self: *LightmapGIData) -> TextureLayered {
}

// LightmapProbe
LightmapProbe :: struct {
	__private: *void;
}

// Lightmapper
Lightmapper :: struct {
	__private: *void;
}

// LightmapperRD
LightmapperRD :: struct {
	__private: *void;
}

// Line2D
Line2D :: struct {
	__private: *void;

	LineJointMode :: enum {
		LINE_JOINT_SHARP :: 0;
		LINE_JOINT_BEVEL :: 1;
		LINE_JOINT_ROUND :: 2;
	}
	LineCapMode :: enum {
		LINE_CAP_NONE :: 0;
		LINE_CAP_BOX :: 1;
		LINE_CAP_ROUND :: 2;
	}
	LineTextureMode :: enum {
		LINE_TEXTURE_NONE :: 0;
		LINE_TEXTURE_TILE :: 1;
		LINE_TEXTURE_STRETCH :: 2;
	}
}

Line2D_set_points :: (using self: *Line2D, points: PackedVector2Array) {
}
Line2D_get_points :: (using self: *Line2D) -> PackedVector2Array {
}
Line2D_set_point_position :: (using self: *Line2D, index: int, position: Vector2) {
}
Line2D_get_point_position :: (using self: *Line2D, index: int) -> Vector2 {
}
Line2D_get_point_count :: (using self: *Line2D) -> int {
}
Line2D_add_point :: (using self: *Line2D, position: Vector2, index: int) {
}
Line2D_remove_point :: (using self: *Line2D, index: int) {
}
Line2D_clear_points :: (using self: *Line2D) {
}
Line2D_set_closed :: (using self: *Line2D, closed: bool) {
}
Line2D_is_closed :: (using self: *Line2D) -> bool {
}
Line2D_set_width :: (using self: *Line2D, width: float) {
}
Line2D_get_width :: (using self: *Line2D) -> float {
}
Line2D_set_curve :: (using self: *Line2D, curve: Curve) {
}
Line2D_get_curve :: (using self: *Line2D) -> Curve {
}
Line2D_set_default_color :: (using self: *Line2D, color: Color) {
}
Line2D_get_default_color :: (using self: *Line2D) -> Color {
}
Line2D_set_gradient :: (using self: *Line2D, color: Gradient) {
}
Line2D_get_gradient :: (using self: *Line2D) -> Gradient {
}
Line2D_set_texture :: (using self: *Line2D, texture: Texture2D) {
}
Line2D_get_texture :: (using self: *Line2D) -> Texture2D {
}
Line2D_set_texture_mode :: (using self: *Line2D, mode: Line2D.LineTextureMode) {
}
Line2D_get_texture_mode :: (using self: *Line2D) -> Line2D.LineTextureMode {
}
Line2D_set_joint_mode :: (using self: *Line2D, mode: Line2D.LineJointMode) {
}
Line2D_get_joint_mode :: (using self: *Line2D) -> Line2D.LineJointMode {
}
Line2D_set_begin_cap_mode :: (using self: *Line2D, mode: Line2D.LineCapMode) {
}
Line2D_get_begin_cap_mode :: (using self: *Line2D) -> Line2D.LineCapMode {
}
Line2D_set_end_cap_mode :: (using self: *Line2D, mode: Line2D.LineCapMode) {
}
Line2D_get_end_cap_mode :: (using self: *Line2D) -> Line2D.LineCapMode {
}
Line2D_set_sharp_limit :: (using self: *Line2D, limit: float) {
}
Line2D_get_sharp_limit :: (using self: *Line2D) -> float {
}
Line2D_set_round_precision :: (using self: *Line2D, precision: int) {
}
Line2D_get_round_precision :: (using self: *Line2D) -> int {
}
Line2D_set_antialiased :: (using self: *Line2D, antialiased: bool) {
}
Line2D_get_antialiased :: (using self: *Line2D) -> bool {
}

// LineEdit
LineEdit :: struct {
	__private: *void;

	MenuItems :: enum {
		MENU_CUT :: 0;
		MENU_COPY :: 1;
		MENU_PASTE :: 2;
		MENU_CLEAR :: 3;
		MENU_SELECT_ALL :: 4;
		MENU_UNDO :: 5;
		MENU_REDO :: 6;
		MENU_SUBMENU_TEXT_DIR :: 7;
		MENU_DIR_INHERITED :: 8;
		MENU_DIR_AUTO :: 9;
		MENU_DIR_LTR :: 10;
		MENU_DIR_RTL :: 11;
		MENU_DISPLAY_UCC :: 12;
		MENU_SUBMENU_INSERT_UCC :: 13;
		MENU_INSERT_LRM :: 14;
		MENU_INSERT_RLM :: 15;
		MENU_INSERT_LRE :: 16;
		MENU_INSERT_RLE :: 17;
		MENU_INSERT_LRO :: 18;
		MENU_INSERT_RLO :: 19;
		MENU_INSERT_PDF :: 20;
		MENU_INSERT_ALM :: 21;
		MENU_INSERT_LRI :: 22;
		MENU_INSERT_RLI :: 23;
		MENU_INSERT_FSI :: 24;
		MENU_INSERT_PDI :: 25;
		MENU_INSERT_ZWJ :: 26;
		MENU_INSERT_ZWNJ :: 27;
		MENU_INSERT_WJ :: 28;
		MENU_INSERT_SHY :: 29;
		MENU_MAX :: 30;
	}
	VirtualKeyboardType :: enum {
		KEYBOARD_TYPE_DEFAULT :: 0;
		KEYBOARD_TYPE_MULTILINE :: 1;
		KEYBOARD_TYPE_NUMBER :: 2;
		KEYBOARD_TYPE_NUMBER_DECIMAL :: 3;
		KEYBOARD_TYPE_PHONE :: 4;
		KEYBOARD_TYPE_EMAIL_ADDRESS :: 5;
		KEYBOARD_TYPE_PASSWORD :: 6;
		KEYBOARD_TYPE_URL :: 7;
	}
}

LineEdit_set_horizontal_alignment :: (using self: *LineEdit, alignment: HorizontalAlignment) {
}
LineEdit_get_horizontal_alignment :: (using self: *LineEdit) -> HorizontalAlignment {
}
LineEdit_clear :: (using self: *LineEdit) {
}
LineEdit_select :: (using self: *LineEdit, from: int, to: int) {
}
LineEdit_select_all :: (using self: *LineEdit) {
}
LineEdit_deselect :: (using self: *LineEdit) {
}
LineEdit_has_selection :: (using self: *LineEdit) -> bool {
}
LineEdit_get_selected_text :: (using self: *LineEdit) -> String {
}
LineEdit_get_selection_from_column :: (using self: *LineEdit) -> int {
}
LineEdit_get_selection_to_column :: (using self: *LineEdit) -> int {
}
LineEdit_set_text :: (using self: *LineEdit, text: String) {
}
LineEdit_get_text :: (using self: *LineEdit) -> String {
}
LineEdit_get_draw_control_chars :: (using self: *LineEdit) -> bool {
}
LineEdit_set_draw_control_chars :: (using self: *LineEdit, enable: bool) {
}
LineEdit_set_text_direction :: (using self: *LineEdit, direction: Control.TextDirection) {
}
LineEdit_get_text_direction :: (using self: *LineEdit) -> Control.TextDirection {
}
LineEdit_set_language :: (using self: *LineEdit, language: String) {
}
LineEdit_get_language :: (using self: *LineEdit) -> String {
}
LineEdit_set_structured_text_bidi_override :: (using self: *LineEdit, parser: TextServer.StructuredTextParser) {
}
LineEdit_get_structured_text_bidi_override :: (using self: *LineEdit) -> TextServer.StructuredTextParser {
}
LineEdit_set_structured_text_bidi_override_options :: (using self: *LineEdit, args: Array) {
}
LineEdit_get_structured_text_bidi_override_options :: (using self: *LineEdit) -> Array {
}
LineEdit_set_placeholder :: (using self: *LineEdit, text: String) {
}
LineEdit_get_placeholder :: (using self: *LineEdit) -> String {
}
LineEdit_set_caret_column :: (using self: *LineEdit, position: int) {
}
LineEdit_get_caret_column :: (using self: *LineEdit) -> int {
}
LineEdit_get_scroll_offset :: (using self: *LineEdit) -> float {
}
LineEdit_set_expand_to_text_length_enabled :: (using self: *LineEdit, enabled: bool) {
}
LineEdit_is_expand_to_text_length_enabled :: (using self: *LineEdit) -> bool {
}
LineEdit_set_caret_blink_enabled :: (using self: *LineEdit, enabled: bool) {
}
LineEdit_is_caret_blink_enabled :: (using self: *LineEdit) -> bool {
}
LineEdit_set_caret_mid_grapheme_enabled :: (using self: *LineEdit, enabled: bool) {
}
LineEdit_is_caret_mid_grapheme_enabled :: (using self: *LineEdit) -> bool {
}
LineEdit_set_caret_force_displayed :: (using self: *LineEdit, enabled: bool) {
}
LineEdit_is_caret_force_displayed :: (using self: *LineEdit) -> bool {
}
LineEdit_set_caret_blink_interval :: (using self: *LineEdit, interval: float) {
}
LineEdit_get_caret_blink_interval :: (using self: *LineEdit) -> float {
}
LineEdit_set_max_length :: (using self: *LineEdit, chars: int) {
}
LineEdit_get_max_length :: (using self: *LineEdit) -> int {
}
LineEdit_insert_text_at_caret :: (using self: *LineEdit, text: String) {
}
LineEdit_delete_char_at_caret :: (using self: *LineEdit) {
}
LineEdit_delete_text :: (using self: *LineEdit, from_column: int, to_column: int) {
}
LineEdit_set_editable :: (using self: *LineEdit, enabled: bool) {
}
LineEdit_is_editable :: (using self: *LineEdit) -> bool {
}
LineEdit_set_secret :: (using self: *LineEdit, enabled: bool) {
}
LineEdit_is_secret :: (using self: *LineEdit) -> bool {
}
LineEdit_set_secret_character :: (using self: *LineEdit, character: String) {
}
LineEdit_get_secret_character :: (using self: *LineEdit) -> String {
}
LineEdit_menu_option :: (using self: *LineEdit, option: int) {
}
LineEdit_get_menu :: (using self: *LineEdit) -> PopupMenu {
}
LineEdit_is_menu_visible :: (using self: *LineEdit) -> bool {
}
LineEdit_set_context_menu_enabled :: (using self: *LineEdit, enable: bool) {
}
LineEdit_is_context_menu_enabled :: (using self: *LineEdit) -> bool {
}
LineEdit_set_virtual_keyboard_enabled :: (using self: *LineEdit, enable: bool) {
}
LineEdit_is_virtual_keyboard_enabled :: (using self: *LineEdit) -> bool {
}
LineEdit_set_virtual_keyboard_type :: (using self: *LineEdit, type: LineEdit.VirtualKeyboardType) {
}
LineEdit_get_virtual_keyboard_type :: (using self: *LineEdit) -> LineEdit.VirtualKeyboardType {
}
LineEdit_set_clear_button_enabled :: (using self: *LineEdit, enable: bool) {
}
LineEdit_is_clear_button_enabled :: (using self: *LineEdit) -> bool {
}
LineEdit_set_shortcut_keys_enabled :: (using self: *LineEdit, enable: bool) {
}
LineEdit_is_shortcut_keys_enabled :: (using self: *LineEdit) -> bool {
}
LineEdit_set_middle_mouse_paste_enabled :: (using self: *LineEdit, enable: bool) {
}
LineEdit_is_middle_mouse_paste_enabled :: (using self: *LineEdit) -> bool {
}
LineEdit_set_selecting_enabled :: (using self: *LineEdit, enable: bool) {
}
LineEdit_is_selecting_enabled :: (using self: *LineEdit) -> bool {
}
LineEdit_set_deselect_on_focus_loss_enabled :: (using self: *LineEdit, enable: bool) {
}
LineEdit_is_deselect_on_focus_loss_enabled :: (using self: *LineEdit) -> bool {
}
LineEdit_set_drag_and_drop_selection_enabled :: (using self: *LineEdit, enable: bool) {
}
LineEdit_is_drag_and_drop_selection_enabled :: (using self: *LineEdit) -> bool {
}
LineEdit_set_right_icon :: (using self: *LineEdit, icon: Texture2D) {
}
LineEdit_get_right_icon :: (using self: *LineEdit) -> Texture2D {
}
LineEdit_set_flat :: (using self: *LineEdit, enabled: bool) {
}
LineEdit_is_flat :: (using self: *LineEdit) -> bool {
}
LineEdit_set_select_all_on_focus :: (using self: *LineEdit, enabled: bool) {
}
LineEdit_is_select_all_on_focus :: (using self: *LineEdit) -> bool {
}

// LinkButton
LinkButton :: struct {
	__private: *void;

	UnderlineMode :: enum {
		UNDERLINE_MODE_ALWAYS :: 0;
		UNDERLINE_MODE_ON_HOVER :: 1;
		UNDERLINE_MODE_NEVER :: 2;
	}
}

LinkButton_set_text :: (using self: *LinkButton, text: String) {
}
LinkButton_get_text :: (using self: *LinkButton) -> String {
}
LinkButton_set_text_direction :: (using self: *LinkButton, direction: Control.TextDirection) {
}
LinkButton_get_text_direction :: (using self: *LinkButton) -> Control.TextDirection {
}
LinkButton_set_language :: (using self: *LinkButton, language: String) {
}
LinkButton_get_language :: (using self: *LinkButton) -> String {
}
LinkButton_set_uri :: (using self: *LinkButton, uri: String) {
}
LinkButton_get_uri :: (using self: *LinkButton) -> String {
}
LinkButton_set_underline_mode :: (using self: *LinkButton, underline_mode: LinkButton.UnderlineMode) {
}
LinkButton_get_underline_mode :: (using self: *LinkButton) -> LinkButton.UnderlineMode {
}
LinkButton_set_structured_text_bidi_override :: (using self: *LinkButton, parser: TextServer.StructuredTextParser) {
}
LinkButton_get_structured_text_bidi_override :: (using self: *LinkButton) -> TextServer.StructuredTextParser {
}
LinkButton_set_structured_text_bidi_override_options :: (using self: *LinkButton, args: Array) {
}
LinkButton_get_structured_text_bidi_override_options :: (using self: *LinkButton) -> Array {
}

// MainLoop
MainLoop :: struct {
	__private: *void;

	NOTIFICATION_OS_MEMORY_WARNING :: 2009;
	NOTIFICATION_TRANSLATION_CHANGED :: 2010;
	NOTIFICATION_WM_ABOUT :: 2011;
	NOTIFICATION_CRASH :: 2012;
	NOTIFICATION_OS_IME_UPDATE :: 2013;
	NOTIFICATION_APPLICATION_RESUMED :: 2014;
	NOTIFICATION_APPLICATION_PAUSED :: 2015;
	NOTIFICATION_APPLICATION_FOCUS_IN :: 2016;
	NOTIFICATION_APPLICATION_FOCUS_OUT :: 2017;
	NOTIFICATION_TEXT_SERVER_CHANGED :: 2018;
}

MainLoop__initialize :: (using self: *MainLoop) {
}
MainLoop__physics_process :: (using self: *MainLoop, delta: float) -> bool {
}
MainLoop__process :: (using self: *MainLoop, delta: float) -> bool {
}
MainLoop__finalize :: (using self: *MainLoop) {
}

// MarginContainer
MarginContainer :: struct {
	__private: *void;
}

// Marker2D
Marker2D :: struct {
	__private: *void;
}

Marker2D_set_gizmo_extents :: (using self: *Marker2D, extents: float) {
}
Marker2D_get_gizmo_extents :: (using self: *Marker2D) -> float {
}

// Marker3D
Marker3D :: struct {
	__private: *void;
}

Marker3D_set_gizmo_extents :: (using self: *Marker3D, extents: float) {
}
Marker3D_get_gizmo_extents :: (using self: *Marker3D) -> float {
}

// Marshalls
Marshalls :: struct {
	__private: *void;
}

Marshalls_variant_to_base64 :: (using self: *Marshalls, variant: Variant, full_objects: bool) -> String {
}
Marshalls_base64_to_variant :: (using self: *Marshalls, base64_str: String, allow_objects: bool) -> Variant {
}
Marshalls_raw_to_base64 :: (using self: *Marshalls, array: PackedByteArray) -> String {
}
Marshalls_base64_to_raw :: (using self: *Marshalls, base64_str: String) -> PackedByteArray {
}
Marshalls_utf8_to_base64 :: (using self: *Marshalls, utf8_str: String) -> String {
}
Marshalls_base64_to_utf8 :: (using self: *Marshalls, base64_str: String) -> String {
}

// Material
Material :: struct {
	__private: *void;

	RENDER_PRIORITY_MAX :: 127;
	RENDER_PRIORITY_MIN :: -128;
}

Material__get_shader_rid :: (using self: *Material) -> RID {
}
Material__get_shader_mode :: (using self: *Material) -> Shader.Mode {
}
Material__can_do_next_pass :: (using self: *Material) -> bool {
}
Material__can_use_render_priority :: (using self: *Material) -> bool {
}
Material_set_next_pass :: (using self: *Material, next_pass: Material) {
}
Material_get_next_pass :: (using self: *Material) -> Material {
}
Material_set_render_priority :: (using self: *Material, priority: int) {
}
Material_get_render_priority :: (using self: *Material) -> int {
}
Material_inspect_native_shader_code :: (using self: *Material) {
}
Material_create_placeholder :: (using self: *Material) -> Resource {
}

// MenuBar
MenuBar :: struct {
	__private: *void;
}

MenuBar_set_switch_on_hover :: (using self: *MenuBar, enable: bool) {
}
MenuBar_is_switch_on_hover :: (using self: *MenuBar) -> bool {
}
MenuBar_set_disable_shortcuts :: (using self: *MenuBar, disabled: bool) {
}
MenuBar_set_prefer_global_menu :: (using self: *MenuBar, enabled: bool) {
}
MenuBar_is_prefer_global_menu :: (using self: *MenuBar) -> bool {
}
MenuBar_is_native_menu :: (using self: *MenuBar) -> bool {
}
MenuBar_get_menu_count :: (using self: *MenuBar) -> int {
}
MenuBar_set_text_direction :: (using self: *MenuBar, direction: Control.TextDirection) {
}
MenuBar_get_text_direction :: (using self: *MenuBar) -> Control.TextDirection {
}
MenuBar_set_language :: (using self: *MenuBar, language: String) {
}
MenuBar_get_language :: (using self: *MenuBar) -> String {
}
MenuBar_set_flat :: (using self: *MenuBar, enabled: bool) {
}
MenuBar_is_flat :: (using self: *MenuBar) -> bool {
}
MenuBar_set_start_index :: (using self: *MenuBar, enabled: int) {
}
MenuBar_get_start_index :: (using self: *MenuBar) -> int {
}
MenuBar_set_menu_title :: (using self: *MenuBar, menu: int, title: String) {
}
MenuBar_get_menu_title :: (using self: *MenuBar, menu: int) -> String {
}
MenuBar_set_menu_tooltip :: (using self: *MenuBar, menu: int, tooltip: String) {
}
MenuBar_get_menu_tooltip :: (using self: *MenuBar, menu: int) -> String {
}
MenuBar_set_menu_disabled :: (using self: *MenuBar, menu: int, disabled: bool) {
}
MenuBar_is_menu_disabled :: (using self: *MenuBar, menu: int) -> bool {
}
MenuBar_set_menu_hidden :: (using self: *MenuBar, menu: int, hidden: bool) {
}
MenuBar_is_menu_hidden :: (using self: *MenuBar, menu: int) -> bool {
}
MenuBar_get_menu_popup :: (using self: *MenuBar, menu: int) -> PopupMenu {
}

// MenuButton
MenuButton :: struct {
	__private: *void;
}

MenuButton_get_popup :: (using self: *MenuButton) -> PopupMenu {
}
MenuButton_show_popup :: (using self: *MenuButton) {
}
MenuButton_set_switch_on_hover :: (using self: *MenuButton, enable: bool) {
}
MenuButton_is_switch_on_hover :: (using self: *MenuButton) -> bool {
}
MenuButton_set_disable_shortcuts :: (using self: *MenuButton, disabled: bool) {
}
MenuButton_set_item_count :: (using self: *MenuButton, count: int) {
}
MenuButton_get_item_count :: (using self: *MenuButton) -> int {
}

// Mesh
Mesh :: struct {
	__private: *void;

	PrimitiveType :: enum {
		PRIMITIVE_POINTS :: 0;
		PRIMITIVE_LINES :: 1;
		PRIMITIVE_LINE_STRIP :: 2;
		PRIMITIVE_TRIANGLES :: 3;
		PRIMITIVE_TRIANGLE_STRIP :: 4;
	}
	ArrayType :: enum {
		ARRAY_VERTEX :: 0;
		ARRAY_NORMAL :: 1;
		ARRAY_TANGENT :: 2;
		ARRAY_COLOR :: 3;
		ARRAY_TEX_UV :: 4;
		ARRAY_TEX_UV2 :: 5;
		ARRAY_CUSTOM0 :: 6;
		ARRAY_CUSTOM1 :: 7;
		ARRAY_CUSTOM2 :: 8;
		ARRAY_CUSTOM3 :: 9;
		ARRAY_BONES :: 10;
		ARRAY_WEIGHTS :: 11;
		ARRAY_INDEX :: 12;
		ARRAY_MAX :: 13;
	}
	ArrayCustomFormat :: enum {
		ARRAY_CUSTOM_RGBA8_UNORM :: 0;
		ARRAY_CUSTOM_RGBA8_SNORM :: 1;
		ARRAY_CUSTOM_RG_HALF :: 2;
		ARRAY_CUSTOM_RGBA_HALF :: 3;
		ARRAY_CUSTOM_R_FLOAT :: 4;
		ARRAY_CUSTOM_RG_FLOAT :: 5;
		ARRAY_CUSTOM_RGB_FLOAT :: 6;
		ARRAY_CUSTOM_RGBA_FLOAT :: 7;
		ARRAY_CUSTOM_MAX :: 8;
	}
	ArrayFormat :: enum_flags {
		ARRAY_FORMAT_VERTEX :: 1;
		ARRAY_FORMAT_NORMAL :: 2;
		ARRAY_FORMAT_TANGENT :: 4;
		ARRAY_FORMAT_COLOR :: 8;
		ARRAY_FORMAT_TEX_UV :: 16;
		ARRAY_FORMAT_TEX_UV2 :: 32;
		ARRAY_FORMAT_CUSTOM0 :: 64;
		ARRAY_FORMAT_CUSTOM1 :: 128;
		ARRAY_FORMAT_CUSTOM2 :: 256;
		ARRAY_FORMAT_CUSTOM3 :: 512;
		ARRAY_FORMAT_BONES :: 1024;
		ARRAY_FORMAT_WEIGHTS :: 2048;
		ARRAY_FORMAT_INDEX :: 4096;
		ARRAY_FORMAT_BLEND_SHAPE_MASK :: 7;
		ARRAY_FORMAT_CUSTOM_BASE :: 13;
		ARRAY_FORMAT_CUSTOM_BITS :: 3;
		ARRAY_FORMAT_CUSTOM0_SHIFT :: 13;
		ARRAY_FORMAT_CUSTOM1_SHIFT :: 16;
		ARRAY_FORMAT_CUSTOM2_SHIFT :: 19;
		ARRAY_FORMAT_CUSTOM3_SHIFT :: 22;
		ARRAY_FORMAT_CUSTOM_MASK :: 7;
		ARRAY_COMPRESS_FLAGS_BASE :: 25;
		ARRAY_FLAG_USE_2D_VERTICES :: 33554432;
		ARRAY_FLAG_USE_DYNAMIC_UPDATE :: 67108864;
		ARRAY_FLAG_USE_8_BONE_WEIGHTS :: 134217728;
		ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY :: 268435456;
		ARRAY_FLAG_COMPRESS_ATTRIBUTES :: 536870912;
	}
	BlendShapeMode :: enum {
		BLEND_SHAPE_MODE_NORMALIZED :: 0;
		BLEND_SHAPE_MODE_RELATIVE :: 1;
	}
}

Mesh__get_surface_count :: (using self: *Mesh) -> int {
}
Mesh__surface_get_array_len :: (using self: *Mesh, index: int) -> int {
}
Mesh__surface_get_array_index_len :: (using self: *Mesh, index: int) -> int {
}
Mesh__surface_get_arrays :: (using self: *Mesh, index: int) -> Array {
}
Mesh__surface_get_blend_shape_arrays :: (using self: *Mesh, index: int) -> Array {
}
Mesh__surface_get_lods :: (using self: *Mesh, index: int) -> Dictionary {
}
Mesh__surface_get_format :: (using self: *Mesh, index: int) -> int {
}
Mesh__surface_get_primitive_type :: (using self: *Mesh, index: int) -> int {
}
Mesh__surface_set_material :: (using self: *Mesh, index: int, material: Material) {
}
Mesh__surface_get_material :: (using self: *Mesh, index: int) -> Material {
}
Mesh__get_blend_shape_count :: (using self: *Mesh) -> int {
}
Mesh__get_blend_shape_name :: (using self: *Mesh, index: int) -> StringName {
}
Mesh__set_blend_shape_name :: (using self: *Mesh, index: int, name: StringName) {
}
Mesh__get_aabb :: (using self: *Mesh) -> AABB {
}
Mesh_set_lightmap_size_hint :: (using self: *Mesh, size: Vector2i) {
}
Mesh_get_lightmap_size_hint :: (using self: *Mesh) -> Vector2i {
}
Mesh_get_aabb :: (using self: *Mesh) -> AABB {
}
Mesh_get_faces :: (using self: *Mesh) -> PackedVector3Array {
}
Mesh_get_surface_count :: (using self: *Mesh) -> int {
}
Mesh_surface_get_arrays :: (using self: *Mesh, surf_idx: int) -> Array {
}
Mesh_surface_get_blend_shape_arrays :: (using self: *Mesh, surf_idx: int) -> Array {
}
Mesh_surface_set_material :: (using self: *Mesh, surf_idx: int, material: Material) {
}
Mesh_surface_get_material :: (using self: *Mesh, surf_idx: int) -> Material {
}
Mesh_create_placeholder :: (using self: *Mesh) -> Resource {
}
Mesh_create_trimesh_shape :: (using self: *Mesh) -> ConcavePolygonShape3D {
}
Mesh_create_convex_shape :: (using self: *Mesh, clean: bool, simplify: bool) -> ConvexPolygonShape3D {
}
Mesh_create_outline :: (using self: *Mesh, margin: float) -> Mesh {
}
Mesh_generate_triangle_mesh :: (using self: *Mesh) -> TriangleMesh {
}

// MeshConvexDecompositionSettings
MeshConvexDecompositionSettings :: struct {
	__private: *void;

	Mode :: enum {
		CONVEX_DECOMPOSITION_MODE_VOXEL :: 0;
		CONVEX_DECOMPOSITION_MODE_TETRAHEDRON :: 1;
	}
}

MeshConvexDecompositionSettings_set_max_concavity :: (using self: *MeshConvexDecompositionSettings, max_concavity: float) {
}
MeshConvexDecompositionSettings_get_max_concavity :: (using self: *MeshConvexDecompositionSettings) -> float {
}
MeshConvexDecompositionSettings_set_symmetry_planes_clipping_bias :: (using self: *MeshConvexDecompositionSettings, symmetry_planes_clipping_bias: float) {
}
MeshConvexDecompositionSettings_get_symmetry_planes_clipping_bias :: (using self: *MeshConvexDecompositionSettings) -> float {
}
MeshConvexDecompositionSettings_set_revolution_axes_clipping_bias :: (using self: *MeshConvexDecompositionSettings, revolution_axes_clipping_bias: float) {
}
MeshConvexDecompositionSettings_get_revolution_axes_clipping_bias :: (using self: *MeshConvexDecompositionSettings) -> float {
}
MeshConvexDecompositionSettings_set_min_volume_per_convex_hull :: (using self: *MeshConvexDecompositionSettings, min_volume_per_convex_hull: float) {
}
MeshConvexDecompositionSettings_get_min_volume_per_convex_hull :: (using self: *MeshConvexDecompositionSettings) -> float {
}
MeshConvexDecompositionSettings_set_resolution :: (using self: *MeshConvexDecompositionSettings, min_volume_per_convex_hull: int) {
}
MeshConvexDecompositionSettings_get_resolution :: (using self: *MeshConvexDecompositionSettings) -> int {
}
MeshConvexDecompositionSettings_set_max_num_vertices_per_convex_hull :: (using self: *MeshConvexDecompositionSettings, max_num_vertices_per_convex_hull: int) {
}
MeshConvexDecompositionSettings_get_max_num_vertices_per_convex_hull :: (using self: *MeshConvexDecompositionSettings) -> int {
}
MeshConvexDecompositionSettings_set_plane_downsampling :: (using self: *MeshConvexDecompositionSettings, plane_downsampling: int) {
}
MeshConvexDecompositionSettings_get_plane_downsampling :: (using self: *MeshConvexDecompositionSettings) -> int {
}
MeshConvexDecompositionSettings_set_convex_hull_downsampling :: (using self: *MeshConvexDecompositionSettings, convex_hull_downsampling: int) {
}
MeshConvexDecompositionSettings_get_convex_hull_downsampling :: (using self: *MeshConvexDecompositionSettings) -> int {
}
MeshConvexDecompositionSettings_set_normalize_mesh :: (using self: *MeshConvexDecompositionSettings, normalize_mesh: bool) {
}
MeshConvexDecompositionSettings_get_normalize_mesh :: (using self: *MeshConvexDecompositionSettings) -> bool {
}
MeshConvexDecompositionSettings_set_mode :: (using self: *MeshConvexDecompositionSettings, mode: MeshConvexDecompositionSettings.Mode) {
}
MeshConvexDecompositionSettings_get_mode :: (using self: *MeshConvexDecompositionSettings) -> MeshConvexDecompositionSettings.Mode {
}
MeshConvexDecompositionSettings_set_convex_hull_approximation :: (using self: *MeshConvexDecompositionSettings, convex_hull_approximation: bool) {
}
MeshConvexDecompositionSettings_get_convex_hull_approximation :: (using self: *MeshConvexDecompositionSettings) -> bool {
}
MeshConvexDecompositionSettings_set_max_convex_hulls :: (using self: *MeshConvexDecompositionSettings, max_convex_hulls: int) {
}
MeshConvexDecompositionSettings_get_max_convex_hulls :: (using self: *MeshConvexDecompositionSettings) -> int {
}
MeshConvexDecompositionSettings_set_project_hull_vertices :: (using self: *MeshConvexDecompositionSettings, project_hull_vertices: bool) {
}
MeshConvexDecompositionSettings_get_project_hull_vertices :: (using self: *MeshConvexDecompositionSettings) -> bool {
}

// MeshDataTool
MeshDataTool :: struct {
	__private: *void;
}

MeshDataTool_clear :: (using self: *MeshDataTool) {
}
MeshDataTool_create_from_surface :: (using self: *MeshDataTool, mesh: ArrayMesh, surface: int) -> Error {
}
MeshDataTool_commit_to_surface :: (using self: *MeshDataTool, mesh: ArrayMesh, compression_flags: int) -> Error {
}
MeshDataTool_get_format :: (using self: *MeshDataTool) -> int {
}
MeshDataTool_get_vertex_count :: (using self: *MeshDataTool) -> int {
}
MeshDataTool_get_edge_count :: (using self: *MeshDataTool) -> int {
}
MeshDataTool_get_face_count :: (using self: *MeshDataTool) -> int {
}
MeshDataTool_set_vertex :: (using self: *MeshDataTool, idx: int, vertex: Vector3) {
}
MeshDataTool_get_vertex :: (using self: *MeshDataTool, idx: int) -> Vector3 {
}
MeshDataTool_set_vertex_normal :: (using self: *MeshDataTool, idx: int, normal: Vector3) {
}
MeshDataTool_get_vertex_normal :: (using self: *MeshDataTool, idx: int) -> Vector3 {
}
MeshDataTool_set_vertex_tangent :: (using self: *MeshDataTool, idx: int, tangent: Plane) {
}
MeshDataTool_get_vertex_tangent :: (using self: *MeshDataTool, idx: int) -> Plane {
}
MeshDataTool_set_vertex_uv :: (using self: *MeshDataTool, idx: int, uv: Vector2) {
}
MeshDataTool_get_vertex_uv :: (using self: *MeshDataTool, idx: int) -> Vector2 {
}
MeshDataTool_set_vertex_uv2 :: (using self: *MeshDataTool, idx: int, uv2: Vector2) {
}
MeshDataTool_get_vertex_uv2 :: (using self: *MeshDataTool, idx: int) -> Vector2 {
}
MeshDataTool_set_vertex_color :: (using self: *MeshDataTool, idx: int, color: Color) {
}
MeshDataTool_get_vertex_color :: (using self: *MeshDataTool, idx: int) -> Color {
}
MeshDataTool_set_vertex_bones :: (using self: *MeshDataTool, idx: int, bones: PackedInt32Array) {
}
MeshDataTool_get_vertex_bones :: (using self: *MeshDataTool, idx: int) -> PackedInt32Array {
}
MeshDataTool_set_vertex_weights :: (using self: *MeshDataTool, idx: int, weights: PackedFloat32Array) {
}
MeshDataTool_get_vertex_weights :: (using self: *MeshDataTool, idx: int) -> PackedFloat32Array {
}
MeshDataTool_set_vertex_meta :: (using self: *MeshDataTool, idx: int, meta: Variant) {
}
MeshDataTool_get_vertex_meta :: (using self: *MeshDataTool, idx: int) -> Variant {
}
MeshDataTool_get_vertex_edges :: (using self: *MeshDataTool, idx: int) -> PackedInt32Array {
}
MeshDataTool_get_vertex_faces :: (using self: *MeshDataTool, idx: int) -> PackedInt32Array {
}
MeshDataTool_get_edge_vertex :: (using self: *MeshDataTool, idx: int, vertex: int) -> int {
}
MeshDataTool_get_edge_faces :: (using self: *MeshDataTool, idx: int) -> PackedInt32Array {
}
MeshDataTool_set_edge_meta :: (using self: *MeshDataTool, idx: int, meta: Variant) {
}
MeshDataTool_get_edge_meta :: (using self: *MeshDataTool, idx: int) -> Variant {
}
MeshDataTool_get_face_vertex :: (using self: *MeshDataTool, idx: int, vertex: int) -> int {
}
MeshDataTool_get_face_edge :: (using self: *MeshDataTool, idx: int, edge: int) -> int {
}
MeshDataTool_set_face_meta :: (using self: *MeshDataTool, idx: int, meta: Variant) {
}
MeshDataTool_get_face_meta :: (using self: *MeshDataTool, idx: int) -> Variant {
}
MeshDataTool_get_face_normal :: (using self: *MeshDataTool, idx: int) -> Vector3 {
}
MeshDataTool_set_material :: (using self: *MeshDataTool, material: Material) {
}
MeshDataTool_get_material :: (using self: *MeshDataTool) -> Material {
}

// MeshInstance2D
MeshInstance2D :: struct {
	__private: *void;
}

MeshInstance2D_set_mesh :: (using self: *MeshInstance2D, mesh: Mesh) {
}
MeshInstance2D_get_mesh :: (using self: *MeshInstance2D) -> Mesh {
}
MeshInstance2D_set_texture :: (using self: *MeshInstance2D, texture: Texture2D) {
}
MeshInstance2D_get_texture :: (using self: *MeshInstance2D) -> Texture2D {
}

// MeshInstance3D
MeshInstance3D :: struct {
	__private: *void;
}

MeshInstance3D_set_mesh :: (using self: *MeshInstance3D, mesh: Mesh) {
}
MeshInstance3D_get_mesh :: (using self: *MeshInstance3D) -> Mesh {
}
MeshInstance3D_set_skeleton_path :: (using self: *MeshInstance3D, skeleton_path: NodePath) {
}
MeshInstance3D_get_skeleton_path :: (using self: *MeshInstance3D) -> NodePath {
}
MeshInstance3D_set_skin :: (using self: *MeshInstance3D, skin: Skin) {
}
MeshInstance3D_get_skin :: (using self: *MeshInstance3D) -> Skin {
}
MeshInstance3D_get_skin_reference :: (using self: *MeshInstance3D) -> SkinReference {
}
MeshInstance3D_get_surface_override_material_count :: (using self: *MeshInstance3D) -> int {
}
MeshInstance3D_set_surface_override_material :: (using self: *MeshInstance3D, surface: int, material: Material) {
}
MeshInstance3D_get_surface_override_material :: (using self: *MeshInstance3D, surface: int) -> Material {
}
MeshInstance3D_get_active_material :: (using self: *MeshInstance3D, surface: int) -> Material {
}
MeshInstance3D_create_trimesh_collision :: (using self: *MeshInstance3D) {
}
MeshInstance3D_create_convex_collision :: (using self: *MeshInstance3D, clean: bool, simplify: bool) {
}
MeshInstance3D_create_multiple_convex_collisions :: (using self: *MeshInstance3D, settings: MeshConvexDecompositionSettings) {
}
MeshInstance3D_get_blend_shape_count :: (using self: *MeshInstance3D) -> int {
}
MeshInstance3D_find_blend_shape_by_name :: (using self: *MeshInstance3D, name: StringName) -> int {
}
MeshInstance3D_get_blend_shape_value :: (using self: *MeshInstance3D, blend_shape_idx: int) -> float {
}
MeshInstance3D_set_blend_shape_value :: (using self: *MeshInstance3D, blend_shape_idx: int, value: float) {
}
MeshInstance3D_create_debug_tangents :: (using self: *MeshInstance3D) {
}
MeshInstance3D_bake_mesh_from_current_blend_shape_mix :: (using self: *MeshInstance3D, existing: ArrayMesh) -> ArrayMesh {
}

// MeshLibrary
MeshLibrary :: struct {
	__private: *void;
}

MeshLibrary_create_item :: (using self: *MeshLibrary, id: int) {
}
MeshLibrary_set_item_name :: (using self: *MeshLibrary, id: int, name: String) {
}
MeshLibrary_set_item_mesh :: (using self: *MeshLibrary, id: int, mesh: Mesh) {
}
MeshLibrary_set_item_mesh_transform :: (using self: *MeshLibrary, id: int, mesh_transform: Transform3D) {
}
MeshLibrary_set_item_navigation_mesh :: (using self: *MeshLibrary, id: int, navigation_mesh: NavigationMesh) {
}
MeshLibrary_set_item_navigation_mesh_transform :: (using self: *MeshLibrary, id: int, navigation_mesh: Transform3D) {
}
MeshLibrary_set_item_navigation_layers :: (using self: *MeshLibrary, id: int, navigation_layers: int) {
}
MeshLibrary_set_item_shapes :: (using self: *MeshLibrary, id: int, shapes: Array) {
}
MeshLibrary_set_item_preview :: (using self: *MeshLibrary, id: int, texture: Texture2D) {
}
MeshLibrary_get_item_name :: (using self: *MeshLibrary, id: int) -> String {
}
MeshLibrary_get_item_mesh :: (using self: *MeshLibrary, id: int) -> Mesh {
}
MeshLibrary_get_item_mesh_transform :: (using self: *MeshLibrary, id: int) -> Transform3D {
}
MeshLibrary_get_item_navigation_mesh :: (using self: *MeshLibrary, id: int) -> NavigationMesh {
}
MeshLibrary_get_item_navigation_mesh_transform :: (using self: *MeshLibrary, id: int) -> Transform3D {
}
MeshLibrary_get_item_navigation_layers :: (using self: *MeshLibrary, id: int) -> int {
}
MeshLibrary_get_item_shapes :: (using self: *MeshLibrary, id: int) -> Array {
}
MeshLibrary_get_item_preview :: (using self: *MeshLibrary, id: int) -> Texture2D {
}
MeshLibrary_remove_item :: (using self: *MeshLibrary, id: int) {
}
MeshLibrary_find_item_by_name :: (using self: *MeshLibrary, name: String) -> int {
}
MeshLibrary_clear :: (using self: *MeshLibrary) {
}
MeshLibrary_get_item_list :: (using self: *MeshLibrary) -> PackedInt32Array {
}
MeshLibrary_get_last_unused_item_id :: (using self: *MeshLibrary) -> int {
}

// MeshTexture
MeshTexture :: struct {
	__private: *void;
}

MeshTexture_set_mesh :: (using self: *MeshTexture, mesh: Mesh) {
}
MeshTexture_get_mesh :: (using self: *MeshTexture) -> Mesh {
}
MeshTexture_set_image_size :: (using self: *MeshTexture, size: Vector2) {
}
MeshTexture_get_image_size :: (using self: *MeshTexture) -> Vector2 {
}
MeshTexture_set_base_texture :: (using self: *MeshTexture, texture: Texture2D) {
}
MeshTexture_get_base_texture :: (using self: *MeshTexture) -> Texture2D {
}

// MethodTweener
MethodTweener :: struct {
	__private: *void;
}

MethodTweener_set_delay :: (using self: *MethodTweener, delay: float) -> MethodTweener {
}
MethodTweener_set_trans :: (using self: *MethodTweener, trans: Tween.TransitionType) -> MethodTweener {
}
MethodTweener_set_ease :: (using self: *MethodTweener, ease: Tween.EaseType) -> MethodTweener {
}

// MissingNode
MissingNode :: struct {
	__private: *void;
}

MissingNode_set_original_class :: (using self: *MissingNode, name: String) {
}
MissingNode_get_original_class :: (using self: *MissingNode) -> String {
}
MissingNode_set_original_scene :: (using self: *MissingNode, name: String) {
}
MissingNode_get_original_scene :: (using self: *MissingNode) -> String {
}
MissingNode_set_recording_properties :: (using self: *MissingNode, enable: bool) {
}
MissingNode_is_recording_properties :: (using self: *MissingNode) -> bool {
}

// MissingResource
MissingResource :: struct {
	__private: *void;
}

MissingResource_set_original_class :: (using self: *MissingResource, name: String) {
}
MissingResource_get_original_class :: (using self: *MissingResource) -> String {
}
MissingResource_set_recording_properties :: (using self: *MissingResource, enable: bool) {
}
MissingResource_is_recording_properties :: (using self: *MissingResource) -> bool {
}

// MobileVRInterface
MobileVRInterface :: struct {
	__private: *void;
}

MobileVRInterface_set_eye_height :: (using self: *MobileVRInterface, eye_height: float) {
}
MobileVRInterface_get_eye_height :: (using self: *MobileVRInterface) -> float {
}
MobileVRInterface_set_iod :: (using self: *MobileVRInterface, iod: float) {
}
MobileVRInterface_get_iod :: (using self: *MobileVRInterface) -> float {
}
MobileVRInterface_set_display_width :: (using self: *MobileVRInterface, display_width: float) {
}
MobileVRInterface_get_display_width :: (using self: *MobileVRInterface) -> float {
}
MobileVRInterface_set_display_to_lens :: (using self: *MobileVRInterface, display_to_lens: float) {
}
MobileVRInterface_get_display_to_lens :: (using self: *MobileVRInterface) -> float {
}
MobileVRInterface_set_offset_rect :: (using self: *MobileVRInterface, offset_rect: Rect2) {
}
MobileVRInterface_get_offset_rect :: (using self: *MobileVRInterface) -> Rect2 {
}
MobileVRInterface_set_oversample :: (using self: *MobileVRInterface, oversample: float) {
}
MobileVRInterface_get_oversample :: (using self: *MobileVRInterface) -> float {
}
MobileVRInterface_set_k1 :: (using self: *MobileVRInterface, k: float) {
}
MobileVRInterface_get_k1 :: (using self: *MobileVRInterface) -> float {
}
MobileVRInterface_set_k2 :: (using self: *MobileVRInterface, k: float) {
}
MobileVRInterface_get_k2 :: (using self: *MobileVRInterface) -> float {
}
MobileVRInterface_get_vrs_min_radius :: (using self: *MobileVRInterface) -> float {
}
MobileVRInterface_set_vrs_min_radius :: (using self: *MobileVRInterface, radius: float) {
}
MobileVRInterface_get_vrs_strength :: (using self: *MobileVRInterface) -> float {
}
MobileVRInterface_set_vrs_strength :: (using self: *MobileVRInterface, strength: float) {
}

// MovieWriter
MovieWriter :: struct {
	__private: *void;
}

MovieWriter__get_audio_mix_rate :: (using self: *MovieWriter) -> int {
}
MovieWriter__get_audio_speaker_mode :: (using self: *MovieWriter) -> AudioServer.SpeakerMode {
}
MovieWriter__handles_file :: (using self: *MovieWriter, path: String) -> bool {
}
MovieWriter__write_begin :: (using self: *MovieWriter, movie_size: Vector2i, fps: int, base_path: String) -> Error {
}
MovieWriter__write_frame :: (using self: *MovieWriter, frame_image: Image, audio_frame_block: *void) -> Error {
}
MovieWriter__write_end :: (using self: *MovieWriter) {
}
MovieWriter_add_writer :: (using self: *MovieWriter, writer: MovieWriter) {
}

// MultiMesh
MultiMesh :: struct {
	__private: *void;

	TransformFormat :: enum {
		TRANSFORM_2D :: 0;
		TRANSFORM_3D :: 1;
	}
}

MultiMesh_set_mesh :: (using self: *MultiMesh, mesh: Mesh) {
}
MultiMesh_get_mesh :: (using self: *MultiMesh) -> Mesh {
}
MultiMesh_set_use_colors :: (using self: *MultiMesh, enable: bool) {
}
MultiMesh_is_using_colors :: (using self: *MultiMesh) -> bool {
}
MultiMesh_set_use_custom_data :: (using self: *MultiMesh, enable: bool) {
}
MultiMesh_is_using_custom_data :: (using self: *MultiMesh) -> bool {
}
MultiMesh_set_transform_format :: (using self: *MultiMesh, format: MultiMesh.TransformFormat) {
}
MultiMesh_get_transform_format :: (using self: *MultiMesh) -> MultiMesh.TransformFormat {
}
MultiMesh_set_instance_count :: (using self: *MultiMesh, count: int) {
}
MultiMesh_get_instance_count :: (using self: *MultiMesh) -> int {
}
MultiMesh_set_visible_instance_count :: (using self: *MultiMesh, count: int) {
}
MultiMesh_get_visible_instance_count :: (using self: *MultiMesh) -> int {
}
MultiMesh_set_instance_transform :: (using self: *MultiMesh, instance: int, transform: Transform3D) {
}
MultiMesh_set_instance_transform_2d :: (using self: *MultiMesh, instance: int, transform: Transform2D) {
}
MultiMesh_get_instance_transform :: (using self: *MultiMesh, instance: int) -> Transform3D {
}
MultiMesh_get_instance_transform_2d :: (using self: *MultiMesh, instance: int) -> Transform2D {
}
MultiMesh_set_instance_color :: (using self: *MultiMesh, instance: int, color: Color) {
}
MultiMesh_get_instance_color :: (using self: *MultiMesh, instance: int) -> Color {
}
MultiMesh_set_instance_custom_data :: (using self: *MultiMesh, instance: int, custom_data: Color) {
}
MultiMesh_get_instance_custom_data :: (using self: *MultiMesh, instance: int) -> Color {
}
MultiMesh_set_custom_aabb :: (using self: *MultiMesh, aabb: AABB) {
}
MultiMesh_get_custom_aabb :: (using self: *MultiMesh) -> AABB {
}
MultiMesh_get_aabb :: (using self: *MultiMesh) -> AABB {
}
MultiMesh_get_buffer :: (using self: *MultiMesh) -> PackedFloat32Array {
}
MultiMesh_set_buffer :: (using self: *MultiMesh, buffer: PackedFloat32Array) {
}

// MultiMeshInstance2D
MultiMeshInstance2D :: struct {
	__private: *void;
}

MultiMeshInstance2D_set_multimesh :: (using self: *MultiMeshInstance2D, multimesh: MultiMesh) {
}
MultiMeshInstance2D_get_multimesh :: (using self: *MultiMeshInstance2D) -> MultiMesh {
}
MultiMeshInstance2D_set_texture :: (using self: *MultiMeshInstance2D, texture: Texture2D) {
}
MultiMeshInstance2D_get_texture :: (using self: *MultiMeshInstance2D) -> Texture2D {
}

// MultiMeshInstance3D
MultiMeshInstance3D :: struct {
	__private: *void;
}

MultiMeshInstance3D_set_multimesh :: (using self: *MultiMeshInstance3D, multimesh: MultiMesh) {
}
MultiMeshInstance3D_get_multimesh :: (using self: *MultiMeshInstance3D) -> MultiMesh {
}

// MultiplayerAPI
MultiplayerAPI :: struct {
	__private: *void;

	RPCMode :: enum {
		RPC_MODE_DISABLED :: 0;
		RPC_MODE_ANY_PEER :: 1;
		RPC_MODE_AUTHORITY :: 2;
	}
}

MultiplayerAPI_has_multiplayer_peer :: (using self: *MultiplayerAPI) -> bool {
}
MultiplayerAPI_get_multiplayer_peer :: (using self: *MultiplayerAPI) -> MultiplayerPeer {
}
MultiplayerAPI_set_multiplayer_peer :: (using self: *MultiplayerAPI, peer: MultiplayerPeer) {
}
MultiplayerAPI_get_unique_id :: (using self: *MultiplayerAPI) -> int {
}
MultiplayerAPI_is_server :: (using self: *MultiplayerAPI) -> bool {
}
MultiplayerAPI_get_remote_sender_id :: (using self: *MultiplayerAPI) -> int {
}
MultiplayerAPI_poll :: (using self: *MultiplayerAPI) -> Error {
}
MultiplayerAPI_rpc :: (using self: *MultiplayerAPI, peer: int, object: Object, method: StringName, arguments: Array) -> Error {
}
MultiplayerAPI_object_configuration_add :: (using self: *MultiplayerAPI, object: Object, configuration: Variant) -> Error {
}
MultiplayerAPI_object_configuration_remove :: (using self: *MultiplayerAPI, object: Object, configuration: Variant) -> Error {
}
MultiplayerAPI_get_peers :: (using self: *MultiplayerAPI) -> PackedInt32Array {
}
MultiplayerAPI_set_default_interface :: (using self: *MultiplayerAPI, interface_name: StringName) {
}
MultiplayerAPI_get_default_interface :: (using self: *MultiplayerAPI) -> StringName {
}
MultiplayerAPI_create_default_interface :: (using self: *MultiplayerAPI) -> MultiplayerAPI {
}

// MultiplayerAPIExtension
MultiplayerAPIExtension :: struct {
	__private: *void;
}

MultiplayerAPIExtension__poll :: (using self: *MultiplayerAPIExtension) -> Error {
}
MultiplayerAPIExtension__set_multiplayer_peer :: (using self: *MultiplayerAPIExtension, multiplayer_peer: MultiplayerPeer) {
}
MultiplayerAPIExtension__get_multiplayer_peer :: (using self: *MultiplayerAPIExtension) -> MultiplayerPeer {
}
MultiplayerAPIExtension__get_unique_id :: (using self: *MultiplayerAPIExtension) -> int {
}
MultiplayerAPIExtension__get_peer_ids :: (using self: *MultiplayerAPIExtension) -> PackedInt32Array {
}
MultiplayerAPIExtension__rpc :: (using self: *MultiplayerAPIExtension, peer: int, object: Object, method: StringName, args: Array) -> Error {
}
MultiplayerAPIExtension__get_remote_sender_id :: (using self: *MultiplayerAPIExtension) -> int {
}
MultiplayerAPIExtension__object_configuration_add :: (using self: *MultiplayerAPIExtension, object: Object, configuration: Variant) -> Error {
}
MultiplayerAPIExtension__object_configuration_remove :: (using self: *MultiplayerAPIExtension, object: Object, configuration: Variant) -> Error {
}

// MultiplayerPeer
MultiplayerPeer :: struct {
	__private: *void;

	TARGET_PEER_BROADCAST :: 0;
	TARGET_PEER_SERVER :: 1;

	ConnectionStatus :: enum {
		CONNECTION_DISCONNECTED :: 0;
		CONNECTION_CONNECTING :: 1;
		CONNECTION_CONNECTED :: 2;
	}
	TransferMode :: enum {
		TRANSFER_MODE_UNRELIABLE :: 0;
		TRANSFER_MODE_UNRELIABLE_ORDERED :: 1;
		TRANSFER_MODE_RELIABLE :: 2;
	}
}

MultiplayerPeer_set_transfer_channel :: (using self: *MultiplayerPeer, channel: int) {
}
MultiplayerPeer_get_transfer_channel :: (using self: *MultiplayerPeer) -> int {
}
MultiplayerPeer_set_transfer_mode :: (using self: *MultiplayerPeer, mode: MultiplayerPeer.TransferMode) {
}
MultiplayerPeer_get_transfer_mode :: (using self: *MultiplayerPeer) -> MultiplayerPeer.TransferMode {
}
MultiplayerPeer_set_target_peer :: (using self: *MultiplayerPeer, id: int) {
}
MultiplayerPeer_get_packet_peer :: (using self: *MultiplayerPeer) -> int {
}
MultiplayerPeer_get_packet_channel :: (using self: *MultiplayerPeer) -> int {
}
MultiplayerPeer_get_packet_mode :: (using self: *MultiplayerPeer) -> MultiplayerPeer.TransferMode {
}
MultiplayerPeer_poll :: (using self: *MultiplayerPeer) {
}
MultiplayerPeer_close :: (using self: *MultiplayerPeer) {
}
MultiplayerPeer_disconnect_peer :: (using self: *MultiplayerPeer, peer: int, force: bool) {
}
MultiplayerPeer_get_connection_status :: (using self: *MultiplayerPeer) -> MultiplayerPeer.ConnectionStatus {
}
MultiplayerPeer_get_unique_id :: (using self: *MultiplayerPeer) -> int {
}
MultiplayerPeer_generate_unique_id :: (using self: *MultiplayerPeer) -> int {
}
MultiplayerPeer_set_refuse_new_connections :: (using self: *MultiplayerPeer, enable: bool) {
}
MultiplayerPeer_is_refusing_new_connections :: (using self: *MultiplayerPeer) -> bool {
}
MultiplayerPeer_is_server_relay_supported :: (using self: *MultiplayerPeer) -> bool {
}

// MultiplayerPeerExtension
MultiplayerPeerExtension :: struct {
	__private: *void;
}

MultiplayerPeerExtension__get_packet :: (using self: *MultiplayerPeerExtension, r_buffer: **u8, r_buffer_size: *s32) -> Error {
}
MultiplayerPeerExtension__put_packet :: (using self: *MultiplayerPeerExtension, p_buffer: *u8, p_buffer_size: int) -> Error {
}
MultiplayerPeerExtension__get_available_packet_count :: (using self: *MultiplayerPeerExtension) -> int {
}
MultiplayerPeerExtension__get_max_packet_size :: (using self: *MultiplayerPeerExtension) -> int {
}
MultiplayerPeerExtension__get_packet_script :: (using self: *MultiplayerPeerExtension) -> PackedByteArray {
}
MultiplayerPeerExtension__put_packet_script :: (using self: *MultiplayerPeerExtension, p_buffer: PackedByteArray) -> Error {
}
MultiplayerPeerExtension__get_packet_channel :: (using self: *MultiplayerPeerExtension) -> int {
}
MultiplayerPeerExtension__get_packet_mode :: (using self: *MultiplayerPeerExtension) -> MultiplayerPeer.TransferMode {
}
MultiplayerPeerExtension__set_transfer_channel :: (using self: *MultiplayerPeerExtension, p_channel: int) {
}
MultiplayerPeerExtension__get_transfer_channel :: (using self: *MultiplayerPeerExtension) -> int {
}
MultiplayerPeerExtension__set_transfer_mode :: (using self: *MultiplayerPeerExtension, p_mode: MultiplayerPeer.TransferMode) {
}
MultiplayerPeerExtension__get_transfer_mode :: (using self: *MultiplayerPeerExtension) -> MultiplayerPeer.TransferMode {
}
MultiplayerPeerExtension__set_target_peer :: (using self: *MultiplayerPeerExtension, p_peer: int) {
}
MultiplayerPeerExtension__get_packet_peer :: (using self: *MultiplayerPeerExtension) -> int {
}
MultiplayerPeerExtension__is_server :: (using self: *MultiplayerPeerExtension) -> bool {
}
MultiplayerPeerExtension__poll :: (using self: *MultiplayerPeerExtension) {
}
MultiplayerPeerExtension__close :: (using self: *MultiplayerPeerExtension) {
}
MultiplayerPeerExtension__disconnect_peer :: (using self: *MultiplayerPeerExtension, p_peer: int, p_force: bool) {
}
MultiplayerPeerExtension__get_unique_id :: (using self: *MultiplayerPeerExtension) -> int {
}
MultiplayerPeerExtension__set_refuse_new_connections :: (using self: *MultiplayerPeerExtension, p_enable: bool) {
}
MultiplayerPeerExtension__is_refusing_new_connections :: (using self: *MultiplayerPeerExtension) -> bool {
}
MultiplayerPeerExtension__is_server_relay_supported :: (using self: *MultiplayerPeerExtension) -> bool {
}
MultiplayerPeerExtension__get_connection_status :: (using self: *MultiplayerPeerExtension) -> MultiplayerPeer.ConnectionStatus {
}

// MultiplayerSpawner
MultiplayerSpawner :: struct {
	__private: *void;
}

MultiplayerSpawner_add_spawnable_scene :: (using self: *MultiplayerSpawner, path: String) {
}
MultiplayerSpawner_get_spawnable_scene_count :: (using self: *MultiplayerSpawner) -> int {
}
MultiplayerSpawner_get_spawnable_scene :: (using self: *MultiplayerSpawner, index: int) -> String {
}
MultiplayerSpawner_clear_spawnable_scenes :: (using self: *MultiplayerSpawner) {
}
MultiplayerSpawner_spawn :: (using self: *MultiplayerSpawner, data: Variant) -> Node {
}
MultiplayerSpawner_get_spawn_path :: (using self: *MultiplayerSpawner) -> NodePath {
}
MultiplayerSpawner_set_spawn_path :: (using self: *MultiplayerSpawner, path: NodePath) {
}
MultiplayerSpawner_get_spawn_limit :: (using self: *MultiplayerSpawner) -> int {
}
MultiplayerSpawner_set_spawn_limit :: (using self: *MultiplayerSpawner, limit: int) {
}
MultiplayerSpawner_get_spawn_function :: (using self: *MultiplayerSpawner) -> Callable {
}
MultiplayerSpawner_set_spawn_function :: (using self: *MultiplayerSpawner, spawn_function: Callable) {
}

// MultiplayerSynchronizer
MultiplayerSynchronizer :: struct {
	__private: *void;

	VisibilityUpdateMode :: enum {
		VISIBILITY_PROCESS_IDLE :: 0;
		VISIBILITY_PROCESS_PHYSICS :: 1;
		VISIBILITY_PROCESS_NONE :: 2;
	}
}

MultiplayerSynchronizer_set_root_path :: (using self: *MultiplayerSynchronizer, path: NodePath) {
}
MultiplayerSynchronizer_get_root_path :: (using self: *MultiplayerSynchronizer) -> NodePath {
}
MultiplayerSynchronizer_set_replication_interval :: (using self: *MultiplayerSynchronizer, milliseconds: float) {
}
MultiplayerSynchronizer_get_replication_interval :: (using self: *MultiplayerSynchronizer) -> float {
}
MultiplayerSynchronizer_set_delta_interval :: (using self: *MultiplayerSynchronizer, milliseconds: float) {
}
MultiplayerSynchronizer_get_delta_interval :: (using self: *MultiplayerSynchronizer) -> float {
}
MultiplayerSynchronizer_set_replication_config :: (using self: *MultiplayerSynchronizer, config: SceneReplicationConfig) {
}
MultiplayerSynchronizer_get_replication_config :: (using self: *MultiplayerSynchronizer) -> SceneReplicationConfig {
}
MultiplayerSynchronizer_set_visibility_update_mode :: (using self: *MultiplayerSynchronizer, mode: MultiplayerSynchronizer.VisibilityUpdateMode) {
}
MultiplayerSynchronizer_get_visibility_update_mode :: (using self: *MultiplayerSynchronizer) -> MultiplayerSynchronizer.VisibilityUpdateMode {
}
MultiplayerSynchronizer_update_visibility :: (using self: *MultiplayerSynchronizer, for_peer: int) {
}
MultiplayerSynchronizer_set_visibility_public :: (using self: *MultiplayerSynchronizer, visible: bool) {
}
MultiplayerSynchronizer_is_visibility_public :: (using self: *MultiplayerSynchronizer) -> bool {
}
MultiplayerSynchronizer_add_visibility_filter :: (using self: *MultiplayerSynchronizer, filter: Callable) {
}
MultiplayerSynchronizer_remove_visibility_filter :: (using self: *MultiplayerSynchronizer, filter: Callable) {
}
MultiplayerSynchronizer_set_visibility_for :: (using self: *MultiplayerSynchronizer, peer: int, visible: bool) {
}
MultiplayerSynchronizer_get_visibility_for :: (using self: *MultiplayerSynchronizer, peer: int) -> bool {
}

// Mutex
Mutex :: struct {
	__private: *void;
}

Mutex_lock :: (using self: *Mutex) {
}
Mutex_try_lock :: (using self: *Mutex) -> bool {
}
Mutex_unlock :: (using self: *Mutex) {
}

// NativeMenu
NativeMenu :: struct {
	__private: *void;

	Feature :: enum {
		FEATURE_GLOBAL_MENU :: 0;
		FEATURE_POPUP_MENU :: 1;
		FEATURE_OPEN_CLOSE_CALLBACK :: 2;
		FEATURE_HOVER_CALLBACK :: 3;
		FEATURE_KEY_CALLBACK :: 4;
	}
	SystemMenus :: enum {
		INVALID_MENU_ID :: 0;
		MAIN_MENU_ID :: 1;
		APPLICATION_MENU_ID :: 2;
		WINDOW_MENU_ID :: 3;
		HELP_MENU_ID :: 4;
		DOCK_MENU_ID :: 5;
	}
}

NativeMenu_has_feature :: (using self: *NativeMenu, feature: NativeMenu.Feature) -> bool {
}
NativeMenu_has_system_menu :: (using self: *NativeMenu, menu_id: NativeMenu.SystemMenus) -> bool {
}
NativeMenu_get_system_menu :: (using self: *NativeMenu, menu_id: NativeMenu.SystemMenus) -> RID {
}
NativeMenu_get_system_menu_name :: (using self: *NativeMenu, menu_id: NativeMenu.SystemMenus) -> String {
}
NativeMenu_create_menu :: (using self: *NativeMenu) -> RID {
}
NativeMenu_has_menu :: (using self: *NativeMenu, rid: RID) -> bool {
}
NativeMenu_free_menu :: (using self: *NativeMenu, rid: RID) {
}
NativeMenu_get_size :: (using self: *NativeMenu, rid: RID) -> Vector2 {
}
NativeMenu_popup :: (using self: *NativeMenu, rid: RID, position: Vector2i) {
}
NativeMenu_set_interface_direction :: (using self: *NativeMenu, rid: RID, is_rtl: bool) {
}
NativeMenu_set_popup_open_callback :: (using self: *NativeMenu, rid: RID, callback: Callable) {
}
NativeMenu_get_popup_open_callback :: (using self: *NativeMenu, rid: RID) -> Callable {
}
NativeMenu_set_popup_close_callback :: (using self: *NativeMenu, rid: RID, callback: Callable) {
}
NativeMenu_get_popup_close_callback :: (using self: *NativeMenu, rid: RID) -> Callable {
}
NativeMenu_set_minimum_width :: (using self: *NativeMenu, rid: RID, width: float) {
}
NativeMenu_get_minimum_width :: (using self: *NativeMenu, rid: RID) -> float {
}
NativeMenu_is_opened :: (using self: *NativeMenu, rid: RID) -> bool {
}
NativeMenu_add_submenu_item :: (using self: *NativeMenu, rid: RID, label: String, submenu_rid: RID, tag: Variant, index: int) -> int {
}
NativeMenu_add_item :: (using self: *NativeMenu, rid: RID, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
NativeMenu_add_check_item :: (using self: *NativeMenu, rid: RID, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
NativeMenu_add_icon_item :: (using self: *NativeMenu, rid: RID, icon: Texture2D, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
NativeMenu_add_icon_check_item :: (using self: *NativeMenu, rid: RID, icon: Texture2D, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
NativeMenu_add_radio_check_item :: (using self: *NativeMenu, rid: RID, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
NativeMenu_add_icon_radio_check_item :: (using self: *NativeMenu, rid: RID, icon: Texture2D, label: String, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
NativeMenu_add_multistate_item :: (using self: *NativeMenu, rid: RID, label: String, max_states: int, default_state: int, callback: Callable, key_callback: Callable, tag: Variant, accelerator: Key, index: int) -> int {
}
NativeMenu_add_separator :: (using self: *NativeMenu, rid: RID, index: int) -> int {
}
NativeMenu_find_item_index_with_text :: (using self: *NativeMenu, rid: RID, text: String) -> int {
}
NativeMenu_find_item_index_with_tag :: (using self: *NativeMenu, rid: RID, tag: Variant) -> int {
}
NativeMenu_find_item_index_with_submenu :: (using self: *NativeMenu, rid: RID, submenu_rid: RID) -> int {
}
NativeMenu_is_item_checked :: (using self: *NativeMenu, rid: RID, idx: int) -> bool {
}
NativeMenu_is_item_checkable :: (using self: *NativeMenu, rid: RID, idx: int) -> bool {
}
NativeMenu_is_item_radio_checkable :: (using self: *NativeMenu, rid: RID, idx: int) -> bool {
}
NativeMenu_get_item_callback :: (using self: *NativeMenu, rid: RID, idx: int) -> Callable {
}
NativeMenu_get_item_key_callback :: (using self: *NativeMenu, rid: RID, idx: int) -> Callable {
}
NativeMenu_get_item_tag :: (using self: *NativeMenu, rid: RID, idx: int) -> Variant {
}
NativeMenu_get_item_text :: (using self: *NativeMenu, rid: RID, idx: int) -> String {
}
NativeMenu_get_item_submenu :: (using self: *NativeMenu, rid: RID, idx: int) -> RID {
}
NativeMenu_get_item_accelerator :: (using self: *NativeMenu, rid: RID, idx: int) -> Key {
}
NativeMenu_is_item_disabled :: (using self: *NativeMenu, rid: RID, idx: int) -> bool {
}
NativeMenu_is_item_hidden :: (using self: *NativeMenu, rid: RID, idx: int) -> bool {
}
NativeMenu_get_item_tooltip :: (using self: *NativeMenu, rid: RID, idx: int) -> String {
}
NativeMenu_get_item_state :: (using self: *NativeMenu, rid: RID, idx: int) -> int {
}
NativeMenu_get_item_max_states :: (using self: *NativeMenu, rid: RID, idx: int) -> int {
}
NativeMenu_get_item_icon :: (using self: *NativeMenu, rid: RID, idx: int) -> Texture2D {
}
NativeMenu_get_item_indentation_level :: (using self: *NativeMenu, rid: RID, idx: int) -> int {
}
NativeMenu_set_item_checked :: (using self: *NativeMenu, rid: RID, idx: int, checked: bool) {
}
NativeMenu_set_item_checkable :: (using self: *NativeMenu, rid: RID, idx: int, checkable: bool) {
}
NativeMenu_set_item_radio_checkable :: (using self: *NativeMenu, rid: RID, idx: int, checkable: bool) {
}
NativeMenu_set_item_callback :: (using self: *NativeMenu, rid: RID, idx: int, callback: Callable) {
}
NativeMenu_set_item_hover_callbacks :: (using self: *NativeMenu, rid: RID, idx: int, callback: Callable) {
}
NativeMenu_set_item_key_callback :: (using self: *NativeMenu, rid: RID, idx: int, key_callback: Callable) {
}
NativeMenu_set_item_tag :: (using self: *NativeMenu, rid: RID, idx: int, tag: Variant) {
}
NativeMenu_set_item_text :: (using self: *NativeMenu, rid: RID, idx: int, text: String) {
}
NativeMenu_set_item_submenu :: (using self: *NativeMenu, rid: RID, idx: int, submenu_rid: RID) {
}
NativeMenu_set_item_accelerator :: (using self: *NativeMenu, rid: RID, idx: int, keycode: Key) {
}
NativeMenu_set_item_disabled :: (using self: *NativeMenu, rid: RID, idx: int, disabled: bool) {
}
NativeMenu_set_item_hidden :: (using self: *NativeMenu, rid: RID, idx: int, hidden: bool) {
}
NativeMenu_set_item_tooltip :: (using self: *NativeMenu, rid: RID, idx: int, tooltip: String) {
}
NativeMenu_set_item_state :: (using self: *NativeMenu, rid: RID, idx: int, state: int) {
}
NativeMenu_set_item_max_states :: (using self: *NativeMenu, rid: RID, idx: int, max_states: int) {
}
NativeMenu_set_item_icon :: (using self: *NativeMenu, rid: RID, idx: int, icon: Texture2D) {
}
NativeMenu_set_item_indentation_level :: (using self: *NativeMenu, rid: RID, idx: int, level: int) {
}
NativeMenu_get_item_count :: (using self: *NativeMenu, rid: RID) -> int {
}
NativeMenu_is_system_menu :: (using self: *NativeMenu, rid: RID) -> bool {
}
NativeMenu_remove_item :: (using self: *NativeMenu, rid: RID, idx: int) {
}
NativeMenu_clear :: (using self: *NativeMenu, rid: RID) {
}

// NavigationAgent2D
NavigationAgent2D :: struct {
	__private: *void;
}

NavigationAgent2D_get_rid :: (using self: *NavigationAgent2D) -> RID {
}
NavigationAgent2D_set_avoidance_enabled :: (using self: *NavigationAgent2D, enabled: bool) {
}
NavigationAgent2D_get_avoidance_enabled :: (using self: *NavigationAgent2D) -> bool {
}
NavigationAgent2D_set_path_desired_distance :: (using self: *NavigationAgent2D, desired_distance: float) {
}
NavigationAgent2D_get_path_desired_distance :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_set_target_desired_distance :: (using self: *NavigationAgent2D, desired_distance: float) {
}
NavigationAgent2D_get_target_desired_distance :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_set_radius :: (using self: *NavigationAgent2D, radius: float) {
}
NavigationAgent2D_get_radius :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_set_neighbor_distance :: (using self: *NavigationAgent2D, neighbor_distance: float) {
}
NavigationAgent2D_get_neighbor_distance :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_set_max_neighbors :: (using self: *NavigationAgent2D, max_neighbors: int) {
}
NavigationAgent2D_get_max_neighbors :: (using self: *NavigationAgent2D) -> int {
}
NavigationAgent2D_set_time_horizon_agents :: (using self: *NavigationAgent2D, time_horizon: float) {
}
NavigationAgent2D_get_time_horizon_agents :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_set_time_horizon_obstacles :: (using self: *NavigationAgent2D, time_horizon: float) {
}
NavigationAgent2D_get_time_horizon_obstacles :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_set_max_speed :: (using self: *NavigationAgent2D, max_speed: float) {
}
NavigationAgent2D_get_max_speed :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_set_path_max_distance :: (using self: *NavigationAgent2D, max_speed: float) {
}
NavigationAgent2D_get_path_max_distance :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_set_navigation_layers :: (using self: *NavigationAgent2D, navigation_layers: int) {
}
NavigationAgent2D_get_navigation_layers :: (using self: *NavigationAgent2D) -> int {
}
NavigationAgent2D_set_navigation_layer_value :: (using self: *NavigationAgent2D, layer_number: int, value: bool) {
}
NavigationAgent2D_get_navigation_layer_value :: (using self: *NavigationAgent2D, layer_number: int) -> bool {
}
NavigationAgent2D_set_pathfinding_algorithm :: (using self: *NavigationAgent2D, pathfinding_algorithm: NavigationPathQueryParameters2D.PathfindingAlgorithm) {
}
NavigationAgent2D_get_pathfinding_algorithm :: (using self: *NavigationAgent2D) -> NavigationPathQueryParameters2D.PathfindingAlgorithm {
}
NavigationAgent2D_set_path_postprocessing :: (using self: *NavigationAgent2D, path_postprocessing: NavigationPathQueryParameters2D.PathPostProcessing) {
}
NavigationAgent2D_get_path_postprocessing :: (using self: *NavigationAgent2D) -> NavigationPathQueryParameters2D.PathPostProcessing {
}
NavigationAgent2D_set_path_metadata_flags :: (using self: *NavigationAgent2D, flags: NavigationPathQueryParameters2D.PathMetadataFlags) {
}
NavigationAgent2D_get_path_metadata_flags :: (using self: *NavigationAgent2D) -> NavigationPathQueryParameters2D.PathMetadataFlags {
}
NavigationAgent2D_set_navigation_map :: (using self: *NavigationAgent2D, navigation_map: RID) {
}
NavigationAgent2D_get_navigation_map :: (using self: *NavigationAgent2D) -> RID {
}
NavigationAgent2D_set_target_position :: (using self: *NavigationAgent2D, position: Vector2) {
}
NavigationAgent2D_get_target_position :: (using self: *NavigationAgent2D) -> Vector2 {
}
NavigationAgent2D_set_simplify_path :: (using self: *NavigationAgent2D, enabled: bool) {
}
NavigationAgent2D_get_simplify_path :: (using self: *NavigationAgent2D) -> bool {
}
NavigationAgent2D_set_simplify_epsilon :: (using self: *NavigationAgent2D, epsilon: float) {
}
NavigationAgent2D_get_simplify_epsilon :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_get_next_path_position :: (using self: *NavigationAgent2D) -> Vector2 {
}
NavigationAgent2D_set_velocity_forced :: (using self: *NavigationAgent2D, velocity: Vector2) {
}
NavigationAgent2D_set_velocity :: (using self: *NavigationAgent2D, velocity: Vector2) {
}
NavigationAgent2D_get_velocity :: (using self: *NavigationAgent2D) -> Vector2 {
}
NavigationAgent2D_distance_to_target :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_get_current_navigation_result :: (using self: *NavigationAgent2D) -> NavigationPathQueryResult2D {
}
NavigationAgent2D_get_current_navigation_path :: (using self: *NavigationAgent2D) -> PackedVector2Array {
}
NavigationAgent2D_get_current_navigation_path_index :: (using self: *NavigationAgent2D) -> int {
}
NavigationAgent2D_is_target_reached :: (using self: *NavigationAgent2D) -> bool {
}
NavigationAgent2D_is_target_reachable :: (using self: *NavigationAgent2D) -> bool {
}
NavigationAgent2D_is_navigation_finished :: (using self: *NavigationAgent2D) -> bool {
}
NavigationAgent2D_get_final_position :: (using self: *NavigationAgent2D) -> Vector2 {
}
NavigationAgent2D_set_avoidance_layers :: (using self: *NavigationAgent2D, layers: int) {
}
NavigationAgent2D_get_avoidance_layers :: (using self: *NavigationAgent2D) -> int {
}
NavigationAgent2D_set_avoidance_mask :: (using self: *NavigationAgent2D, mask: int) {
}
NavigationAgent2D_get_avoidance_mask :: (using self: *NavigationAgent2D) -> int {
}
NavigationAgent2D_set_avoidance_layer_value :: (using self: *NavigationAgent2D, layer_number: int, value: bool) {
}
NavigationAgent2D_get_avoidance_layer_value :: (using self: *NavigationAgent2D, layer_number: int) -> bool {
}
NavigationAgent2D_set_avoidance_mask_value :: (using self: *NavigationAgent2D, mask_number: int, value: bool) {
}
NavigationAgent2D_get_avoidance_mask_value :: (using self: *NavigationAgent2D, mask_number: int) -> bool {
}
NavigationAgent2D_set_avoidance_priority :: (using self: *NavigationAgent2D, priority: float) {
}
NavigationAgent2D_get_avoidance_priority :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_set_debug_enabled :: (using self: *NavigationAgent2D, enabled: bool) {
}
NavigationAgent2D_get_debug_enabled :: (using self: *NavigationAgent2D) -> bool {
}
NavigationAgent2D_set_debug_use_custom :: (using self: *NavigationAgent2D, enabled: bool) {
}
NavigationAgent2D_get_debug_use_custom :: (using self: *NavigationAgent2D) -> bool {
}
NavigationAgent2D_set_debug_path_custom_color :: (using self: *NavigationAgent2D, color: Color) {
}
NavigationAgent2D_get_debug_path_custom_color :: (using self: *NavigationAgent2D) -> Color {
}
NavigationAgent2D_set_debug_path_custom_point_size :: (using self: *NavigationAgent2D, point_size: float) {
}
NavigationAgent2D_get_debug_path_custom_point_size :: (using self: *NavigationAgent2D) -> float {
}
NavigationAgent2D_set_debug_path_custom_line_width :: (using self: *NavigationAgent2D, line_width: float) {
}
NavigationAgent2D_get_debug_path_custom_line_width :: (using self: *NavigationAgent2D) -> float {
}

// NavigationAgent3D
NavigationAgent3D :: struct {
	__private: *void;
}

NavigationAgent3D_get_rid :: (using self: *NavigationAgent3D) -> RID {
}
NavigationAgent3D_set_avoidance_enabled :: (using self: *NavigationAgent3D, enabled: bool) {
}
NavigationAgent3D_get_avoidance_enabled :: (using self: *NavigationAgent3D) -> bool {
}
NavigationAgent3D_set_path_desired_distance :: (using self: *NavigationAgent3D, desired_distance: float) {
}
NavigationAgent3D_get_path_desired_distance :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_set_target_desired_distance :: (using self: *NavigationAgent3D, desired_distance: float) {
}
NavigationAgent3D_get_target_desired_distance :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_set_radius :: (using self: *NavigationAgent3D, radius: float) {
}
NavigationAgent3D_get_radius :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_set_height :: (using self: *NavigationAgent3D, height: float) {
}
NavigationAgent3D_get_height :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_set_path_height_offset :: (using self: *NavigationAgent3D, path_height_offset: float) {
}
NavigationAgent3D_get_path_height_offset :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_set_use_3d_avoidance :: (using self: *NavigationAgent3D, enabled: bool) {
}
NavigationAgent3D_get_use_3d_avoidance :: (using self: *NavigationAgent3D) -> bool {
}
NavigationAgent3D_set_keep_y_velocity :: (using self: *NavigationAgent3D, enabled: bool) {
}
NavigationAgent3D_get_keep_y_velocity :: (using self: *NavigationAgent3D) -> bool {
}
NavigationAgent3D_set_neighbor_distance :: (using self: *NavigationAgent3D, neighbor_distance: float) {
}
NavigationAgent3D_get_neighbor_distance :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_set_max_neighbors :: (using self: *NavigationAgent3D, max_neighbors: int) {
}
NavigationAgent3D_get_max_neighbors :: (using self: *NavigationAgent3D) -> int {
}
NavigationAgent3D_set_time_horizon_agents :: (using self: *NavigationAgent3D, time_horizon: float) {
}
NavigationAgent3D_get_time_horizon_agents :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_set_time_horizon_obstacles :: (using self: *NavigationAgent3D, time_horizon: float) {
}
NavigationAgent3D_get_time_horizon_obstacles :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_set_max_speed :: (using self: *NavigationAgent3D, max_speed: float) {
}
NavigationAgent3D_get_max_speed :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_set_path_max_distance :: (using self: *NavigationAgent3D, max_speed: float) {
}
NavigationAgent3D_get_path_max_distance :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_set_navigation_layers :: (using self: *NavigationAgent3D, navigation_layers: int) {
}
NavigationAgent3D_get_navigation_layers :: (using self: *NavigationAgent3D) -> int {
}
NavigationAgent3D_set_navigation_layer_value :: (using self: *NavigationAgent3D, layer_number: int, value: bool) {
}
NavigationAgent3D_get_navigation_layer_value :: (using self: *NavigationAgent3D, layer_number: int) -> bool {
}
NavigationAgent3D_set_pathfinding_algorithm :: (using self: *NavigationAgent3D, pathfinding_algorithm: NavigationPathQueryParameters3D.PathfindingAlgorithm) {
}
NavigationAgent3D_get_pathfinding_algorithm :: (using self: *NavigationAgent3D) -> NavigationPathQueryParameters3D.PathfindingAlgorithm {
}
NavigationAgent3D_set_path_postprocessing :: (using self: *NavigationAgent3D, path_postprocessing: NavigationPathQueryParameters3D.PathPostProcessing) {
}
NavigationAgent3D_get_path_postprocessing :: (using self: *NavigationAgent3D) -> NavigationPathQueryParameters3D.PathPostProcessing {
}
NavigationAgent3D_set_path_metadata_flags :: (using self: *NavigationAgent3D, flags: NavigationPathQueryParameters3D.PathMetadataFlags) {
}
NavigationAgent3D_get_path_metadata_flags :: (using self: *NavigationAgent3D) -> NavigationPathQueryParameters3D.PathMetadataFlags {
}
NavigationAgent3D_set_navigation_map :: (using self: *NavigationAgent3D, navigation_map: RID) {
}
NavigationAgent3D_get_navigation_map :: (using self: *NavigationAgent3D) -> RID {
}
NavigationAgent3D_set_target_position :: (using self: *NavigationAgent3D, position: Vector3) {
}
NavigationAgent3D_get_target_position :: (using self: *NavigationAgent3D) -> Vector3 {
}
NavigationAgent3D_set_simplify_path :: (using self: *NavigationAgent3D, enabled: bool) {
}
NavigationAgent3D_get_simplify_path :: (using self: *NavigationAgent3D) -> bool {
}
NavigationAgent3D_set_simplify_epsilon :: (using self: *NavigationAgent3D, epsilon: float) {
}
NavigationAgent3D_get_simplify_epsilon :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_get_next_path_position :: (using self: *NavigationAgent3D) -> Vector3 {
}
NavigationAgent3D_set_velocity_forced :: (using self: *NavigationAgent3D, velocity: Vector3) {
}
NavigationAgent3D_set_velocity :: (using self: *NavigationAgent3D, velocity: Vector3) {
}
NavigationAgent3D_get_velocity :: (using self: *NavigationAgent3D) -> Vector3 {
}
NavigationAgent3D_distance_to_target :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_get_current_navigation_result :: (using self: *NavigationAgent3D) -> NavigationPathQueryResult3D {
}
NavigationAgent3D_get_current_navigation_path :: (using self: *NavigationAgent3D) -> PackedVector3Array {
}
NavigationAgent3D_get_current_navigation_path_index :: (using self: *NavigationAgent3D) -> int {
}
NavigationAgent3D_is_target_reached :: (using self: *NavigationAgent3D) -> bool {
}
NavigationAgent3D_is_target_reachable :: (using self: *NavigationAgent3D) -> bool {
}
NavigationAgent3D_is_navigation_finished :: (using self: *NavigationAgent3D) -> bool {
}
NavigationAgent3D_get_final_position :: (using self: *NavigationAgent3D) -> Vector3 {
}
NavigationAgent3D_set_avoidance_layers :: (using self: *NavigationAgent3D, layers: int) {
}
NavigationAgent3D_get_avoidance_layers :: (using self: *NavigationAgent3D) -> int {
}
NavigationAgent3D_set_avoidance_mask :: (using self: *NavigationAgent3D, mask: int) {
}
NavigationAgent3D_get_avoidance_mask :: (using self: *NavigationAgent3D) -> int {
}
NavigationAgent3D_set_avoidance_layer_value :: (using self: *NavigationAgent3D, layer_number: int, value: bool) {
}
NavigationAgent3D_get_avoidance_layer_value :: (using self: *NavigationAgent3D, layer_number: int) -> bool {
}
NavigationAgent3D_set_avoidance_mask_value :: (using self: *NavigationAgent3D, mask_number: int, value: bool) {
}
NavigationAgent3D_get_avoidance_mask_value :: (using self: *NavigationAgent3D, mask_number: int) -> bool {
}
NavigationAgent3D_set_avoidance_priority :: (using self: *NavigationAgent3D, priority: float) {
}
NavigationAgent3D_get_avoidance_priority :: (using self: *NavigationAgent3D) -> float {
}
NavigationAgent3D_set_debug_enabled :: (using self: *NavigationAgent3D, enabled: bool) {
}
NavigationAgent3D_get_debug_enabled :: (using self: *NavigationAgent3D) -> bool {
}
NavigationAgent3D_set_debug_use_custom :: (using self: *NavigationAgent3D, enabled: bool) {
}
NavigationAgent3D_get_debug_use_custom :: (using self: *NavigationAgent3D) -> bool {
}
NavigationAgent3D_set_debug_path_custom_color :: (using self: *NavigationAgent3D, color: Color) {
}
NavigationAgent3D_get_debug_path_custom_color :: (using self: *NavigationAgent3D) -> Color {
}
NavigationAgent3D_set_debug_path_custom_point_size :: (using self: *NavigationAgent3D, point_size: float) {
}
NavigationAgent3D_get_debug_path_custom_point_size :: (using self: *NavigationAgent3D) -> float {
}

// NavigationLink2D
NavigationLink2D :: struct {
	__private: *void;
}

NavigationLink2D_get_rid :: (using self: *NavigationLink2D) -> RID {
}
NavigationLink2D_set_enabled :: (using self: *NavigationLink2D, enabled: bool) {
}
NavigationLink2D_is_enabled :: (using self: *NavigationLink2D) -> bool {
}
NavigationLink2D_set_bidirectional :: (using self: *NavigationLink2D, bidirectional: bool) {
}
NavigationLink2D_is_bidirectional :: (using self: *NavigationLink2D) -> bool {
}
NavigationLink2D_set_navigation_layers :: (using self: *NavigationLink2D, navigation_layers: int) {
}
NavigationLink2D_get_navigation_layers :: (using self: *NavigationLink2D) -> int {
}
NavigationLink2D_set_navigation_layer_value :: (using self: *NavigationLink2D, layer_number: int, value: bool) {
}
NavigationLink2D_get_navigation_layer_value :: (using self: *NavigationLink2D, layer_number: int) -> bool {
}
NavigationLink2D_set_start_position :: (using self: *NavigationLink2D, position: Vector2) {
}
NavigationLink2D_get_start_position :: (using self: *NavigationLink2D) -> Vector2 {
}
NavigationLink2D_set_end_position :: (using self: *NavigationLink2D, position: Vector2) {
}
NavigationLink2D_get_end_position :: (using self: *NavigationLink2D) -> Vector2 {
}
NavigationLink2D_set_global_start_position :: (using self: *NavigationLink2D, position: Vector2) {
}
NavigationLink2D_get_global_start_position :: (using self: *NavigationLink2D) -> Vector2 {
}
NavigationLink2D_set_global_end_position :: (using self: *NavigationLink2D, position: Vector2) {
}
NavigationLink2D_get_global_end_position :: (using self: *NavigationLink2D) -> Vector2 {
}
NavigationLink2D_set_enter_cost :: (using self: *NavigationLink2D, enter_cost: float) {
}
NavigationLink2D_get_enter_cost :: (using self: *NavigationLink2D) -> float {
}
NavigationLink2D_set_travel_cost :: (using self: *NavigationLink2D, travel_cost: float) {
}
NavigationLink2D_get_travel_cost :: (using self: *NavigationLink2D) -> float {
}

// NavigationLink3D
NavigationLink3D :: struct {
	__private: *void;
}

NavigationLink3D_get_rid :: (using self: *NavigationLink3D) -> RID {
}
NavigationLink3D_set_enabled :: (using self: *NavigationLink3D, enabled: bool) {
}
NavigationLink3D_is_enabled :: (using self: *NavigationLink3D) -> bool {
}
NavigationLink3D_set_bidirectional :: (using self: *NavigationLink3D, bidirectional: bool) {
}
NavigationLink3D_is_bidirectional :: (using self: *NavigationLink3D) -> bool {
}
NavigationLink3D_set_navigation_layers :: (using self: *NavigationLink3D, navigation_layers: int) {
}
NavigationLink3D_get_navigation_layers :: (using self: *NavigationLink3D) -> int {
}
NavigationLink3D_set_navigation_layer_value :: (using self: *NavigationLink3D, layer_number: int, value: bool) {
}
NavigationLink3D_get_navigation_layer_value :: (using self: *NavigationLink3D, layer_number: int) -> bool {
}
NavigationLink3D_set_start_position :: (using self: *NavigationLink3D, position: Vector3) {
}
NavigationLink3D_get_start_position :: (using self: *NavigationLink3D) -> Vector3 {
}
NavigationLink3D_set_end_position :: (using self: *NavigationLink3D, position: Vector3) {
}
NavigationLink3D_get_end_position :: (using self: *NavigationLink3D) -> Vector3 {
}
NavigationLink3D_set_global_start_position :: (using self: *NavigationLink3D, position: Vector3) {
}
NavigationLink3D_get_global_start_position :: (using self: *NavigationLink3D) -> Vector3 {
}
NavigationLink3D_set_global_end_position :: (using self: *NavigationLink3D, position: Vector3) {
}
NavigationLink3D_get_global_end_position :: (using self: *NavigationLink3D) -> Vector3 {
}
NavigationLink3D_set_enter_cost :: (using self: *NavigationLink3D, enter_cost: float) {
}
NavigationLink3D_get_enter_cost :: (using self: *NavigationLink3D) -> float {
}
NavigationLink3D_set_travel_cost :: (using self: *NavigationLink3D, travel_cost: float) {
}
NavigationLink3D_get_travel_cost :: (using self: *NavigationLink3D) -> float {
}

// NavigationMesh
NavigationMesh :: struct {
	__private: *void;

	SamplePartitionType :: enum {
		SAMPLE_PARTITION_WATERSHED :: 0;
		SAMPLE_PARTITION_MONOTONE :: 1;
		SAMPLE_PARTITION_LAYERS :: 2;
		SAMPLE_PARTITION_MAX :: 3;
	}
	ParsedGeometryType :: enum {
		PARSED_GEOMETRY_MESH_INSTANCES :: 0;
		PARSED_GEOMETRY_STATIC_COLLIDERS :: 1;
		PARSED_GEOMETRY_BOTH :: 2;
		PARSED_GEOMETRY_MAX :: 3;
	}
	SourceGeometryMode :: enum {
		SOURCE_GEOMETRY_ROOT_NODE_CHILDREN :: 0;
		SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN :: 1;
		SOURCE_GEOMETRY_GROUPS_EXPLICIT :: 2;
		SOURCE_GEOMETRY_MAX :: 3;
	}
}

NavigationMesh_set_sample_partition_type :: (using self: *NavigationMesh, sample_partition_type: NavigationMesh.SamplePartitionType) {
}
NavigationMesh_get_sample_partition_type :: (using self: *NavigationMesh) -> NavigationMesh.SamplePartitionType {
}
NavigationMesh_set_parsed_geometry_type :: (using self: *NavigationMesh, geometry_type: NavigationMesh.ParsedGeometryType) {
}
NavigationMesh_get_parsed_geometry_type :: (using self: *NavigationMesh) -> NavigationMesh.ParsedGeometryType {
}
NavigationMesh_set_collision_mask :: (using self: *NavigationMesh, mask: int) {
}
NavigationMesh_get_collision_mask :: (using self: *NavigationMesh) -> int {
}
NavigationMesh_set_collision_mask_value :: (using self: *NavigationMesh, layer_number: int, value: bool) {
}
NavigationMesh_get_collision_mask_value :: (using self: *NavigationMesh, layer_number: int) -> bool {
}
NavigationMesh_set_source_geometry_mode :: (using self: *NavigationMesh, mask: NavigationMesh.SourceGeometryMode) {
}
NavigationMesh_get_source_geometry_mode :: (using self: *NavigationMesh) -> NavigationMesh.SourceGeometryMode {
}
NavigationMesh_set_source_group_name :: (using self: *NavigationMesh, mask: StringName) {
}
NavigationMesh_get_source_group_name :: (using self: *NavigationMesh) -> StringName {
}
NavigationMesh_set_cell_size :: (using self: *NavigationMesh, cell_size: float) {
}
NavigationMesh_get_cell_size :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_cell_height :: (using self: *NavigationMesh, cell_height: float) {
}
NavigationMesh_get_cell_height :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_border_size :: (using self: *NavigationMesh, border_size: float) {
}
NavigationMesh_get_border_size :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_agent_height :: (using self: *NavigationMesh, agent_height: float) {
}
NavigationMesh_get_agent_height :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_agent_radius :: (using self: *NavigationMesh, agent_radius: float) {
}
NavigationMesh_get_agent_radius :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_agent_max_climb :: (using self: *NavigationMesh, agent_max_climb: float) {
}
NavigationMesh_get_agent_max_climb :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_agent_max_slope :: (using self: *NavigationMesh, agent_max_slope: float) {
}
NavigationMesh_get_agent_max_slope :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_region_min_size :: (using self: *NavigationMesh, region_min_size: float) {
}
NavigationMesh_get_region_min_size :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_region_merge_size :: (using self: *NavigationMesh, region_merge_size: float) {
}
NavigationMesh_get_region_merge_size :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_edge_max_length :: (using self: *NavigationMesh, edge_max_length: float) {
}
NavigationMesh_get_edge_max_length :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_edge_max_error :: (using self: *NavigationMesh, edge_max_error: float) {
}
NavigationMesh_get_edge_max_error :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_vertices_per_polygon :: (using self: *NavigationMesh, vertices_per_polygon: float) {
}
NavigationMesh_get_vertices_per_polygon :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_detail_sample_distance :: (using self: *NavigationMesh, detail_sample_dist: float) {
}
NavigationMesh_get_detail_sample_distance :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_detail_sample_max_error :: (using self: *NavigationMesh, detail_sample_max_error: float) {
}
NavigationMesh_get_detail_sample_max_error :: (using self: *NavigationMesh) -> float {
}
NavigationMesh_set_filter_low_hanging_obstacles :: (using self: *NavigationMesh, filter_low_hanging_obstacles: bool) {
}
NavigationMesh_get_filter_low_hanging_obstacles :: (using self: *NavigationMesh) -> bool {
}
NavigationMesh_set_filter_ledge_spans :: (using self: *NavigationMesh, filter_ledge_spans: bool) {
}
NavigationMesh_get_filter_ledge_spans :: (using self: *NavigationMesh) -> bool {
}
NavigationMesh_set_filter_walkable_low_height_spans :: (using self: *NavigationMesh, filter_walkable_low_height_spans: bool) {
}
NavigationMesh_get_filter_walkable_low_height_spans :: (using self: *NavigationMesh) -> bool {
}
NavigationMesh_set_filter_baking_aabb :: (using self: *NavigationMesh, baking_aabb: AABB) {
}
NavigationMesh_get_filter_baking_aabb :: (using self: *NavigationMesh) -> AABB {
}
NavigationMesh_set_filter_baking_aabb_offset :: (using self: *NavigationMesh, baking_aabb_offset: Vector3) {
}
NavigationMesh_get_filter_baking_aabb_offset :: (using self: *NavigationMesh) -> Vector3 {
}
NavigationMesh_set_vertices :: (using self: *NavigationMesh, vertices: PackedVector3Array) {
}
NavigationMesh_get_vertices :: (using self: *NavigationMesh) -> PackedVector3Array {
}
NavigationMesh_add_polygon :: (using self: *NavigationMesh, polygon: PackedInt32Array) {
}
NavigationMesh_get_polygon_count :: (using self: *NavigationMesh) -> int {
}
NavigationMesh_get_polygon :: (using self: *NavigationMesh, idx: int) -> PackedInt32Array {
}
NavigationMesh_clear_polygons :: (using self: *NavigationMesh) {
}
NavigationMesh_create_from_mesh :: (using self: *NavigationMesh, mesh: Mesh) {
}
NavigationMesh_clear :: (using self: *NavigationMesh) {
}

// NavigationMeshGenerator
NavigationMeshGenerator :: struct {
	__private: *void;
}

NavigationMeshGenerator_bake :: (using self: *NavigationMeshGenerator, navigation_mesh: NavigationMesh, root_node: Node) {
}
NavigationMeshGenerator_clear :: (using self: *NavigationMeshGenerator, navigation_mesh: NavigationMesh) {
}
NavigationMeshGenerator_parse_source_geometry_data :: (using self: *NavigationMeshGenerator, navigation_mesh: NavigationMesh, source_geometry_data: NavigationMeshSourceGeometryData3D, root_node: Node, callback: Callable) {
}
NavigationMeshGenerator_bake_from_source_geometry_data :: (using self: *NavigationMeshGenerator, navigation_mesh: NavigationMesh, source_geometry_data: NavigationMeshSourceGeometryData3D, callback: Callable) {
}

// NavigationMeshSourceGeometryData2D
NavigationMeshSourceGeometryData2D :: struct {
	__private: *void;
}

NavigationMeshSourceGeometryData2D_clear :: (using self: *NavigationMeshSourceGeometryData2D) {
}
NavigationMeshSourceGeometryData2D_has_data :: (using self: *NavigationMeshSourceGeometryData2D) -> bool {
}
NavigationMeshSourceGeometryData2D_set_traversable_outlines :: (using self: *NavigationMeshSourceGeometryData2D, traversable_outlines: Array) {
}
NavigationMeshSourceGeometryData2D_get_traversable_outlines :: (using self: *NavigationMeshSourceGeometryData2D) -> Array {
}
NavigationMeshSourceGeometryData2D_set_obstruction_outlines :: (using self: *NavigationMeshSourceGeometryData2D, obstruction_outlines: Array) {
}
NavigationMeshSourceGeometryData2D_get_obstruction_outlines :: (using self: *NavigationMeshSourceGeometryData2D) -> Array {
}
NavigationMeshSourceGeometryData2D_append_traversable_outlines :: (using self: *NavigationMeshSourceGeometryData2D, traversable_outlines: Array) {
}
NavigationMeshSourceGeometryData2D_append_obstruction_outlines :: (using self: *NavigationMeshSourceGeometryData2D, obstruction_outlines: Array) {
}
NavigationMeshSourceGeometryData2D_add_traversable_outline :: (using self: *NavigationMeshSourceGeometryData2D, shape_outline: PackedVector2Array) {
}
NavigationMeshSourceGeometryData2D_add_obstruction_outline :: (using self: *NavigationMeshSourceGeometryData2D, shape_outline: PackedVector2Array) {
}
NavigationMeshSourceGeometryData2D_merge :: (using self: *NavigationMeshSourceGeometryData2D, other_geometry: NavigationMeshSourceGeometryData2D) {
}
NavigationMeshSourceGeometryData2D_add_projected_obstruction :: (using self: *NavigationMeshSourceGeometryData2D, vertices: PackedVector2Array, carve: bool) {
}
NavigationMeshSourceGeometryData2D_clear_projected_obstructions :: (using self: *NavigationMeshSourceGeometryData2D) {
}
NavigationMeshSourceGeometryData2D_set_projected_obstructions :: (using self: *NavigationMeshSourceGeometryData2D, projected_obstructions: Array) {
}
NavigationMeshSourceGeometryData2D_get_projected_obstructions :: (using self: *NavigationMeshSourceGeometryData2D) -> Array {
}

// NavigationMeshSourceGeometryData3D
NavigationMeshSourceGeometryData3D :: struct {
	__private: *void;
}

NavigationMeshSourceGeometryData3D_set_vertices :: (using self: *NavigationMeshSourceGeometryData3D, vertices: PackedFloat32Array) {
}
NavigationMeshSourceGeometryData3D_get_vertices :: (using self: *NavigationMeshSourceGeometryData3D) -> PackedFloat32Array {
}
NavigationMeshSourceGeometryData3D_set_indices :: (using self: *NavigationMeshSourceGeometryData3D, indices: PackedInt32Array) {
}
NavigationMeshSourceGeometryData3D_get_indices :: (using self: *NavigationMeshSourceGeometryData3D) -> PackedInt32Array {
}
NavigationMeshSourceGeometryData3D_append_arrays :: (using self: *NavigationMeshSourceGeometryData3D, vertices: PackedFloat32Array, indices: PackedInt32Array) {
}
NavigationMeshSourceGeometryData3D_clear :: (using self: *NavigationMeshSourceGeometryData3D) {
}
NavigationMeshSourceGeometryData3D_has_data :: (using self: *NavigationMeshSourceGeometryData3D) -> bool {
}
NavigationMeshSourceGeometryData3D_add_mesh :: (using self: *NavigationMeshSourceGeometryData3D, mesh: Mesh, xform: Transform3D) {
}
NavigationMeshSourceGeometryData3D_add_mesh_array :: (using self: *NavigationMeshSourceGeometryData3D, mesh_array: Array, xform: Transform3D) {
}
NavigationMeshSourceGeometryData3D_add_faces :: (using self: *NavigationMeshSourceGeometryData3D, faces: PackedVector3Array, xform: Transform3D) {
}
NavigationMeshSourceGeometryData3D_merge :: (using self: *NavigationMeshSourceGeometryData3D, other_geometry: NavigationMeshSourceGeometryData3D) {
}
NavigationMeshSourceGeometryData3D_add_projected_obstruction :: (using self: *NavigationMeshSourceGeometryData3D, vertices: PackedVector3Array, elevation: float, height: float, carve: bool) {
}
NavigationMeshSourceGeometryData3D_clear_projected_obstructions :: (using self: *NavigationMeshSourceGeometryData3D) {
}
NavigationMeshSourceGeometryData3D_set_projected_obstructions :: (using self: *NavigationMeshSourceGeometryData3D, projected_obstructions: Array) {
}
NavigationMeshSourceGeometryData3D_get_projected_obstructions :: (using self: *NavigationMeshSourceGeometryData3D) -> Array {
}

// NavigationObstacle2D
NavigationObstacle2D :: struct {
	__private: *void;
}

NavigationObstacle2D_get_rid :: (using self: *NavigationObstacle2D) -> RID {
}
NavigationObstacle2D_set_avoidance_enabled :: (using self: *NavigationObstacle2D, enabled: bool) {
}
NavigationObstacle2D_get_avoidance_enabled :: (using self: *NavigationObstacle2D) -> bool {
}
NavigationObstacle2D_set_navigation_map :: (using self: *NavigationObstacle2D, navigation_map: RID) {
}
NavigationObstacle2D_get_navigation_map :: (using self: *NavigationObstacle2D) -> RID {
}
NavigationObstacle2D_set_radius :: (using self: *NavigationObstacle2D, radius: float) {
}
NavigationObstacle2D_get_radius :: (using self: *NavigationObstacle2D) -> float {
}
NavigationObstacle2D_set_velocity :: (using self: *NavigationObstacle2D, velocity: Vector2) {
}
NavigationObstacle2D_get_velocity :: (using self: *NavigationObstacle2D) -> Vector2 {
}
NavigationObstacle2D_set_vertices :: (using self: *NavigationObstacle2D, vertices: PackedVector2Array) {
}
NavigationObstacle2D_get_vertices :: (using self: *NavigationObstacle2D) -> PackedVector2Array {
}
NavigationObstacle2D_set_avoidance_layers :: (using self: *NavigationObstacle2D, layers: int) {
}
NavigationObstacle2D_get_avoidance_layers :: (using self: *NavigationObstacle2D) -> int {
}
NavigationObstacle2D_set_avoidance_layer_value :: (using self: *NavigationObstacle2D, layer_number: int, value: bool) {
}
NavigationObstacle2D_get_avoidance_layer_value :: (using self: *NavigationObstacle2D, layer_number: int) -> bool {
}
NavigationObstacle2D_set_affect_navigation_mesh :: (using self: *NavigationObstacle2D, enabled: bool) {
}
NavigationObstacle2D_get_affect_navigation_mesh :: (using self: *NavigationObstacle2D) -> bool {
}
NavigationObstacle2D_set_carve_navigation_mesh :: (using self: *NavigationObstacle2D, enabled: bool) {
}
NavigationObstacle2D_get_carve_navigation_mesh :: (using self: *NavigationObstacle2D) -> bool {
}

// NavigationObstacle3D
NavigationObstacle3D :: struct {
	__private: *void;
}

NavigationObstacle3D_get_rid :: (using self: *NavigationObstacle3D) -> RID {
}
NavigationObstacle3D_set_avoidance_enabled :: (using self: *NavigationObstacle3D, enabled: bool) {
}
NavigationObstacle3D_get_avoidance_enabled :: (using self: *NavigationObstacle3D) -> bool {
}
NavigationObstacle3D_set_navigation_map :: (using self: *NavigationObstacle3D, navigation_map: RID) {
}
NavigationObstacle3D_get_navigation_map :: (using self: *NavigationObstacle3D) -> RID {
}
NavigationObstacle3D_set_radius :: (using self: *NavigationObstacle3D, radius: float) {
}
NavigationObstacle3D_get_radius :: (using self: *NavigationObstacle3D) -> float {
}
NavigationObstacle3D_set_height :: (using self: *NavigationObstacle3D, height: float) {
}
NavigationObstacle3D_get_height :: (using self: *NavigationObstacle3D) -> float {
}
NavigationObstacle3D_set_velocity :: (using self: *NavigationObstacle3D, velocity: Vector3) {
}
NavigationObstacle3D_get_velocity :: (using self: *NavigationObstacle3D) -> Vector3 {
}
NavigationObstacle3D_set_vertices :: (using self: *NavigationObstacle3D, vertices: PackedVector3Array) {
}
NavigationObstacle3D_get_vertices :: (using self: *NavigationObstacle3D) -> PackedVector3Array {
}
NavigationObstacle3D_set_avoidance_layers :: (using self: *NavigationObstacle3D, layers: int) {
}
NavigationObstacle3D_get_avoidance_layers :: (using self: *NavigationObstacle3D) -> int {
}
NavigationObstacle3D_set_avoidance_layer_value :: (using self: *NavigationObstacle3D, layer_number: int, value: bool) {
}
NavigationObstacle3D_get_avoidance_layer_value :: (using self: *NavigationObstacle3D, layer_number: int) -> bool {
}
NavigationObstacle3D_set_use_3d_avoidance :: (using self: *NavigationObstacle3D, enabled: bool) {
}
NavigationObstacle3D_get_use_3d_avoidance :: (using self: *NavigationObstacle3D) -> bool {
}
NavigationObstacle3D_set_affect_navigation_mesh :: (using self: *NavigationObstacle3D, enabled: bool) {
}
NavigationObstacle3D_get_affect_navigation_mesh :: (using self: *NavigationObstacle3D) -> bool {
}
NavigationObstacle3D_set_carve_navigation_mesh :: (using self: *NavigationObstacle3D, enabled: bool) {
}
NavigationObstacle3D_get_carve_navigation_mesh :: (using self: *NavigationObstacle3D) -> bool {
}

// NavigationPathQueryParameters2D
NavigationPathQueryParameters2D :: struct {
	__private: *void;

	PathfindingAlgorithm :: enum {
		PATHFINDING_ALGORITHM_ASTAR :: 0;
	}
	PathPostProcessing :: enum {
		PATH_POSTPROCESSING_CORRIDORFUNNEL :: 0;
		PATH_POSTPROCESSING_EDGECENTERED :: 1;
	}
	PathMetadataFlags :: enum_flags {
		PATH_METADATA_INCLUDE_NONE :: 0;
		PATH_METADATA_INCLUDE_TYPES :: 1;
		PATH_METADATA_INCLUDE_RIDS :: 2;
		PATH_METADATA_INCLUDE_OWNERS :: 4;
		PATH_METADATA_INCLUDE_ALL :: 7;
	}
}

NavigationPathQueryParameters2D_set_pathfinding_algorithm :: (using self: *NavigationPathQueryParameters2D, pathfinding_algorithm: NavigationPathQueryParameters2D.PathfindingAlgorithm) {
}
NavigationPathQueryParameters2D_get_pathfinding_algorithm :: (using self: *NavigationPathQueryParameters2D) -> NavigationPathQueryParameters2D.PathfindingAlgorithm {
}
NavigationPathQueryParameters2D_set_path_postprocessing :: (using self: *NavigationPathQueryParameters2D, path_postprocessing: NavigationPathQueryParameters2D.PathPostProcessing) {
}
NavigationPathQueryParameters2D_get_path_postprocessing :: (using self: *NavigationPathQueryParameters2D) -> NavigationPathQueryParameters2D.PathPostProcessing {
}
NavigationPathQueryParameters2D_set_map :: (using self: *NavigationPathQueryParameters2D, map: RID) {
}
NavigationPathQueryParameters2D_get_map :: (using self: *NavigationPathQueryParameters2D) -> RID {
}
NavigationPathQueryParameters2D_set_start_position :: (using self: *NavigationPathQueryParameters2D, start_position: Vector2) {
}
NavigationPathQueryParameters2D_get_start_position :: (using self: *NavigationPathQueryParameters2D) -> Vector2 {
}
NavigationPathQueryParameters2D_set_target_position :: (using self: *NavigationPathQueryParameters2D, target_position: Vector2) {
}
NavigationPathQueryParameters2D_get_target_position :: (using self: *NavigationPathQueryParameters2D) -> Vector2 {
}
NavigationPathQueryParameters2D_set_navigation_layers :: (using self: *NavigationPathQueryParameters2D, navigation_layers: int) {
}
NavigationPathQueryParameters2D_get_navigation_layers :: (using self: *NavigationPathQueryParameters2D) -> int {
}
NavigationPathQueryParameters2D_set_metadata_flags :: (using self: *NavigationPathQueryParameters2D, flags: NavigationPathQueryParameters2D.PathMetadataFlags) {
}
NavigationPathQueryParameters2D_get_metadata_flags :: (using self: *NavigationPathQueryParameters2D) -> NavigationPathQueryParameters2D.PathMetadataFlags {
}
NavigationPathQueryParameters2D_set_simplify_path :: (using self: *NavigationPathQueryParameters2D, enabled: bool) {
}
NavigationPathQueryParameters2D_get_simplify_path :: (using self: *NavigationPathQueryParameters2D) -> bool {
}
NavigationPathQueryParameters2D_set_simplify_epsilon :: (using self: *NavigationPathQueryParameters2D, epsilon: float) {
}
NavigationPathQueryParameters2D_get_simplify_epsilon :: (using self: *NavigationPathQueryParameters2D) -> float {
}

// NavigationPathQueryParameters3D
NavigationPathQueryParameters3D :: struct {
	__private: *void;

	PathfindingAlgorithm :: enum {
		PATHFINDING_ALGORITHM_ASTAR :: 0;
	}
	PathPostProcessing :: enum {
		PATH_POSTPROCESSING_CORRIDORFUNNEL :: 0;
		PATH_POSTPROCESSING_EDGECENTERED :: 1;
	}
	PathMetadataFlags :: enum_flags {
		PATH_METADATA_INCLUDE_NONE :: 0;
		PATH_METADATA_INCLUDE_TYPES :: 1;
		PATH_METADATA_INCLUDE_RIDS :: 2;
		PATH_METADATA_INCLUDE_OWNERS :: 4;
		PATH_METADATA_INCLUDE_ALL :: 7;
	}
}

NavigationPathQueryParameters3D_set_pathfinding_algorithm :: (using self: *NavigationPathQueryParameters3D, pathfinding_algorithm: NavigationPathQueryParameters3D.PathfindingAlgorithm) {
}
NavigationPathQueryParameters3D_get_pathfinding_algorithm :: (using self: *NavigationPathQueryParameters3D) -> NavigationPathQueryParameters3D.PathfindingAlgorithm {
}
NavigationPathQueryParameters3D_set_path_postprocessing :: (using self: *NavigationPathQueryParameters3D, path_postprocessing: NavigationPathQueryParameters3D.PathPostProcessing) {
}
NavigationPathQueryParameters3D_get_path_postprocessing :: (using self: *NavigationPathQueryParameters3D) -> NavigationPathQueryParameters3D.PathPostProcessing {
}
NavigationPathQueryParameters3D_set_map :: (using self: *NavigationPathQueryParameters3D, map: RID) {
}
NavigationPathQueryParameters3D_get_map :: (using self: *NavigationPathQueryParameters3D) -> RID {
}
NavigationPathQueryParameters3D_set_start_position :: (using self: *NavigationPathQueryParameters3D, start_position: Vector3) {
}
NavigationPathQueryParameters3D_get_start_position :: (using self: *NavigationPathQueryParameters3D) -> Vector3 {
}
NavigationPathQueryParameters3D_set_target_position :: (using self: *NavigationPathQueryParameters3D, target_position: Vector3) {
}
NavigationPathQueryParameters3D_get_target_position :: (using self: *NavigationPathQueryParameters3D) -> Vector3 {
}
NavigationPathQueryParameters3D_set_navigation_layers :: (using self: *NavigationPathQueryParameters3D, navigation_layers: int) {
}
NavigationPathQueryParameters3D_get_navigation_layers :: (using self: *NavigationPathQueryParameters3D) -> int {
}
NavigationPathQueryParameters3D_set_metadata_flags :: (using self: *NavigationPathQueryParameters3D, flags: NavigationPathQueryParameters3D.PathMetadataFlags) {
}
NavigationPathQueryParameters3D_get_metadata_flags :: (using self: *NavigationPathQueryParameters3D) -> NavigationPathQueryParameters3D.PathMetadataFlags {
}
NavigationPathQueryParameters3D_set_simplify_path :: (using self: *NavigationPathQueryParameters3D, enabled: bool) {
}
NavigationPathQueryParameters3D_get_simplify_path :: (using self: *NavigationPathQueryParameters3D) -> bool {
}
NavigationPathQueryParameters3D_set_simplify_epsilon :: (using self: *NavigationPathQueryParameters3D, epsilon: float) {
}
NavigationPathQueryParameters3D_get_simplify_epsilon :: (using self: *NavigationPathQueryParameters3D) -> float {
}

// NavigationPathQueryResult2D
NavigationPathQueryResult2D :: struct {
	__private: *void;

	PathSegmentType :: enum {
		PATH_SEGMENT_TYPE_REGION :: 0;
		PATH_SEGMENT_TYPE_LINK :: 1;
	}
}

NavigationPathQueryResult2D_set_path :: (using self: *NavigationPathQueryResult2D, path: PackedVector2Array) {
}
NavigationPathQueryResult2D_get_path :: (using self: *NavigationPathQueryResult2D) -> PackedVector2Array {
}
NavigationPathQueryResult2D_set_path_types :: (using self: *NavigationPathQueryResult2D, path_types: PackedInt32Array) {
}
NavigationPathQueryResult2D_get_path_types :: (using self: *NavigationPathQueryResult2D) -> PackedInt32Array {
}
NavigationPathQueryResult2D_set_path_rids :: (using self: *NavigationPathQueryResult2D, path_rids: Array) {
}
NavigationPathQueryResult2D_get_path_rids :: (using self: *NavigationPathQueryResult2D) -> Array {
}
NavigationPathQueryResult2D_set_path_owner_ids :: (using self: *NavigationPathQueryResult2D, path_owner_ids: PackedInt64Array) {
}
NavigationPathQueryResult2D_get_path_owner_ids :: (using self: *NavigationPathQueryResult2D) -> PackedInt64Array {
}
NavigationPathQueryResult2D_reset :: (using self: *NavigationPathQueryResult2D) {
}

// NavigationPathQueryResult3D
NavigationPathQueryResult3D :: struct {
	__private: *void;

	PathSegmentType :: enum {
		PATH_SEGMENT_TYPE_REGION :: 0;
		PATH_SEGMENT_TYPE_LINK :: 1;
	}
}

NavigationPathQueryResult3D_set_path :: (using self: *NavigationPathQueryResult3D, path: PackedVector3Array) {
}
NavigationPathQueryResult3D_get_path :: (using self: *NavigationPathQueryResult3D) -> PackedVector3Array {
}
NavigationPathQueryResult3D_set_path_types :: (using self: *NavigationPathQueryResult3D, path_types: PackedInt32Array) {
}
NavigationPathQueryResult3D_get_path_types :: (using self: *NavigationPathQueryResult3D) -> PackedInt32Array {
}
NavigationPathQueryResult3D_set_path_rids :: (using self: *NavigationPathQueryResult3D, path_rids: Array) {
}
NavigationPathQueryResult3D_get_path_rids :: (using self: *NavigationPathQueryResult3D) -> Array {
}
NavigationPathQueryResult3D_set_path_owner_ids :: (using self: *NavigationPathQueryResult3D, path_owner_ids: PackedInt64Array) {
}
NavigationPathQueryResult3D_get_path_owner_ids :: (using self: *NavigationPathQueryResult3D) -> PackedInt64Array {
}
NavigationPathQueryResult3D_reset :: (using self: *NavigationPathQueryResult3D) {
}

// NavigationPolygon
NavigationPolygon :: struct {
	__private: *void;

	ParsedGeometryType :: enum {
		PARSED_GEOMETRY_MESH_INSTANCES :: 0;
		PARSED_GEOMETRY_STATIC_COLLIDERS :: 1;
		PARSED_GEOMETRY_BOTH :: 2;
		PARSED_GEOMETRY_MAX :: 3;
	}
	SourceGeometryMode :: enum {
		SOURCE_GEOMETRY_ROOT_NODE_CHILDREN :: 0;
		SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN :: 1;
		SOURCE_GEOMETRY_GROUPS_EXPLICIT :: 2;
		SOURCE_GEOMETRY_MAX :: 3;
	}
}

NavigationPolygon_set_vertices :: (using self: *NavigationPolygon, vertices: PackedVector2Array) {
}
NavigationPolygon_get_vertices :: (using self: *NavigationPolygon) -> PackedVector2Array {
}
NavigationPolygon_add_polygon :: (using self: *NavigationPolygon, polygon: PackedInt32Array) {
}
NavigationPolygon_get_polygon_count :: (using self: *NavigationPolygon) -> int {
}
NavigationPolygon_get_polygon :: (using self: *NavigationPolygon, idx: int) -> PackedInt32Array {
}
NavigationPolygon_clear_polygons :: (using self: *NavigationPolygon) {
}
NavigationPolygon_get_navigation_mesh :: (using self: *NavigationPolygon) -> NavigationMesh {
}
NavigationPolygon_add_outline :: (using self: *NavigationPolygon, outline: PackedVector2Array) {
}
NavigationPolygon_add_outline_at_index :: (using self: *NavigationPolygon, outline: PackedVector2Array, index: int) {
}
NavigationPolygon_get_outline_count :: (using self: *NavigationPolygon) -> int {
}
NavigationPolygon_set_outline :: (using self: *NavigationPolygon, idx: int, outline: PackedVector2Array) {
}
NavigationPolygon_get_outline :: (using self: *NavigationPolygon, idx: int) -> PackedVector2Array {
}
NavigationPolygon_remove_outline :: (using self: *NavigationPolygon, idx: int) {
}
NavigationPolygon_clear_outlines :: (using self: *NavigationPolygon) {
}
NavigationPolygon_make_polygons_from_outlines :: (using self: *NavigationPolygon) {
}
NavigationPolygon_set_cell_size :: (using self: *NavigationPolygon, cell_size: float) {
}
NavigationPolygon_get_cell_size :: (using self: *NavigationPolygon) -> float {
}
NavigationPolygon_set_border_size :: (using self: *NavigationPolygon, border_size: float) {
}
NavigationPolygon_get_border_size :: (using self: *NavigationPolygon) -> float {
}
NavigationPolygon_set_parsed_geometry_type :: (using self: *NavigationPolygon, geometry_type: NavigationPolygon.ParsedGeometryType) {
}
NavigationPolygon_get_parsed_geometry_type :: (using self: *NavigationPolygon) -> NavigationPolygon.ParsedGeometryType {
}
NavigationPolygon_set_parsed_collision_mask :: (using self: *NavigationPolygon, mask: int) {
}
NavigationPolygon_get_parsed_collision_mask :: (using self: *NavigationPolygon) -> int {
}
NavigationPolygon_set_parsed_collision_mask_value :: (using self: *NavigationPolygon, layer_number: int, value: bool) {
}
NavigationPolygon_get_parsed_collision_mask_value :: (using self: *NavigationPolygon, layer_number: int) -> bool {
}
NavigationPolygon_set_source_geometry_mode :: (using self: *NavigationPolygon, geometry_mode: NavigationPolygon.SourceGeometryMode) {
}
NavigationPolygon_get_source_geometry_mode :: (using self: *NavigationPolygon) -> NavigationPolygon.SourceGeometryMode {
}
NavigationPolygon_set_source_geometry_group_name :: (using self: *NavigationPolygon, group_name: StringName) {
}
NavigationPolygon_get_source_geometry_group_name :: (using self: *NavigationPolygon) -> StringName {
}
NavigationPolygon_set_agent_radius :: (using self: *NavigationPolygon, agent_radius: float) {
}
NavigationPolygon_get_agent_radius :: (using self: *NavigationPolygon) -> float {
}
NavigationPolygon_set_baking_rect :: (using self: *NavigationPolygon, rect: Rect2) {
}
NavigationPolygon_get_baking_rect :: (using self: *NavigationPolygon) -> Rect2 {
}
NavigationPolygon_set_baking_rect_offset :: (using self: *NavigationPolygon, rect_offset: Vector2) {
}
NavigationPolygon_get_baking_rect_offset :: (using self: *NavigationPolygon) -> Vector2 {
}
NavigationPolygon_clear :: (using self: *NavigationPolygon) {
}

// NavigationRegion2D
NavigationRegion2D :: struct {
	__private: *void;
}

NavigationRegion2D_get_rid :: (using self: *NavigationRegion2D) -> RID {
}
NavigationRegion2D_set_navigation_polygon :: (using self: *NavigationRegion2D, navigation_polygon: NavigationPolygon) {
}
NavigationRegion2D_get_navigation_polygon :: (using self: *NavigationRegion2D) -> NavigationPolygon {
}
NavigationRegion2D_set_enabled :: (using self: *NavigationRegion2D, enabled: bool) {
}
NavigationRegion2D_is_enabled :: (using self: *NavigationRegion2D) -> bool {
}
NavigationRegion2D_set_navigation_map :: (using self: *NavigationRegion2D, navigation_map: RID) {
}
NavigationRegion2D_get_navigation_map :: (using self: *NavigationRegion2D) -> RID {
}
NavigationRegion2D_set_use_edge_connections :: (using self: *NavigationRegion2D, enabled: bool) {
}
NavigationRegion2D_get_use_edge_connections :: (using self: *NavigationRegion2D) -> bool {
}
NavigationRegion2D_set_navigation_layers :: (using self: *NavigationRegion2D, navigation_layers: int) {
}
NavigationRegion2D_get_navigation_layers :: (using self: *NavigationRegion2D) -> int {
}
NavigationRegion2D_set_navigation_layer_value :: (using self: *NavigationRegion2D, layer_number: int, value: bool) {
}
NavigationRegion2D_get_navigation_layer_value :: (using self: *NavigationRegion2D, layer_number: int) -> bool {
}
NavigationRegion2D_get_region_rid :: (using self: *NavigationRegion2D) -> RID {
}
NavigationRegion2D_set_enter_cost :: (using self: *NavigationRegion2D, enter_cost: float) {
}
NavigationRegion2D_get_enter_cost :: (using self: *NavigationRegion2D) -> float {
}
NavigationRegion2D_set_travel_cost :: (using self: *NavigationRegion2D, travel_cost: float) {
}
NavigationRegion2D_get_travel_cost :: (using self: *NavigationRegion2D) -> float {
}
NavigationRegion2D_bake_navigation_polygon :: (using self: *NavigationRegion2D, on_thread: bool) {
}
NavigationRegion2D_is_baking :: (using self: *NavigationRegion2D) -> bool {
}

// NavigationRegion3D
NavigationRegion3D :: struct {
	__private: *void;
}

NavigationRegion3D_get_rid :: (using self: *NavigationRegion3D) -> RID {
}
NavigationRegion3D_set_navigation_mesh :: (using self: *NavigationRegion3D, navigation_mesh: NavigationMesh) {
}
NavigationRegion3D_get_navigation_mesh :: (using self: *NavigationRegion3D) -> NavigationMesh {
}
NavigationRegion3D_set_enabled :: (using self: *NavigationRegion3D, enabled: bool) {
}
NavigationRegion3D_is_enabled :: (using self: *NavigationRegion3D) -> bool {
}
NavigationRegion3D_set_navigation_map :: (using self: *NavigationRegion3D, navigation_map: RID) {
}
NavigationRegion3D_get_navigation_map :: (using self: *NavigationRegion3D) -> RID {
}
NavigationRegion3D_set_use_edge_connections :: (using self: *NavigationRegion3D, enabled: bool) {
}
NavigationRegion3D_get_use_edge_connections :: (using self: *NavigationRegion3D) -> bool {
}
NavigationRegion3D_set_navigation_layers :: (using self: *NavigationRegion3D, navigation_layers: int) {
}
NavigationRegion3D_get_navigation_layers :: (using self: *NavigationRegion3D) -> int {
}
NavigationRegion3D_set_navigation_layer_value :: (using self: *NavigationRegion3D, layer_number: int, value: bool) {
}
NavigationRegion3D_get_navigation_layer_value :: (using self: *NavigationRegion3D, layer_number: int) -> bool {
}
NavigationRegion3D_get_region_rid :: (using self: *NavigationRegion3D) -> RID {
}
NavigationRegion3D_set_enter_cost :: (using self: *NavigationRegion3D, enter_cost: float) {
}
NavigationRegion3D_get_enter_cost :: (using self: *NavigationRegion3D) -> float {
}
NavigationRegion3D_set_travel_cost :: (using self: *NavigationRegion3D, travel_cost: float) {
}
NavigationRegion3D_get_travel_cost :: (using self: *NavigationRegion3D) -> float {
}
NavigationRegion3D_bake_navigation_mesh :: (using self: *NavigationRegion3D, on_thread: bool) {
}
NavigationRegion3D_is_baking :: (using self: *NavigationRegion3D) -> bool {
}

// NavigationServer2D
NavigationServer2D :: struct {
	__private: *void;
}

NavigationServer2D_get_maps :: (using self: *NavigationServer2D) -> Array {
}
NavigationServer2D_map_create :: (using self: *NavigationServer2D) -> RID {
}
NavigationServer2D_map_set_active :: (using self: *NavigationServer2D, map: RID, active: bool) {
}
NavigationServer2D_map_is_active :: (using self: *NavigationServer2D, map: RID) -> bool {
}
NavigationServer2D_map_set_cell_size :: (using self: *NavigationServer2D, map: RID, cell_size: float) {
}
NavigationServer2D_map_get_cell_size :: (using self: *NavigationServer2D, map: RID) -> float {
}
NavigationServer2D_map_set_use_edge_connections :: (using self: *NavigationServer2D, map: RID, enabled: bool) {
}
NavigationServer2D_map_get_use_edge_connections :: (using self: *NavigationServer2D, map: RID) -> bool {
}
NavigationServer2D_map_set_edge_connection_margin :: (using self: *NavigationServer2D, map: RID, margin: float) {
}
NavigationServer2D_map_get_edge_connection_margin :: (using self: *NavigationServer2D, map: RID) -> float {
}
NavigationServer2D_map_set_link_connection_radius :: (using self: *NavigationServer2D, map: RID, radius: float) {
}
NavigationServer2D_map_get_link_connection_radius :: (using self: *NavigationServer2D, map: RID) -> float {
}
NavigationServer2D_map_get_path :: (using self: *NavigationServer2D, map: RID, origin: Vector2, destination: Vector2, optimize: bool, navigation_layers: int) -> PackedVector2Array {
}
NavigationServer2D_map_get_closest_point :: (using self: *NavigationServer2D, map: RID, to_point: Vector2) -> Vector2 {
}
NavigationServer2D_map_get_closest_point_owner :: (using self: *NavigationServer2D, map: RID, to_point: Vector2) -> RID {
}
NavigationServer2D_map_get_links :: (using self: *NavigationServer2D, map: RID) -> Array {
}
NavigationServer2D_map_get_regions :: (using self: *NavigationServer2D, map: RID) -> Array {
}
NavigationServer2D_map_get_agents :: (using self: *NavigationServer2D, map: RID) -> Array {
}
NavigationServer2D_map_get_obstacles :: (using self: *NavigationServer2D, map: RID) -> Array {
}
NavigationServer2D_map_force_update :: (using self: *NavigationServer2D, map: RID) {
}
NavigationServer2D_map_get_iteration_id :: (using self: *NavigationServer2D, map: RID) -> int {
}
NavigationServer2D_map_get_random_point :: (using self: *NavigationServer2D, map: RID, navigation_layers: int, uniformly: bool) -> Vector2 {
}
NavigationServer2D_query_path :: (using self: *NavigationServer2D, parameters: NavigationPathQueryParameters2D, result: NavigationPathQueryResult2D) {
}
NavigationServer2D_region_create :: (using self: *NavigationServer2D) -> RID {
}
NavigationServer2D_region_set_enabled :: (using self: *NavigationServer2D, region: RID, enabled: bool) {
}
NavigationServer2D_region_get_enabled :: (using self: *NavigationServer2D, region: RID) -> bool {
}
NavigationServer2D_region_set_use_edge_connections :: (using self: *NavigationServer2D, region: RID, enabled: bool) {
}
NavigationServer2D_region_get_use_edge_connections :: (using self: *NavigationServer2D, region: RID) -> bool {
}
NavigationServer2D_region_set_enter_cost :: (using self: *NavigationServer2D, region: RID, enter_cost: float) {
}
NavigationServer2D_region_get_enter_cost :: (using self: *NavigationServer2D, region: RID) -> float {
}
NavigationServer2D_region_set_travel_cost :: (using self: *NavigationServer2D, region: RID, travel_cost: float) {
}
NavigationServer2D_region_get_travel_cost :: (using self: *NavigationServer2D, region: RID) -> float {
}
NavigationServer2D_region_set_owner_id :: (using self: *NavigationServer2D, region: RID, owner_id: int) {
}
NavigationServer2D_region_get_owner_id :: (using self: *NavigationServer2D, region: RID) -> int {
}
NavigationServer2D_region_owns_point :: (using self: *NavigationServer2D, region: RID, point: Vector2) -> bool {
}
NavigationServer2D_region_set_map :: (using self: *NavigationServer2D, region: RID, map: RID) {
}
NavigationServer2D_region_get_map :: (using self: *NavigationServer2D, region: RID) -> RID {
}
NavigationServer2D_region_set_navigation_layers :: (using self: *NavigationServer2D, region: RID, navigation_layers: int) {
}
NavigationServer2D_region_get_navigation_layers :: (using self: *NavigationServer2D, region: RID) -> int {
}
NavigationServer2D_region_set_transform :: (using self: *NavigationServer2D, region: RID, transform: Transform2D) {
}
NavigationServer2D_region_get_transform :: (using self: *NavigationServer2D, region: RID) -> Transform2D {
}
NavigationServer2D_region_set_navigation_polygon :: (using self: *NavigationServer2D, region: RID, navigation_polygon: NavigationPolygon) {
}
NavigationServer2D_region_get_connections_count :: (using self: *NavigationServer2D, region: RID) -> int {
}
NavigationServer2D_region_get_connection_pathway_start :: (using self: *NavigationServer2D, region: RID, connection: int) -> Vector2 {
}
NavigationServer2D_region_get_connection_pathway_end :: (using self: *NavigationServer2D, region: RID, connection: int) -> Vector2 {
}
NavigationServer2D_region_get_random_point :: (using self: *NavigationServer2D, region: RID, navigation_layers: int, uniformly: bool) -> Vector2 {
}
NavigationServer2D_link_create :: (using self: *NavigationServer2D) -> RID {
}
NavigationServer2D_link_set_map :: (using self: *NavigationServer2D, link: RID, map: RID) {
}
NavigationServer2D_link_get_map :: (using self: *NavigationServer2D, link: RID) -> RID {
}
NavigationServer2D_link_set_enabled :: (using self: *NavigationServer2D, link: RID, enabled: bool) {
}
NavigationServer2D_link_get_enabled :: (using self: *NavigationServer2D, link: RID) -> bool {
}
NavigationServer2D_link_set_bidirectional :: (using self: *NavigationServer2D, link: RID, bidirectional: bool) {
}
NavigationServer2D_link_is_bidirectional :: (using self: *NavigationServer2D, link: RID) -> bool {
}
NavigationServer2D_link_set_navigation_layers :: (using self: *NavigationServer2D, link: RID, navigation_layers: int) {
}
NavigationServer2D_link_get_navigation_layers :: (using self: *NavigationServer2D, link: RID) -> int {
}
NavigationServer2D_link_set_start_position :: (using self: *NavigationServer2D, link: RID, position: Vector2) {
}
NavigationServer2D_link_get_start_position :: (using self: *NavigationServer2D, link: RID) -> Vector2 {
}
NavigationServer2D_link_set_end_position :: (using self: *NavigationServer2D, link: RID, position: Vector2) {
}
NavigationServer2D_link_get_end_position :: (using self: *NavigationServer2D, link: RID) -> Vector2 {
}
NavigationServer2D_link_set_enter_cost :: (using self: *NavigationServer2D, link: RID, enter_cost: float) {
}
NavigationServer2D_link_get_enter_cost :: (using self: *NavigationServer2D, link: RID) -> float {
}
NavigationServer2D_link_set_travel_cost :: (using self: *NavigationServer2D, link: RID, travel_cost: float) {
}
NavigationServer2D_link_get_travel_cost :: (using self: *NavigationServer2D, link: RID) -> float {
}
NavigationServer2D_link_set_owner_id :: (using self: *NavigationServer2D, link: RID, owner_id: int) {
}
NavigationServer2D_link_get_owner_id :: (using self: *NavigationServer2D, link: RID) -> int {
}
NavigationServer2D_agent_create :: (using self: *NavigationServer2D) -> RID {
}
NavigationServer2D_agent_set_avoidance_enabled :: (using self: *NavigationServer2D, agent: RID, enabled: bool) {
}
NavigationServer2D_agent_get_avoidance_enabled :: (using self: *NavigationServer2D, agent: RID) -> bool {
}
NavigationServer2D_agent_set_map :: (using self: *NavigationServer2D, agent: RID, map: RID) {
}
NavigationServer2D_agent_get_map :: (using self: *NavigationServer2D, agent: RID) -> RID {
}
NavigationServer2D_agent_set_paused :: (using self: *NavigationServer2D, agent: RID, paused: bool) {
}
NavigationServer2D_agent_get_paused :: (using self: *NavigationServer2D, agent: RID) -> bool {
}
NavigationServer2D_agent_set_neighbor_distance :: (using self: *NavigationServer2D, agent: RID, distance: float) {
}
NavigationServer2D_agent_get_neighbor_distance :: (using self: *NavigationServer2D, agent: RID) -> float {
}
NavigationServer2D_agent_set_max_neighbors :: (using self: *NavigationServer2D, agent: RID, count: int) {
}
NavigationServer2D_agent_get_max_neighbors :: (using self: *NavigationServer2D, agent: RID) -> int {
}
NavigationServer2D_agent_set_time_horizon_agents :: (using self: *NavigationServer2D, agent: RID, time_horizon: float) {
}
NavigationServer2D_agent_get_time_horizon_agents :: (using self: *NavigationServer2D, agent: RID) -> float {
}
NavigationServer2D_agent_set_time_horizon_obstacles :: (using self: *NavigationServer2D, agent: RID, time_horizon: float) {
}
NavigationServer2D_agent_get_time_horizon_obstacles :: (using self: *NavigationServer2D, agent: RID) -> float {
}
NavigationServer2D_agent_set_radius :: (using self: *NavigationServer2D, agent: RID, radius: float) {
}
NavigationServer2D_agent_get_radius :: (using self: *NavigationServer2D, agent: RID) -> float {
}
NavigationServer2D_agent_set_max_speed :: (using self: *NavigationServer2D, agent: RID, max_speed: float) {
}
NavigationServer2D_agent_get_max_speed :: (using self: *NavigationServer2D, agent: RID) -> float {
}
NavigationServer2D_agent_set_velocity_forced :: (using self: *NavigationServer2D, agent: RID, velocity: Vector2) {
}
NavigationServer2D_agent_set_velocity :: (using self: *NavigationServer2D, agent: RID, velocity: Vector2) {
}
NavigationServer2D_agent_get_velocity :: (using self: *NavigationServer2D, agent: RID) -> Vector2 {
}
NavigationServer2D_agent_set_position :: (using self: *NavigationServer2D, agent: RID, position: Vector2) {
}
NavigationServer2D_agent_get_position :: (using self: *NavigationServer2D, agent: RID) -> Vector2 {
}
NavigationServer2D_agent_is_map_changed :: (using self: *NavigationServer2D, agent: RID) -> bool {
}
NavigationServer2D_agent_set_avoidance_callback :: (using self: *NavigationServer2D, agent: RID, callback: Callable) {
}
NavigationServer2D_agent_has_avoidance_callback :: (using self: *NavigationServer2D, agent: RID) -> bool {
}
NavigationServer2D_agent_set_avoidance_layers :: (using self: *NavigationServer2D, agent: RID, layers: int) {
}
NavigationServer2D_agent_get_avoidance_layers :: (using self: *NavigationServer2D, agent: RID) -> int {
}
NavigationServer2D_agent_set_avoidance_mask :: (using self: *NavigationServer2D, agent: RID, mask: int) {
}
NavigationServer2D_agent_get_avoidance_mask :: (using self: *NavigationServer2D, agent: RID) -> int {
}
NavigationServer2D_agent_set_avoidance_priority :: (using self: *NavigationServer2D, agent: RID, priority: float) {
}
NavigationServer2D_agent_get_avoidance_priority :: (using self: *NavigationServer2D, agent: RID) -> float {
}
NavigationServer2D_obstacle_create :: (using self: *NavigationServer2D) -> RID {
}
NavigationServer2D_obstacle_set_avoidance_enabled :: (using self: *NavigationServer2D, obstacle: RID, enabled: bool) {
}
NavigationServer2D_obstacle_get_avoidance_enabled :: (using self: *NavigationServer2D, obstacle: RID) -> bool {
}
NavigationServer2D_obstacle_set_map :: (using self: *NavigationServer2D, obstacle: RID, map: RID) {
}
NavigationServer2D_obstacle_get_map :: (using self: *NavigationServer2D, obstacle: RID) -> RID {
}
NavigationServer2D_obstacle_set_paused :: (using self: *NavigationServer2D, obstacle: RID, paused: bool) {
}
NavigationServer2D_obstacle_get_paused :: (using self: *NavigationServer2D, obstacle: RID) -> bool {
}
NavigationServer2D_obstacle_set_radius :: (using self: *NavigationServer2D, obstacle: RID, radius: float) {
}
NavigationServer2D_obstacle_get_radius :: (using self: *NavigationServer2D, obstacle: RID) -> float {
}
NavigationServer2D_obstacle_set_velocity :: (using self: *NavigationServer2D, obstacle: RID, velocity: Vector2) {
}
NavigationServer2D_obstacle_get_velocity :: (using self: *NavigationServer2D, obstacle: RID) -> Vector2 {
}
NavigationServer2D_obstacle_set_position :: (using self: *NavigationServer2D, obstacle: RID, position: Vector2) {
}
NavigationServer2D_obstacle_get_position :: (using self: *NavigationServer2D, obstacle: RID) -> Vector2 {
}
NavigationServer2D_obstacle_set_vertices :: (using self: *NavigationServer2D, obstacle: RID, vertices: PackedVector2Array) {
}
NavigationServer2D_obstacle_get_vertices :: (using self: *NavigationServer2D, obstacle: RID) -> PackedVector2Array {
}
NavigationServer2D_obstacle_set_avoidance_layers :: (using self: *NavigationServer2D, obstacle: RID, layers: int) {
}
NavigationServer2D_obstacle_get_avoidance_layers :: (using self: *NavigationServer2D, obstacle: RID) -> int {
}
NavigationServer2D_parse_source_geometry_data :: (using self: *NavigationServer2D, navigation_polygon: NavigationPolygon, source_geometry_data: NavigationMeshSourceGeometryData2D, root_node: Node, callback: Callable) {
}
NavigationServer2D_bake_from_source_geometry_data :: (using self: *NavigationServer2D, navigation_polygon: NavigationPolygon, source_geometry_data: NavigationMeshSourceGeometryData2D, callback: Callable) {
}
NavigationServer2D_bake_from_source_geometry_data_async :: (using self: *NavigationServer2D, navigation_polygon: NavigationPolygon, source_geometry_data: NavigationMeshSourceGeometryData2D, callback: Callable) {
}
NavigationServer2D_is_baking_navigation_polygon :: (using self: *NavigationServer2D, navigation_polygon: NavigationPolygon) -> bool {
}
NavigationServer2D_source_geometry_parser_create :: (using self: *NavigationServer2D) -> RID {
}
NavigationServer2D_source_geometry_parser_set_callback :: (using self: *NavigationServer2D, parser: RID, callback: Callable) {
}
NavigationServer2D_simplify_path :: (using self: *NavigationServer2D, path: PackedVector2Array, epsilon: float) -> PackedVector2Array {
}
NavigationServer2D_free_rid :: (using self: *NavigationServer2D, rid: RID) {
}
NavigationServer2D_set_debug_enabled :: (using self: *NavigationServer2D, enabled: bool) {
}
NavigationServer2D_get_debug_enabled :: (using self: *NavigationServer2D) -> bool {
}

// NavigationServer3D
NavigationServer3D :: struct {
	__private: *void;

	ProcessInfo :: enum {
		INFO_ACTIVE_MAPS :: 0;
		INFO_REGION_COUNT :: 1;
		INFO_AGENT_COUNT :: 2;
		INFO_LINK_COUNT :: 3;
		INFO_POLYGON_COUNT :: 4;
		INFO_EDGE_COUNT :: 5;
		INFO_EDGE_MERGE_COUNT :: 6;
		INFO_EDGE_CONNECTION_COUNT :: 7;
		INFO_EDGE_FREE_COUNT :: 8;
	}
}

NavigationServer3D_get_maps :: (using self: *NavigationServer3D) -> Array {
}
NavigationServer3D_map_create :: (using self: *NavigationServer3D) -> RID {
}
NavigationServer3D_map_set_active :: (using self: *NavigationServer3D, map: RID, active: bool) {
}
NavigationServer3D_map_is_active :: (using self: *NavigationServer3D, map: RID) -> bool {
}
NavigationServer3D_map_set_up :: (using self: *NavigationServer3D, map: RID, up: Vector3) {
}
NavigationServer3D_map_get_up :: (using self: *NavigationServer3D, map: RID) -> Vector3 {
}
NavigationServer3D_map_set_cell_size :: (using self: *NavigationServer3D, map: RID, cell_size: float) {
}
NavigationServer3D_map_get_cell_size :: (using self: *NavigationServer3D, map: RID) -> float {
}
NavigationServer3D_map_set_cell_height :: (using self: *NavigationServer3D, map: RID, cell_height: float) {
}
NavigationServer3D_map_get_cell_height :: (using self: *NavigationServer3D, map: RID) -> float {
}
NavigationServer3D_map_set_merge_rasterizer_cell_scale :: (using self: *NavigationServer3D, map: RID, scale: float) {
}
NavigationServer3D_map_get_merge_rasterizer_cell_scale :: (using self: *NavigationServer3D, map: RID) -> float {
}
NavigationServer3D_map_set_use_edge_connections :: (using self: *NavigationServer3D, map: RID, enabled: bool) {
}
NavigationServer3D_map_get_use_edge_connections :: (using self: *NavigationServer3D, map: RID) -> bool {
}
NavigationServer3D_map_set_edge_connection_margin :: (using self: *NavigationServer3D, map: RID, margin: float) {
}
NavigationServer3D_map_get_edge_connection_margin :: (using self: *NavigationServer3D, map: RID) -> float {
}
NavigationServer3D_map_set_link_connection_radius :: (using self: *NavigationServer3D, map: RID, radius: float) {
}
NavigationServer3D_map_get_link_connection_radius :: (using self: *NavigationServer3D, map: RID) -> float {
}
NavigationServer3D_map_get_path :: (using self: *NavigationServer3D, map: RID, origin: Vector3, destination: Vector3, optimize: bool, navigation_layers: int) -> PackedVector3Array {
}
NavigationServer3D_map_get_closest_point_to_segment :: (using self: *NavigationServer3D, map: RID, start: Vector3, end: Vector3, use_collision: bool) -> Vector3 {
}
NavigationServer3D_map_get_closest_point :: (using self: *NavigationServer3D, map: RID, to_point: Vector3) -> Vector3 {
}
NavigationServer3D_map_get_closest_point_normal :: (using self: *NavigationServer3D, map: RID, to_point: Vector3) -> Vector3 {
}
NavigationServer3D_map_get_closest_point_owner :: (using self: *NavigationServer3D, map: RID, to_point: Vector3) -> RID {
}
NavigationServer3D_map_get_links :: (using self: *NavigationServer3D, map: RID) -> Array {
}
NavigationServer3D_map_get_regions :: (using self: *NavigationServer3D, map: RID) -> Array {
}
NavigationServer3D_map_get_agents :: (using self: *NavigationServer3D, map: RID) -> Array {
}
NavigationServer3D_map_get_obstacles :: (using self: *NavigationServer3D, map: RID) -> Array {
}
NavigationServer3D_map_force_update :: (using self: *NavigationServer3D, map: RID) {
}
NavigationServer3D_map_get_iteration_id :: (using self: *NavigationServer3D, map: RID) -> int {
}
NavigationServer3D_map_get_random_point :: (using self: *NavigationServer3D, map: RID, navigation_layers: int, uniformly: bool) -> Vector3 {
}
NavigationServer3D_query_path :: (using self: *NavigationServer3D, parameters: NavigationPathQueryParameters3D, result: NavigationPathQueryResult3D) {
}
NavigationServer3D_region_create :: (using self: *NavigationServer3D) -> RID {
}
NavigationServer3D_region_set_enabled :: (using self: *NavigationServer3D, region: RID, enabled: bool) {
}
NavigationServer3D_region_get_enabled :: (using self: *NavigationServer3D, region: RID) -> bool {
}
NavigationServer3D_region_set_use_edge_connections :: (using self: *NavigationServer3D, region: RID, enabled: bool) {
}
NavigationServer3D_region_get_use_edge_connections :: (using self: *NavigationServer3D, region: RID) -> bool {
}
NavigationServer3D_region_set_enter_cost :: (using self: *NavigationServer3D, region: RID, enter_cost: float) {
}
NavigationServer3D_region_get_enter_cost :: (using self: *NavigationServer3D, region: RID) -> float {
}
NavigationServer3D_region_set_travel_cost :: (using self: *NavigationServer3D, region: RID, travel_cost: float) {
}
NavigationServer3D_region_get_travel_cost :: (using self: *NavigationServer3D, region: RID) -> float {
}
NavigationServer3D_region_set_owner_id :: (using self: *NavigationServer3D, region: RID, owner_id: int) {
}
NavigationServer3D_region_get_owner_id :: (using self: *NavigationServer3D, region: RID) -> int {
}
NavigationServer3D_region_owns_point :: (using self: *NavigationServer3D, region: RID, point: Vector3) -> bool {
}
NavigationServer3D_region_set_map :: (using self: *NavigationServer3D, region: RID, map: RID) {
}
NavigationServer3D_region_get_map :: (using self: *NavigationServer3D, region: RID) -> RID {
}
NavigationServer3D_region_set_navigation_layers :: (using self: *NavigationServer3D, region: RID, navigation_layers: int) {
}
NavigationServer3D_region_get_navigation_layers :: (using self: *NavigationServer3D, region: RID) -> int {
}
NavigationServer3D_region_set_transform :: (using self: *NavigationServer3D, region: RID, transform: Transform3D) {
}
NavigationServer3D_region_get_transform :: (using self: *NavigationServer3D, region: RID) -> Transform3D {
}
NavigationServer3D_region_set_navigation_mesh :: (using self: *NavigationServer3D, region: RID, navigation_mesh: NavigationMesh) {
}
NavigationServer3D_region_bake_navigation_mesh :: (using self: *NavigationServer3D, navigation_mesh: NavigationMesh, root_node: Node) {
}
NavigationServer3D_region_get_connections_count :: (using self: *NavigationServer3D, region: RID) -> int {
}
NavigationServer3D_region_get_connection_pathway_start :: (using self: *NavigationServer3D, region: RID, connection: int) -> Vector3 {
}
NavigationServer3D_region_get_connection_pathway_end :: (using self: *NavigationServer3D, region: RID, connection: int) -> Vector3 {
}
NavigationServer3D_region_get_random_point :: (using self: *NavigationServer3D, region: RID, navigation_layers: int, uniformly: bool) -> Vector3 {
}
NavigationServer3D_link_create :: (using self: *NavigationServer3D) -> RID {
}
NavigationServer3D_link_set_map :: (using self: *NavigationServer3D, link: RID, map: RID) {
}
NavigationServer3D_link_get_map :: (using self: *NavigationServer3D, link: RID) -> RID {
}
NavigationServer3D_link_set_enabled :: (using self: *NavigationServer3D, link: RID, enabled: bool) {
}
NavigationServer3D_link_get_enabled :: (using self: *NavigationServer3D, link: RID) -> bool {
}
NavigationServer3D_link_set_bidirectional :: (using self: *NavigationServer3D, link: RID, bidirectional: bool) {
}
NavigationServer3D_link_is_bidirectional :: (using self: *NavigationServer3D, link: RID) -> bool {
}
NavigationServer3D_link_set_navigation_layers :: (using self: *NavigationServer3D, link: RID, navigation_layers: int) {
}
NavigationServer3D_link_get_navigation_layers :: (using self: *NavigationServer3D, link: RID) -> int {
}
NavigationServer3D_link_set_start_position :: (using self: *NavigationServer3D, link: RID, position: Vector3) {
}
NavigationServer3D_link_get_start_position :: (using self: *NavigationServer3D, link: RID) -> Vector3 {
}
NavigationServer3D_link_set_end_position :: (using self: *NavigationServer3D, link: RID, position: Vector3) {
}
NavigationServer3D_link_get_end_position :: (using self: *NavigationServer3D, link: RID) -> Vector3 {
}
NavigationServer3D_link_set_enter_cost :: (using self: *NavigationServer3D, link: RID, enter_cost: float) {
}
NavigationServer3D_link_get_enter_cost :: (using self: *NavigationServer3D, link: RID) -> float {
}
NavigationServer3D_link_set_travel_cost :: (using self: *NavigationServer3D, link: RID, travel_cost: float) {
}
NavigationServer3D_link_get_travel_cost :: (using self: *NavigationServer3D, link: RID) -> float {
}
NavigationServer3D_link_set_owner_id :: (using self: *NavigationServer3D, link: RID, owner_id: int) {
}
NavigationServer3D_link_get_owner_id :: (using self: *NavigationServer3D, link: RID) -> int {
}
NavigationServer3D_agent_create :: (using self: *NavigationServer3D) -> RID {
}
NavigationServer3D_agent_set_avoidance_enabled :: (using self: *NavigationServer3D, agent: RID, enabled: bool) {
}
NavigationServer3D_agent_get_avoidance_enabled :: (using self: *NavigationServer3D, agent: RID) -> bool {
}
NavigationServer3D_agent_set_use_3d_avoidance :: (using self: *NavigationServer3D, agent: RID, enabled: bool) {
}
NavigationServer3D_agent_get_use_3d_avoidance :: (using self: *NavigationServer3D, agent: RID) -> bool {
}
NavigationServer3D_agent_set_map :: (using self: *NavigationServer3D, agent: RID, map: RID) {
}
NavigationServer3D_agent_get_map :: (using self: *NavigationServer3D, agent: RID) -> RID {
}
NavigationServer3D_agent_set_paused :: (using self: *NavigationServer3D, agent: RID, paused: bool) {
}
NavigationServer3D_agent_get_paused :: (using self: *NavigationServer3D, agent: RID) -> bool {
}
NavigationServer3D_agent_set_neighbor_distance :: (using self: *NavigationServer3D, agent: RID, distance: float) {
}
NavigationServer3D_agent_get_neighbor_distance :: (using self: *NavigationServer3D, agent: RID) -> float {
}
NavigationServer3D_agent_set_max_neighbors :: (using self: *NavigationServer3D, agent: RID, count: int) {
}
NavigationServer3D_agent_get_max_neighbors :: (using self: *NavigationServer3D, agent: RID) -> int {
}
NavigationServer3D_agent_set_time_horizon_agents :: (using self: *NavigationServer3D, agent: RID, time_horizon: float) {
}
NavigationServer3D_agent_get_time_horizon_agents :: (using self: *NavigationServer3D, agent: RID) -> float {
}
NavigationServer3D_agent_set_time_horizon_obstacles :: (using self: *NavigationServer3D, agent: RID, time_horizon: float) {
}
NavigationServer3D_agent_get_time_horizon_obstacles :: (using self: *NavigationServer3D, agent: RID) -> float {
}
NavigationServer3D_agent_set_radius :: (using self: *NavigationServer3D, agent: RID, radius: float) {
}
NavigationServer3D_agent_get_radius :: (using self: *NavigationServer3D, agent: RID) -> float {
}
NavigationServer3D_agent_set_height :: (using self: *NavigationServer3D, agent: RID, height: float) {
}
NavigationServer3D_agent_get_height :: (using self: *NavigationServer3D, agent: RID) -> float {
}
NavigationServer3D_agent_set_max_speed :: (using self: *NavigationServer3D, agent: RID, max_speed: float) {
}
NavigationServer3D_agent_get_max_speed :: (using self: *NavigationServer3D, agent: RID) -> float {
}
NavigationServer3D_agent_set_velocity_forced :: (using self: *NavigationServer3D, agent: RID, velocity: Vector3) {
}
NavigationServer3D_agent_set_velocity :: (using self: *NavigationServer3D, agent: RID, velocity: Vector3) {
}
NavigationServer3D_agent_get_velocity :: (using self: *NavigationServer3D, agent: RID) -> Vector3 {
}
NavigationServer3D_agent_set_position :: (using self: *NavigationServer3D, agent: RID, position: Vector3) {
}
NavigationServer3D_agent_get_position :: (using self: *NavigationServer3D, agent: RID) -> Vector3 {
}
NavigationServer3D_agent_is_map_changed :: (using self: *NavigationServer3D, agent: RID) -> bool {
}
NavigationServer3D_agent_set_avoidance_callback :: (using self: *NavigationServer3D, agent: RID, callback: Callable) {
}
NavigationServer3D_agent_has_avoidance_callback :: (using self: *NavigationServer3D, agent: RID) -> bool {
}
NavigationServer3D_agent_set_avoidance_layers :: (using self: *NavigationServer3D, agent: RID, layers: int) {
}
NavigationServer3D_agent_get_avoidance_layers :: (using self: *NavigationServer3D, agent: RID) -> int {
}
NavigationServer3D_agent_set_avoidance_mask :: (using self: *NavigationServer3D, agent: RID, mask: int) {
}
NavigationServer3D_agent_get_avoidance_mask :: (using self: *NavigationServer3D, agent: RID) -> int {
}
NavigationServer3D_agent_set_avoidance_priority :: (using self: *NavigationServer3D, agent: RID, priority: float) {
}
NavigationServer3D_agent_get_avoidance_priority :: (using self: *NavigationServer3D, agent: RID) -> float {
}
NavigationServer3D_obstacle_create :: (using self: *NavigationServer3D) -> RID {
}
NavigationServer3D_obstacle_set_avoidance_enabled :: (using self: *NavigationServer3D, obstacle: RID, enabled: bool) {
}
NavigationServer3D_obstacle_get_avoidance_enabled :: (using self: *NavigationServer3D, obstacle: RID) -> bool {
}
NavigationServer3D_obstacle_set_use_3d_avoidance :: (using self: *NavigationServer3D, obstacle: RID, enabled: bool) {
}
NavigationServer3D_obstacle_get_use_3d_avoidance :: (using self: *NavigationServer3D, obstacle: RID) -> bool {
}
NavigationServer3D_obstacle_set_map :: (using self: *NavigationServer3D, obstacle: RID, map: RID) {
}
NavigationServer3D_obstacle_get_map :: (using self: *NavigationServer3D, obstacle: RID) -> RID {
}
NavigationServer3D_obstacle_set_paused :: (using self: *NavigationServer3D, obstacle: RID, paused: bool) {
}
NavigationServer3D_obstacle_get_paused :: (using self: *NavigationServer3D, obstacle: RID) -> bool {
}
NavigationServer3D_obstacle_set_radius :: (using self: *NavigationServer3D, obstacle: RID, radius: float) {
}
NavigationServer3D_obstacle_get_radius :: (using self: *NavigationServer3D, obstacle: RID) -> float {
}
NavigationServer3D_obstacle_set_height :: (using self: *NavigationServer3D, obstacle: RID, height: float) {
}
NavigationServer3D_obstacle_get_height :: (using self: *NavigationServer3D, obstacle: RID) -> float {
}
NavigationServer3D_obstacle_set_velocity :: (using self: *NavigationServer3D, obstacle: RID, velocity: Vector3) {
}
NavigationServer3D_obstacle_get_velocity :: (using self: *NavigationServer3D, obstacle: RID) -> Vector3 {
}
NavigationServer3D_obstacle_set_position :: (using self: *NavigationServer3D, obstacle: RID, position: Vector3) {
}
NavigationServer3D_obstacle_get_position :: (using self: *NavigationServer3D, obstacle: RID) -> Vector3 {
}
NavigationServer3D_obstacle_set_vertices :: (using self: *NavigationServer3D, obstacle: RID, vertices: PackedVector3Array) {
}
NavigationServer3D_obstacle_get_vertices :: (using self: *NavigationServer3D, obstacle: RID) -> PackedVector3Array {
}
NavigationServer3D_obstacle_set_avoidance_layers :: (using self: *NavigationServer3D, obstacle: RID, layers: int) {
}
NavigationServer3D_obstacle_get_avoidance_layers :: (using self: *NavigationServer3D, obstacle: RID) -> int {
}
NavigationServer3D_parse_source_geometry_data :: (using self: *NavigationServer3D, navigation_mesh: NavigationMesh, source_geometry_data: NavigationMeshSourceGeometryData3D, root_node: Node, callback: Callable) {
}
NavigationServer3D_bake_from_source_geometry_data :: (using self: *NavigationServer3D, navigation_mesh: NavigationMesh, source_geometry_data: NavigationMeshSourceGeometryData3D, callback: Callable) {
}
NavigationServer3D_bake_from_source_geometry_data_async :: (using self: *NavigationServer3D, navigation_mesh: NavigationMesh, source_geometry_data: NavigationMeshSourceGeometryData3D, callback: Callable) {
}
NavigationServer3D_is_baking_navigation_mesh :: (using self: *NavigationServer3D, navigation_mesh: NavigationMesh) -> bool {
}
NavigationServer3D_source_geometry_parser_create :: (using self: *NavigationServer3D) -> RID {
}
NavigationServer3D_source_geometry_parser_set_callback :: (using self: *NavigationServer3D, parser: RID, callback: Callable) {
}
NavigationServer3D_simplify_path :: (using self: *NavigationServer3D, path: PackedVector3Array, epsilon: float) -> PackedVector3Array {
}
NavigationServer3D_free_rid :: (using self: *NavigationServer3D, rid: RID) {
}
NavigationServer3D_set_active :: (using self: *NavigationServer3D, active: bool) {
}
NavigationServer3D_set_debug_enabled :: (using self: *NavigationServer3D, enabled: bool) {
}
NavigationServer3D_get_debug_enabled :: (using self: *NavigationServer3D) -> bool {
}
NavigationServer3D_get_process_info :: (using self: *NavigationServer3D, process_info: NavigationServer3D.ProcessInfo) -> int {
}

// NinePatchRect
NinePatchRect :: struct {
	__private: *void;

	AxisStretchMode :: enum {
		AXIS_STRETCH_MODE_STRETCH :: 0;
		AXIS_STRETCH_MODE_TILE :: 1;
		AXIS_STRETCH_MODE_TILE_FIT :: 2;
	}
}

NinePatchRect_set_texture :: (using self: *NinePatchRect, texture: Texture2D) {
}
NinePatchRect_get_texture :: (using self: *NinePatchRect) -> Texture2D {
}
NinePatchRect_set_patch_margin :: (using self: *NinePatchRect, margin: Side, value: int) {
}
NinePatchRect_get_patch_margin :: (using self: *NinePatchRect, margin: Side) -> int {
}
NinePatchRect_set_region_rect :: (using self: *NinePatchRect, rect: Rect2) {
}
NinePatchRect_get_region_rect :: (using self: *NinePatchRect) -> Rect2 {
}
NinePatchRect_set_draw_center :: (using self: *NinePatchRect, draw_center: bool) {
}
NinePatchRect_is_draw_center_enabled :: (using self: *NinePatchRect) -> bool {
}
NinePatchRect_set_h_axis_stretch_mode :: (using self: *NinePatchRect, mode: NinePatchRect.AxisStretchMode) {
}
NinePatchRect_get_h_axis_stretch_mode :: (using self: *NinePatchRect) -> NinePatchRect.AxisStretchMode {
}
NinePatchRect_set_v_axis_stretch_mode :: (using self: *NinePatchRect, mode: NinePatchRect.AxisStretchMode) {
}
NinePatchRect_get_v_axis_stretch_mode :: (using self: *NinePatchRect) -> NinePatchRect.AxisStretchMode {
}

// Node
Node :: struct {
	__private: *void;

	NOTIFICATION_ENTER_TREE :: 10;
	NOTIFICATION_EXIT_TREE :: 11;
	NOTIFICATION_MOVED_IN_PARENT :: 12;
	NOTIFICATION_READY :: 13;
	NOTIFICATION_PAUSED :: 14;
	NOTIFICATION_UNPAUSED :: 15;
	NOTIFICATION_PHYSICS_PROCESS :: 16;
	NOTIFICATION_PROCESS :: 17;
	NOTIFICATION_PARENTED :: 18;
	NOTIFICATION_UNPARENTED :: 19;
	NOTIFICATION_SCENE_INSTANTIATED :: 20;
	NOTIFICATION_DRAG_BEGIN :: 21;
	NOTIFICATION_DRAG_END :: 22;
	NOTIFICATION_PATH_RENAMED :: 23;
	NOTIFICATION_CHILD_ORDER_CHANGED :: 24;
	NOTIFICATION_INTERNAL_PROCESS :: 25;
	NOTIFICATION_INTERNAL_PHYSICS_PROCESS :: 26;
	NOTIFICATION_POST_ENTER_TREE :: 27;
	NOTIFICATION_DISABLED :: 28;
	NOTIFICATION_ENABLED :: 29;
	NOTIFICATION_RESET_PHYSICS_INTERPOLATION :: 2001;
	NOTIFICATION_EDITOR_PRE_SAVE :: 9001;
	NOTIFICATION_EDITOR_POST_SAVE :: 9002;
	NOTIFICATION_WM_MOUSE_ENTER :: 1002;
	NOTIFICATION_WM_MOUSE_EXIT :: 1003;
	NOTIFICATION_WM_WINDOW_FOCUS_IN :: 1004;
	NOTIFICATION_WM_WINDOW_FOCUS_OUT :: 1005;
	NOTIFICATION_WM_CLOSE_REQUEST :: 1006;
	NOTIFICATION_WM_GO_BACK_REQUEST :: 1007;
	NOTIFICATION_WM_SIZE_CHANGED :: 1008;
	NOTIFICATION_WM_DPI_CHANGE :: 1009;
	NOTIFICATION_VP_MOUSE_ENTER :: 1010;
	NOTIFICATION_VP_MOUSE_EXIT :: 1011;
	NOTIFICATION_OS_MEMORY_WARNING :: 2009;
	NOTIFICATION_TRANSLATION_CHANGED :: 2010;
	NOTIFICATION_WM_ABOUT :: 2011;
	NOTIFICATION_CRASH :: 2012;
	NOTIFICATION_OS_IME_UPDATE :: 2013;
	NOTIFICATION_APPLICATION_RESUMED :: 2014;
	NOTIFICATION_APPLICATION_PAUSED :: 2015;
	NOTIFICATION_APPLICATION_FOCUS_IN :: 2016;
	NOTIFICATION_APPLICATION_FOCUS_OUT :: 2017;
	NOTIFICATION_TEXT_SERVER_CHANGED :: 2018;

	ProcessMode :: enum {
		PROCESS_MODE_INHERIT :: 0;
		PROCESS_MODE_PAUSABLE :: 1;
		PROCESS_MODE_WHEN_PAUSED :: 2;
		PROCESS_MODE_ALWAYS :: 3;
		PROCESS_MODE_DISABLED :: 4;
	}
	ProcessThreadGroup :: enum {
		PROCESS_THREAD_GROUP_INHERIT :: 0;
		PROCESS_THREAD_GROUP_MAIN_THREAD :: 1;
		PROCESS_THREAD_GROUP_SUB_THREAD :: 2;
	}
	ProcessThreadMessages :: enum_flags {
		FLAG_PROCESS_THREAD_MESSAGES :: 1;
		FLAG_PROCESS_THREAD_MESSAGES_PHYSICS :: 2;
		FLAG_PROCESS_THREAD_MESSAGES_ALL :: 3;
	}
	PhysicsInterpolationMode :: enum {
		PHYSICS_INTERPOLATION_MODE_INHERIT :: 0;
		PHYSICS_INTERPOLATION_MODE_ON :: 1;
		PHYSICS_INTERPOLATION_MODE_OFF :: 2;
	}
	DuplicateFlags :: enum {
		DUPLICATE_SIGNALS :: 1;
		DUPLICATE_GROUPS :: 2;
		DUPLICATE_SCRIPTS :: 4;
		DUPLICATE_USE_INSTANTIATION :: 8;
	}
	InternalMode :: enum {
		INTERNAL_MODE_DISABLED :: 0;
		INTERNAL_MODE_FRONT :: 1;
		INTERNAL_MODE_BACK :: 2;
	}
	AutoTranslateMode :: enum {
		AUTO_TRANSLATE_MODE_INHERIT :: 0;
		AUTO_TRANSLATE_MODE_ALWAYS :: 1;
		AUTO_TRANSLATE_MODE_DISABLED :: 2;
	}
}

Node__process :: (using self: *Node, delta: float) {
}
Node__physics_process :: (using self: *Node, delta: float) {
}
Node__enter_tree :: (using self: *Node) {
}
Node__exit_tree :: (using self: *Node) {
}
Node__ready :: (using self: *Node) {
}
Node__get_configuration_warnings :: (using self: *Node) -> PackedStringArray {
}
Node__input :: (using self: *Node, event: InputEvent) {
}
Node__shortcut_input :: (using self: *Node, event: InputEvent) {
}
Node__unhandled_input :: (using self: *Node, event: InputEvent) {
}
Node__unhandled_key_input :: (using self: *Node, event: InputEvent) {
}
Node_print_orphan_nodes :: (using self: *Node) {
}
Node_add_sibling :: (using self: *Node, sibling: Node, force_readable_name: bool) {
}
Node_set_name :: (using self: *Node, name: String) {
}
Node_get_name :: (using self: *Node) -> StringName {
}
Node_add_child :: (using self: *Node, node: Node, force_readable_name: bool, internal: Node.InternalMode) {
}
Node_remove_child :: (using self: *Node, node: Node) {
}
Node_reparent :: (using self: *Node, new_parent: Node, keep_global_transform: bool) {
}
Node_get_child_count :: (using self: *Node, include_internal: bool) -> int {
}
Node_get_children :: (using self: *Node, include_internal: bool) -> Array {
}
Node_get_child :: (using self: *Node, idx: int, include_internal: bool) -> Node {
}
Node_has_node :: (using self: *Node, path: NodePath) -> bool {
}
Node_get_node :: (using self: *Node, path: NodePath) -> Node {
}
Node_get_node_or_null :: (using self: *Node, path: NodePath) -> Node {
}
Node_get_parent :: (using self: *Node) -> Node {
}
Node_find_child :: (using self: *Node, pattern: String, recursive: bool, owned: bool) -> Node {
}
Node_find_children :: (using self: *Node, pattern: String, type: String, recursive: bool, owned: bool) -> Array {
}
Node_find_parent :: (using self: *Node, pattern: String) -> Node {
}
Node_has_node_and_resource :: (using self: *Node, path: NodePath) -> bool {
}
Node_get_node_and_resource :: (using self: *Node, path: NodePath) -> Array {
}
Node_is_inside_tree :: (using self: *Node) -> bool {
}
Node_is_part_of_edited_scene :: (using self: *Node) -> bool {
}
Node_is_ancestor_of :: (using self: *Node, node: Node) -> bool {
}
Node_is_greater_than :: (using self: *Node, node: Node) -> bool {
}
Node_get_path :: (using self: *Node) -> NodePath {
}
Node_get_path_to :: (using self: *Node, node: Node, use_unique_path: bool) -> NodePath {
}
Node_add_to_group :: (using self: *Node, group: StringName, persistent: bool) {
}
Node_remove_from_group :: (using self: *Node, group: StringName) {
}
Node_is_in_group :: (using self: *Node, group: StringName) -> bool {
}
Node_move_child :: (using self: *Node, child_node: Node, to_index: int) {
}
Node_get_groups :: (using self: *Node) -> Array {
}
Node_set_owner :: (using self: *Node, owner: Node) {
}
Node_get_owner :: (using self: *Node) -> Node {
}
Node_get_index :: (using self: *Node, include_internal: bool) -> int {
}
Node_print_tree :: (using self: *Node) {
}
Node_print_tree_pretty :: (using self: *Node) {
}
Node_get_tree_string :: (using self: *Node) -> String {
}
Node_get_tree_string_pretty :: (using self: *Node) -> String {
}
Node_set_scene_file_path :: (using self: *Node, scene_file_path: String) {
}
Node_get_scene_file_path :: (using self: *Node) -> String {
}
Node_propagate_notification :: (using self: *Node, what: int) {
}
Node_propagate_call :: (using self: *Node, method: StringName, args: Array, parent_first: bool) {
}
Node_set_physics_process :: (using self: *Node, enable: bool) {
}
Node_get_physics_process_delta_time :: (using self: *Node) -> float {
}
Node_is_physics_processing :: (using self: *Node) -> bool {
}
Node_get_process_delta_time :: (using self: *Node) -> float {
}
Node_set_process :: (using self: *Node, enable: bool) {
}
Node_set_process_priority :: (using self: *Node, priority: int) {
}
Node_get_process_priority :: (using self: *Node) -> int {
}
Node_set_physics_process_priority :: (using self: *Node, priority: int) {
}
Node_get_physics_process_priority :: (using self: *Node) -> int {
}
Node_is_processing :: (using self: *Node) -> bool {
}
Node_set_process_input :: (using self: *Node, enable: bool) {
}
Node_is_processing_input :: (using self: *Node) -> bool {
}
Node_set_process_shortcut_input :: (using self: *Node, enable: bool) {
}
Node_is_processing_shortcut_input :: (using self: *Node) -> bool {
}
Node_set_process_unhandled_input :: (using self: *Node, enable: bool) {
}
Node_is_processing_unhandled_input :: (using self: *Node) -> bool {
}
Node_set_process_unhandled_key_input :: (using self: *Node, enable: bool) {
}
Node_is_processing_unhandled_key_input :: (using self: *Node) -> bool {
}
Node_set_process_mode :: (using self: *Node, mode: Node.ProcessMode) {
}
Node_get_process_mode :: (using self: *Node) -> Node.ProcessMode {
}
Node_can_process :: (using self: *Node) -> bool {
}
Node_set_process_thread_group :: (using self: *Node, mode: Node.ProcessThreadGroup) {
}
Node_get_process_thread_group :: (using self: *Node) -> Node.ProcessThreadGroup {
}
Node_set_process_thread_messages :: (using self: *Node, flags: Node.ProcessThreadMessages) {
}
Node_get_process_thread_messages :: (using self: *Node) -> Node.ProcessThreadMessages {
}
Node_set_process_thread_group_order :: (using self: *Node, order: int) {
}
Node_get_process_thread_group_order :: (using self: *Node) -> int {
}
Node_set_display_folded :: (using self: *Node, fold: bool) {
}
Node_is_displayed_folded :: (using self: *Node) -> bool {
}
Node_set_process_internal :: (using self: *Node, enable: bool) {
}
Node_is_processing_internal :: (using self: *Node) -> bool {
}
Node_set_physics_process_internal :: (using self: *Node, enable: bool) {
}
Node_is_physics_processing_internal :: (using self: *Node) -> bool {
}
Node_set_physics_interpolation_mode :: (using self: *Node, mode: Node.PhysicsInterpolationMode) {
}
Node_get_physics_interpolation_mode :: (using self: *Node) -> Node.PhysicsInterpolationMode {
}
Node_is_physics_interpolated :: (using self: *Node) -> bool {
}
Node_is_physics_interpolated_and_enabled :: (using self: *Node) -> bool {
}
Node_reset_physics_interpolation :: (using self: *Node) {
}
Node_set_auto_translate_mode :: (using self: *Node, mode: Node.AutoTranslateMode) {
}
Node_get_auto_translate_mode :: (using self: *Node) -> Node.AutoTranslateMode {
}
Node_get_window :: (using self: *Node) -> Window {
}
Node_get_last_exclusive_window :: (using self: *Node) -> Window {
}
Node_get_tree :: (using self: *Node) -> SceneTree {
}
Node_create_tween :: (using self: *Node) -> Tween {
}
Node_duplicate :: (using self: *Node, flags: int) -> Node {
}
Node_replace_by :: (using self: *Node, node: Node, keep_groups: bool) {
}
Node_set_scene_instance_load_placeholder :: (using self: *Node, load_placeholder: bool) {
}
Node_get_scene_instance_load_placeholder :: (using self: *Node) -> bool {
}
Node_set_editable_instance :: (using self: *Node, node: Node, is_editable: bool) {
}
Node_is_editable_instance :: (using self: *Node, node: Node) -> bool {
}
Node_get_viewport :: (using self: *Node) -> Viewport {
}
Node_queue_free :: (using self: *Node) {
}
Node_request_ready :: (using self: *Node) {
}
Node_is_node_ready :: (using self: *Node) -> bool {
}
Node_set_multiplayer_authority :: (using self: *Node, id: int, recursive: bool) {
}
Node_get_multiplayer_authority :: (using self: *Node) -> int {
}
Node_is_multiplayer_authority :: (using self: *Node) -> bool {
}
Node_get_multiplayer :: (using self: *Node) -> MultiplayerAPI {
}
Node_rpc_config :: (using self: *Node, method: StringName, config: Variant) {
}
Node_set_editor_description :: (using self: *Node, editor_description: String) {
}
Node_get_editor_description :: (using self: *Node) -> String {
}
Node_set_unique_name_in_owner :: (using self: *Node, enable: bool) {
}
Node_is_unique_name_in_owner :: (using self: *Node) -> bool {
}
Node_atr :: (using self: *Node, message: String, _context: StringName) -> String {
}
Node_atr_n :: (using self: *Node, message: String, plural_message: StringName, n: int, _context: StringName) -> String {
}
Node_rpc :: (using self: *Node, method: StringName) -> Error {
}
Node_rpc_id :: (using self: *Node, peer_id: int, method: StringName) -> Error {
}
Node_update_configuration_warnings :: (using self: *Node) {
}
Node_call_deferred_thread_group :: (using self: *Node, method: StringName) -> Variant {
}
Node_set_deferred_thread_group :: (using self: *Node, property: StringName, value: Variant) {
}
Node_notify_deferred_thread_group :: (using self: *Node, what: int) {
}
Node_call_thread_safe :: (using self: *Node, method: StringName) -> Variant {
}
Node_set_thread_safe :: (using self: *Node, property: StringName, value: Variant) {
}
Node_notify_thread_safe :: (using self: *Node, what: int) {
}

// Node2D
Node2D :: struct {
	__private: *void;
}

Node2D_set_position :: (using self: *Node2D, position: Vector2) {
}
Node2D_set_rotation :: (using self: *Node2D, radians: float) {
}
Node2D_set_rotation_degrees :: (using self: *Node2D, degrees: float) {
}
Node2D_set_skew :: (using self: *Node2D, radians: float) {
}
Node2D_set_scale :: (using self: *Node2D, scale: Vector2) {
}
Node2D_get_position :: (using self: *Node2D) -> Vector2 {
}
Node2D_get_rotation :: (using self: *Node2D) -> float {
}
Node2D_get_rotation_degrees :: (using self: *Node2D) -> float {
}
Node2D_get_skew :: (using self: *Node2D) -> float {
}
Node2D_get_scale :: (using self: *Node2D) -> Vector2 {
}
Node2D_rotate :: (using self: *Node2D, radians: float) {
}
Node2D_move_local_x :: (using self: *Node2D, delta: float, scaled: bool) {
}
Node2D_move_local_y :: (using self: *Node2D, delta: float, scaled: bool) {
}
Node2D_translate :: (using self: *Node2D, offset: Vector2) {
}
Node2D_global_translate :: (using self: *Node2D, offset: Vector2) {
}
Node2D_apply_scale :: (using self: *Node2D, ratio: Vector2) {
}
Node2D_set_global_position :: (using self: *Node2D, position: Vector2) {
}
Node2D_get_global_position :: (using self: *Node2D) -> Vector2 {
}
Node2D_set_global_rotation :: (using self: *Node2D, radians: float) {
}
Node2D_set_global_rotation_degrees :: (using self: *Node2D, degrees: float) {
}
Node2D_get_global_rotation :: (using self: *Node2D) -> float {
}
Node2D_get_global_rotation_degrees :: (using self: *Node2D) -> float {
}
Node2D_set_global_skew :: (using self: *Node2D, radians: float) {
}
Node2D_get_global_skew :: (using self: *Node2D) -> float {
}
Node2D_set_global_scale :: (using self: *Node2D, scale: Vector2) {
}
Node2D_get_global_scale :: (using self: *Node2D) -> Vector2 {
}
Node2D_set_transform :: (using self: *Node2D, xform: Transform2D) {
}
Node2D_set_global_transform :: (using self: *Node2D, xform: Transform2D) {
}
Node2D_look_at :: (using self: *Node2D, point: Vector2) {
}
Node2D_get_angle_to :: (using self: *Node2D, point: Vector2) -> float {
}
Node2D_to_local :: (using self: *Node2D, global_point: Vector2) -> Vector2 {
}
Node2D_to_global :: (using self: *Node2D, local_point: Vector2) -> Vector2 {
}
Node2D_get_relative_transform_to_parent :: (using self: *Node2D, parent: Node) -> Transform2D {
}

// Node3D
Node3D :: struct {
	__private: *void;

	NOTIFICATION_TRANSFORM_CHANGED :: 2000;
	NOTIFICATION_ENTER_WORLD :: 41;
	NOTIFICATION_EXIT_WORLD :: 42;
	NOTIFICATION_VISIBILITY_CHANGED :: 43;
	NOTIFICATION_LOCAL_TRANSFORM_CHANGED :: 44;

	RotationEditMode :: enum {
		ROTATION_EDIT_MODE_EULER :: 0;
		ROTATION_EDIT_MODE_QUATERNION :: 1;
		ROTATION_EDIT_MODE_BASIS :: 2;
	}
}

Node3D_set_transform :: (using self: *Node3D, local: Transform3D) {
}
Node3D_get_transform :: (using self: *Node3D) -> Transform3D {
}
Node3D_set_position :: (using self: *Node3D, position: Vector3) {
}
Node3D_get_position :: (using self: *Node3D) -> Vector3 {
}
Node3D_set_rotation :: (using self: *Node3D, euler_radians: Vector3) {
}
Node3D_get_rotation :: (using self: *Node3D) -> Vector3 {
}
Node3D_set_rotation_degrees :: (using self: *Node3D, euler_degrees: Vector3) {
}
Node3D_get_rotation_degrees :: (using self: *Node3D) -> Vector3 {
}
Node3D_set_rotation_order :: (using self: *Node3D, order: EulerOrder) {
}
Node3D_get_rotation_order :: (using self: *Node3D) -> EulerOrder {
}
Node3D_set_rotation_edit_mode :: (using self: *Node3D, edit_mode: Node3D.RotationEditMode) {
}
Node3D_get_rotation_edit_mode :: (using self: *Node3D) -> Node3D.RotationEditMode {
}
Node3D_set_scale :: (using self: *Node3D, scale: Vector3) {
}
Node3D_get_scale :: (using self: *Node3D) -> Vector3 {
}
Node3D_set_quaternion :: (using self: *Node3D, quaternion: Quaternion) {
}
Node3D_get_quaternion :: (using self: *Node3D) -> Quaternion {
}
Node3D_set_basis :: (using self: *Node3D, basis: Basis) {
}
Node3D_get_basis :: (using self: *Node3D) -> Basis {
}
Node3D_set_global_transform :: (using self: *Node3D, global: Transform3D) {
}
Node3D_get_global_transform :: (using self: *Node3D) -> Transform3D {
}
Node3D_set_global_position :: (using self: *Node3D, position: Vector3) {
}
Node3D_get_global_position :: (using self: *Node3D) -> Vector3 {
}
Node3D_set_global_basis :: (using self: *Node3D, basis: Basis) {
}
Node3D_get_global_basis :: (using self: *Node3D) -> Basis {
}
Node3D_set_global_rotation :: (using self: *Node3D, euler_radians: Vector3) {
}
Node3D_get_global_rotation :: (using self: *Node3D) -> Vector3 {
}
Node3D_set_global_rotation_degrees :: (using self: *Node3D, euler_degrees: Vector3) {
}
Node3D_get_global_rotation_degrees :: (using self: *Node3D) -> Vector3 {
}
Node3D_get_parent_node_3d :: (using self: *Node3D) -> Node3D {
}
Node3D_set_ignore_transform_notification :: (using self: *Node3D, enabled: bool) {
}
Node3D_set_as_top_level :: (using self: *Node3D, enable: bool) {
}
Node3D_is_set_as_top_level :: (using self: *Node3D) -> bool {
}
Node3D_set_disable_scale :: (using self: *Node3D, disable: bool) {
}
Node3D_is_scale_disabled :: (using self: *Node3D) -> bool {
}
Node3D_get_world_3d :: (using self: *Node3D) -> World3D {
}
Node3D_force_update_transform :: (using self: *Node3D) {
}
Node3D_set_visibility_parent :: (using self: *Node3D, path: NodePath) {
}
Node3D_get_visibility_parent :: (using self: *Node3D) -> NodePath {
}
Node3D_update_gizmos :: (using self: *Node3D) {
}
Node3D_add_gizmo :: (using self: *Node3D, gizmo: Node3DGizmo) {
}
Node3D_get_gizmos :: (using self: *Node3D) -> Array {
}
Node3D_clear_gizmos :: (using self: *Node3D) {
}
Node3D_set_subgizmo_selection :: (using self: *Node3D, gizmo: Node3DGizmo, id: int, transform: Transform3D) {
}
Node3D_clear_subgizmo_selection :: (using self: *Node3D) {
}
Node3D_set_visible :: (using self: *Node3D, visible: bool) {
}
Node3D_is_visible :: (using self: *Node3D) -> bool {
}
Node3D_is_visible_in_tree :: (using self: *Node3D) -> bool {
}
Node3D_show :: (using self: *Node3D) {
}
Node3D_hide :: (using self: *Node3D) {
}
Node3D_set_notify_local_transform :: (using self: *Node3D, enable: bool) {
}
Node3D_is_local_transform_notification_enabled :: (using self: *Node3D) -> bool {
}
Node3D_set_notify_transform :: (using self: *Node3D, enable: bool) {
}
Node3D_is_transform_notification_enabled :: (using self: *Node3D) -> bool {
}
Node3D_rotate :: (using self: *Node3D, axis: Vector3, angle: float) {
}
Node3D_global_rotate :: (using self: *Node3D, axis: Vector3, angle: float) {
}
Node3D_global_scale :: (using self: *Node3D, scale: Vector3) {
}
Node3D_global_translate :: (using self: *Node3D, offset: Vector3) {
}
Node3D_rotate_object_local :: (using self: *Node3D, axis: Vector3, angle: float) {
}
Node3D_scale_object_local :: (using self: *Node3D, scale: Vector3) {
}
Node3D_translate_object_local :: (using self: *Node3D, offset: Vector3) {
}
Node3D_rotate_x :: (using self: *Node3D, angle: float) {
}
Node3D_rotate_y :: (using self: *Node3D, angle: float) {
}
Node3D_rotate_z :: (using self: *Node3D, angle: float) {
}
Node3D_translate :: (using self: *Node3D, offset: Vector3) {
}
Node3D_orthonormalize :: (using self: *Node3D) {
}
Node3D_set_identity :: (using self: *Node3D) {
}
Node3D_look_at :: (using self: *Node3D, target: Vector3, up: Vector3, use_model_front: bool) {
}
Node3D_look_at_from_position :: (using self: *Node3D, position: Vector3, target: Vector3, up: Vector3, use_model_front: bool) {
}
Node3D_to_local :: (using self: *Node3D, global_point: Vector3) -> Vector3 {
}
Node3D_to_global :: (using self: *Node3D, local_point: Vector3) -> Vector3 {
}

// Node3DGizmo
Node3DGizmo :: struct {
	__private: *void;
}

// Noise
Noise :: struct {
	__private: *void;
}

Noise_get_noise_1d :: (using self: *Noise, x: float) -> float {
}
Noise_get_noise_2d :: (using self: *Noise, x: float, y: float) -> float {
}
Noise_get_noise_2dv :: (using self: *Noise, v: Vector2) -> float {
}
Noise_get_noise_3d :: (using self: *Noise, x: float, y: float, z: float) -> float {
}
Noise_get_noise_3dv :: (using self: *Noise, v: Vector3) -> float {
}
Noise_get_image :: (using self: *Noise, width: int, height: int, invert: bool, in_3d_space: bool, normalize: bool) -> Image {
}
Noise_get_seamless_image :: (using self: *Noise, width: int, height: int, invert: bool, in_3d_space: bool, skirt: float, normalize: bool) -> Image {
}
Noise_get_image_3d :: (using self: *Noise, width: int, height: int, depth: int, invert: bool, normalize: bool) -> Array {
}
Noise_get_seamless_image_3d :: (using self: *Noise, width: int, height: int, depth: int, invert: bool, skirt: float, normalize: bool) -> Array {
}

// NoiseTexture2D
NoiseTexture2D :: struct {
	__private: *void;
}

NoiseTexture2D_set_width :: (using self: *NoiseTexture2D, width: int) {
}
NoiseTexture2D_set_height :: (using self: *NoiseTexture2D, height: int) {
}
NoiseTexture2D_set_invert :: (using self: *NoiseTexture2D, invert: bool) {
}
NoiseTexture2D_get_invert :: (using self: *NoiseTexture2D) -> bool {
}
NoiseTexture2D_set_in_3d_space :: (using self: *NoiseTexture2D, enable: bool) {
}
NoiseTexture2D_is_in_3d_space :: (using self: *NoiseTexture2D) -> bool {
}
NoiseTexture2D_set_generate_mipmaps :: (using self: *NoiseTexture2D, invert: bool) {
}
NoiseTexture2D_is_generating_mipmaps :: (using self: *NoiseTexture2D) -> bool {
}
NoiseTexture2D_set_seamless :: (using self: *NoiseTexture2D, seamless: bool) {
}
NoiseTexture2D_get_seamless :: (using self: *NoiseTexture2D) -> bool {
}
NoiseTexture2D_set_seamless_blend_skirt :: (using self: *NoiseTexture2D, seamless_blend_skirt: float) {
}
NoiseTexture2D_get_seamless_blend_skirt :: (using self: *NoiseTexture2D) -> float {
}
NoiseTexture2D_set_as_normal_map :: (using self: *NoiseTexture2D, as_normal_map: bool) {
}
NoiseTexture2D_is_normal_map :: (using self: *NoiseTexture2D) -> bool {
}
NoiseTexture2D_set_bump_strength :: (using self: *NoiseTexture2D, bump_strength: float) {
}
NoiseTexture2D_get_bump_strength :: (using self: *NoiseTexture2D) -> float {
}
NoiseTexture2D_set_normalize :: (using self: *NoiseTexture2D, normalize: bool) {
}
NoiseTexture2D_is_normalized :: (using self: *NoiseTexture2D) -> bool {
}
NoiseTexture2D_set_color_ramp :: (using self: *NoiseTexture2D, gradient: Gradient) {
}
NoiseTexture2D_get_color_ramp :: (using self: *NoiseTexture2D) -> Gradient {
}
NoiseTexture2D_set_noise :: (using self: *NoiseTexture2D, noise: Noise) {
}
NoiseTexture2D_get_noise :: (using self: *NoiseTexture2D) -> Noise {
}

// NoiseTexture3D
NoiseTexture3D :: struct {
	__private: *void;
}

NoiseTexture3D_set_width :: (using self: *NoiseTexture3D, width: int) {
}
NoiseTexture3D_set_height :: (using self: *NoiseTexture3D, height: int) {
}
NoiseTexture3D_set_depth :: (using self: *NoiseTexture3D, depth: int) {
}
NoiseTexture3D_set_invert :: (using self: *NoiseTexture3D, invert: bool) {
}
NoiseTexture3D_get_invert :: (using self: *NoiseTexture3D) -> bool {
}
NoiseTexture3D_set_seamless :: (using self: *NoiseTexture3D, seamless: bool) {
}
NoiseTexture3D_get_seamless :: (using self: *NoiseTexture3D) -> bool {
}
NoiseTexture3D_set_seamless_blend_skirt :: (using self: *NoiseTexture3D, seamless_blend_skirt: float) {
}
NoiseTexture3D_get_seamless_blend_skirt :: (using self: *NoiseTexture3D) -> float {
}
NoiseTexture3D_set_normalize :: (using self: *NoiseTexture3D, normalize: bool) {
}
NoiseTexture3D_is_normalized :: (using self: *NoiseTexture3D) -> bool {
}
NoiseTexture3D_set_color_ramp :: (using self: *NoiseTexture3D, gradient: Gradient) {
}
NoiseTexture3D_get_color_ramp :: (using self: *NoiseTexture3D) -> Gradient {
}
NoiseTexture3D_set_noise :: (using self: *NoiseTexture3D, noise: Noise) {
}
NoiseTexture3D_get_noise :: (using self: *NoiseTexture3D) -> Noise {
}

// ORMMaterial3D
ORMMaterial3D :: struct {
	__private: *void;
}

// OS
OS :: struct {
	__private: *void;

	RenderingDriver :: enum {
		RENDERING_DRIVER_VULKAN :: 0;
		RENDERING_DRIVER_OPENGL3 :: 1;
		RENDERING_DRIVER_D3D12 :: 2;
	}
	SystemDir :: enum {
		SYSTEM_DIR_DESKTOP :: 0;
		SYSTEM_DIR_DCIM :: 1;
		SYSTEM_DIR_DOCUMENTS :: 2;
		SYSTEM_DIR_DOWNLOADS :: 3;
		SYSTEM_DIR_MOVIES :: 4;
		SYSTEM_DIR_MUSIC :: 5;
		SYSTEM_DIR_PICTURES :: 6;
		SYSTEM_DIR_RINGTONES :: 7;
	}
}

OS_get_entropy :: (using self: *OS, size: int) -> PackedByteArray {
}
OS_get_system_ca_certificates :: (using self: *OS) -> String {
}
OS_get_connected_midi_inputs :: (using self: *OS) -> PackedStringArray {
}
OS_open_midi_inputs :: (using self: *OS) {
}
OS_close_midi_inputs :: (using self: *OS) {
}
OS_alert :: (using self: *OS, text: String, title: String) {
}
OS_crash :: (using self: *OS, message: String) {
}
OS_set_low_processor_usage_mode :: (using self: *OS, enable: bool) {
}
OS_is_in_low_processor_usage_mode :: (using self: *OS) -> bool {
}
OS_set_low_processor_usage_mode_sleep_usec :: (using self: *OS, usec: int) {
}
OS_get_low_processor_usage_mode_sleep_usec :: (using self: *OS) -> int {
}
OS_set_delta_smoothing :: (using self: *OS, delta_smoothing_enabled: bool) {
}
OS_is_delta_smoothing_enabled :: (using self: *OS) -> bool {
}
OS_get_processor_count :: (using self: *OS) -> int {
}
OS_get_processor_name :: (using self: *OS) -> String {
}
OS_get_system_fonts :: (using self: *OS) -> PackedStringArray {
}
OS_get_system_font_path :: (using self: *OS, font_name: String, weight: int, stretch: int, italic: bool) -> String {
}
OS_get_system_font_path_for_text :: (using self: *OS, font_name: String, text: String, locale: String, script: String, weight: int, stretch: int, italic: bool) -> PackedStringArray {
}
OS_get_executable_path :: (using self: *OS) -> String {
}
OS_read_string_from_stdin :: (using self: *OS) -> String {
}
OS_execute :: (using self: *OS, path: String, arguments: PackedStringArray, output: Array, read_stderr: bool, open_console: bool) -> int {
}
OS_execute_with_pipe :: (using self: *OS, path: String, arguments: PackedStringArray) -> Dictionary {
}
OS_create_process :: (using self: *OS, path: String, arguments: PackedStringArray, open_console: bool) -> int {
}
OS_create_instance :: (using self: *OS, arguments: PackedStringArray) -> int {
}
OS_kill :: (using self: *OS, pid: int) -> Error {
}
OS_shell_open :: (using self: *OS, uri: String) -> Error {
}
OS_shell_show_in_file_manager :: (using self: *OS, file_or_dir_path: String, open_folder: bool) -> Error {
}
OS_is_process_running :: (using self: *OS, pid: int) -> bool {
}
OS_get_process_exit_code :: (using self: *OS, pid: int) -> int {
}
OS_get_process_id :: (using self: *OS) -> int {
}
OS_has_environment :: (using self: *OS, variable: String) -> bool {
}
OS_get_environment :: (using self: *OS, variable: String) -> String {
}
OS_set_environment :: (using self: *OS, variable: String, value: String) {
}
OS_unset_environment :: (using self: *OS, variable: String) {
}
OS_get_name :: (using self: *OS) -> String {
}
OS_get_distribution_name :: (using self: *OS) -> String {
}
OS_get_version :: (using self: *OS) -> String {
}
OS_get_cmdline_args :: (using self: *OS) -> PackedStringArray {
}
OS_get_cmdline_user_args :: (using self: *OS) -> PackedStringArray {
}
OS_get_video_adapter_driver_info :: (using self: *OS) -> PackedStringArray {
}
OS_set_restart_on_exit :: (using self: *OS, restart: bool, arguments: PackedStringArray) {
}
OS_is_restart_on_exit_set :: (using self: *OS) -> bool {
}
OS_get_restart_on_exit_arguments :: (using self: *OS) -> PackedStringArray {
}
OS_delay_usec :: (using self: *OS, usec: int) {
}
OS_delay_msec :: (using self: *OS, msec: int) {
}
OS_get_locale :: (using self: *OS) -> String {
}
OS_get_locale_language :: (using self: *OS) -> String {
}
OS_get_model_name :: (using self: *OS) -> String {
}
OS_is_userfs_persistent :: (using self: *OS) -> bool {
}
OS_is_stdout_verbose :: (using self: *OS) -> bool {
}
OS_is_debug_build :: (using self: *OS) -> bool {
}
OS_get_static_memory_usage :: (using self: *OS) -> int {
}
OS_get_static_memory_peak_usage :: (using self: *OS) -> int {
}
OS_get_memory_info :: (using self: *OS) -> Dictionary {
}
OS_move_to_trash :: (using self: *OS, path: String) -> Error {
}
OS_get_user_data_dir :: (using self: *OS) -> String {
}
OS_get_system_dir :: (using self: *OS, dir: OS.SystemDir, shared_storage: bool) -> String {
}
OS_get_config_dir :: (using self: *OS) -> String {
}
OS_get_data_dir :: (using self: *OS) -> String {
}
OS_get_cache_dir :: (using self: *OS) -> String {
}
OS_get_unique_id :: (using self: *OS) -> String {
}
OS_get_keycode_string :: (using self: *OS, code: Key) -> String {
}
OS_is_keycode_unicode :: (using self: *OS, code: int) -> bool {
}
OS_find_keycode_from_string :: (using self: *OS, _string: String) -> Key {
}
OS_set_use_file_access_save_and_swap :: (using self: *OS, enabled: bool) {
}
OS_set_thread_name :: (using self: *OS, name: String) -> Error {
}
OS_get_thread_caller_id :: (using self: *OS) -> int {
}
OS_get_main_thread_id :: (using self: *OS) -> int {
}
OS_has_feature :: (using self: *OS, tag_name: String) -> bool {
}
OS_is_sandboxed :: (using self: *OS) -> bool {
}
OS_request_permission :: (using self: *OS, name: String) -> bool {
}
OS_request_permissions :: (using self: *OS) -> bool {
}
OS_get_granted_permissions :: (using self: *OS) -> PackedStringArray {
}
OS_revoke_granted_permissions :: (using self: *OS) {
}

// Object
Object :: struct {
	__private: *void;

	NOTIFICATION_POSTINITIALIZE :: 0;
	NOTIFICATION_PREDELETE :: 1;
	NOTIFICATION_EXTENSION_RELOADED :: 2;

	ConnectFlags :: enum {
		CONNECT_DEFERRED :: 1;
		CONNECT_PERSIST :: 2;
		CONNECT_ONE_SHOT :: 4;
		CONNECT_REFERENCE_COUNTED :: 8;
	}
}

Object_get_class :: (using self: *Object) -> String {
}
Object_is_class :: (using self: *Object, class: String) -> bool {
}
Object_set :: (using self: *Object, property: StringName, value: Variant) {
}
Object_get :: (using self: *Object, property: StringName) -> Variant {
}
Object_set_indexed :: (using self: *Object, property_path: NodePath, value: Variant) {
}
Object_get_indexed :: (using self: *Object, property_path: NodePath) -> Variant {
}
Object_get_property_list :: (using self: *Object) -> Dictionary {
}
Object_get_method_list :: (using self: *Object) -> Dictionary {
}
Object_property_can_revert :: (using self: *Object, property: StringName) -> bool {
}
Object_property_get_revert :: (using self: *Object, property: StringName) -> Variant {
}
Object_notification :: (using self: *Object, what: int, reversed: bool) {
}
Object_to_string :: (using self: *Object) -> String {
}
Object_get_instance_id :: (using self: *Object) -> int {
}
Object_set_script :: (using self: *Object, script: Variant) {
}
Object_get_script :: (using self: *Object) -> Variant {
}
Object_set_meta :: (using self: *Object, name: StringName, value: Variant) {
}
Object_remove_meta :: (using self: *Object, name: StringName) {
}
Object_get_meta :: (using self: *Object, name: StringName, default: Variant) -> Variant {
}
Object_has_meta :: (using self: *Object, name: StringName) -> bool {
}
Object_get_meta_list :: (using self: *Object) -> Array {
}
Object_add_user_signal :: (using self: *Object, signal: String, arguments: Array) {
}
Object_has_user_signal :: (using self: *Object, signal: StringName) -> bool {
}
Object_remove_user_signal :: (using self: *Object, signal: StringName) {
}
Object_emit_signal :: (using self: *Object, signal: StringName) -> Error {
}
Object_call :: (using self: *Object, method: StringName) -> Variant {
}
Object_call_deferred :: (using self: *Object, method: StringName) -> Variant {
}
Object_set_deferred :: (using self: *Object, property: StringName, value: Variant) {
}
Object_callv :: (using self: *Object, method: StringName, arg_array: Array) -> Variant {
}
Object_has_method :: (using self: *Object, method: StringName) -> bool {
}
Object_get_method_argument_count :: (using self: *Object, method: StringName) -> int {
}
Object_has_signal :: (using self: *Object, signal: StringName) -> bool {
}
Object_get_signal_list :: (using self: *Object) -> Dictionary {
}
Object_get_signal_connection_list :: (using self: *Object, signal: StringName) -> Dictionary {
}
Object_get_incoming_connections :: (using self: *Object) -> Dictionary {
}
Object_connect :: (using self: *Object, signal: StringName, callable: Callable, flags: int) -> Error {
}
Object_disconnect :: (using self: *Object, signal: StringName, callable: Callable) {
}
Object_is_connected :: (using self: *Object, signal: StringName, callable: Callable) -> bool {
}
Object_set_block_signals :: (using self: *Object, enable: bool) {
}
Object_is_blocking_signals :: (using self: *Object) -> bool {
}
Object_notify_property_list_changed :: (using self: *Object) {
}
Object_set_message_translation :: (using self: *Object, enable: bool) {
}
Object_can_translate_messages :: (using self: *Object) -> bool {
}
Object_tr :: (using self: *Object, message: StringName, _context: StringName) -> String {
}
Object_tr_n :: (using self: *Object, message: StringName, plural_message: StringName, n: int, _context: StringName) -> String {
}
Object_is_queued_for_deletion :: (using self: *Object) -> bool {
}
Object_cancel_free :: (using self: *Object) {
}

// Occluder3D
Occluder3D :: struct {
	__private: *void;
}

Occluder3D_get_vertices :: (using self: *Occluder3D) -> PackedVector3Array {
}
Occluder3D_get_indices :: (using self: *Occluder3D) -> PackedInt32Array {
}

// OccluderInstance3D
OccluderInstance3D :: struct {
	__private: *void;
}

OccluderInstance3D_set_bake_mask :: (using self: *OccluderInstance3D, mask: int) {
}
OccluderInstance3D_get_bake_mask :: (using self: *OccluderInstance3D) -> int {
}
OccluderInstance3D_set_bake_mask_value :: (using self: *OccluderInstance3D, layer_number: int, value: bool) {
}
OccluderInstance3D_get_bake_mask_value :: (using self: *OccluderInstance3D, layer_number: int) -> bool {
}
OccluderInstance3D_set_bake_simplification_distance :: (using self: *OccluderInstance3D, simplification_distance: float) {
}
OccluderInstance3D_get_bake_simplification_distance :: (using self: *OccluderInstance3D) -> float {
}
OccluderInstance3D_set_occluder :: (using self: *OccluderInstance3D, occluder: Occluder3D) {
}
OccluderInstance3D_get_occluder :: (using self: *OccluderInstance3D) -> Occluder3D {
}

// OccluderPolygon2D
OccluderPolygon2D :: struct {
	__private: *void;

	CullMode :: enum {
		CULL_DISABLED :: 0;
		CULL_CLOCKWISE :: 1;
		CULL_COUNTER_CLOCKWISE :: 2;
	}
}

OccluderPolygon2D_set_closed :: (using self: *OccluderPolygon2D, closed: bool) {
}
OccluderPolygon2D_is_closed :: (using self: *OccluderPolygon2D) -> bool {
}
OccluderPolygon2D_set_cull_mode :: (using self: *OccluderPolygon2D, cull_mode: OccluderPolygon2D.CullMode) {
}
OccluderPolygon2D_get_cull_mode :: (using self: *OccluderPolygon2D) -> OccluderPolygon2D.CullMode {
}
OccluderPolygon2D_set_polygon :: (using self: *OccluderPolygon2D, polygon: PackedVector2Array) {
}
OccluderPolygon2D_get_polygon :: (using self: *OccluderPolygon2D) -> PackedVector2Array {
}

// OfflineMultiplayerPeer
OfflineMultiplayerPeer :: struct {
	__private: *void;
}

// OggPacketSequence
OggPacketSequence :: struct {
	__private: *void;
}

OggPacketSequence_set_packet_data :: (using self: *OggPacketSequence, packet_data: Array) {
}
OggPacketSequence_get_packet_data :: (using self: *OggPacketSequence) -> Array {
}
OggPacketSequence_set_packet_granule_positions :: (using self: *OggPacketSequence, granule_positions: PackedInt64Array) {
}
OggPacketSequence_get_packet_granule_positions :: (using self: *OggPacketSequence) -> PackedInt64Array {
}
OggPacketSequence_set_sampling_rate :: (using self: *OggPacketSequence, sampling_rate: float) {
}
OggPacketSequence_get_sampling_rate :: (using self: *OggPacketSequence) -> float {
}
OggPacketSequence_get_length :: (using self: *OggPacketSequence) -> float {
}

// OggPacketSequencePlayback
OggPacketSequencePlayback :: struct {
	__private: *void;
}

// OmniLight3D
OmniLight3D :: struct {
	__private: *void;

	ShadowMode :: enum {
		SHADOW_DUAL_PARABOLOID :: 0;
		SHADOW_CUBE :: 1;
	}
}

OmniLight3D_set_shadow_mode :: (using self: *OmniLight3D, mode: OmniLight3D.ShadowMode) {
}
OmniLight3D_get_shadow_mode :: (using self: *OmniLight3D) -> OmniLight3D.ShadowMode {
}

// OpenXRAPIExtension
OpenXRAPIExtension :: struct {
	__private: *void;

	OpenXRAlphaBlendModeSupport :: enum {
		OPENXR_ALPHA_BLEND_MODE_SUPPORT_NONE :: 0;
		OPENXR_ALPHA_BLEND_MODE_SUPPORT_REAL :: 1;
		OPENXR_ALPHA_BLEND_MODE_SUPPORT_EMULATING :: 2;
	}
}

OpenXRAPIExtension_get_instance :: (using self: *OpenXRAPIExtension) -> int {
}
OpenXRAPIExtension_get_system_id :: (using self: *OpenXRAPIExtension) -> int {
}
OpenXRAPIExtension_get_session :: (using self: *OpenXRAPIExtension) -> int {
}
OpenXRAPIExtension_transform_from_pose :: (using self: *OpenXRAPIExtension, pose: *void) -> Transform3D {
}
OpenXRAPIExtension_xr_result :: (using self: *OpenXRAPIExtension, result: int, format: String, args: Array) -> bool {
}
OpenXRAPIExtension_openxr_is_enabled :: (using self: *OpenXRAPIExtension, check_run_in_editor: bool) -> bool {
}
OpenXRAPIExtension_get_instance_proc_addr :: (using self: *OpenXRAPIExtension, name: String) -> int {
}
OpenXRAPIExtension_get_error_string :: (using self: *OpenXRAPIExtension, result: int) -> String {
}
OpenXRAPIExtension_get_swapchain_format_name :: (using self: *OpenXRAPIExtension, swapchain_format: int) -> String {
}
OpenXRAPIExtension_is_initialized :: (using self: *OpenXRAPIExtension) -> bool {
}
OpenXRAPIExtension_is_running :: (using self: *OpenXRAPIExtension) -> bool {
}
OpenXRAPIExtension_get_play_space :: (using self: *OpenXRAPIExtension) -> int {
}
OpenXRAPIExtension_get_predicted_display_time :: (using self: *OpenXRAPIExtension) -> int {
}
OpenXRAPIExtension_get_next_frame_time :: (using self: *OpenXRAPIExtension) -> int {
}
OpenXRAPIExtension_can_render :: (using self: *OpenXRAPIExtension) -> bool {
}
OpenXRAPIExtension_get_hand_tracker :: (using self: *OpenXRAPIExtension, hand_index: int) -> int {
}
OpenXRAPIExtension_register_composition_layer_provider :: (using self: *OpenXRAPIExtension, extension: OpenXRExtensionWrapperExtension) {
}
OpenXRAPIExtension_unregister_composition_layer_provider :: (using self: *OpenXRAPIExtension, extension: OpenXRExtensionWrapperExtension) {
}
OpenXRAPIExtension_set_emulate_environment_blend_mode_alpha_blend :: (using self: *OpenXRAPIExtension, enabled: bool) {
}
OpenXRAPIExtension_is_environment_blend_mode_alpha_supported :: (using self: *OpenXRAPIExtension) -> OpenXRAPIExtension.OpenXRAlphaBlendModeSupport {
}

// OpenXRAction
OpenXRAction :: struct {
	__private: *void;

	ActionType :: enum {
		OPENXR_ACTION_BOOL :: 0;
		OPENXR_ACTION_FLOAT :: 1;
		OPENXR_ACTION_VECTOR2 :: 2;
		OPENXR_ACTION_POSE :: 3;
	}
}

OpenXRAction_set_localized_name :: (using self: *OpenXRAction, localized_name: String) {
}
OpenXRAction_get_localized_name :: (using self: *OpenXRAction) -> String {
}
OpenXRAction_set_action_type :: (using self: *OpenXRAction, action_type: OpenXRAction.ActionType) {
}
OpenXRAction_get_action_type :: (using self: *OpenXRAction) -> OpenXRAction.ActionType {
}
OpenXRAction_set_toplevel_paths :: (using self: *OpenXRAction, toplevel_paths: PackedStringArray) {
}
OpenXRAction_get_toplevel_paths :: (using self: *OpenXRAction) -> PackedStringArray {
}

// OpenXRActionMap
OpenXRActionMap :: struct {
	__private: *void;
}

OpenXRActionMap_set_action_sets :: (using self: *OpenXRActionMap, action_sets: Array) {
}
OpenXRActionMap_get_action_sets :: (using self: *OpenXRActionMap) -> Array {
}
OpenXRActionMap_get_action_set_count :: (using self: *OpenXRActionMap) -> int {
}
OpenXRActionMap_find_action_set :: (using self: *OpenXRActionMap, name: String) -> OpenXRActionSet {
}
OpenXRActionMap_get_action_set :: (using self: *OpenXRActionMap, idx: int) -> OpenXRActionSet {
}
OpenXRActionMap_add_action_set :: (using self: *OpenXRActionMap, action_set: OpenXRActionSet) {
}
OpenXRActionMap_remove_action_set :: (using self: *OpenXRActionMap, action_set: OpenXRActionSet) {
}
OpenXRActionMap_set_interaction_profiles :: (using self: *OpenXRActionMap, interaction_profiles: Array) {
}
OpenXRActionMap_get_interaction_profiles :: (using self: *OpenXRActionMap) -> Array {
}
OpenXRActionMap_get_interaction_profile_count :: (using self: *OpenXRActionMap) -> int {
}
OpenXRActionMap_find_interaction_profile :: (using self: *OpenXRActionMap, name: String) -> OpenXRInteractionProfile {
}
OpenXRActionMap_get_interaction_profile :: (using self: *OpenXRActionMap, idx: int) -> OpenXRInteractionProfile {
}
OpenXRActionMap_add_interaction_profile :: (using self: *OpenXRActionMap, interaction_profile: OpenXRInteractionProfile) {
}
OpenXRActionMap_remove_interaction_profile :: (using self: *OpenXRActionMap, interaction_profile: OpenXRInteractionProfile) {
}
OpenXRActionMap_create_default_action_sets :: (using self: *OpenXRActionMap) {
}

// OpenXRActionSet
OpenXRActionSet :: struct {
	__private: *void;
}

OpenXRActionSet_set_localized_name :: (using self: *OpenXRActionSet, localized_name: String) {
}
OpenXRActionSet_get_localized_name :: (using self: *OpenXRActionSet) -> String {
}
OpenXRActionSet_set_priority :: (using self: *OpenXRActionSet, priority: int) {
}
OpenXRActionSet_get_priority :: (using self: *OpenXRActionSet) -> int {
}
OpenXRActionSet_get_action_count :: (using self: *OpenXRActionSet) -> int {
}
OpenXRActionSet_set_actions :: (using self: *OpenXRActionSet, actions: Array) {
}
OpenXRActionSet_get_actions :: (using self: *OpenXRActionSet) -> Array {
}
OpenXRActionSet_add_action :: (using self: *OpenXRActionSet, action: OpenXRAction) {
}
OpenXRActionSet_remove_action :: (using self: *OpenXRActionSet, action: OpenXRAction) {
}

// OpenXRCompositionLayer
OpenXRCompositionLayer :: struct {
	__private: *void;
}

OpenXRCompositionLayer_set_layer_viewport :: (using self: *OpenXRCompositionLayer, viewport: SubViewport) {
}
OpenXRCompositionLayer_get_layer_viewport :: (using self: *OpenXRCompositionLayer) -> SubViewport {
}
OpenXRCompositionLayer_set_enable_hole_punch :: (using self: *OpenXRCompositionLayer, enable: bool) {
}
OpenXRCompositionLayer_get_enable_hole_punch :: (using self: *OpenXRCompositionLayer) -> bool {
}
OpenXRCompositionLayer_set_sort_order :: (using self: *OpenXRCompositionLayer, order: int) {
}
OpenXRCompositionLayer_get_sort_order :: (using self: *OpenXRCompositionLayer) -> int {
}
OpenXRCompositionLayer_set_alpha_blend :: (using self: *OpenXRCompositionLayer, enabled: bool) {
}
OpenXRCompositionLayer_get_alpha_blend :: (using self: *OpenXRCompositionLayer) -> bool {
}
OpenXRCompositionLayer_is_natively_supported :: (using self: *OpenXRCompositionLayer) -> bool {
}
OpenXRCompositionLayer_intersects_ray :: (using self: *OpenXRCompositionLayer, origin: Vector3, direction: Vector3) -> Vector2 {
}

// OpenXRCompositionLayerCylinder
OpenXRCompositionLayerCylinder :: struct {
	__private: *void;
}

OpenXRCompositionLayerCylinder_set_radius :: (using self: *OpenXRCompositionLayerCylinder, radius: float) {
}
OpenXRCompositionLayerCylinder_get_radius :: (using self: *OpenXRCompositionLayerCylinder) -> float {
}
OpenXRCompositionLayerCylinder_set_aspect_ratio :: (using self: *OpenXRCompositionLayerCylinder, aspect_ratio: float) {
}
OpenXRCompositionLayerCylinder_get_aspect_ratio :: (using self: *OpenXRCompositionLayerCylinder) -> float {
}
OpenXRCompositionLayerCylinder_set_central_angle :: (using self: *OpenXRCompositionLayerCylinder, angle: float) {
}
OpenXRCompositionLayerCylinder_get_central_angle :: (using self: *OpenXRCompositionLayerCylinder) -> float {
}
OpenXRCompositionLayerCylinder_set_fallback_segments :: (using self: *OpenXRCompositionLayerCylinder, segments: int) {
}
OpenXRCompositionLayerCylinder_get_fallback_segments :: (using self: *OpenXRCompositionLayerCylinder) -> int {
}

// OpenXRCompositionLayerEquirect
OpenXRCompositionLayerEquirect :: struct {
	__private: *void;
}

OpenXRCompositionLayerEquirect_set_radius :: (using self: *OpenXRCompositionLayerEquirect, radius: float) {
}
OpenXRCompositionLayerEquirect_get_radius :: (using self: *OpenXRCompositionLayerEquirect) -> float {
}
OpenXRCompositionLayerEquirect_set_central_horizontal_angle :: (using self: *OpenXRCompositionLayerEquirect, angle: float) {
}
OpenXRCompositionLayerEquirect_get_central_horizontal_angle :: (using self: *OpenXRCompositionLayerEquirect) -> float {
}
OpenXRCompositionLayerEquirect_set_upper_vertical_angle :: (using self: *OpenXRCompositionLayerEquirect, angle: float) {
}
OpenXRCompositionLayerEquirect_get_upper_vertical_angle :: (using self: *OpenXRCompositionLayerEquirect) -> float {
}
OpenXRCompositionLayerEquirect_set_lower_vertical_angle :: (using self: *OpenXRCompositionLayerEquirect, angle: float) {
}
OpenXRCompositionLayerEquirect_get_lower_vertical_angle :: (using self: *OpenXRCompositionLayerEquirect) -> float {
}
OpenXRCompositionLayerEquirect_set_fallback_segments :: (using self: *OpenXRCompositionLayerEquirect, segments: int) {
}
OpenXRCompositionLayerEquirect_get_fallback_segments :: (using self: *OpenXRCompositionLayerEquirect) -> int {
}

// OpenXRCompositionLayerQuad
OpenXRCompositionLayerQuad :: struct {
	__private: *void;
}

OpenXRCompositionLayerQuad_set_quad_size :: (using self: *OpenXRCompositionLayerQuad, size: Vector2) {
}
OpenXRCompositionLayerQuad_get_quad_size :: (using self: *OpenXRCompositionLayerQuad) -> Vector2 {
}

// OpenXRExtensionWrapperExtension
OpenXRExtensionWrapperExtension :: struct {
	__private: *void;
}

OpenXRExtensionWrapperExtension__get_requested_extensions :: (using self: *OpenXRExtensionWrapperExtension) -> Dictionary {
}
OpenXRExtensionWrapperExtension__set_system_properties_and_get_next_pointer :: (using self: *OpenXRExtensionWrapperExtension, next_pointer: *void) -> int {
}
OpenXRExtensionWrapperExtension__set_instance_create_info_and_get_next_pointer :: (using self: *OpenXRExtensionWrapperExtension, next_pointer: *void) -> int {
}
OpenXRExtensionWrapperExtension__set_session_create_and_get_next_pointer :: (using self: *OpenXRExtensionWrapperExtension, next_pointer: *void) -> int {
}
OpenXRExtensionWrapperExtension__set_swapchain_create_info_and_get_next_pointer :: (using self: *OpenXRExtensionWrapperExtension, next_pointer: *void) -> int {
}
OpenXRExtensionWrapperExtension__set_hand_joint_locations_and_get_next_pointer :: (using self: *OpenXRExtensionWrapperExtension, hand_index: int, next_pointer: *void) -> int {
}
OpenXRExtensionWrapperExtension__get_composition_layer_count :: (using self: *OpenXRExtensionWrapperExtension) -> int {
}
OpenXRExtensionWrapperExtension__get_composition_layer :: (using self: *OpenXRExtensionWrapperExtension, index: int) -> int {
}
OpenXRExtensionWrapperExtension__get_composition_layer_order :: (using self: *OpenXRExtensionWrapperExtension, index: int) -> int {
}
OpenXRExtensionWrapperExtension__get_suggested_tracker_names :: (using self: *OpenXRExtensionWrapperExtension) -> PackedStringArray {
}
OpenXRExtensionWrapperExtension__on_register_metadata :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_before_instance_created :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_instance_created :: (using self: *OpenXRExtensionWrapperExtension, instance: int) {
}
OpenXRExtensionWrapperExtension__on_instance_destroyed :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_session_created :: (using self: *OpenXRExtensionWrapperExtension, session: int) {
}
OpenXRExtensionWrapperExtension__on_process :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_pre_render :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_main_swapchains_created :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_session_destroyed :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_state_idle :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_state_ready :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_state_synchronized :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_state_visible :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_state_focused :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_state_stopping :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_state_loss_pending :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_state_exiting :: (using self: *OpenXRExtensionWrapperExtension) {
}
OpenXRExtensionWrapperExtension__on_event_polled :: (using self: *OpenXRExtensionWrapperExtension, event: *void) -> bool {
}
OpenXRExtensionWrapperExtension__set_viewport_composition_layer_and_get_next_pointer :: (using self: *OpenXRExtensionWrapperExtension, layer: *void, property_values: Dictionary, next_pointer: *void) -> int {
}
OpenXRExtensionWrapperExtension__get_viewport_composition_layer_extension_properties :: (using self: *OpenXRExtensionWrapperExtension) -> Dictionary {
}
OpenXRExtensionWrapperExtension__get_viewport_composition_layer_extension_property_defaults :: (using self: *OpenXRExtensionWrapperExtension) -> Dictionary {
}
OpenXRExtensionWrapperExtension__on_viewport_composition_layer_destroyed :: (using self: *OpenXRExtensionWrapperExtension, layer: *void) {
}
OpenXRExtensionWrapperExtension_get_openxr_api :: (using self: *OpenXRExtensionWrapperExtension) -> OpenXRAPIExtension {
}
OpenXRExtensionWrapperExtension_register_extension_wrapper :: (using self: *OpenXRExtensionWrapperExtension) {
}

// OpenXRHand
OpenXRHand :: struct {
	__private: *void;

	Hands :: enum {
		HAND_LEFT :: 0;
		HAND_RIGHT :: 1;
		HAND_MAX :: 2;
	}
	MotionRange :: enum {
		MOTION_RANGE_UNOBSTRUCTED :: 0;
		MOTION_RANGE_CONFORM_TO_CONTROLLER :: 1;
		MOTION_RANGE_MAX :: 2;
	}
	SkeletonRig :: enum {
		SKELETON_RIG_OPENXR :: 0;
		SKELETON_RIG_HUMANOID :: 1;
		SKELETON_RIG_MAX :: 2;
	}
	BoneUpdate :: enum {
		BONE_UPDATE_FULL :: 0;
		BONE_UPDATE_ROTATION_ONLY :: 1;
		BONE_UPDATE_MAX :: 2;
	}
}

OpenXRHand_set_hand :: (using self: *OpenXRHand, hand: OpenXRHand.Hands) {
}
OpenXRHand_get_hand :: (using self: *OpenXRHand) -> OpenXRHand.Hands {
}
OpenXRHand_set_hand_skeleton :: (using self: *OpenXRHand, hand_skeleton: NodePath) {
}
OpenXRHand_get_hand_skeleton :: (using self: *OpenXRHand) -> NodePath {
}
OpenXRHand_set_motion_range :: (using self: *OpenXRHand, motion_range: OpenXRHand.MotionRange) {
}
OpenXRHand_get_motion_range :: (using self: *OpenXRHand) -> OpenXRHand.MotionRange {
}
OpenXRHand_set_skeleton_rig :: (using self: *OpenXRHand, skeleton_rig: OpenXRHand.SkeletonRig) {
}
OpenXRHand_get_skeleton_rig :: (using self: *OpenXRHand) -> OpenXRHand.SkeletonRig {
}
OpenXRHand_set_bone_update :: (using self: *OpenXRHand, bone_update: OpenXRHand.BoneUpdate) {
}
OpenXRHand_get_bone_update :: (using self: *OpenXRHand) -> OpenXRHand.BoneUpdate {
}

// OpenXRIPBinding
OpenXRIPBinding :: struct {
	__private: *void;
}

OpenXRIPBinding_set_action :: (using self: *OpenXRIPBinding, action: OpenXRAction) {
}
OpenXRIPBinding_get_action :: (using self: *OpenXRIPBinding) -> OpenXRAction {
}
OpenXRIPBinding_get_path_count :: (using self: *OpenXRIPBinding) -> int {
}
OpenXRIPBinding_set_paths :: (using self: *OpenXRIPBinding, paths: PackedStringArray) {
}
OpenXRIPBinding_get_paths :: (using self: *OpenXRIPBinding) -> PackedStringArray {
}
OpenXRIPBinding_has_path :: (using self: *OpenXRIPBinding, path: String) -> bool {
}
OpenXRIPBinding_add_path :: (using self: *OpenXRIPBinding, path: String) {
}
OpenXRIPBinding_remove_path :: (using self: *OpenXRIPBinding, path: String) {
}

// OpenXRInteractionProfile
OpenXRInteractionProfile :: struct {
	__private: *void;
}

OpenXRInteractionProfile_set_interaction_profile_path :: (using self: *OpenXRInteractionProfile, interaction_profile_path: String) {
}
OpenXRInteractionProfile_get_interaction_profile_path :: (using self: *OpenXRInteractionProfile) -> String {
}
OpenXRInteractionProfile_get_binding_count :: (using self: *OpenXRInteractionProfile) -> int {
}
OpenXRInteractionProfile_get_binding :: (using self: *OpenXRInteractionProfile, index: int) -> OpenXRIPBinding {
}
OpenXRInteractionProfile_set_bindings :: (using self: *OpenXRInteractionProfile, bindings: Array) {
}
OpenXRInteractionProfile_get_bindings :: (using self: *OpenXRInteractionProfile) -> Array {
}

// OpenXRInteractionProfileMetadata
OpenXRInteractionProfileMetadata :: struct {
	__private: *void;
}

OpenXRInteractionProfileMetadata_register_profile_rename :: (using self: *OpenXRInteractionProfileMetadata, old_name: String, new_name: String) {
}
OpenXRInteractionProfileMetadata_register_top_level_path :: (using self: *OpenXRInteractionProfileMetadata, display_name: String, openxr_path: String, openxr_extension_name: String) {
}
OpenXRInteractionProfileMetadata_register_interaction_profile :: (using self: *OpenXRInteractionProfileMetadata, display_name: String, openxr_path: String, openxr_extension_name: String) {
}
OpenXRInteractionProfileMetadata_register_io_path :: (using self: *OpenXRInteractionProfileMetadata, interaction_profile: String, display_name: String, toplevel_path: String, openxr_path: String, openxr_extension_name: String, action_type: OpenXRAction.ActionType) {
}

// OpenXRInterface
OpenXRInterface :: struct {
	__private: *void;

	Hand :: enum {
		HAND_LEFT :: 0;
		HAND_RIGHT :: 1;
		HAND_MAX :: 2;
	}
	HandMotionRange :: enum {
		HAND_MOTION_RANGE_UNOBSTRUCTED :: 0;
		HAND_MOTION_RANGE_CONFORM_TO_CONTROLLER :: 1;
		HAND_MOTION_RANGE_MAX :: 2;
	}
	HandTrackedSource :: enum {
		HAND_TRACKED_SOURCE_UNKNOWN :: 0;
		HAND_TRACKED_SOURCE_UNOBSTRUCTED :: 1;
		HAND_TRACKED_SOURCE_CONTROLLER :: 2;
		HAND_TRACKED_SOURCE_MAX :: 3;
	}
	HandJoints :: enum {
		HAND_JOINT_PALM :: 0;
		HAND_JOINT_WRIST :: 1;
		HAND_JOINT_THUMB_METACARPAL :: 2;
		HAND_JOINT_THUMB_PROXIMAL :: 3;
		HAND_JOINT_THUMB_DISTAL :: 4;
		HAND_JOINT_THUMB_TIP :: 5;
		HAND_JOINT_INDEX_METACARPAL :: 6;
		HAND_JOINT_INDEX_PROXIMAL :: 7;
		HAND_JOINT_INDEX_INTERMEDIATE :: 8;
		HAND_JOINT_INDEX_DISTAL :: 9;
		HAND_JOINT_INDEX_TIP :: 10;
		HAND_JOINT_MIDDLE_METACARPAL :: 11;
		HAND_JOINT_MIDDLE_PROXIMAL :: 12;
		HAND_JOINT_MIDDLE_INTERMEDIATE :: 13;
		HAND_JOINT_MIDDLE_DISTAL :: 14;
		HAND_JOINT_MIDDLE_TIP :: 15;
		HAND_JOINT_RING_METACARPAL :: 16;
		HAND_JOINT_RING_PROXIMAL :: 17;
		HAND_JOINT_RING_INTERMEDIATE :: 18;
		HAND_JOINT_RING_DISTAL :: 19;
		HAND_JOINT_RING_TIP :: 20;
		HAND_JOINT_LITTLE_METACARPAL :: 21;
		HAND_JOINT_LITTLE_PROXIMAL :: 22;
		HAND_JOINT_LITTLE_INTERMEDIATE :: 23;
		HAND_JOINT_LITTLE_DISTAL :: 24;
		HAND_JOINT_LITTLE_TIP :: 25;
		HAND_JOINT_MAX :: 26;
	}
	HandJointFlags :: enum_flags {
		HAND_JOINT_NONE :: 0;
		HAND_JOINT_ORIENTATION_VALID :: 1;
		HAND_JOINT_ORIENTATION_TRACKED :: 2;
		HAND_JOINT_POSITION_VALID :: 4;
		HAND_JOINT_POSITION_TRACKED :: 8;
		HAND_JOINT_LINEAR_VELOCITY_VALID :: 16;
		HAND_JOINT_ANGULAR_VELOCITY_VALID :: 32;
	}
}

OpenXRInterface_get_display_refresh_rate :: (using self: *OpenXRInterface) -> float {
}
OpenXRInterface_set_display_refresh_rate :: (using self: *OpenXRInterface, refresh_rate: float) {
}
OpenXRInterface_get_render_target_size_multiplier :: (using self: *OpenXRInterface) -> float {
}
OpenXRInterface_set_render_target_size_multiplier :: (using self: *OpenXRInterface, multiplier: float) {
}
OpenXRInterface_is_foveation_supported :: (using self: *OpenXRInterface) -> bool {
}
OpenXRInterface_get_foveation_level :: (using self: *OpenXRInterface) -> int {
}
OpenXRInterface_set_foveation_level :: (using self: *OpenXRInterface, foveation_level: int) {
}
OpenXRInterface_get_foveation_dynamic :: (using self: *OpenXRInterface) -> bool {
}
OpenXRInterface_set_foveation_dynamic :: (using self: *OpenXRInterface, foveation_dynamic: bool) {
}
OpenXRInterface_is_action_set_active :: (using self: *OpenXRInterface, name: String) -> bool {
}
OpenXRInterface_set_action_set_active :: (using self: *OpenXRInterface, name: String, active: bool) {
}
OpenXRInterface_get_action_sets :: (using self: *OpenXRInterface) -> Array {
}
OpenXRInterface_get_available_display_refresh_rates :: (using self: *OpenXRInterface) -> Array {
}
OpenXRInterface_set_motion_range :: (using self: *OpenXRInterface, hand: OpenXRInterface.Hand, motion_range: OpenXRInterface.HandMotionRange) {
}
OpenXRInterface_get_motion_range :: (using self: *OpenXRInterface, hand: OpenXRInterface.Hand) -> OpenXRInterface.HandMotionRange {
}
OpenXRInterface_get_hand_tracking_source :: (using self: *OpenXRInterface, hand: OpenXRInterface.Hand) -> OpenXRInterface.HandTrackedSource {
}
OpenXRInterface_get_hand_joint_flags :: (using self: *OpenXRInterface, hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> OpenXRInterface.HandJointFlags {
}
OpenXRInterface_get_hand_joint_rotation :: (using self: *OpenXRInterface, hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> Quaternion {
}
OpenXRInterface_get_hand_joint_position :: (using self: *OpenXRInterface, hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> Vector3 {
}
OpenXRInterface_get_hand_joint_radius :: (using self: *OpenXRInterface, hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> float {
}
OpenXRInterface_get_hand_joint_linear_velocity :: (using self: *OpenXRInterface, hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> Vector3 {
}
OpenXRInterface_get_hand_joint_angular_velocity :: (using self: *OpenXRInterface, hand: OpenXRInterface.Hand, joint: OpenXRInterface.HandJoints) -> Vector3 {
}
OpenXRInterface_is_hand_tracking_supported :: (using self: *OpenXRInterface) -> bool {
}
OpenXRInterface_is_hand_interaction_supported :: (using self: *OpenXRInterface) -> bool {
}
OpenXRInterface_is_eye_gaze_interaction_supported :: (using self: *OpenXRInterface) -> bool {
}
OpenXRInterface_get_vrs_min_radius :: (using self: *OpenXRInterface) -> float {
}
OpenXRInterface_set_vrs_min_radius :: (using self: *OpenXRInterface, radius: float) {
}
OpenXRInterface_get_vrs_strength :: (using self: *OpenXRInterface) -> float {
}
OpenXRInterface_set_vrs_strength :: (using self: *OpenXRInterface, strength: float) {
}

// OptimizedTranslation
OptimizedTranslation :: struct {
	__private: *void;
}

OptimizedTranslation_generate :: (using self: *OptimizedTranslation, from: Translation) {
}

// OptionButton
OptionButton :: struct {
	__private: *void;
}

OptionButton_add_item :: (using self: *OptionButton, label: String, id: int) {
}
OptionButton_add_icon_item :: (using self: *OptionButton, texture: Texture2D, label: String, id: int) {
}
OptionButton_set_item_text :: (using self: *OptionButton, idx: int, text: String) {
}
OptionButton_set_item_icon :: (using self: *OptionButton, idx: int, texture: Texture2D) {
}
OptionButton_set_item_disabled :: (using self: *OptionButton, idx: int, disabled: bool) {
}
OptionButton_set_item_id :: (using self: *OptionButton, idx: int, id: int) {
}
OptionButton_set_item_metadata :: (using self: *OptionButton, idx: int, metadata: Variant) {
}
OptionButton_set_item_tooltip :: (using self: *OptionButton, idx: int, tooltip: String) {
}
OptionButton_get_item_text :: (using self: *OptionButton, idx: int) -> String {
}
OptionButton_get_item_icon :: (using self: *OptionButton, idx: int) -> Texture2D {
}
OptionButton_get_item_id :: (using self: *OptionButton, idx: int) -> int {
}
OptionButton_get_item_index :: (using self: *OptionButton, id: int) -> int {
}
OptionButton_get_item_metadata :: (using self: *OptionButton, idx: int) -> Variant {
}
OptionButton_get_item_tooltip :: (using self: *OptionButton, idx: int) -> String {
}
OptionButton_is_item_disabled :: (using self: *OptionButton, idx: int) -> bool {
}
OptionButton_is_item_separator :: (using self: *OptionButton, idx: int) -> bool {
}
OptionButton_add_separator :: (using self: *OptionButton, text: String) {
}
OptionButton_clear :: (using self: *OptionButton) {
}
OptionButton_select :: (using self: *OptionButton, idx: int) {
}
OptionButton_get_selected :: (using self: *OptionButton) -> int {
}
OptionButton_get_selected_id :: (using self: *OptionButton) -> int {
}
OptionButton_get_selected_metadata :: (using self: *OptionButton) -> Variant {
}
OptionButton_remove_item :: (using self: *OptionButton, idx: int) {
}
OptionButton_get_popup :: (using self: *OptionButton) -> PopupMenu {
}
OptionButton_show_popup :: (using self: *OptionButton) {
}
OptionButton_set_item_count :: (using self: *OptionButton, count: int) {
}
OptionButton_get_item_count :: (using self: *OptionButton) -> int {
}
OptionButton_has_selectable_items :: (using self: *OptionButton) -> bool {
}
OptionButton_get_selectable_item :: (using self: *OptionButton, from_last: bool) -> int {
}
OptionButton_set_fit_to_longest_item :: (using self: *OptionButton, fit: bool) {
}
OptionButton_is_fit_to_longest_item :: (using self: *OptionButton) -> bool {
}
OptionButton_set_allow_reselect :: (using self: *OptionButton, allow: bool) {
}
OptionButton_get_allow_reselect :: (using self: *OptionButton) -> bool {
}
OptionButton_set_disable_shortcuts :: (using self: *OptionButton, disabled: bool) {
}

// PCKPacker
PCKPacker :: struct {
	__private: *void;
}

PCKPacker_pck_start :: (using self: *PCKPacker, pck_name: String, alignment: int, key: String, encrypt_directory: bool) -> Error {
}
PCKPacker_add_file :: (using self: *PCKPacker, pck_path: String, source_path: String, encrypt: bool) -> Error {
}
PCKPacker_flush :: (using self: *PCKPacker, verbose: bool) -> Error {
}

// PackedDataContainer
PackedDataContainer :: struct {
	__private: *void;
}

PackedDataContainer_pack :: (using self: *PackedDataContainer, value: Variant) -> Error {
}
PackedDataContainer_size :: (using self: *PackedDataContainer) -> int {
}

// PackedDataContainerRef
PackedDataContainerRef :: struct {
	__private: *void;
}

PackedDataContainerRef_size :: (using self: *PackedDataContainerRef) -> int {
}

// PackedScene
PackedScene :: struct {
	__private: *void;

	GenEditState :: enum {
		GEN_EDIT_STATE_DISABLED :: 0;
		GEN_EDIT_STATE_INSTANCE :: 1;
		GEN_EDIT_STATE_MAIN :: 2;
		GEN_EDIT_STATE_MAIN_INHERITED :: 3;
	}
}

PackedScene_pack :: (using self: *PackedScene, path: Node) -> Error {
}
PackedScene_instantiate :: (using self: *PackedScene, edit_state: PackedScene.GenEditState) -> Node {
}
PackedScene_can_instantiate :: (using self: *PackedScene) -> bool {
}
PackedScene_get_state :: (using self: *PackedScene) -> SceneState {
}

// PacketPeer
PacketPeer :: struct {
	__private: *void;
}

PacketPeer_get_var :: (using self: *PacketPeer, allow_objects: bool) -> Variant {
}
PacketPeer_put_var :: (using self: *PacketPeer, var: Variant, full_objects: bool) -> Error {
}
PacketPeer_get_packet :: (using self: *PacketPeer) -> PackedByteArray {
}
PacketPeer_put_packet :: (using self: *PacketPeer, buffer: PackedByteArray) -> Error {
}
PacketPeer_get_packet_error :: (using self: *PacketPeer) -> Error {
}
PacketPeer_get_available_packet_count :: (using self: *PacketPeer) -> int {
}
PacketPeer_get_encode_buffer_max_size :: (using self: *PacketPeer) -> int {
}
PacketPeer_set_encode_buffer_max_size :: (using self: *PacketPeer, max_size: int) {
}

// PacketPeerDTLS
PacketPeerDTLS :: struct {
	__private: *void;

	Status :: enum {
		STATUS_DISCONNECTED :: 0;
		STATUS_HANDSHAKING :: 1;
		STATUS_CONNECTED :: 2;
		STATUS_ERROR :: 3;
		STATUS_ERROR_HOSTNAME_MISMATCH :: 4;
	}
}

PacketPeerDTLS_poll :: (using self: *PacketPeerDTLS) {
}
PacketPeerDTLS_connect_to_peer :: (using self: *PacketPeerDTLS, packet_peer: PacketPeerUDP, hostname: String, client_options: TLSOptions) -> Error {
}
PacketPeerDTLS_get_status :: (using self: *PacketPeerDTLS) -> PacketPeerDTLS.Status {
}
PacketPeerDTLS_disconnect_from_peer :: (using self: *PacketPeerDTLS) {
}

// PacketPeerExtension
PacketPeerExtension :: struct {
	__private: *void;
}

PacketPeerExtension__get_packet :: (using self: *PacketPeerExtension, r_buffer: **u8, r_buffer_size: *s32) -> Error {
}
PacketPeerExtension__put_packet :: (using self: *PacketPeerExtension, p_buffer: *u8, p_buffer_size: int) -> Error {
}
PacketPeerExtension__get_available_packet_count :: (using self: *PacketPeerExtension) -> int {
}
PacketPeerExtension__get_max_packet_size :: (using self: *PacketPeerExtension) -> int {
}

// PacketPeerStream
PacketPeerStream :: struct {
	__private: *void;
}

PacketPeerStream_set_stream_peer :: (using self: *PacketPeerStream, peer: StreamPeer) {
}
PacketPeerStream_get_stream_peer :: (using self: *PacketPeerStream) -> StreamPeer {
}
PacketPeerStream_set_input_buffer_max_size :: (using self: *PacketPeerStream, max_size_bytes: int) {
}
PacketPeerStream_set_output_buffer_max_size :: (using self: *PacketPeerStream, max_size_bytes: int) {
}
PacketPeerStream_get_input_buffer_max_size :: (using self: *PacketPeerStream) -> int {
}
PacketPeerStream_get_output_buffer_max_size :: (using self: *PacketPeerStream) -> int {
}

// PacketPeerUDP
PacketPeerUDP :: struct {
	__private: *void;
}

PacketPeerUDP_bind :: (using self: *PacketPeerUDP, port: int, bind_address: String, recv_buf_size: int) -> Error {
}
PacketPeerUDP_close :: (using self: *PacketPeerUDP) {
}
PacketPeerUDP_wait :: (using self: *PacketPeerUDP) -> Error {
}
PacketPeerUDP_is_bound :: (using self: *PacketPeerUDP) -> bool {
}
PacketPeerUDP_connect_to_host :: (using self: *PacketPeerUDP, host: String, port: int) -> Error {
}
PacketPeerUDP_is_socket_connected :: (using self: *PacketPeerUDP) -> bool {
}
PacketPeerUDP_get_packet_ip :: (using self: *PacketPeerUDP) -> String {
}
PacketPeerUDP_get_packet_port :: (using self: *PacketPeerUDP) -> int {
}
PacketPeerUDP_get_local_port :: (using self: *PacketPeerUDP) -> int {
}
PacketPeerUDP_set_dest_address :: (using self: *PacketPeerUDP, host: String, port: int) -> Error {
}
PacketPeerUDP_set_broadcast_enabled :: (using self: *PacketPeerUDP, enabled: bool) {
}
PacketPeerUDP_join_multicast_group :: (using self: *PacketPeerUDP, multicast_address: String, interface_name: String) -> Error {
}
PacketPeerUDP_leave_multicast_group :: (using self: *PacketPeerUDP, multicast_address: String, interface_name: String) -> Error {
}

// Panel
Panel :: struct {
	__private: *void;
}

// PanelContainer
PanelContainer :: struct {
	__private: *void;
}

// PanoramaSkyMaterial
PanoramaSkyMaterial :: struct {
	__private: *void;
}

PanoramaSkyMaterial_set_panorama :: (using self: *PanoramaSkyMaterial, texture: Texture2D) {
}
PanoramaSkyMaterial_get_panorama :: (using self: *PanoramaSkyMaterial) -> Texture2D {
}
PanoramaSkyMaterial_set_filtering_enabled :: (using self: *PanoramaSkyMaterial, enabled: bool) {
}
PanoramaSkyMaterial_is_filtering_enabled :: (using self: *PanoramaSkyMaterial) -> bool {
}
PanoramaSkyMaterial_set_energy_multiplier :: (using self: *PanoramaSkyMaterial, multiplier: float) {
}
PanoramaSkyMaterial_get_energy_multiplier :: (using self: *PanoramaSkyMaterial) -> float {
}

// Parallax2D
Parallax2D :: struct {
	__private: *void;
}

Parallax2D_set_scroll_scale :: (using self: *Parallax2D, scale: Vector2) {
}
Parallax2D_get_scroll_scale :: (using self: *Parallax2D) -> Vector2 {
}
Parallax2D_set_repeat_size :: (using self: *Parallax2D, repeat_size: Vector2) {
}
Parallax2D_get_repeat_size :: (using self: *Parallax2D) -> Vector2 {
}
Parallax2D_set_repeat_times :: (using self: *Parallax2D, repeat_times: int) {
}
Parallax2D_get_repeat_times :: (using self: *Parallax2D) -> int {
}
Parallax2D_set_autoscroll :: (using self: *Parallax2D, autoscroll: Vector2) {
}
Parallax2D_get_autoscroll :: (using self: *Parallax2D) -> Vector2 {
}
Parallax2D_set_scroll_offset :: (using self: *Parallax2D, offset: Vector2) {
}
Parallax2D_get_scroll_offset :: (using self: *Parallax2D) -> Vector2 {
}
Parallax2D_set_screen_offset :: (using self: *Parallax2D, offset: Vector2) {
}
Parallax2D_get_screen_offset :: (using self: *Parallax2D) -> Vector2 {
}
Parallax2D_set_limit_begin :: (using self: *Parallax2D, offset: Vector2) {
}
Parallax2D_get_limit_begin :: (using self: *Parallax2D) -> Vector2 {
}
Parallax2D_set_limit_end :: (using self: *Parallax2D, offset: Vector2) {
}
Parallax2D_get_limit_end :: (using self: *Parallax2D) -> Vector2 {
}
Parallax2D_set_follow_viewport :: (using self: *Parallax2D, follow: bool) {
}
Parallax2D_get_follow_viewport :: (using self: *Parallax2D) -> bool {
}
Parallax2D_set_ignore_camera_scroll :: (using self: *Parallax2D, ignore: bool) {
}
Parallax2D_is_ignore_camera_scroll :: (using self: *Parallax2D) -> bool {
}

// ParallaxBackground
ParallaxBackground :: struct {
	__private: *void;
}

ParallaxBackground_set_scroll_offset :: (using self: *ParallaxBackground, offset: Vector2) {
}
ParallaxBackground_get_scroll_offset :: (using self: *ParallaxBackground) -> Vector2 {
}
ParallaxBackground_set_scroll_base_offset :: (using self: *ParallaxBackground, offset: Vector2) {
}
ParallaxBackground_get_scroll_base_offset :: (using self: *ParallaxBackground) -> Vector2 {
}
ParallaxBackground_set_scroll_base_scale :: (using self: *ParallaxBackground, scale: Vector2) {
}
ParallaxBackground_get_scroll_base_scale :: (using self: *ParallaxBackground) -> Vector2 {
}
ParallaxBackground_set_limit_begin :: (using self: *ParallaxBackground, offset: Vector2) {
}
ParallaxBackground_get_limit_begin :: (using self: *ParallaxBackground) -> Vector2 {
}
ParallaxBackground_set_limit_end :: (using self: *ParallaxBackground, offset: Vector2) {
}
ParallaxBackground_get_limit_end :: (using self: *ParallaxBackground) -> Vector2 {
}
ParallaxBackground_set_ignore_camera_zoom :: (using self: *ParallaxBackground, ignore: bool) {
}
ParallaxBackground_is_ignore_camera_zoom :: (using self: *ParallaxBackground) -> bool {
}

// ParallaxLayer
ParallaxLayer :: struct {
	__private: *void;
}

ParallaxLayer_set_motion_scale :: (using self: *ParallaxLayer, scale: Vector2) {
}
ParallaxLayer_get_motion_scale :: (using self: *ParallaxLayer) -> Vector2 {
}
ParallaxLayer_set_motion_offset :: (using self: *ParallaxLayer, offset: Vector2) {
}
ParallaxLayer_get_motion_offset :: (using self: *ParallaxLayer) -> Vector2 {
}
ParallaxLayer_set_mirroring :: (using self: *ParallaxLayer, mirror: Vector2) {
}
ParallaxLayer_get_mirroring :: (using self: *ParallaxLayer) -> Vector2 {
}

// ParticleProcessMaterial
ParticleProcessMaterial :: struct {
	__private: *void;

	Parameter :: enum {
		PARAM_INITIAL_LINEAR_VELOCITY :: 0;
		PARAM_ANGULAR_VELOCITY :: 1;
		PARAM_ORBIT_VELOCITY :: 2;
		PARAM_LINEAR_ACCEL :: 3;
		PARAM_RADIAL_ACCEL :: 4;
		PARAM_TANGENTIAL_ACCEL :: 5;
		PARAM_DAMPING :: 6;
		PARAM_ANGLE :: 7;
		PARAM_SCALE :: 8;
		PARAM_HUE_VARIATION :: 9;
		PARAM_ANIM_SPEED :: 10;
		PARAM_ANIM_OFFSET :: 11;
		PARAM_RADIAL_VELOCITY :: 15;
		PARAM_DIRECTIONAL_VELOCITY :: 16;
		PARAM_SCALE_OVER_VELOCITY :: 17;
		PARAM_MAX :: 18;
		PARAM_TURB_VEL_INFLUENCE :: 13;
		PARAM_TURB_INIT_DISPLACEMENT :: 14;
		PARAM_TURB_INFLUENCE_OVER_LIFE :: 12;
	}
	ParticleFlags :: enum {
		PARTICLE_FLAG_ALIGN_Y_TO_VELOCITY :: 0;
		PARTICLE_FLAG_ROTATE_Y :: 1;
		PARTICLE_FLAG_DISABLE_Z :: 2;
		PARTICLE_FLAG_DAMPING_AS_FRICTION :: 3;
		PARTICLE_FLAG_MAX :: 4;
	}
	EmissionShape :: enum {
		EMISSION_SHAPE_POINT :: 0;
		EMISSION_SHAPE_SPHERE :: 1;
		EMISSION_SHAPE_SPHERE_SURFACE :: 2;
		EMISSION_SHAPE_BOX :: 3;
		EMISSION_SHAPE_POINTS :: 4;
		EMISSION_SHAPE_DIRECTED_POINTS :: 5;
		EMISSION_SHAPE_RING :: 6;
		EMISSION_SHAPE_MAX :: 7;
	}
	SubEmitterMode :: enum {
		SUB_EMITTER_DISABLED :: 0;
		SUB_EMITTER_CONSTANT :: 1;
		SUB_EMITTER_AT_END :: 2;
		SUB_EMITTER_AT_COLLISION :: 3;
		SUB_EMITTER_MAX :: 4;
	}
	CollisionMode :: enum {
		COLLISION_DISABLED :: 0;
		COLLISION_RIGID :: 1;
		COLLISION_HIDE_ON_CONTACT :: 2;
		COLLISION_MAX :: 3;
	}
}

ParticleProcessMaterial_set_direction :: (using self: *ParticleProcessMaterial, degrees: Vector3) {
}
ParticleProcessMaterial_get_direction :: (using self: *ParticleProcessMaterial) -> Vector3 {
}
ParticleProcessMaterial_set_inherit_velocity_ratio :: (using self: *ParticleProcessMaterial, ratio: float) {
}
ParticleProcessMaterial_get_inherit_velocity_ratio :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_spread :: (using self: *ParticleProcessMaterial, degrees: float) {
}
ParticleProcessMaterial_get_spread :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_flatness :: (using self: *ParticleProcessMaterial, amount: float) {
}
ParticleProcessMaterial_get_flatness :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_param :: (using self: *ParticleProcessMaterial, param: ParticleProcessMaterial.Parameter, value: Vector2) {
}
ParticleProcessMaterial_get_param :: (using self: *ParticleProcessMaterial, param: ParticleProcessMaterial.Parameter) -> Vector2 {
}
ParticleProcessMaterial_set_param_min :: (using self: *ParticleProcessMaterial, param: ParticleProcessMaterial.Parameter, value: float) {
}
ParticleProcessMaterial_get_param_min :: (using self: *ParticleProcessMaterial, param: ParticleProcessMaterial.Parameter) -> float {
}
ParticleProcessMaterial_set_param_max :: (using self: *ParticleProcessMaterial, param: ParticleProcessMaterial.Parameter, value: float) {
}
ParticleProcessMaterial_get_param_max :: (using self: *ParticleProcessMaterial, param: ParticleProcessMaterial.Parameter) -> float {
}
ParticleProcessMaterial_set_param_texture :: (using self: *ParticleProcessMaterial, param: ParticleProcessMaterial.Parameter, texture: Texture2D) {
}
ParticleProcessMaterial_get_param_texture :: (using self: *ParticleProcessMaterial, param: ParticleProcessMaterial.Parameter) -> Texture2D {
}
ParticleProcessMaterial_set_color :: (using self: *ParticleProcessMaterial, color: Color) {
}
ParticleProcessMaterial_get_color :: (using self: *ParticleProcessMaterial) -> Color {
}
ParticleProcessMaterial_set_color_ramp :: (using self: *ParticleProcessMaterial, ramp: Texture2D) {
}
ParticleProcessMaterial_get_color_ramp :: (using self: *ParticleProcessMaterial) -> Texture2D {
}
ParticleProcessMaterial_set_alpha_curve :: (using self: *ParticleProcessMaterial, curve: Texture2D) {
}
ParticleProcessMaterial_get_alpha_curve :: (using self: *ParticleProcessMaterial) -> Texture2D {
}
ParticleProcessMaterial_set_emission_curve :: (using self: *ParticleProcessMaterial, curve: Texture2D) {
}
ParticleProcessMaterial_get_emission_curve :: (using self: *ParticleProcessMaterial) -> Texture2D {
}
ParticleProcessMaterial_set_color_initial_ramp :: (using self: *ParticleProcessMaterial, ramp: Texture2D) {
}
ParticleProcessMaterial_get_color_initial_ramp :: (using self: *ParticleProcessMaterial) -> Texture2D {
}
ParticleProcessMaterial_set_velocity_limit_curve :: (using self: *ParticleProcessMaterial, curve: Texture2D) {
}
ParticleProcessMaterial_get_velocity_limit_curve :: (using self: *ParticleProcessMaterial) -> Texture2D {
}
ParticleProcessMaterial_set_particle_flag :: (using self: *ParticleProcessMaterial, particle_flag: ParticleProcessMaterial.ParticleFlags, enable: bool) {
}
ParticleProcessMaterial_get_particle_flag :: (using self: *ParticleProcessMaterial, particle_flag: ParticleProcessMaterial.ParticleFlags) -> bool {
}
ParticleProcessMaterial_set_velocity_pivot :: (using self: *ParticleProcessMaterial, pivot: Vector3) {
}
ParticleProcessMaterial_get_velocity_pivot :: (using self: *ParticleProcessMaterial) -> Vector3 {
}
ParticleProcessMaterial_set_emission_shape :: (using self: *ParticleProcessMaterial, shape: ParticleProcessMaterial.EmissionShape) {
}
ParticleProcessMaterial_get_emission_shape :: (using self: *ParticleProcessMaterial) -> ParticleProcessMaterial.EmissionShape {
}
ParticleProcessMaterial_set_emission_sphere_radius :: (using self: *ParticleProcessMaterial, radius: float) {
}
ParticleProcessMaterial_get_emission_sphere_radius :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_emission_box_extents :: (using self: *ParticleProcessMaterial, extents: Vector3) {
}
ParticleProcessMaterial_get_emission_box_extents :: (using self: *ParticleProcessMaterial) -> Vector3 {
}
ParticleProcessMaterial_set_emission_point_texture :: (using self: *ParticleProcessMaterial, texture: Texture2D) {
}
ParticleProcessMaterial_get_emission_point_texture :: (using self: *ParticleProcessMaterial) -> Texture2D {
}
ParticleProcessMaterial_set_emission_normal_texture :: (using self: *ParticleProcessMaterial, texture: Texture2D) {
}
ParticleProcessMaterial_get_emission_normal_texture :: (using self: *ParticleProcessMaterial) -> Texture2D {
}
ParticleProcessMaterial_set_emission_color_texture :: (using self: *ParticleProcessMaterial, texture: Texture2D) {
}
ParticleProcessMaterial_get_emission_color_texture :: (using self: *ParticleProcessMaterial) -> Texture2D {
}
ParticleProcessMaterial_set_emission_point_count :: (using self: *ParticleProcessMaterial, point_count: int) {
}
ParticleProcessMaterial_get_emission_point_count :: (using self: *ParticleProcessMaterial) -> int {
}
ParticleProcessMaterial_set_emission_ring_axis :: (using self: *ParticleProcessMaterial, axis: Vector3) {
}
ParticleProcessMaterial_get_emission_ring_axis :: (using self: *ParticleProcessMaterial) -> Vector3 {
}
ParticleProcessMaterial_set_emission_ring_height :: (using self: *ParticleProcessMaterial, height: float) {
}
ParticleProcessMaterial_get_emission_ring_height :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_emission_ring_radius :: (using self: *ParticleProcessMaterial, radius: float) {
}
ParticleProcessMaterial_get_emission_ring_radius :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_emission_ring_inner_radius :: (using self: *ParticleProcessMaterial, inner_radius: float) {
}
ParticleProcessMaterial_get_emission_ring_inner_radius :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_emission_shape_offset :: (using self: *ParticleProcessMaterial, emission_shape_offset: Vector3) {
}
ParticleProcessMaterial_get_emission_shape_offset :: (using self: *ParticleProcessMaterial) -> Vector3 {
}
ParticleProcessMaterial_set_emission_shape_scale :: (using self: *ParticleProcessMaterial, emission_shape_scale: Vector3) {
}
ParticleProcessMaterial_get_emission_shape_scale :: (using self: *ParticleProcessMaterial) -> Vector3 {
}
ParticleProcessMaterial_get_turbulence_enabled :: (using self: *ParticleProcessMaterial) -> bool {
}
ParticleProcessMaterial_set_turbulence_enabled :: (using self: *ParticleProcessMaterial, turbulence_enabled: bool) {
}
ParticleProcessMaterial_get_turbulence_noise_strength :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_turbulence_noise_strength :: (using self: *ParticleProcessMaterial, turbulence_noise_strength: float) {
}
ParticleProcessMaterial_get_turbulence_noise_scale :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_turbulence_noise_scale :: (using self: *ParticleProcessMaterial, turbulence_noise_scale: float) {
}
ParticleProcessMaterial_get_turbulence_noise_speed_random :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_turbulence_noise_speed_random :: (using self: *ParticleProcessMaterial, turbulence_noise_speed_random: float) {
}
ParticleProcessMaterial_get_turbulence_noise_speed :: (using self: *ParticleProcessMaterial) -> Vector3 {
}
ParticleProcessMaterial_set_turbulence_noise_speed :: (using self: *ParticleProcessMaterial, turbulence_noise_speed: Vector3) {
}
ParticleProcessMaterial_get_gravity :: (using self: *ParticleProcessMaterial) -> Vector3 {
}
ParticleProcessMaterial_set_gravity :: (using self: *ParticleProcessMaterial, accel_vec: Vector3) {
}
ParticleProcessMaterial_set_lifetime_randomness :: (using self: *ParticleProcessMaterial, randomness: float) {
}
ParticleProcessMaterial_get_lifetime_randomness :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_get_sub_emitter_mode :: (using self: *ParticleProcessMaterial) -> ParticleProcessMaterial.SubEmitterMode {
}
ParticleProcessMaterial_set_sub_emitter_mode :: (using self: *ParticleProcessMaterial, mode: ParticleProcessMaterial.SubEmitterMode) {
}
ParticleProcessMaterial_get_sub_emitter_frequency :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_sub_emitter_frequency :: (using self: *ParticleProcessMaterial, hz: float) {
}
ParticleProcessMaterial_get_sub_emitter_amount_at_end :: (using self: *ParticleProcessMaterial) -> int {
}
ParticleProcessMaterial_set_sub_emitter_amount_at_end :: (using self: *ParticleProcessMaterial, amount: int) {
}
ParticleProcessMaterial_get_sub_emitter_amount_at_collision :: (using self: *ParticleProcessMaterial) -> int {
}
ParticleProcessMaterial_set_sub_emitter_amount_at_collision :: (using self: *ParticleProcessMaterial, amount: int) {
}
ParticleProcessMaterial_get_sub_emitter_keep_velocity :: (using self: *ParticleProcessMaterial) -> bool {
}
ParticleProcessMaterial_set_sub_emitter_keep_velocity :: (using self: *ParticleProcessMaterial, enable: bool) {
}
ParticleProcessMaterial_set_attractor_interaction_enabled :: (using self: *ParticleProcessMaterial, enabled: bool) {
}
ParticleProcessMaterial_is_attractor_interaction_enabled :: (using self: *ParticleProcessMaterial) -> bool {
}
ParticleProcessMaterial_set_collision_mode :: (using self: *ParticleProcessMaterial, mode: ParticleProcessMaterial.CollisionMode) {
}
ParticleProcessMaterial_get_collision_mode :: (using self: *ParticleProcessMaterial) -> ParticleProcessMaterial.CollisionMode {
}
ParticleProcessMaterial_set_collision_use_scale :: (using self: *ParticleProcessMaterial, radius: bool) {
}
ParticleProcessMaterial_is_collision_using_scale :: (using self: *ParticleProcessMaterial) -> bool {
}
ParticleProcessMaterial_set_collision_friction :: (using self: *ParticleProcessMaterial, friction: float) {
}
ParticleProcessMaterial_get_collision_friction :: (using self: *ParticleProcessMaterial) -> float {
}
ParticleProcessMaterial_set_collision_bounce :: (using self: *ParticleProcessMaterial, bounce: float) {
}
ParticleProcessMaterial_get_collision_bounce :: (using self: *ParticleProcessMaterial) -> float {
}

// Path2D
Path2D :: struct {
	__private: *void;
}

Path2D_set_curve :: (using self: *Path2D, curve: Curve2D) {
}
Path2D_get_curve :: (using self: *Path2D) -> Curve2D {
}

// Path3D
Path3D :: struct {
	__private: *void;
}

Path3D_set_curve :: (using self: *Path3D, curve: Curve3D) {
}
Path3D_get_curve :: (using self: *Path3D) -> Curve3D {
}

// PathFollow2D
PathFollow2D :: struct {
	__private: *void;
}

PathFollow2D_set_progress :: (using self: *PathFollow2D, progress: float) {
}
PathFollow2D_get_progress :: (using self: *PathFollow2D) -> float {
}
PathFollow2D_set_h_offset :: (using self: *PathFollow2D, h_offset: float) {
}
PathFollow2D_get_h_offset :: (using self: *PathFollow2D) -> float {
}
PathFollow2D_set_v_offset :: (using self: *PathFollow2D, v_offset: float) {
}
PathFollow2D_get_v_offset :: (using self: *PathFollow2D) -> float {
}
PathFollow2D_set_progress_ratio :: (using self: *PathFollow2D, ratio: float) {
}
PathFollow2D_get_progress_ratio :: (using self: *PathFollow2D) -> float {
}
PathFollow2D_set_rotates :: (using self: *PathFollow2D, enabled: bool) {
}
PathFollow2D_is_rotating :: (using self: *PathFollow2D) -> bool {
}
PathFollow2D_set_cubic_interpolation :: (using self: *PathFollow2D, enabled: bool) {
}
PathFollow2D_get_cubic_interpolation :: (using self: *PathFollow2D) -> bool {
}
PathFollow2D_set_loop :: (using self: *PathFollow2D, loop: bool) {
}
PathFollow2D_has_loop :: (using self: *PathFollow2D) -> bool {
}

// PathFollow3D
PathFollow3D :: struct {
	__private: *void;

	RotationMode :: enum {
		ROTATION_NONE :: 0;
		ROTATION_Y :: 1;
		ROTATION_XY :: 2;
		ROTATION_XYZ :: 3;
		ROTATION_ORIENTED :: 4;
	}
}

PathFollow3D_set_progress :: (using self: *PathFollow3D, progress: float) {
}
PathFollow3D_get_progress :: (using self: *PathFollow3D) -> float {
}
PathFollow3D_set_h_offset :: (using self: *PathFollow3D, h_offset: float) {
}
PathFollow3D_get_h_offset :: (using self: *PathFollow3D) -> float {
}
PathFollow3D_set_v_offset :: (using self: *PathFollow3D, v_offset: float) {
}
PathFollow3D_get_v_offset :: (using self: *PathFollow3D) -> float {
}
PathFollow3D_set_progress_ratio :: (using self: *PathFollow3D, ratio: float) {
}
PathFollow3D_get_progress_ratio :: (using self: *PathFollow3D) -> float {
}
PathFollow3D_set_rotation_mode :: (using self: *PathFollow3D, rotation_mode: PathFollow3D.RotationMode) {
}
PathFollow3D_get_rotation_mode :: (using self: *PathFollow3D) -> PathFollow3D.RotationMode {
}
PathFollow3D_set_cubic_interpolation :: (using self: *PathFollow3D, enabled: bool) {
}
PathFollow3D_get_cubic_interpolation :: (using self: *PathFollow3D) -> bool {
}
PathFollow3D_set_use_model_front :: (using self: *PathFollow3D, enabled: bool) {
}
PathFollow3D_is_using_model_front :: (using self: *PathFollow3D) -> bool {
}
PathFollow3D_set_loop :: (using self: *PathFollow3D, loop: bool) {
}
PathFollow3D_has_loop :: (using self: *PathFollow3D) -> bool {
}
PathFollow3D_set_tilt_enabled :: (using self: *PathFollow3D, enabled: bool) {
}
PathFollow3D_is_tilt_enabled :: (using self: *PathFollow3D) -> bool {
}
PathFollow3D_correct_posture :: (using self: *PathFollow3D, transform: Transform3D, rotation_mode: PathFollow3D.RotationMode) -> Transform3D {
}

// Performance
Performance :: struct {
	__private: *void;

	Monitor :: enum {
		TIME_FPS :: 0;
		TIME_PROCESS :: 1;
		TIME_PHYSICS_PROCESS :: 2;
		TIME_NAVIGATION_PROCESS :: 3;
		MEMORY_STATIC :: 4;
		MEMORY_STATIC_MAX :: 5;
		MEMORY_MESSAGE_BUFFER_MAX :: 6;
		OBJECT_COUNT :: 7;
		OBJECT_RESOURCE_COUNT :: 8;
		OBJECT_NODE_COUNT :: 9;
		OBJECT_ORPHAN_NODE_COUNT :: 10;
		RENDER_TOTAL_OBJECTS_IN_FRAME :: 11;
		RENDER_TOTAL_PRIMITIVES_IN_FRAME :: 12;
		RENDER_TOTAL_DRAW_CALLS_IN_FRAME :: 13;
		RENDER_VIDEO_MEM_USED :: 14;
		RENDER_TEXTURE_MEM_USED :: 15;
		RENDER_BUFFER_MEM_USED :: 16;
		PHYSICS_2D_ACTIVE_OBJECTS :: 17;
		PHYSICS_2D_COLLISION_PAIRS :: 18;
		PHYSICS_2D_ISLAND_COUNT :: 19;
		PHYSICS_3D_ACTIVE_OBJECTS :: 20;
		PHYSICS_3D_COLLISION_PAIRS :: 21;
		PHYSICS_3D_ISLAND_COUNT :: 22;
		AUDIO_OUTPUT_LATENCY :: 23;
		NAVIGATION_ACTIVE_MAPS :: 24;
		NAVIGATION_REGION_COUNT :: 25;
		NAVIGATION_AGENT_COUNT :: 26;
		NAVIGATION_LINK_COUNT :: 27;
		NAVIGATION_POLYGON_COUNT :: 28;
		NAVIGATION_EDGE_COUNT :: 29;
		NAVIGATION_EDGE_MERGE_COUNT :: 30;
		NAVIGATION_EDGE_CONNECTION_COUNT :: 31;
		NAVIGATION_EDGE_FREE_COUNT :: 32;
		MONITOR_MAX :: 33;
	}
}

Performance_get_monitor :: (using self: *Performance, monitor: Performance.Monitor) -> float {
}
Performance_add_custom_monitor :: (using self: *Performance, id: StringName, callable: Callable, arguments: Array) {
}
Performance_remove_custom_monitor :: (using self: *Performance, id: StringName) {
}
Performance_has_custom_monitor :: (using self: *Performance, id: StringName) -> bool {
}
Performance_get_custom_monitor :: (using self: *Performance, id: StringName) -> Variant {
}
Performance_get_monitor_modification_time :: (using self: *Performance) -> int {
}
Performance_get_custom_monitor_names :: (using self: *Performance) -> Array {
}

// PhysicalBone2D
PhysicalBone2D :: struct {
	__private: *void;
}

PhysicalBone2D_get_joint :: (using self: *PhysicalBone2D) -> Joint2D {
}
PhysicalBone2D_get_auto_configure_joint :: (using self: *PhysicalBone2D) -> bool {
}
PhysicalBone2D_set_auto_configure_joint :: (using self: *PhysicalBone2D, auto_configure_joint: bool) {
}
PhysicalBone2D_set_simulate_physics :: (using self: *PhysicalBone2D, simulate_physics: bool) {
}
PhysicalBone2D_get_simulate_physics :: (using self: *PhysicalBone2D) -> bool {
}
PhysicalBone2D_is_simulating_physics :: (using self: *PhysicalBone2D) -> bool {
}
PhysicalBone2D_set_bone2d_nodepath :: (using self: *PhysicalBone2D, nodepath: NodePath) {
}
PhysicalBone2D_get_bone2d_nodepath :: (using self: *PhysicalBone2D) -> NodePath {
}
PhysicalBone2D_set_bone2d_index :: (using self: *PhysicalBone2D, bone_index: int) {
}
PhysicalBone2D_get_bone2d_index :: (using self: *PhysicalBone2D) -> int {
}
PhysicalBone2D_set_follow_bone_when_simulating :: (using self: *PhysicalBone2D, follow_bone: bool) {
}
PhysicalBone2D_get_follow_bone_when_simulating :: (using self: *PhysicalBone2D) -> bool {
}

// PhysicalBone3D
PhysicalBone3D :: struct {
	__private: *void;

	DampMode :: enum {
		DAMP_MODE_COMBINE :: 0;
		DAMP_MODE_REPLACE :: 1;
	}
	JointType :: enum {
		JOINT_TYPE_NONE :: 0;
		JOINT_TYPE_PIN :: 1;
		JOINT_TYPE_CONE :: 2;
		JOINT_TYPE_HINGE :: 3;
		JOINT_TYPE_SLIDER :: 4;
		JOINT_TYPE_6DOF :: 5;
	}
}

PhysicalBone3D__integrate_forces :: (using self: *PhysicalBone3D, state: PhysicsDirectBodyState3D) {
}
PhysicalBone3D_apply_central_impulse :: (using self: *PhysicalBone3D, impulse: Vector3) {
}
PhysicalBone3D_apply_impulse :: (using self: *PhysicalBone3D, impulse: Vector3, position: Vector3) {
}
PhysicalBone3D_set_joint_type :: (using self: *PhysicalBone3D, joint_type: PhysicalBone3D.JointType) {
}
PhysicalBone3D_get_joint_type :: (using self: *PhysicalBone3D) -> PhysicalBone3D.JointType {
}
PhysicalBone3D_set_joint_offset :: (using self: *PhysicalBone3D, offset: Transform3D) {
}
PhysicalBone3D_get_joint_offset :: (using self: *PhysicalBone3D) -> Transform3D {
}
PhysicalBone3D_set_joint_rotation :: (using self: *PhysicalBone3D, euler: Vector3) {
}
PhysicalBone3D_get_joint_rotation :: (using self: *PhysicalBone3D) -> Vector3 {
}
PhysicalBone3D_set_body_offset :: (using self: *PhysicalBone3D, offset: Transform3D) {
}
PhysicalBone3D_get_body_offset :: (using self: *PhysicalBone3D) -> Transform3D {
}
PhysicalBone3D_get_simulate_physics :: (using self: *PhysicalBone3D) -> bool {
}
PhysicalBone3D_is_simulating_physics :: (using self: *PhysicalBone3D) -> bool {
}
PhysicalBone3D_get_bone_id :: (using self: *PhysicalBone3D) -> int {
}
PhysicalBone3D_set_mass :: (using self: *PhysicalBone3D, mass: float) {
}
PhysicalBone3D_get_mass :: (using self: *PhysicalBone3D) -> float {
}
PhysicalBone3D_set_friction :: (using self: *PhysicalBone3D, friction: float) {
}
PhysicalBone3D_get_friction :: (using self: *PhysicalBone3D) -> float {
}
PhysicalBone3D_set_bounce :: (using self: *PhysicalBone3D, bounce: float) {
}
PhysicalBone3D_get_bounce :: (using self: *PhysicalBone3D) -> float {
}
PhysicalBone3D_set_gravity_scale :: (using self: *PhysicalBone3D, gravity_scale: float) {
}
PhysicalBone3D_get_gravity_scale :: (using self: *PhysicalBone3D) -> float {
}
PhysicalBone3D_set_linear_damp_mode :: (using self: *PhysicalBone3D, linear_damp_mode: PhysicalBone3D.DampMode) {
}
PhysicalBone3D_get_linear_damp_mode :: (using self: *PhysicalBone3D) -> PhysicalBone3D.DampMode {
}
PhysicalBone3D_set_angular_damp_mode :: (using self: *PhysicalBone3D, angular_damp_mode: PhysicalBone3D.DampMode) {
}
PhysicalBone3D_get_angular_damp_mode :: (using self: *PhysicalBone3D) -> PhysicalBone3D.DampMode {
}
PhysicalBone3D_set_linear_damp :: (using self: *PhysicalBone3D, linear_damp: float) {
}
PhysicalBone3D_get_linear_damp :: (using self: *PhysicalBone3D) -> float {
}
PhysicalBone3D_set_angular_damp :: (using self: *PhysicalBone3D, angular_damp: float) {
}
PhysicalBone3D_get_angular_damp :: (using self: *PhysicalBone3D) -> float {
}
PhysicalBone3D_set_linear_velocity :: (using self: *PhysicalBone3D, linear_velocity: Vector3) {
}
PhysicalBone3D_get_linear_velocity :: (using self: *PhysicalBone3D) -> Vector3 {
}
PhysicalBone3D_set_angular_velocity :: (using self: *PhysicalBone3D, angular_velocity: Vector3) {
}
PhysicalBone3D_get_angular_velocity :: (using self: *PhysicalBone3D) -> Vector3 {
}
PhysicalBone3D_set_use_custom_integrator :: (using self: *PhysicalBone3D, enable: bool) {
}
PhysicalBone3D_is_using_custom_integrator :: (using self: *PhysicalBone3D) -> bool {
}
PhysicalBone3D_set_can_sleep :: (using self: *PhysicalBone3D, able_to_sleep: bool) {
}
PhysicalBone3D_is_able_to_sleep :: (using self: *PhysicalBone3D) -> bool {
}

// PhysicalBoneSimulator3D
PhysicalBoneSimulator3D :: struct {
	__private: *void;
}

PhysicalBoneSimulator3D_is_simulating_physics :: (using self: *PhysicalBoneSimulator3D) -> bool {
}
PhysicalBoneSimulator3D_physical_bones_stop_simulation :: (using self: *PhysicalBoneSimulator3D) {
}
PhysicalBoneSimulator3D_physical_bones_start_simulation :: (using self: *PhysicalBoneSimulator3D, bones: Array) {
}
PhysicalBoneSimulator3D_physical_bones_add_collision_exception :: (using self: *PhysicalBoneSimulator3D, exception: RID) {
}
PhysicalBoneSimulator3D_physical_bones_remove_collision_exception :: (using self: *PhysicalBoneSimulator3D, exception: RID) {
}

// PhysicalSkyMaterial
PhysicalSkyMaterial :: struct {
	__private: *void;
}

PhysicalSkyMaterial_set_rayleigh_coefficient :: (using self: *PhysicalSkyMaterial, rayleigh: float) {
}
PhysicalSkyMaterial_get_rayleigh_coefficient :: (using self: *PhysicalSkyMaterial) -> float {
}
PhysicalSkyMaterial_set_rayleigh_color :: (using self: *PhysicalSkyMaterial, color: Color) {
}
PhysicalSkyMaterial_get_rayleigh_color :: (using self: *PhysicalSkyMaterial) -> Color {
}
PhysicalSkyMaterial_set_mie_coefficient :: (using self: *PhysicalSkyMaterial, mie: float) {
}
PhysicalSkyMaterial_get_mie_coefficient :: (using self: *PhysicalSkyMaterial) -> float {
}
PhysicalSkyMaterial_set_mie_eccentricity :: (using self: *PhysicalSkyMaterial, eccentricity: float) {
}
PhysicalSkyMaterial_get_mie_eccentricity :: (using self: *PhysicalSkyMaterial) -> float {
}
PhysicalSkyMaterial_set_mie_color :: (using self: *PhysicalSkyMaterial, color: Color) {
}
PhysicalSkyMaterial_get_mie_color :: (using self: *PhysicalSkyMaterial) -> Color {
}
PhysicalSkyMaterial_set_turbidity :: (using self: *PhysicalSkyMaterial, turbidity: float) {
}
PhysicalSkyMaterial_get_turbidity :: (using self: *PhysicalSkyMaterial) -> float {
}
PhysicalSkyMaterial_set_sun_disk_scale :: (using self: *PhysicalSkyMaterial, scale: float) {
}
PhysicalSkyMaterial_get_sun_disk_scale :: (using self: *PhysicalSkyMaterial) -> float {
}
PhysicalSkyMaterial_set_ground_color :: (using self: *PhysicalSkyMaterial, color: Color) {
}
PhysicalSkyMaterial_get_ground_color :: (using self: *PhysicalSkyMaterial) -> Color {
}
PhysicalSkyMaterial_set_energy_multiplier :: (using self: *PhysicalSkyMaterial, multiplier: float) {
}
PhysicalSkyMaterial_get_energy_multiplier :: (using self: *PhysicalSkyMaterial) -> float {
}
PhysicalSkyMaterial_set_use_debanding :: (using self: *PhysicalSkyMaterial, use_debanding: bool) {
}
PhysicalSkyMaterial_get_use_debanding :: (using self: *PhysicalSkyMaterial) -> bool {
}
PhysicalSkyMaterial_set_night_sky :: (using self: *PhysicalSkyMaterial, night_sky: Texture2D) {
}
PhysicalSkyMaterial_get_night_sky :: (using self: *PhysicalSkyMaterial) -> Texture2D {
}

// PhysicsBody2D
PhysicsBody2D :: struct {
	__private: *void;
}

PhysicsBody2D_move_and_collide :: (using self: *PhysicsBody2D, motion: Vector2, test_only: bool, safe_margin: float, recovery_as_collision: bool) -> KinematicCollision2D {
}
PhysicsBody2D_test_move :: (using self: *PhysicsBody2D, from: Transform2D, motion: Vector2, collision: KinematicCollision2D, safe_margin: float, recovery_as_collision: bool) -> bool {
}
PhysicsBody2D_get_gravity :: (using self: *PhysicsBody2D) -> Vector2 {
}
PhysicsBody2D_get_collision_exceptions :: (using self: *PhysicsBody2D) -> Array {
}
PhysicsBody2D_add_collision_exception_with :: (using self: *PhysicsBody2D, body: Node) {
}
PhysicsBody2D_remove_collision_exception_with :: (using self: *PhysicsBody2D, body: Node) {
}

// PhysicsBody3D
PhysicsBody3D :: struct {
	__private: *void;
}

PhysicsBody3D_move_and_collide :: (using self: *PhysicsBody3D, motion: Vector3, test_only: bool, safe_margin: float, recovery_as_collision: bool, max_collisions: int) -> KinematicCollision3D {
}
PhysicsBody3D_test_move :: (using self: *PhysicsBody3D, from: Transform3D, motion: Vector3, collision: KinematicCollision3D, safe_margin: float, recovery_as_collision: bool, max_collisions: int) -> bool {
}
PhysicsBody3D_get_gravity :: (using self: *PhysicsBody3D) -> Vector3 {
}
PhysicsBody3D_set_axis_lock :: (using self: *PhysicsBody3D, axis: PhysicsServer3D.BodyAxis, lock: bool) {
}
PhysicsBody3D_get_axis_lock :: (using self: *PhysicsBody3D, axis: PhysicsServer3D.BodyAxis) -> bool {
}
PhysicsBody3D_get_collision_exceptions :: (using self: *PhysicsBody3D) -> Array {
}
PhysicsBody3D_add_collision_exception_with :: (using self: *PhysicsBody3D, body: Node) {
}
PhysicsBody3D_remove_collision_exception_with :: (using self: *PhysicsBody3D, body: Node) {
}

// PhysicsDirectBodyState2D
PhysicsDirectBodyState2D :: struct {
	__private: *void;
}

PhysicsDirectBodyState2D_get_total_gravity :: (using self: *PhysicsDirectBodyState2D) -> Vector2 {
}
PhysicsDirectBodyState2D_get_total_linear_damp :: (using self: *PhysicsDirectBodyState2D) -> float {
}
PhysicsDirectBodyState2D_get_total_angular_damp :: (using self: *PhysicsDirectBodyState2D) -> float {
}
PhysicsDirectBodyState2D_get_center_of_mass :: (using self: *PhysicsDirectBodyState2D) -> Vector2 {
}
PhysicsDirectBodyState2D_get_center_of_mass_local :: (using self: *PhysicsDirectBodyState2D) -> Vector2 {
}
PhysicsDirectBodyState2D_get_inverse_mass :: (using self: *PhysicsDirectBodyState2D) -> float {
}
PhysicsDirectBodyState2D_get_inverse_inertia :: (using self: *PhysicsDirectBodyState2D) -> float {
}
PhysicsDirectBodyState2D_set_linear_velocity :: (using self: *PhysicsDirectBodyState2D, velocity: Vector2) {
}
PhysicsDirectBodyState2D_get_linear_velocity :: (using self: *PhysicsDirectBodyState2D) -> Vector2 {
}
PhysicsDirectBodyState2D_set_angular_velocity :: (using self: *PhysicsDirectBodyState2D, velocity: float) {
}
PhysicsDirectBodyState2D_get_angular_velocity :: (using self: *PhysicsDirectBodyState2D) -> float {
}
PhysicsDirectBodyState2D_set_transform :: (using self: *PhysicsDirectBodyState2D, transform: Transform2D) {
}
PhysicsDirectBodyState2D_get_transform :: (using self: *PhysicsDirectBodyState2D) -> Transform2D {
}
PhysicsDirectBodyState2D_get_velocity_at_local_position :: (using self: *PhysicsDirectBodyState2D, local_position: Vector2) -> Vector2 {
}
PhysicsDirectBodyState2D_apply_central_impulse :: (using self: *PhysicsDirectBodyState2D, impulse: Vector2) {
}
PhysicsDirectBodyState2D_apply_torque_impulse :: (using self: *PhysicsDirectBodyState2D, impulse: float) {
}
PhysicsDirectBodyState2D_apply_impulse :: (using self: *PhysicsDirectBodyState2D, impulse: Vector2, position: Vector2) {
}
PhysicsDirectBodyState2D_apply_central_force :: (using self: *PhysicsDirectBodyState2D, force: Vector2) {
}
PhysicsDirectBodyState2D_apply_force :: (using self: *PhysicsDirectBodyState2D, force: Vector2, position: Vector2) {
}
PhysicsDirectBodyState2D_apply_torque :: (using self: *PhysicsDirectBodyState2D, torque: float) {
}
PhysicsDirectBodyState2D_add_constant_central_force :: (using self: *PhysicsDirectBodyState2D, force: Vector2) {
}
PhysicsDirectBodyState2D_add_constant_force :: (using self: *PhysicsDirectBodyState2D, force: Vector2, position: Vector2) {
}
PhysicsDirectBodyState2D_add_constant_torque :: (using self: *PhysicsDirectBodyState2D, torque: float) {
}
PhysicsDirectBodyState2D_set_constant_force :: (using self: *PhysicsDirectBodyState2D, force: Vector2) {
}
PhysicsDirectBodyState2D_get_constant_force :: (using self: *PhysicsDirectBodyState2D) -> Vector2 {
}
PhysicsDirectBodyState2D_set_constant_torque :: (using self: *PhysicsDirectBodyState2D, torque: float) {
}
PhysicsDirectBodyState2D_get_constant_torque :: (using self: *PhysicsDirectBodyState2D) -> float {
}
PhysicsDirectBodyState2D_set_sleep_state :: (using self: *PhysicsDirectBodyState2D, enabled: bool) {
}
PhysicsDirectBodyState2D_is_sleeping :: (using self: *PhysicsDirectBodyState2D) -> bool {
}
PhysicsDirectBodyState2D_get_contact_count :: (using self: *PhysicsDirectBodyState2D) -> int {
}
PhysicsDirectBodyState2D_get_contact_local_position :: (using self: *PhysicsDirectBodyState2D, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2D_get_contact_local_normal :: (using self: *PhysicsDirectBodyState2D, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2D_get_contact_local_shape :: (using self: *PhysicsDirectBodyState2D, contact_idx: int) -> int {
}
PhysicsDirectBodyState2D_get_contact_local_velocity_at_position :: (using self: *PhysicsDirectBodyState2D, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2D_get_contact_collider :: (using self: *PhysicsDirectBodyState2D, contact_idx: int) -> RID {
}
PhysicsDirectBodyState2D_get_contact_collider_position :: (using self: *PhysicsDirectBodyState2D, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2D_get_contact_collider_id :: (using self: *PhysicsDirectBodyState2D, contact_idx: int) -> int {
}
PhysicsDirectBodyState2D_get_contact_collider_object :: (using self: *PhysicsDirectBodyState2D, contact_idx: int) -> Object {
}
PhysicsDirectBodyState2D_get_contact_collider_shape :: (using self: *PhysicsDirectBodyState2D, contact_idx: int) -> int {
}
PhysicsDirectBodyState2D_get_contact_collider_velocity_at_position :: (using self: *PhysicsDirectBodyState2D, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2D_get_contact_impulse :: (using self: *PhysicsDirectBodyState2D, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2D_get_step :: (using self: *PhysicsDirectBodyState2D) -> float {
}
PhysicsDirectBodyState2D_integrate_forces :: (using self: *PhysicsDirectBodyState2D) {
}
PhysicsDirectBodyState2D_get_space_state :: (using self: *PhysicsDirectBodyState2D) -> PhysicsDirectSpaceState2D {
}

// PhysicsDirectBodyState2DExtension
PhysicsDirectBodyState2DExtension :: struct {
	__private: *void;
}

PhysicsDirectBodyState2DExtension__get_total_gravity :: (using self: *PhysicsDirectBodyState2DExtension) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__get_total_linear_damp :: (using self: *PhysicsDirectBodyState2DExtension) -> float {
}
PhysicsDirectBodyState2DExtension__get_total_angular_damp :: (using self: *PhysicsDirectBodyState2DExtension) -> float {
}
PhysicsDirectBodyState2DExtension__get_center_of_mass :: (using self: *PhysicsDirectBodyState2DExtension) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__get_center_of_mass_local :: (using self: *PhysicsDirectBodyState2DExtension) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__get_inverse_mass :: (using self: *PhysicsDirectBodyState2DExtension) -> float {
}
PhysicsDirectBodyState2DExtension__get_inverse_inertia :: (using self: *PhysicsDirectBodyState2DExtension) -> float {
}
PhysicsDirectBodyState2DExtension__set_linear_velocity :: (using self: *PhysicsDirectBodyState2DExtension, velocity: Vector2) {
}
PhysicsDirectBodyState2DExtension__get_linear_velocity :: (using self: *PhysicsDirectBodyState2DExtension) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__set_angular_velocity :: (using self: *PhysicsDirectBodyState2DExtension, velocity: float) {
}
PhysicsDirectBodyState2DExtension__get_angular_velocity :: (using self: *PhysicsDirectBodyState2DExtension) -> float {
}
PhysicsDirectBodyState2DExtension__set_transform :: (using self: *PhysicsDirectBodyState2DExtension, transform: Transform2D) {
}
PhysicsDirectBodyState2DExtension__get_transform :: (using self: *PhysicsDirectBodyState2DExtension) -> Transform2D {
}
PhysicsDirectBodyState2DExtension__get_velocity_at_local_position :: (using self: *PhysicsDirectBodyState2DExtension, local_position: Vector2) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__apply_central_impulse :: (using self: *PhysicsDirectBodyState2DExtension, impulse: Vector2) {
}
PhysicsDirectBodyState2DExtension__apply_impulse :: (using self: *PhysicsDirectBodyState2DExtension, impulse: Vector2, position: Vector2) {
}
PhysicsDirectBodyState2DExtension__apply_torque_impulse :: (using self: *PhysicsDirectBodyState2DExtension, impulse: float) {
}
PhysicsDirectBodyState2DExtension__apply_central_force :: (using self: *PhysicsDirectBodyState2DExtension, force: Vector2) {
}
PhysicsDirectBodyState2DExtension__apply_force :: (using self: *PhysicsDirectBodyState2DExtension, force: Vector2, position: Vector2) {
}
PhysicsDirectBodyState2DExtension__apply_torque :: (using self: *PhysicsDirectBodyState2DExtension, torque: float) {
}
PhysicsDirectBodyState2DExtension__add_constant_central_force :: (using self: *PhysicsDirectBodyState2DExtension, force: Vector2) {
}
PhysicsDirectBodyState2DExtension__add_constant_force :: (using self: *PhysicsDirectBodyState2DExtension, force: Vector2, position: Vector2) {
}
PhysicsDirectBodyState2DExtension__add_constant_torque :: (using self: *PhysicsDirectBodyState2DExtension, torque: float) {
}
PhysicsDirectBodyState2DExtension__set_constant_force :: (using self: *PhysicsDirectBodyState2DExtension, force: Vector2) {
}
PhysicsDirectBodyState2DExtension__get_constant_force :: (using self: *PhysicsDirectBodyState2DExtension) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__set_constant_torque :: (using self: *PhysicsDirectBodyState2DExtension, torque: float) {
}
PhysicsDirectBodyState2DExtension__get_constant_torque :: (using self: *PhysicsDirectBodyState2DExtension) -> float {
}
PhysicsDirectBodyState2DExtension__set_sleep_state :: (using self: *PhysicsDirectBodyState2DExtension, enabled: bool) {
}
PhysicsDirectBodyState2DExtension__is_sleeping :: (using self: *PhysicsDirectBodyState2DExtension) -> bool {
}
PhysicsDirectBodyState2DExtension__get_contact_count :: (using self: *PhysicsDirectBodyState2DExtension) -> int {
}
PhysicsDirectBodyState2DExtension__get_contact_local_position :: (using self: *PhysicsDirectBodyState2DExtension, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__get_contact_local_normal :: (using self: *PhysicsDirectBodyState2DExtension, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__get_contact_local_shape :: (using self: *PhysicsDirectBodyState2DExtension, contact_idx: int) -> int {
}
PhysicsDirectBodyState2DExtension__get_contact_local_velocity_at_position :: (using self: *PhysicsDirectBodyState2DExtension, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__get_contact_collider :: (using self: *PhysicsDirectBodyState2DExtension, contact_idx: int) -> RID {
}
PhysicsDirectBodyState2DExtension__get_contact_collider_position :: (using self: *PhysicsDirectBodyState2DExtension, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__get_contact_collider_id :: (using self: *PhysicsDirectBodyState2DExtension, contact_idx: int) -> int {
}
PhysicsDirectBodyState2DExtension__get_contact_collider_object :: (using self: *PhysicsDirectBodyState2DExtension, contact_idx: int) -> Object {
}
PhysicsDirectBodyState2DExtension__get_contact_collider_shape :: (using self: *PhysicsDirectBodyState2DExtension, contact_idx: int) -> int {
}
PhysicsDirectBodyState2DExtension__get_contact_collider_velocity_at_position :: (using self: *PhysicsDirectBodyState2DExtension, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__get_contact_impulse :: (using self: *PhysicsDirectBodyState2DExtension, contact_idx: int) -> Vector2 {
}
PhysicsDirectBodyState2DExtension__get_step :: (using self: *PhysicsDirectBodyState2DExtension) -> float {
}
PhysicsDirectBodyState2DExtension__integrate_forces :: (using self: *PhysicsDirectBodyState2DExtension) {
}
PhysicsDirectBodyState2DExtension__get_space_state :: (using self: *PhysicsDirectBodyState2DExtension) -> PhysicsDirectSpaceState2D {
}

// PhysicsDirectBodyState3D
PhysicsDirectBodyState3D :: struct {
	__private: *void;
}

PhysicsDirectBodyState3D_get_total_gravity :: (using self: *PhysicsDirectBodyState3D) -> Vector3 {
}
PhysicsDirectBodyState3D_get_total_linear_damp :: (using self: *PhysicsDirectBodyState3D) -> float {
}
PhysicsDirectBodyState3D_get_total_angular_damp :: (using self: *PhysicsDirectBodyState3D) -> float {
}
PhysicsDirectBodyState3D_get_center_of_mass :: (using self: *PhysicsDirectBodyState3D) -> Vector3 {
}
PhysicsDirectBodyState3D_get_center_of_mass_local :: (using self: *PhysicsDirectBodyState3D) -> Vector3 {
}
PhysicsDirectBodyState3D_get_principal_inertia_axes :: (using self: *PhysicsDirectBodyState3D) -> Basis {
}
PhysicsDirectBodyState3D_get_inverse_mass :: (using self: *PhysicsDirectBodyState3D) -> float {
}
PhysicsDirectBodyState3D_get_inverse_inertia :: (using self: *PhysicsDirectBodyState3D) -> Vector3 {
}
PhysicsDirectBodyState3D_get_inverse_inertia_tensor :: (using self: *PhysicsDirectBodyState3D) -> Basis {
}
PhysicsDirectBodyState3D_set_linear_velocity :: (using self: *PhysicsDirectBodyState3D, velocity: Vector3) {
}
PhysicsDirectBodyState3D_get_linear_velocity :: (using self: *PhysicsDirectBodyState3D) -> Vector3 {
}
PhysicsDirectBodyState3D_set_angular_velocity :: (using self: *PhysicsDirectBodyState3D, velocity: Vector3) {
}
PhysicsDirectBodyState3D_get_angular_velocity :: (using self: *PhysicsDirectBodyState3D) -> Vector3 {
}
PhysicsDirectBodyState3D_set_transform :: (using self: *PhysicsDirectBodyState3D, transform: Transform3D) {
}
PhysicsDirectBodyState3D_get_transform :: (using self: *PhysicsDirectBodyState3D) -> Transform3D {
}
PhysicsDirectBodyState3D_get_velocity_at_local_position :: (using self: *PhysicsDirectBodyState3D, local_position: Vector3) -> Vector3 {
}
PhysicsDirectBodyState3D_apply_central_impulse :: (using self: *PhysicsDirectBodyState3D, impulse: Vector3) {
}
PhysicsDirectBodyState3D_apply_impulse :: (using self: *PhysicsDirectBodyState3D, impulse: Vector3, position: Vector3) {
}
PhysicsDirectBodyState3D_apply_torque_impulse :: (using self: *PhysicsDirectBodyState3D, impulse: Vector3) {
}
PhysicsDirectBodyState3D_apply_central_force :: (using self: *PhysicsDirectBodyState3D, force: Vector3) {
}
PhysicsDirectBodyState3D_apply_force :: (using self: *PhysicsDirectBodyState3D, force: Vector3, position: Vector3) {
}
PhysicsDirectBodyState3D_apply_torque :: (using self: *PhysicsDirectBodyState3D, torque: Vector3) {
}
PhysicsDirectBodyState3D_add_constant_central_force :: (using self: *PhysicsDirectBodyState3D, force: Vector3) {
}
PhysicsDirectBodyState3D_add_constant_force :: (using self: *PhysicsDirectBodyState3D, force: Vector3, position: Vector3) {
}
PhysicsDirectBodyState3D_add_constant_torque :: (using self: *PhysicsDirectBodyState3D, torque: Vector3) {
}
PhysicsDirectBodyState3D_set_constant_force :: (using self: *PhysicsDirectBodyState3D, force: Vector3) {
}
PhysicsDirectBodyState3D_get_constant_force :: (using self: *PhysicsDirectBodyState3D) -> Vector3 {
}
PhysicsDirectBodyState3D_set_constant_torque :: (using self: *PhysicsDirectBodyState3D, torque: Vector3) {
}
PhysicsDirectBodyState3D_get_constant_torque :: (using self: *PhysicsDirectBodyState3D) -> Vector3 {
}
PhysicsDirectBodyState3D_set_sleep_state :: (using self: *PhysicsDirectBodyState3D, enabled: bool) {
}
PhysicsDirectBodyState3D_is_sleeping :: (using self: *PhysicsDirectBodyState3D) -> bool {
}
PhysicsDirectBodyState3D_get_contact_count :: (using self: *PhysicsDirectBodyState3D) -> int {
}
PhysicsDirectBodyState3D_get_contact_local_position :: (using self: *PhysicsDirectBodyState3D, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3D_get_contact_local_normal :: (using self: *PhysicsDirectBodyState3D, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3D_get_contact_impulse :: (using self: *PhysicsDirectBodyState3D, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3D_get_contact_local_shape :: (using self: *PhysicsDirectBodyState3D, contact_idx: int) -> int {
}
PhysicsDirectBodyState3D_get_contact_local_velocity_at_position :: (using self: *PhysicsDirectBodyState3D, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3D_get_contact_collider :: (using self: *PhysicsDirectBodyState3D, contact_idx: int) -> RID {
}
PhysicsDirectBodyState3D_get_contact_collider_position :: (using self: *PhysicsDirectBodyState3D, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3D_get_contact_collider_id :: (using self: *PhysicsDirectBodyState3D, contact_idx: int) -> int {
}
PhysicsDirectBodyState3D_get_contact_collider_object :: (using self: *PhysicsDirectBodyState3D, contact_idx: int) -> Object {
}
PhysicsDirectBodyState3D_get_contact_collider_shape :: (using self: *PhysicsDirectBodyState3D, contact_idx: int) -> int {
}
PhysicsDirectBodyState3D_get_contact_collider_velocity_at_position :: (using self: *PhysicsDirectBodyState3D, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3D_get_step :: (using self: *PhysicsDirectBodyState3D) -> float {
}
PhysicsDirectBodyState3D_integrate_forces :: (using self: *PhysicsDirectBodyState3D) {
}
PhysicsDirectBodyState3D_get_space_state :: (using self: *PhysicsDirectBodyState3D) -> PhysicsDirectSpaceState3D {
}

// PhysicsDirectBodyState3DExtension
PhysicsDirectBodyState3DExtension :: struct {
	__private: *void;
}

PhysicsDirectBodyState3DExtension__get_total_gravity :: (using self: *PhysicsDirectBodyState3DExtension) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__get_total_linear_damp :: (using self: *PhysicsDirectBodyState3DExtension) -> float {
}
PhysicsDirectBodyState3DExtension__get_total_angular_damp :: (using self: *PhysicsDirectBodyState3DExtension) -> float {
}
PhysicsDirectBodyState3DExtension__get_center_of_mass :: (using self: *PhysicsDirectBodyState3DExtension) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__get_center_of_mass_local :: (using self: *PhysicsDirectBodyState3DExtension) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__get_principal_inertia_axes :: (using self: *PhysicsDirectBodyState3DExtension) -> Basis {
}
PhysicsDirectBodyState3DExtension__get_inverse_mass :: (using self: *PhysicsDirectBodyState3DExtension) -> float {
}
PhysicsDirectBodyState3DExtension__get_inverse_inertia :: (using self: *PhysicsDirectBodyState3DExtension) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__get_inverse_inertia_tensor :: (using self: *PhysicsDirectBodyState3DExtension) -> Basis {
}
PhysicsDirectBodyState3DExtension__set_linear_velocity :: (using self: *PhysicsDirectBodyState3DExtension, velocity: Vector3) {
}
PhysicsDirectBodyState3DExtension__get_linear_velocity :: (using self: *PhysicsDirectBodyState3DExtension) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__set_angular_velocity :: (using self: *PhysicsDirectBodyState3DExtension, velocity: Vector3) {
}
PhysicsDirectBodyState3DExtension__get_angular_velocity :: (using self: *PhysicsDirectBodyState3DExtension) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__set_transform :: (using self: *PhysicsDirectBodyState3DExtension, transform: Transform3D) {
}
PhysicsDirectBodyState3DExtension__get_transform :: (using self: *PhysicsDirectBodyState3DExtension) -> Transform3D {
}
PhysicsDirectBodyState3DExtension__get_velocity_at_local_position :: (using self: *PhysicsDirectBodyState3DExtension, local_position: Vector3) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__apply_central_impulse :: (using self: *PhysicsDirectBodyState3DExtension, impulse: Vector3) {
}
PhysicsDirectBodyState3DExtension__apply_impulse :: (using self: *PhysicsDirectBodyState3DExtension, impulse: Vector3, position: Vector3) {
}
PhysicsDirectBodyState3DExtension__apply_torque_impulse :: (using self: *PhysicsDirectBodyState3DExtension, impulse: Vector3) {
}
PhysicsDirectBodyState3DExtension__apply_central_force :: (using self: *PhysicsDirectBodyState3DExtension, force: Vector3) {
}
PhysicsDirectBodyState3DExtension__apply_force :: (using self: *PhysicsDirectBodyState3DExtension, force: Vector3, position: Vector3) {
}
PhysicsDirectBodyState3DExtension__apply_torque :: (using self: *PhysicsDirectBodyState3DExtension, torque: Vector3) {
}
PhysicsDirectBodyState3DExtension__add_constant_central_force :: (using self: *PhysicsDirectBodyState3DExtension, force: Vector3) {
}
PhysicsDirectBodyState3DExtension__add_constant_force :: (using self: *PhysicsDirectBodyState3DExtension, force: Vector3, position: Vector3) {
}
PhysicsDirectBodyState3DExtension__add_constant_torque :: (using self: *PhysicsDirectBodyState3DExtension, torque: Vector3) {
}
PhysicsDirectBodyState3DExtension__set_constant_force :: (using self: *PhysicsDirectBodyState3DExtension, force: Vector3) {
}
PhysicsDirectBodyState3DExtension__get_constant_force :: (using self: *PhysicsDirectBodyState3DExtension) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__set_constant_torque :: (using self: *PhysicsDirectBodyState3DExtension, torque: Vector3) {
}
PhysicsDirectBodyState3DExtension__get_constant_torque :: (using self: *PhysicsDirectBodyState3DExtension) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__set_sleep_state :: (using self: *PhysicsDirectBodyState3DExtension, enabled: bool) {
}
PhysicsDirectBodyState3DExtension__is_sleeping :: (using self: *PhysicsDirectBodyState3DExtension) -> bool {
}
PhysicsDirectBodyState3DExtension__get_contact_count :: (using self: *PhysicsDirectBodyState3DExtension) -> int {
}
PhysicsDirectBodyState3DExtension__get_contact_local_position :: (using self: *PhysicsDirectBodyState3DExtension, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__get_contact_local_normal :: (using self: *PhysicsDirectBodyState3DExtension, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__get_contact_impulse :: (using self: *PhysicsDirectBodyState3DExtension, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__get_contact_local_shape :: (using self: *PhysicsDirectBodyState3DExtension, contact_idx: int) -> int {
}
PhysicsDirectBodyState3DExtension__get_contact_local_velocity_at_position :: (using self: *PhysicsDirectBodyState3DExtension, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__get_contact_collider :: (using self: *PhysicsDirectBodyState3DExtension, contact_idx: int) -> RID {
}
PhysicsDirectBodyState3DExtension__get_contact_collider_position :: (using self: *PhysicsDirectBodyState3DExtension, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__get_contact_collider_id :: (using self: *PhysicsDirectBodyState3DExtension, contact_idx: int) -> int {
}
PhysicsDirectBodyState3DExtension__get_contact_collider_object :: (using self: *PhysicsDirectBodyState3DExtension, contact_idx: int) -> Object {
}
PhysicsDirectBodyState3DExtension__get_contact_collider_shape :: (using self: *PhysicsDirectBodyState3DExtension, contact_idx: int) -> int {
}
PhysicsDirectBodyState3DExtension__get_contact_collider_velocity_at_position :: (using self: *PhysicsDirectBodyState3DExtension, contact_idx: int) -> Vector3 {
}
PhysicsDirectBodyState3DExtension__get_step :: (using self: *PhysicsDirectBodyState3DExtension) -> float {
}
PhysicsDirectBodyState3DExtension__integrate_forces :: (using self: *PhysicsDirectBodyState3DExtension) {
}
PhysicsDirectBodyState3DExtension__get_space_state :: (using self: *PhysicsDirectBodyState3DExtension) -> PhysicsDirectSpaceState3D {
}

// PhysicsDirectSpaceState2D
PhysicsDirectSpaceState2D :: struct {
	__private: *void;
}

PhysicsDirectSpaceState2D_intersect_point :: (using self: *PhysicsDirectSpaceState2D, parameters: PhysicsPointQueryParameters2D, max_results: int) -> Dictionary {
}
PhysicsDirectSpaceState2D_intersect_ray :: (using self: *PhysicsDirectSpaceState2D, parameters: PhysicsRayQueryParameters2D) -> Dictionary {
}
PhysicsDirectSpaceState2D_intersect_shape :: (using self: *PhysicsDirectSpaceState2D, parameters: PhysicsShapeQueryParameters2D, max_results: int) -> Dictionary {
}
PhysicsDirectSpaceState2D_cast_motion :: (using self: *PhysicsDirectSpaceState2D, parameters: PhysicsShapeQueryParameters2D) -> PackedFloat32Array {
}
PhysicsDirectSpaceState2D_collide_shape :: (using self: *PhysicsDirectSpaceState2D, parameters: PhysicsShapeQueryParameters2D, max_results: int) -> Array {
}
PhysicsDirectSpaceState2D_get_rest_info :: (using self: *PhysicsDirectSpaceState2D, parameters: PhysicsShapeQueryParameters2D) -> Dictionary {
}

// PhysicsDirectSpaceState2DExtension
PhysicsDirectSpaceState2DExtension :: struct {
	__private: *void;
}

PhysicsDirectSpaceState2DExtension__intersect_ray :: (using self: *PhysicsDirectSpaceState2DExtension, from: Vector2, to: Vector2, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, hit_from_inside: bool, result: *PhysicsServer2DExtensionRayResult) -> bool {
}
PhysicsDirectSpaceState2DExtension__intersect_point :: (using self: *PhysicsDirectSpaceState2DExtension, position: Vector2, canvas_instance_id: int, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, results: *PhysicsServer2DExtensionShapeResult, max_results: int) -> int {
}
PhysicsDirectSpaceState2DExtension__intersect_shape :: (using self: *PhysicsDirectSpaceState2DExtension, shape_rid: RID, transform: Transform2D, motion: Vector2, margin: float, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, result: *PhysicsServer2DExtensionShapeResult, max_results: int) -> int {
}
PhysicsDirectSpaceState2DExtension__cast_motion :: (using self: *PhysicsDirectSpaceState2DExtension, shape_rid: RID, transform: Transform2D, motion: Vector2, margin: float, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, closest_safe: *float, closest_unsafe: *float) -> bool {
}
PhysicsDirectSpaceState2DExtension__collide_shape :: (using self: *PhysicsDirectSpaceState2DExtension, shape_rid: RID, transform: Transform2D, motion: Vector2, margin: float, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, results: *void, max_results: int, result_count: *s32) -> bool {
}
PhysicsDirectSpaceState2DExtension__rest_info :: (using self: *PhysicsDirectSpaceState2DExtension, shape_rid: RID, transform: Transform2D, motion: Vector2, margin: float, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, rest_info: *PhysicsServer2DExtensionShapeRestInfo) -> bool {
}
PhysicsDirectSpaceState2DExtension_is_body_excluded_from_query :: (using self: *PhysicsDirectSpaceState2DExtension, body: RID) -> bool {
}

// PhysicsDirectSpaceState3D
PhysicsDirectSpaceState3D :: struct {
	__private: *void;
}

PhysicsDirectSpaceState3D_intersect_point :: (using self: *PhysicsDirectSpaceState3D, parameters: PhysicsPointQueryParameters3D, max_results: int) -> Dictionary {
}
PhysicsDirectSpaceState3D_intersect_ray :: (using self: *PhysicsDirectSpaceState3D, parameters: PhysicsRayQueryParameters3D) -> Dictionary {
}
PhysicsDirectSpaceState3D_intersect_shape :: (using self: *PhysicsDirectSpaceState3D, parameters: PhysicsShapeQueryParameters3D, max_results: int) -> Dictionary {
}
PhysicsDirectSpaceState3D_cast_motion :: (using self: *PhysicsDirectSpaceState3D, parameters: PhysicsShapeQueryParameters3D) -> PackedFloat32Array {
}
PhysicsDirectSpaceState3D_collide_shape :: (using self: *PhysicsDirectSpaceState3D, parameters: PhysicsShapeQueryParameters3D, max_results: int) -> Array {
}
PhysicsDirectSpaceState3D_get_rest_info :: (using self: *PhysicsDirectSpaceState3D, parameters: PhysicsShapeQueryParameters3D) -> Dictionary {
}

// PhysicsDirectSpaceState3DExtension
PhysicsDirectSpaceState3DExtension :: struct {
	__private: *void;
}

PhysicsDirectSpaceState3DExtension__intersect_ray :: (using self: *PhysicsDirectSpaceState3DExtension, from: Vector3, to: Vector3, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, hit_from_inside: bool, hit_back_faces: bool, pick_ray: bool, result: *PhysicsServer3DExtensionRayResult) -> bool {
}
PhysicsDirectSpaceState3DExtension__intersect_point :: (using self: *PhysicsDirectSpaceState3DExtension, position: Vector3, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, results: *PhysicsServer3DExtensionShapeResult, max_results: int) -> int {
}
PhysicsDirectSpaceState3DExtension__intersect_shape :: (using self: *PhysicsDirectSpaceState3DExtension, shape_rid: RID, transform: Transform3D, motion: Vector3, margin: float, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, result_count: *PhysicsServer3DExtensionShapeResult, max_results: int) -> int {
}
PhysicsDirectSpaceState3DExtension__cast_motion :: (using self: *PhysicsDirectSpaceState3DExtension, shape_rid: RID, transform: Transform3D, motion: Vector3, margin: float, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, closest_safe: *float, closest_unsafe: *float, info: *PhysicsServer3DExtensionShapeRestInfo) -> bool {
}
PhysicsDirectSpaceState3DExtension__collide_shape :: (using self: *PhysicsDirectSpaceState3DExtension, shape_rid: RID, transform: Transform3D, motion: Vector3, margin: float, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, results: *void, max_results: int, result_count: *s32) -> bool {
}
PhysicsDirectSpaceState3DExtension__rest_info :: (using self: *PhysicsDirectSpaceState3DExtension, shape_rid: RID, transform: Transform3D, motion: Vector3, margin: float, collision_mask: int, collide_with_bodies: bool, collide_with_areas: bool, rest_info: *PhysicsServer3DExtensionShapeRestInfo) -> bool {
}
PhysicsDirectSpaceState3DExtension__get_closest_point_to_object_volume :: (using self: *PhysicsDirectSpaceState3DExtension, object: RID, point: Vector3) -> Vector3 {
}
PhysicsDirectSpaceState3DExtension_is_body_excluded_from_query :: (using self: *PhysicsDirectSpaceState3DExtension, body: RID) -> bool {
}

// PhysicsMaterial
PhysicsMaterial :: struct {
	__private: *void;
}

PhysicsMaterial_set_friction :: (using self: *PhysicsMaterial, friction: float) {
}
PhysicsMaterial_get_friction :: (using self: *PhysicsMaterial) -> float {
}
PhysicsMaterial_set_rough :: (using self: *PhysicsMaterial, rough: bool) {
}
PhysicsMaterial_is_rough :: (using self: *PhysicsMaterial) -> bool {
}
PhysicsMaterial_set_bounce :: (using self: *PhysicsMaterial, bounce: float) {
}
PhysicsMaterial_get_bounce :: (using self: *PhysicsMaterial) -> float {
}
PhysicsMaterial_set_absorbent :: (using self: *PhysicsMaterial, absorbent: bool) {
}
PhysicsMaterial_is_absorbent :: (using self: *PhysicsMaterial) -> bool {
}

// PhysicsPointQueryParameters2D
PhysicsPointQueryParameters2D :: struct {
	__private: *void;
}

PhysicsPointQueryParameters2D_set_position :: (using self: *PhysicsPointQueryParameters2D, position: Vector2) {
}
PhysicsPointQueryParameters2D_get_position :: (using self: *PhysicsPointQueryParameters2D) -> Vector2 {
}
PhysicsPointQueryParameters2D_set_canvas_instance_id :: (using self: *PhysicsPointQueryParameters2D, canvas_instance_id: int) {
}
PhysicsPointQueryParameters2D_get_canvas_instance_id :: (using self: *PhysicsPointQueryParameters2D) -> int {
}
PhysicsPointQueryParameters2D_set_collision_mask :: (using self: *PhysicsPointQueryParameters2D, collision_mask: int) {
}
PhysicsPointQueryParameters2D_get_collision_mask :: (using self: *PhysicsPointQueryParameters2D) -> int {
}
PhysicsPointQueryParameters2D_set_exclude :: (using self: *PhysicsPointQueryParameters2D, exclude: Array) {
}
PhysicsPointQueryParameters2D_get_exclude :: (using self: *PhysicsPointQueryParameters2D) -> Array {
}
PhysicsPointQueryParameters2D_set_collide_with_bodies :: (using self: *PhysicsPointQueryParameters2D, enable: bool) {
}
PhysicsPointQueryParameters2D_is_collide_with_bodies_enabled :: (using self: *PhysicsPointQueryParameters2D) -> bool {
}
PhysicsPointQueryParameters2D_set_collide_with_areas :: (using self: *PhysicsPointQueryParameters2D, enable: bool) {
}
PhysicsPointQueryParameters2D_is_collide_with_areas_enabled :: (using self: *PhysicsPointQueryParameters2D) -> bool {
}

// PhysicsPointQueryParameters3D
PhysicsPointQueryParameters3D :: struct {
	__private: *void;
}

PhysicsPointQueryParameters3D_set_position :: (using self: *PhysicsPointQueryParameters3D, position: Vector3) {
}
PhysicsPointQueryParameters3D_get_position :: (using self: *PhysicsPointQueryParameters3D) -> Vector3 {
}
PhysicsPointQueryParameters3D_set_collision_mask :: (using self: *PhysicsPointQueryParameters3D, collision_mask: int) {
}
PhysicsPointQueryParameters3D_get_collision_mask :: (using self: *PhysicsPointQueryParameters3D) -> int {
}
PhysicsPointQueryParameters3D_set_exclude :: (using self: *PhysicsPointQueryParameters3D, exclude: Array) {
}
PhysicsPointQueryParameters3D_get_exclude :: (using self: *PhysicsPointQueryParameters3D) -> Array {
}
PhysicsPointQueryParameters3D_set_collide_with_bodies :: (using self: *PhysicsPointQueryParameters3D, enable: bool) {
}
PhysicsPointQueryParameters3D_is_collide_with_bodies_enabled :: (using self: *PhysicsPointQueryParameters3D) -> bool {
}
PhysicsPointQueryParameters3D_set_collide_with_areas :: (using self: *PhysicsPointQueryParameters3D, enable: bool) {
}
PhysicsPointQueryParameters3D_is_collide_with_areas_enabled :: (using self: *PhysicsPointQueryParameters3D) -> bool {
}

// PhysicsRayQueryParameters2D
PhysicsRayQueryParameters2D :: struct {
	__private: *void;
}

PhysicsRayQueryParameters2D_create :: (using self: *PhysicsRayQueryParameters2D, from: Vector2, to: Vector2, collision_mask: int, exclude: Array) -> PhysicsRayQueryParameters2D {
}
PhysicsRayQueryParameters2D_set_from :: (using self: *PhysicsRayQueryParameters2D, from: Vector2) {
}
PhysicsRayQueryParameters2D_get_from :: (using self: *PhysicsRayQueryParameters2D) -> Vector2 {
}
PhysicsRayQueryParameters2D_set_to :: (using self: *PhysicsRayQueryParameters2D, to: Vector2) {
}
PhysicsRayQueryParameters2D_get_to :: (using self: *PhysicsRayQueryParameters2D) -> Vector2 {
}
PhysicsRayQueryParameters2D_set_collision_mask :: (using self: *PhysicsRayQueryParameters2D, collision_mask: int) {
}
PhysicsRayQueryParameters2D_get_collision_mask :: (using self: *PhysicsRayQueryParameters2D) -> int {
}
PhysicsRayQueryParameters2D_set_exclude :: (using self: *PhysicsRayQueryParameters2D, exclude: Array) {
}
PhysicsRayQueryParameters2D_get_exclude :: (using self: *PhysicsRayQueryParameters2D) -> Array {
}
PhysicsRayQueryParameters2D_set_collide_with_bodies :: (using self: *PhysicsRayQueryParameters2D, enable: bool) {
}
PhysicsRayQueryParameters2D_is_collide_with_bodies_enabled :: (using self: *PhysicsRayQueryParameters2D) -> bool {
}
PhysicsRayQueryParameters2D_set_collide_with_areas :: (using self: *PhysicsRayQueryParameters2D, enable: bool) {
}
PhysicsRayQueryParameters2D_is_collide_with_areas_enabled :: (using self: *PhysicsRayQueryParameters2D) -> bool {
}
PhysicsRayQueryParameters2D_set_hit_from_inside :: (using self: *PhysicsRayQueryParameters2D, enable: bool) {
}
PhysicsRayQueryParameters2D_is_hit_from_inside_enabled :: (using self: *PhysicsRayQueryParameters2D) -> bool {
}

// PhysicsRayQueryParameters3D
PhysicsRayQueryParameters3D :: struct {
	__private: *void;
}

PhysicsRayQueryParameters3D_create :: (using self: *PhysicsRayQueryParameters3D, from: Vector3, to: Vector3, collision_mask: int, exclude: Array) -> PhysicsRayQueryParameters3D {
}
PhysicsRayQueryParameters3D_set_from :: (using self: *PhysicsRayQueryParameters3D, from: Vector3) {
}
PhysicsRayQueryParameters3D_get_from :: (using self: *PhysicsRayQueryParameters3D) -> Vector3 {
}
PhysicsRayQueryParameters3D_set_to :: (using self: *PhysicsRayQueryParameters3D, to: Vector3) {
}
PhysicsRayQueryParameters3D_get_to :: (using self: *PhysicsRayQueryParameters3D) -> Vector3 {
}
PhysicsRayQueryParameters3D_set_collision_mask :: (using self: *PhysicsRayQueryParameters3D, collision_mask: int) {
}
PhysicsRayQueryParameters3D_get_collision_mask :: (using self: *PhysicsRayQueryParameters3D) -> int {
}
PhysicsRayQueryParameters3D_set_exclude :: (using self: *PhysicsRayQueryParameters3D, exclude: Array) {
}
PhysicsRayQueryParameters3D_get_exclude :: (using self: *PhysicsRayQueryParameters3D) -> Array {
}
PhysicsRayQueryParameters3D_set_collide_with_bodies :: (using self: *PhysicsRayQueryParameters3D, enable: bool) {
}
PhysicsRayQueryParameters3D_is_collide_with_bodies_enabled :: (using self: *PhysicsRayQueryParameters3D) -> bool {
}
PhysicsRayQueryParameters3D_set_collide_with_areas :: (using self: *PhysicsRayQueryParameters3D, enable: bool) {
}
PhysicsRayQueryParameters3D_is_collide_with_areas_enabled :: (using self: *PhysicsRayQueryParameters3D) -> bool {
}
PhysicsRayQueryParameters3D_set_hit_from_inside :: (using self: *PhysicsRayQueryParameters3D, enable: bool) {
}
PhysicsRayQueryParameters3D_is_hit_from_inside_enabled :: (using self: *PhysicsRayQueryParameters3D) -> bool {
}
PhysicsRayQueryParameters3D_set_hit_back_faces :: (using self: *PhysicsRayQueryParameters3D, enable: bool) {
}
PhysicsRayQueryParameters3D_is_hit_back_faces_enabled :: (using self: *PhysicsRayQueryParameters3D) -> bool {
}

// PhysicsServer2D
PhysicsServer2D :: struct {
	__private: *void;

	SpaceParameter :: enum {
		SPACE_PARAM_CONTACT_RECYCLE_RADIUS :: 0;
		SPACE_PARAM_CONTACT_MAX_SEPARATION :: 1;
		SPACE_PARAM_CONTACT_MAX_ALLOWED_PENETRATION :: 2;
		SPACE_PARAM_CONTACT_DEFAULT_BIAS :: 3;
		SPACE_PARAM_BODY_LINEAR_VELOCITY_SLEEP_THRESHOLD :: 4;
		SPACE_PARAM_BODY_ANGULAR_VELOCITY_SLEEP_THRESHOLD :: 5;
		SPACE_PARAM_BODY_TIME_TO_SLEEP :: 6;
		SPACE_PARAM_CONSTRAINT_DEFAULT_BIAS :: 7;
		SPACE_PARAM_SOLVER_ITERATIONS :: 8;
	}
	ShapeType :: enum {
		SHAPE_WORLD_BOUNDARY :: 0;
		SHAPE_SEPARATION_RAY :: 1;
		SHAPE_SEGMENT :: 2;
		SHAPE_CIRCLE :: 3;
		SHAPE_RECTANGLE :: 4;
		SHAPE_CAPSULE :: 5;
		SHAPE_CONVEX_POLYGON :: 6;
		SHAPE_CONCAVE_POLYGON :: 7;
		SHAPE_CUSTOM :: 8;
	}
	AreaParameter :: enum {
		AREA_PARAM_GRAVITY_OVERRIDE_MODE :: 0;
		AREA_PARAM_GRAVITY :: 1;
		AREA_PARAM_GRAVITY_VECTOR :: 2;
		AREA_PARAM_GRAVITY_IS_POINT :: 3;
		AREA_PARAM_GRAVITY_POINT_UNIT_DISTANCE :: 4;
		AREA_PARAM_LINEAR_DAMP_OVERRIDE_MODE :: 5;
		AREA_PARAM_LINEAR_DAMP :: 6;
		AREA_PARAM_ANGULAR_DAMP_OVERRIDE_MODE :: 7;
		AREA_PARAM_ANGULAR_DAMP :: 8;
		AREA_PARAM_PRIORITY :: 9;
	}
	AreaSpaceOverrideMode :: enum {
		AREA_SPACE_OVERRIDE_DISABLED :: 0;
		AREA_SPACE_OVERRIDE_COMBINE :: 1;
		AREA_SPACE_OVERRIDE_COMBINE_REPLACE :: 2;
		AREA_SPACE_OVERRIDE_REPLACE :: 3;
		AREA_SPACE_OVERRIDE_REPLACE_COMBINE :: 4;
	}
	BodyMode :: enum {
		BODY_MODE_STATIC :: 0;
		BODY_MODE_KINEMATIC :: 1;
		BODY_MODE_RIGID :: 2;
		BODY_MODE_RIGID_LINEAR :: 3;
	}
	BodyParameter :: enum {
		BODY_PARAM_BOUNCE :: 0;
		BODY_PARAM_FRICTION :: 1;
		BODY_PARAM_MASS :: 2;
		BODY_PARAM_INERTIA :: 3;
		BODY_PARAM_CENTER_OF_MASS :: 4;
		BODY_PARAM_GRAVITY_SCALE :: 5;
		BODY_PARAM_LINEAR_DAMP_MODE :: 6;
		BODY_PARAM_ANGULAR_DAMP_MODE :: 7;
		BODY_PARAM_LINEAR_DAMP :: 8;
		BODY_PARAM_ANGULAR_DAMP :: 9;
		BODY_PARAM_MAX :: 10;
	}
	BodyDampMode :: enum {
		BODY_DAMP_MODE_COMBINE :: 0;
		BODY_DAMP_MODE_REPLACE :: 1;
	}
	BodyState :: enum {
		BODY_STATE_TRANSFORM :: 0;
		BODY_STATE_LINEAR_VELOCITY :: 1;
		BODY_STATE_ANGULAR_VELOCITY :: 2;
		BODY_STATE_SLEEPING :: 3;
		BODY_STATE_CAN_SLEEP :: 4;
	}
	JointType :: enum {
		JOINT_TYPE_PIN :: 0;
		JOINT_TYPE_GROOVE :: 1;
		JOINT_TYPE_DAMPED_SPRING :: 2;
		JOINT_TYPE_MAX :: 3;
	}
	JointParam :: enum {
		JOINT_PARAM_BIAS :: 0;
		JOINT_PARAM_MAX_BIAS :: 1;
		JOINT_PARAM_MAX_FORCE :: 2;
	}
	PinJointParam :: enum {
		PIN_JOINT_SOFTNESS :: 0;
		PIN_JOINT_LIMIT_UPPER :: 1;
		PIN_JOINT_LIMIT_LOWER :: 2;
		PIN_JOINT_MOTOR_TARGET_VELOCITY :: 3;
	}
	PinJointFlag :: enum {
		PIN_JOINT_FLAG_ANGULAR_LIMIT_ENABLED :: 0;
		PIN_JOINT_FLAG_MOTOR_ENABLED :: 1;
	}
	DampedSpringParam :: enum {
		DAMPED_SPRING_REST_LENGTH :: 0;
		DAMPED_SPRING_STIFFNESS :: 1;
		DAMPED_SPRING_DAMPING :: 2;
	}
	CCDMode :: enum {
		CCD_MODE_DISABLED :: 0;
		CCD_MODE_CAST_RAY :: 1;
		CCD_MODE_CAST_SHAPE :: 2;
	}
	AreaBodyStatus :: enum {
		AREA_BODY_ADDED :: 0;
		AREA_BODY_REMOVED :: 1;
	}
	ProcessInfo :: enum {
		INFO_ACTIVE_OBJECTS :: 0;
		INFO_COLLISION_PAIRS :: 1;
		INFO_ISLAND_COUNT :: 2;
	}
}

PhysicsServer2D_world_boundary_shape_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_separation_ray_shape_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_segment_shape_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_circle_shape_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_rectangle_shape_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_capsule_shape_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_convex_polygon_shape_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_concave_polygon_shape_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_shape_set_data :: (using self: *PhysicsServer2D, shape: RID, data: Variant) {
}
PhysicsServer2D_shape_get_type :: (using self: *PhysicsServer2D, shape: RID) -> PhysicsServer2D.ShapeType {
}
PhysicsServer2D_shape_get_data :: (using self: *PhysicsServer2D, shape: RID) -> Variant {
}
PhysicsServer2D_space_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_space_set_active :: (using self: *PhysicsServer2D, space: RID, active: bool) {
}
PhysicsServer2D_space_is_active :: (using self: *PhysicsServer2D, space: RID) -> bool {
}
PhysicsServer2D_space_set_param :: (using self: *PhysicsServer2D, space: RID, param: PhysicsServer2D.SpaceParameter, value: float) {
}
PhysicsServer2D_space_get_param :: (using self: *PhysicsServer2D, space: RID, param: PhysicsServer2D.SpaceParameter) -> float {
}
PhysicsServer2D_space_get_direct_state :: (using self: *PhysicsServer2D, space: RID) -> PhysicsDirectSpaceState2D {
}
PhysicsServer2D_area_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_area_set_space :: (using self: *PhysicsServer2D, area: RID, space: RID) {
}
PhysicsServer2D_area_get_space :: (using self: *PhysicsServer2D, area: RID) -> RID {
}
PhysicsServer2D_area_add_shape :: (using self: *PhysicsServer2D, area: RID, shape: RID, transform: Transform2D, disabled: bool) {
}
PhysicsServer2D_area_set_shape :: (using self: *PhysicsServer2D, area: RID, shape_idx: int, shape: RID) {
}
PhysicsServer2D_area_set_shape_transform :: (using self: *PhysicsServer2D, area: RID, shape_idx: int, transform: Transform2D) {
}
PhysicsServer2D_area_set_shape_disabled :: (using self: *PhysicsServer2D, area: RID, shape_idx: int, disabled: bool) {
}
PhysicsServer2D_area_get_shape_count :: (using self: *PhysicsServer2D, area: RID) -> int {
}
PhysicsServer2D_area_get_shape :: (using self: *PhysicsServer2D, area: RID, shape_idx: int) -> RID {
}
PhysicsServer2D_area_get_shape_transform :: (using self: *PhysicsServer2D, area: RID, shape_idx: int) -> Transform2D {
}
PhysicsServer2D_area_remove_shape :: (using self: *PhysicsServer2D, area: RID, shape_idx: int) {
}
PhysicsServer2D_area_clear_shapes :: (using self: *PhysicsServer2D, area: RID) {
}
PhysicsServer2D_area_set_collision_layer :: (using self: *PhysicsServer2D, area: RID, layer: int) {
}
PhysicsServer2D_area_get_collision_layer :: (using self: *PhysicsServer2D, area: RID) -> int {
}
PhysicsServer2D_area_set_collision_mask :: (using self: *PhysicsServer2D, area: RID, mask: int) {
}
PhysicsServer2D_area_get_collision_mask :: (using self: *PhysicsServer2D, area: RID) -> int {
}
PhysicsServer2D_area_set_param :: (using self: *PhysicsServer2D, area: RID, param: PhysicsServer2D.AreaParameter, value: Variant) {
}
PhysicsServer2D_area_set_transform :: (using self: *PhysicsServer2D, area: RID, transform: Transform2D) {
}
PhysicsServer2D_area_get_param :: (using self: *PhysicsServer2D, area: RID, param: PhysicsServer2D.AreaParameter) -> Variant {
}
PhysicsServer2D_area_get_transform :: (using self: *PhysicsServer2D, area: RID) -> Transform2D {
}
PhysicsServer2D_area_attach_object_instance_id :: (using self: *PhysicsServer2D, area: RID, id: int) {
}
PhysicsServer2D_area_get_object_instance_id :: (using self: *PhysicsServer2D, area: RID) -> int {
}
PhysicsServer2D_area_attach_canvas_instance_id :: (using self: *PhysicsServer2D, area: RID, id: int) {
}
PhysicsServer2D_area_get_canvas_instance_id :: (using self: *PhysicsServer2D, area: RID) -> int {
}
PhysicsServer2D_area_set_monitor_callback :: (using self: *PhysicsServer2D, area: RID, callback: Callable) {
}
PhysicsServer2D_area_set_area_monitor_callback :: (using self: *PhysicsServer2D, area: RID, callback: Callable) {
}
PhysicsServer2D_area_set_monitorable :: (using self: *PhysicsServer2D, area: RID, monitorable: bool) {
}
PhysicsServer2D_body_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_body_set_space :: (using self: *PhysicsServer2D, body: RID, space: RID) {
}
PhysicsServer2D_body_get_space :: (using self: *PhysicsServer2D, body: RID) -> RID {
}
PhysicsServer2D_body_set_mode :: (using self: *PhysicsServer2D, body: RID, mode: PhysicsServer2D.BodyMode) {
}
PhysicsServer2D_body_get_mode :: (using self: *PhysicsServer2D, body: RID) -> PhysicsServer2D.BodyMode {
}
PhysicsServer2D_body_add_shape :: (using self: *PhysicsServer2D, body: RID, shape: RID, transform: Transform2D, disabled: bool) {
}
PhysicsServer2D_body_set_shape :: (using self: *PhysicsServer2D, body: RID, shape_idx: int, shape: RID) {
}
PhysicsServer2D_body_set_shape_transform :: (using self: *PhysicsServer2D, body: RID, shape_idx: int, transform: Transform2D) {
}
PhysicsServer2D_body_get_shape_count :: (using self: *PhysicsServer2D, body: RID) -> int {
}
PhysicsServer2D_body_get_shape :: (using self: *PhysicsServer2D, body: RID, shape_idx: int) -> RID {
}
PhysicsServer2D_body_get_shape_transform :: (using self: *PhysicsServer2D, body: RID, shape_idx: int) -> Transform2D {
}
PhysicsServer2D_body_remove_shape :: (using self: *PhysicsServer2D, body: RID, shape_idx: int) {
}
PhysicsServer2D_body_clear_shapes :: (using self: *PhysicsServer2D, body: RID) {
}
PhysicsServer2D_body_set_shape_disabled :: (using self: *PhysicsServer2D, body: RID, shape_idx: int, disabled: bool) {
}
PhysicsServer2D_body_set_shape_as_one_way_collision :: (using self: *PhysicsServer2D, body: RID, shape_idx: int, enable: bool, margin: float) {
}
PhysicsServer2D_body_attach_object_instance_id :: (using self: *PhysicsServer2D, body: RID, id: int) {
}
PhysicsServer2D_body_get_object_instance_id :: (using self: *PhysicsServer2D, body: RID) -> int {
}
PhysicsServer2D_body_attach_canvas_instance_id :: (using self: *PhysicsServer2D, body: RID, id: int) {
}
PhysicsServer2D_body_get_canvas_instance_id :: (using self: *PhysicsServer2D, body: RID) -> int {
}
PhysicsServer2D_body_set_continuous_collision_detection_mode :: (using self: *PhysicsServer2D, body: RID, mode: PhysicsServer2D.CCDMode) {
}
PhysicsServer2D_body_get_continuous_collision_detection_mode :: (using self: *PhysicsServer2D, body: RID) -> PhysicsServer2D.CCDMode {
}
PhysicsServer2D_body_set_collision_layer :: (using self: *PhysicsServer2D, body: RID, layer: int) {
}
PhysicsServer2D_body_get_collision_layer :: (using self: *PhysicsServer2D, body: RID) -> int {
}
PhysicsServer2D_body_set_collision_mask :: (using self: *PhysicsServer2D, body: RID, mask: int) {
}
PhysicsServer2D_body_get_collision_mask :: (using self: *PhysicsServer2D, body: RID) -> int {
}
PhysicsServer2D_body_set_collision_priority :: (using self: *PhysicsServer2D, body: RID, priority: float) {
}
PhysicsServer2D_body_get_collision_priority :: (using self: *PhysicsServer2D, body: RID) -> float {
}
PhysicsServer2D_body_set_param :: (using self: *PhysicsServer2D, body: RID, param: PhysicsServer2D.BodyParameter, value: Variant) {
}
PhysicsServer2D_body_get_param :: (using self: *PhysicsServer2D, body: RID, param: PhysicsServer2D.BodyParameter) -> Variant {
}
PhysicsServer2D_body_reset_mass_properties :: (using self: *PhysicsServer2D, body: RID) {
}
PhysicsServer2D_body_set_state :: (using self: *PhysicsServer2D, body: RID, state: PhysicsServer2D.BodyState, value: Variant) {
}
PhysicsServer2D_body_get_state :: (using self: *PhysicsServer2D, body: RID, state: PhysicsServer2D.BodyState) -> Variant {
}
PhysicsServer2D_body_apply_central_impulse :: (using self: *PhysicsServer2D, body: RID, impulse: Vector2) {
}
PhysicsServer2D_body_apply_torque_impulse :: (using self: *PhysicsServer2D, body: RID, impulse: float) {
}
PhysicsServer2D_body_apply_impulse :: (using self: *PhysicsServer2D, body: RID, impulse: Vector2, position: Vector2) {
}
PhysicsServer2D_body_apply_central_force :: (using self: *PhysicsServer2D, body: RID, force: Vector2) {
}
PhysicsServer2D_body_apply_force :: (using self: *PhysicsServer2D, body: RID, force: Vector2, position: Vector2) {
}
PhysicsServer2D_body_apply_torque :: (using self: *PhysicsServer2D, body: RID, torque: float) {
}
PhysicsServer2D_body_add_constant_central_force :: (using self: *PhysicsServer2D, body: RID, force: Vector2) {
}
PhysicsServer2D_body_add_constant_force :: (using self: *PhysicsServer2D, body: RID, force: Vector2, position: Vector2) {
}
PhysicsServer2D_body_add_constant_torque :: (using self: *PhysicsServer2D, body: RID, torque: float) {
}
PhysicsServer2D_body_set_constant_force :: (using self: *PhysicsServer2D, body: RID, force: Vector2) {
}
PhysicsServer2D_body_get_constant_force :: (using self: *PhysicsServer2D, body: RID) -> Vector2 {
}
PhysicsServer2D_body_set_constant_torque :: (using self: *PhysicsServer2D, body: RID, torque: float) {
}
PhysicsServer2D_body_get_constant_torque :: (using self: *PhysicsServer2D, body: RID) -> float {
}
PhysicsServer2D_body_set_axis_velocity :: (using self: *PhysicsServer2D, body: RID, axis_velocity: Vector2) {
}
PhysicsServer2D_body_add_collision_exception :: (using self: *PhysicsServer2D, body: RID, excepted_body: RID) {
}
PhysicsServer2D_body_remove_collision_exception :: (using self: *PhysicsServer2D, body: RID, excepted_body: RID) {
}
PhysicsServer2D_body_set_max_contacts_reported :: (using self: *PhysicsServer2D, body: RID, amount: int) {
}
PhysicsServer2D_body_get_max_contacts_reported :: (using self: *PhysicsServer2D, body: RID) -> int {
}
PhysicsServer2D_body_set_omit_force_integration :: (using self: *PhysicsServer2D, body: RID, enable: bool) {
}
PhysicsServer2D_body_is_omitting_force_integration :: (using self: *PhysicsServer2D, body: RID) -> bool {
}
PhysicsServer2D_body_set_state_sync_callback :: (using self: *PhysicsServer2D, body: RID, callable: Callable) {
}
PhysicsServer2D_body_set_force_integration_callback :: (using self: *PhysicsServer2D, body: RID, callable: Callable, userdata: Variant) {
}
PhysicsServer2D_body_test_motion :: (using self: *PhysicsServer2D, body: RID, parameters: PhysicsTestMotionParameters2D, result: PhysicsTestMotionResult2D) -> bool {
}
PhysicsServer2D_body_get_direct_state :: (using self: *PhysicsServer2D, body: RID) -> PhysicsDirectBodyState2D {
}
PhysicsServer2D_joint_create :: (using self: *PhysicsServer2D) -> RID {
}
PhysicsServer2D_joint_clear :: (using self: *PhysicsServer2D, joint: RID) {
}
PhysicsServer2D_joint_set_param :: (using self: *PhysicsServer2D, joint: RID, param: PhysicsServer2D.JointParam, value: float) {
}
PhysicsServer2D_joint_get_param :: (using self: *PhysicsServer2D, joint: RID, param: PhysicsServer2D.JointParam) -> float {
}
PhysicsServer2D_joint_disable_collisions_between_bodies :: (using self: *PhysicsServer2D, joint: RID, disable: bool) {
}
PhysicsServer2D_joint_is_disabled_collisions_between_bodies :: (using self: *PhysicsServer2D, joint: RID) -> bool {
}
PhysicsServer2D_joint_make_pin :: (using self: *PhysicsServer2D, joint: RID, anchor: Vector2, body_a: RID, body_b: RID) {
}
PhysicsServer2D_joint_make_groove :: (using self: *PhysicsServer2D, joint: RID, groove1_a: Vector2, groove2_a: Vector2, anchor_b: Vector2, body_a: RID, body_b: RID) {
}
PhysicsServer2D_joint_make_damped_spring :: (using self: *PhysicsServer2D, joint: RID, anchor_a: Vector2, anchor_b: Vector2, body_a: RID, body_b: RID) {
}
PhysicsServer2D_pin_joint_set_flag :: (using self: *PhysicsServer2D, joint: RID, flag: PhysicsServer2D.PinJointFlag, enabled: bool) {
}
PhysicsServer2D_pin_joint_get_flag :: (using self: *PhysicsServer2D, joint: RID, flag: PhysicsServer2D.PinJointFlag) -> bool {
}
PhysicsServer2D_pin_joint_set_param :: (using self: *PhysicsServer2D, joint: RID, param: PhysicsServer2D.PinJointParam, value: float) {
}
PhysicsServer2D_pin_joint_get_param :: (using self: *PhysicsServer2D, joint: RID, param: PhysicsServer2D.PinJointParam) -> float {
}
PhysicsServer2D_damped_spring_joint_set_param :: (using self: *PhysicsServer2D, joint: RID, param: PhysicsServer2D.DampedSpringParam, value: float) {
}
PhysicsServer2D_damped_spring_joint_get_param :: (using self: *PhysicsServer2D, joint: RID, param: PhysicsServer2D.DampedSpringParam) -> float {
}
PhysicsServer2D_joint_get_type :: (using self: *PhysicsServer2D, joint: RID) -> PhysicsServer2D.JointType {
}
PhysicsServer2D_free_rid :: (using self: *PhysicsServer2D, rid: RID) {
}
PhysicsServer2D_set_active :: (using self: *PhysicsServer2D, active: bool) {
}
PhysicsServer2D_get_process_info :: (using self: *PhysicsServer2D, process_info: PhysicsServer2D.ProcessInfo) -> int {
}

// PhysicsServer2DExtension
PhysicsServer2DExtension :: struct {
	__private: *void;
}

PhysicsServer2DExtension__world_boundary_shape_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__separation_ray_shape_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__segment_shape_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__circle_shape_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__rectangle_shape_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__capsule_shape_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__convex_polygon_shape_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__concave_polygon_shape_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__shape_set_data :: (using self: *PhysicsServer2DExtension, shape: RID, data: Variant) {
}
PhysicsServer2DExtension__shape_set_custom_solver_bias :: (using self: *PhysicsServer2DExtension, shape: RID, bias: float) {
}
PhysicsServer2DExtension__shape_get_type :: (using self: *PhysicsServer2DExtension, shape: RID) -> PhysicsServer2D.ShapeType {
}
PhysicsServer2DExtension__shape_get_data :: (using self: *PhysicsServer2DExtension, shape: RID) -> Variant {
}
PhysicsServer2DExtension__shape_get_custom_solver_bias :: (using self: *PhysicsServer2DExtension, shape: RID) -> float {
}
PhysicsServer2DExtension__shape_collide :: (using self: *PhysicsServer2DExtension, shape_A: RID, xform_A: Transform2D, motion_A: Vector2, shape_B: RID, xform_B: Transform2D, motion_B: Vector2, results: *void, result_max: int, result_count: *s32) -> bool {
}
PhysicsServer2DExtension__space_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__space_set_active :: (using self: *PhysicsServer2DExtension, space: RID, active: bool) {
}
PhysicsServer2DExtension__space_is_active :: (using self: *PhysicsServer2DExtension, space: RID) -> bool {
}
PhysicsServer2DExtension__space_set_param :: (using self: *PhysicsServer2DExtension, space: RID, param: PhysicsServer2D.SpaceParameter, value: float) {
}
PhysicsServer2DExtension__space_get_param :: (using self: *PhysicsServer2DExtension, space: RID, param: PhysicsServer2D.SpaceParameter) -> float {
}
PhysicsServer2DExtension__space_get_direct_state :: (using self: *PhysicsServer2DExtension, space: RID) -> PhysicsDirectSpaceState2D {
}
PhysicsServer2DExtension__space_set_debug_contacts :: (using self: *PhysicsServer2DExtension, space: RID, max_contacts: int) {
}
PhysicsServer2DExtension__space_get_contacts :: (using self: *PhysicsServer2DExtension, space: RID) -> PackedVector2Array {
}
PhysicsServer2DExtension__space_get_contact_count :: (using self: *PhysicsServer2DExtension, space: RID) -> int {
}
PhysicsServer2DExtension__area_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__area_set_space :: (using self: *PhysicsServer2DExtension, area: RID, space: RID) {
}
PhysicsServer2DExtension__area_get_space :: (using self: *PhysicsServer2DExtension, area: RID) -> RID {
}
PhysicsServer2DExtension__area_add_shape :: (using self: *PhysicsServer2DExtension, area: RID, shape: RID, transform: Transform2D, disabled: bool) {
}
PhysicsServer2DExtension__area_set_shape :: (using self: *PhysicsServer2DExtension, area: RID, shape_idx: int, shape: RID) {
}
PhysicsServer2DExtension__area_set_shape_transform :: (using self: *PhysicsServer2DExtension, area: RID, shape_idx: int, transform: Transform2D) {
}
PhysicsServer2DExtension__area_set_shape_disabled :: (using self: *PhysicsServer2DExtension, area: RID, shape_idx: int, disabled: bool) {
}
PhysicsServer2DExtension__area_get_shape_count :: (using self: *PhysicsServer2DExtension, area: RID) -> int {
}
PhysicsServer2DExtension__area_get_shape :: (using self: *PhysicsServer2DExtension, area: RID, shape_idx: int) -> RID {
}
PhysicsServer2DExtension__area_get_shape_transform :: (using self: *PhysicsServer2DExtension, area: RID, shape_idx: int) -> Transform2D {
}
PhysicsServer2DExtension__area_remove_shape :: (using self: *PhysicsServer2DExtension, area: RID, shape_idx: int) {
}
PhysicsServer2DExtension__area_clear_shapes :: (using self: *PhysicsServer2DExtension, area: RID) {
}
PhysicsServer2DExtension__area_attach_object_instance_id :: (using self: *PhysicsServer2DExtension, area: RID, id: int) {
}
PhysicsServer2DExtension__area_get_object_instance_id :: (using self: *PhysicsServer2DExtension, area: RID) -> int {
}
PhysicsServer2DExtension__area_attach_canvas_instance_id :: (using self: *PhysicsServer2DExtension, area: RID, id: int) {
}
PhysicsServer2DExtension__area_get_canvas_instance_id :: (using self: *PhysicsServer2DExtension, area: RID) -> int {
}
PhysicsServer2DExtension__area_set_param :: (using self: *PhysicsServer2DExtension, area: RID, param: PhysicsServer2D.AreaParameter, value: Variant) {
}
PhysicsServer2DExtension__area_set_transform :: (using self: *PhysicsServer2DExtension, area: RID, transform: Transform2D) {
}
PhysicsServer2DExtension__area_get_param :: (using self: *PhysicsServer2DExtension, area: RID, param: PhysicsServer2D.AreaParameter) -> Variant {
}
PhysicsServer2DExtension__area_get_transform :: (using self: *PhysicsServer2DExtension, area: RID) -> Transform2D {
}
PhysicsServer2DExtension__area_set_collision_layer :: (using self: *PhysicsServer2DExtension, area: RID, layer: int) {
}
PhysicsServer2DExtension__area_get_collision_layer :: (using self: *PhysicsServer2DExtension, area: RID) -> int {
}
PhysicsServer2DExtension__area_set_collision_mask :: (using self: *PhysicsServer2DExtension, area: RID, mask: int) {
}
PhysicsServer2DExtension__area_get_collision_mask :: (using self: *PhysicsServer2DExtension, area: RID) -> int {
}
PhysicsServer2DExtension__area_set_monitorable :: (using self: *PhysicsServer2DExtension, area: RID, monitorable: bool) {
}
PhysicsServer2DExtension__area_set_pickable :: (using self: *PhysicsServer2DExtension, area: RID, pickable: bool) {
}
PhysicsServer2DExtension__area_set_monitor_callback :: (using self: *PhysicsServer2DExtension, area: RID, callback: Callable) {
}
PhysicsServer2DExtension__area_set_area_monitor_callback :: (using self: *PhysicsServer2DExtension, area: RID, callback: Callable) {
}
PhysicsServer2DExtension__body_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__body_set_space :: (using self: *PhysicsServer2DExtension, body: RID, space: RID) {
}
PhysicsServer2DExtension__body_get_space :: (using self: *PhysicsServer2DExtension, body: RID) -> RID {
}
PhysicsServer2DExtension__body_set_mode :: (using self: *PhysicsServer2DExtension, body: RID, mode: PhysicsServer2D.BodyMode) {
}
PhysicsServer2DExtension__body_get_mode :: (using self: *PhysicsServer2DExtension, body: RID) -> PhysicsServer2D.BodyMode {
}
PhysicsServer2DExtension__body_add_shape :: (using self: *PhysicsServer2DExtension, body: RID, shape: RID, transform: Transform2D, disabled: bool) {
}
PhysicsServer2DExtension__body_set_shape :: (using self: *PhysicsServer2DExtension, body: RID, shape_idx: int, shape: RID) {
}
PhysicsServer2DExtension__body_set_shape_transform :: (using self: *PhysicsServer2DExtension, body: RID, shape_idx: int, transform: Transform2D) {
}
PhysicsServer2DExtension__body_get_shape_count :: (using self: *PhysicsServer2DExtension, body: RID) -> int {
}
PhysicsServer2DExtension__body_get_shape :: (using self: *PhysicsServer2DExtension, body: RID, shape_idx: int) -> RID {
}
PhysicsServer2DExtension__body_get_shape_transform :: (using self: *PhysicsServer2DExtension, body: RID, shape_idx: int) -> Transform2D {
}
PhysicsServer2DExtension__body_set_shape_disabled :: (using self: *PhysicsServer2DExtension, body: RID, shape_idx: int, disabled: bool) {
}
PhysicsServer2DExtension__body_set_shape_as_one_way_collision :: (using self: *PhysicsServer2DExtension, body: RID, shape_idx: int, enable: bool, margin: float) {
}
PhysicsServer2DExtension__body_remove_shape :: (using self: *PhysicsServer2DExtension, body: RID, shape_idx: int) {
}
PhysicsServer2DExtension__body_clear_shapes :: (using self: *PhysicsServer2DExtension, body: RID) {
}
PhysicsServer2DExtension__body_attach_object_instance_id :: (using self: *PhysicsServer2DExtension, body: RID, id: int) {
}
PhysicsServer2DExtension__body_get_object_instance_id :: (using self: *PhysicsServer2DExtension, body: RID) -> int {
}
PhysicsServer2DExtension__body_attach_canvas_instance_id :: (using self: *PhysicsServer2DExtension, body: RID, id: int) {
}
PhysicsServer2DExtension__body_get_canvas_instance_id :: (using self: *PhysicsServer2DExtension, body: RID) -> int {
}
PhysicsServer2DExtension__body_set_continuous_collision_detection_mode :: (using self: *PhysicsServer2DExtension, body: RID, mode: PhysicsServer2D.CCDMode) {
}
PhysicsServer2DExtension__body_get_continuous_collision_detection_mode :: (using self: *PhysicsServer2DExtension, body: RID) -> PhysicsServer2D.CCDMode {
}
PhysicsServer2DExtension__body_set_collision_layer :: (using self: *PhysicsServer2DExtension, body: RID, layer: int) {
}
PhysicsServer2DExtension__body_get_collision_layer :: (using self: *PhysicsServer2DExtension, body: RID) -> int {
}
PhysicsServer2DExtension__body_set_collision_mask :: (using self: *PhysicsServer2DExtension, body: RID, mask: int) {
}
PhysicsServer2DExtension__body_get_collision_mask :: (using self: *PhysicsServer2DExtension, body: RID) -> int {
}
PhysicsServer2DExtension__body_set_collision_priority :: (using self: *PhysicsServer2DExtension, body: RID, priority: float) {
}
PhysicsServer2DExtension__body_get_collision_priority :: (using self: *PhysicsServer2DExtension, body: RID) -> float {
}
PhysicsServer2DExtension__body_set_param :: (using self: *PhysicsServer2DExtension, body: RID, param: PhysicsServer2D.BodyParameter, value: Variant) {
}
PhysicsServer2DExtension__body_get_param :: (using self: *PhysicsServer2DExtension, body: RID, param: PhysicsServer2D.BodyParameter) -> Variant {
}
PhysicsServer2DExtension__body_reset_mass_properties :: (using self: *PhysicsServer2DExtension, body: RID) {
}
PhysicsServer2DExtension__body_set_state :: (using self: *PhysicsServer2DExtension, body: RID, state: PhysicsServer2D.BodyState, value: Variant) {
}
PhysicsServer2DExtension__body_get_state :: (using self: *PhysicsServer2DExtension, body: RID, state: PhysicsServer2D.BodyState) -> Variant {
}
PhysicsServer2DExtension__body_apply_central_impulse :: (using self: *PhysicsServer2DExtension, body: RID, impulse: Vector2) {
}
PhysicsServer2DExtension__body_apply_torque_impulse :: (using self: *PhysicsServer2DExtension, body: RID, impulse: float) {
}
PhysicsServer2DExtension__body_apply_impulse :: (using self: *PhysicsServer2DExtension, body: RID, impulse: Vector2, position: Vector2) {
}
PhysicsServer2DExtension__body_apply_central_force :: (using self: *PhysicsServer2DExtension, body: RID, force: Vector2) {
}
PhysicsServer2DExtension__body_apply_force :: (using self: *PhysicsServer2DExtension, body: RID, force: Vector2, position: Vector2) {
}
PhysicsServer2DExtension__body_apply_torque :: (using self: *PhysicsServer2DExtension, body: RID, torque: float) {
}
PhysicsServer2DExtension__body_add_constant_central_force :: (using self: *PhysicsServer2DExtension, body: RID, force: Vector2) {
}
PhysicsServer2DExtension__body_add_constant_force :: (using self: *PhysicsServer2DExtension, body: RID, force: Vector2, position: Vector2) {
}
PhysicsServer2DExtension__body_add_constant_torque :: (using self: *PhysicsServer2DExtension, body: RID, torque: float) {
}
PhysicsServer2DExtension__body_set_constant_force :: (using self: *PhysicsServer2DExtension, body: RID, force: Vector2) {
}
PhysicsServer2DExtension__body_get_constant_force :: (using self: *PhysicsServer2DExtension, body: RID) -> Vector2 {
}
PhysicsServer2DExtension__body_set_constant_torque :: (using self: *PhysicsServer2DExtension, body: RID, torque: float) {
}
PhysicsServer2DExtension__body_get_constant_torque :: (using self: *PhysicsServer2DExtension, body: RID) -> float {
}
PhysicsServer2DExtension__body_set_axis_velocity :: (using self: *PhysicsServer2DExtension, body: RID, axis_velocity: Vector2) {
}
PhysicsServer2DExtension__body_add_collision_exception :: (using self: *PhysicsServer2DExtension, body: RID, excepted_body: RID) {
}
PhysicsServer2DExtension__body_remove_collision_exception :: (using self: *PhysicsServer2DExtension, body: RID, excepted_body: RID) {
}
PhysicsServer2DExtension__body_get_collision_exceptions :: (using self: *PhysicsServer2DExtension, body: RID) -> Array {
}
PhysicsServer2DExtension__body_set_max_contacts_reported :: (using self: *PhysicsServer2DExtension, body: RID, amount: int) {
}
PhysicsServer2DExtension__body_get_max_contacts_reported :: (using self: *PhysicsServer2DExtension, body: RID) -> int {
}
PhysicsServer2DExtension__body_set_contacts_reported_depth_threshold :: (using self: *PhysicsServer2DExtension, body: RID, threshold: float) {
}
PhysicsServer2DExtension__body_get_contacts_reported_depth_threshold :: (using self: *PhysicsServer2DExtension, body: RID) -> float {
}
PhysicsServer2DExtension__body_set_omit_force_integration :: (using self: *PhysicsServer2DExtension, body: RID, enable: bool) {
}
PhysicsServer2DExtension__body_is_omitting_force_integration :: (using self: *PhysicsServer2DExtension, body: RID) -> bool {
}
PhysicsServer2DExtension__body_set_state_sync_callback :: (using self: *PhysicsServer2DExtension, body: RID, callable: Callable) {
}
PhysicsServer2DExtension__body_set_force_integration_callback :: (using self: *PhysicsServer2DExtension, body: RID, callable: Callable, userdata: Variant) {
}
PhysicsServer2DExtension__body_collide_shape :: (using self: *PhysicsServer2DExtension, body: RID, body_shape: int, shape: RID, shape_xform: Transform2D, motion: Vector2, results: *void, result_max: int, result_count: *s32) -> bool {
}
PhysicsServer2DExtension__body_set_pickable :: (using self: *PhysicsServer2DExtension, body: RID, pickable: bool) {
}
PhysicsServer2DExtension__body_get_direct_state :: (using self: *PhysicsServer2DExtension, body: RID) -> PhysicsDirectBodyState2D {
}
PhysicsServer2DExtension__body_test_motion :: (using self: *PhysicsServer2DExtension, body: RID, from: Transform2D, motion: Vector2, margin: float, collide_separation_ray: bool, recovery_as_collision: bool, result: *PhysicsServer2DExtensionMotionResult) -> bool {
}
PhysicsServer2DExtension__joint_create :: (using self: *PhysicsServer2DExtension) -> RID {
}
PhysicsServer2DExtension__joint_clear :: (using self: *PhysicsServer2DExtension, joint: RID) {
}
PhysicsServer2DExtension__joint_set_param :: (using self: *PhysicsServer2DExtension, joint: RID, param: PhysicsServer2D.JointParam, value: float) {
}
PhysicsServer2DExtension__joint_get_param :: (using self: *PhysicsServer2DExtension, joint: RID, param: PhysicsServer2D.JointParam) -> float {
}
PhysicsServer2DExtension__joint_disable_collisions_between_bodies :: (using self: *PhysicsServer2DExtension, joint: RID, disable: bool) {
}
PhysicsServer2DExtension__joint_is_disabled_collisions_between_bodies :: (using self: *PhysicsServer2DExtension, joint: RID) -> bool {
}
PhysicsServer2DExtension__joint_make_pin :: (using self: *PhysicsServer2DExtension, joint: RID, anchor: Vector2, body_a: RID, body_b: RID) {
}
PhysicsServer2DExtension__joint_make_groove :: (using self: *PhysicsServer2DExtension, joint: RID, a_groove1: Vector2, a_groove2: Vector2, b_anchor: Vector2, body_a: RID, body_b: RID) {
}
PhysicsServer2DExtension__joint_make_damped_spring :: (using self: *PhysicsServer2DExtension, joint: RID, anchor_a: Vector2, anchor_b: Vector2, body_a: RID, body_b: RID) {
}
PhysicsServer2DExtension__pin_joint_set_flag :: (using self: *PhysicsServer2DExtension, joint: RID, flag: PhysicsServer2D.PinJointFlag, enabled: bool) {
}
PhysicsServer2DExtension__pin_joint_get_flag :: (using self: *PhysicsServer2DExtension, joint: RID, flag: PhysicsServer2D.PinJointFlag) -> bool {
}
PhysicsServer2DExtension__pin_joint_set_param :: (using self: *PhysicsServer2DExtension, joint: RID, param: PhysicsServer2D.PinJointParam, value: float) {
}
PhysicsServer2DExtension__pin_joint_get_param :: (using self: *PhysicsServer2DExtension, joint: RID, param: PhysicsServer2D.PinJointParam) -> float {
}
PhysicsServer2DExtension__damped_spring_joint_set_param :: (using self: *PhysicsServer2DExtension, joint: RID, param: PhysicsServer2D.DampedSpringParam, value: float) {
}
PhysicsServer2DExtension__damped_spring_joint_get_param :: (using self: *PhysicsServer2DExtension, joint: RID, param: PhysicsServer2D.DampedSpringParam) -> float {
}
PhysicsServer2DExtension__joint_get_type :: (using self: *PhysicsServer2DExtension, joint: RID) -> PhysicsServer2D.JointType {
}
PhysicsServer2DExtension__free_rid :: (using self: *PhysicsServer2DExtension, rid: RID) {
}
PhysicsServer2DExtension__set_active :: (using self: *PhysicsServer2DExtension, active: bool) {
}
PhysicsServer2DExtension__init :: (using self: *PhysicsServer2DExtension) {
}
PhysicsServer2DExtension__step :: (using self: *PhysicsServer2DExtension, step: float) {
}
PhysicsServer2DExtension__sync :: (using self: *PhysicsServer2DExtension) {
}
PhysicsServer2DExtension__flush_queries :: (using self: *PhysicsServer2DExtension) {
}
PhysicsServer2DExtension__end_sync :: (using self: *PhysicsServer2DExtension) {
}
PhysicsServer2DExtension__finish :: (using self: *PhysicsServer2DExtension) {
}
PhysicsServer2DExtension__is_flushing_queries :: (using self: *PhysicsServer2DExtension) -> bool {
}
PhysicsServer2DExtension__get_process_info :: (using self: *PhysicsServer2DExtension, process_info: PhysicsServer2D.ProcessInfo) -> int {
}
PhysicsServer2DExtension_body_test_motion_is_excluding_body :: (using self: *PhysicsServer2DExtension, body: RID) -> bool {
}
PhysicsServer2DExtension_body_test_motion_is_excluding_object :: (using self: *PhysicsServer2DExtension, object: int) -> bool {
}

// PhysicsServer2DManager
PhysicsServer2DManager :: struct {
	__private: *void;
}

PhysicsServer2DManager_register_server :: (using self: *PhysicsServer2DManager, name: String, create_callback: Callable) {
}
PhysicsServer2DManager_set_default_server :: (using self: *PhysicsServer2DManager, name: String, priority: int) {
}

// PhysicsServer3D
PhysicsServer3D :: struct {
	__private: *void;

	JointType :: enum {
		JOINT_TYPE_PIN :: 0;
		JOINT_TYPE_HINGE :: 1;
		JOINT_TYPE_SLIDER :: 2;
		JOINT_TYPE_CONE_TWIST :: 3;
		JOINT_TYPE_6DOF :: 4;
		JOINT_TYPE_MAX :: 5;
	}
	PinJointParam :: enum {
		PIN_JOINT_BIAS :: 0;
		PIN_JOINT_DAMPING :: 1;
		PIN_JOINT_IMPULSE_CLAMP :: 2;
	}
	HingeJointParam :: enum {
		HINGE_JOINT_BIAS :: 0;
		HINGE_JOINT_LIMIT_UPPER :: 1;
		HINGE_JOINT_LIMIT_LOWER :: 2;
		HINGE_JOINT_LIMIT_BIAS :: 3;
		HINGE_JOINT_LIMIT_SOFTNESS :: 4;
		HINGE_JOINT_LIMIT_RELAXATION :: 5;
		HINGE_JOINT_MOTOR_TARGET_VELOCITY :: 6;
		HINGE_JOINT_MOTOR_MAX_IMPULSE :: 7;
	}
	HingeJointFlag :: enum {
		HINGE_JOINT_FLAG_USE_LIMIT :: 0;
		HINGE_JOINT_FLAG_ENABLE_MOTOR :: 1;
	}
	SliderJointParam :: enum {
		SLIDER_JOINT_LINEAR_LIMIT_UPPER :: 0;
		SLIDER_JOINT_LINEAR_LIMIT_LOWER :: 1;
		SLIDER_JOINT_LINEAR_LIMIT_SOFTNESS :: 2;
		SLIDER_JOINT_LINEAR_LIMIT_RESTITUTION :: 3;
		SLIDER_JOINT_LINEAR_LIMIT_DAMPING :: 4;
		SLIDER_JOINT_LINEAR_MOTION_SOFTNESS :: 5;
		SLIDER_JOINT_LINEAR_MOTION_RESTITUTION :: 6;
		SLIDER_JOINT_LINEAR_MOTION_DAMPING :: 7;
		SLIDER_JOINT_LINEAR_ORTHOGONAL_SOFTNESS :: 8;
		SLIDER_JOINT_LINEAR_ORTHOGONAL_RESTITUTION :: 9;
		SLIDER_JOINT_LINEAR_ORTHOGONAL_DAMPING :: 10;
		SLIDER_JOINT_ANGULAR_LIMIT_UPPER :: 11;
		SLIDER_JOINT_ANGULAR_LIMIT_LOWER :: 12;
		SLIDER_JOINT_ANGULAR_LIMIT_SOFTNESS :: 13;
		SLIDER_JOINT_ANGULAR_LIMIT_RESTITUTION :: 14;
		SLIDER_JOINT_ANGULAR_LIMIT_DAMPING :: 15;
		SLIDER_JOINT_ANGULAR_MOTION_SOFTNESS :: 16;
		SLIDER_JOINT_ANGULAR_MOTION_RESTITUTION :: 17;
		SLIDER_JOINT_ANGULAR_MOTION_DAMPING :: 18;
		SLIDER_JOINT_ANGULAR_ORTHOGONAL_SOFTNESS :: 19;
		SLIDER_JOINT_ANGULAR_ORTHOGONAL_RESTITUTION :: 20;
		SLIDER_JOINT_ANGULAR_ORTHOGONAL_DAMPING :: 21;
		SLIDER_JOINT_MAX :: 22;
	}
	ConeTwistJointParam :: enum {
		CONE_TWIST_JOINT_SWING_SPAN :: 0;
		CONE_TWIST_JOINT_TWIST_SPAN :: 1;
		CONE_TWIST_JOINT_BIAS :: 2;
		CONE_TWIST_JOINT_SOFTNESS :: 3;
		CONE_TWIST_JOINT_RELAXATION :: 4;
	}
	G6DOFJointAxisParam :: enum {
		G6DOF_JOINT_LINEAR_LOWER_LIMIT :: 0;
		G6DOF_JOINT_LINEAR_UPPER_LIMIT :: 1;
		G6DOF_JOINT_LINEAR_LIMIT_SOFTNESS :: 2;
		G6DOF_JOINT_LINEAR_RESTITUTION :: 3;
		G6DOF_JOINT_LINEAR_DAMPING :: 4;
		G6DOF_JOINT_LINEAR_MOTOR_TARGET_VELOCITY :: 5;
		G6DOF_JOINT_LINEAR_MOTOR_FORCE_LIMIT :: 6;
		G6DOF_JOINT_LINEAR_SPRING_STIFFNESS :: 7;
		G6DOF_JOINT_LINEAR_SPRING_DAMPING :: 8;
		G6DOF_JOINT_LINEAR_SPRING_EQUILIBRIUM_POINT :: 9;
		G6DOF_JOINT_ANGULAR_LOWER_LIMIT :: 10;
		G6DOF_JOINT_ANGULAR_UPPER_LIMIT :: 11;
		G6DOF_JOINT_ANGULAR_LIMIT_SOFTNESS :: 12;
		G6DOF_JOINT_ANGULAR_DAMPING :: 13;
		G6DOF_JOINT_ANGULAR_RESTITUTION :: 14;
		G6DOF_JOINT_ANGULAR_FORCE_LIMIT :: 15;
		G6DOF_JOINT_ANGULAR_ERP :: 16;
		G6DOF_JOINT_ANGULAR_MOTOR_TARGET_VELOCITY :: 17;
		G6DOF_JOINT_ANGULAR_MOTOR_FORCE_LIMIT :: 18;
		G6DOF_JOINT_ANGULAR_SPRING_STIFFNESS :: 19;
		G6DOF_JOINT_ANGULAR_SPRING_DAMPING :: 20;
		G6DOF_JOINT_ANGULAR_SPRING_EQUILIBRIUM_POINT :: 21;
		G6DOF_JOINT_MAX :: 22;
	}
	G6DOFJointAxisFlag :: enum {
		G6DOF_JOINT_FLAG_ENABLE_LINEAR_LIMIT :: 0;
		G6DOF_JOINT_FLAG_ENABLE_ANGULAR_LIMIT :: 1;
		G6DOF_JOINT_FLAG_ENABLE_ANGULAR_SPRING :: 2;
		G6DOF_JOINT_FLAG_ENABLE_LINEAR_SPRING :: 3;
		G6DOF_JOINT_FLAG_ENABLE_MOTOR :: 4;
		G6DOF_JOINT_FLAG_ENABLE_LINEAR_MOTOR :: 5;
		G6DOF_JOINT_FLAG_MAX :: 6;
	}
	ShapeType :: enum {
		SHAPE_WORLD_BOUNDARY :: 0;
		SHAPE_SEPARATION_RAY :: 1;
		SHAPE_SPHERE :: 2;
		SHAPE_BOX :: 3;
		SHAPE_CAPSULE :: 4;
		SHAPE_CYLINDER :: 5;
		SHAPE_CONVEX_POLYGON :: 6;
		SHAPE_CONCAVE_POLYGON :: 7;
		SHAPE_HEIGHTMAP :: 8;
		SHAPE_SOFT_BODY :: 9;
		SHAPE_CUSTOM :: 10;
	}
	AreaParameter :: enum {
		AREA_PARAM_GRAVITY_OVERRIDE_MODE :: 0;
		AREA_PARAM_GRAVITY :: 1;
		AREA_PARAM_GRAVITY_VECTOR :: 2;
		AREA_PARAM_GRAVITY_IS_POINT :: 3;
		AREA_PARAM_GRAVITY_POINT_UNIT_DISTANCE :: 4;
		AREA_PARAM_LINEAR_DAMP_OVERRIDE_MODE :: 5;
		AREA_PARAM_LINEAR_DAMP :: 6;
		AREA_PARAM_ANGULAR_DAMP_OVERRIDE_MODE :: 7;
		AREA_PARAM_ANGULAR_DAMP :: 8;
		AREA_PARAM_PRIORITY :: 9;
		AREA_PARAM_WIND_FORCE_MAGNITUDE :: 10;
		AREA_PARAM_WIND_SOURCE :: 11;
		AREA_PARAM_WIND_DIRECTION :: 12;
		AREA_PARAM_WIND_ATTENUATION_FACTOR :: 13;
	}
	AreaSpaceOverrideMode :: enum {
		AREA_SPACE_OVERRIDE_DISABLED :: 0;
		AREA_SPACE_OVERRIDE_COMBINE :: 1;
		AREA_SPACE_OVERRIDE_COMBINE_REPLACE :: 2;
		AREA_SPACE_OVERRIDE_REPLACE :: 3;
		AREA_SPACE_OVERRIDE_REPLACE_COMBINE :: 4;
	}
	BodyMode :: enum {
		BODY_MODE_STATIC :: 0;
		BODY_MODE_KINEMATIC :: 1;
		BODY_MODE_RIGID :: 2;
		BODY_MODE_RIGID_LINEAR :: 3;
	}
	BodyParameter :: enum {
		BODY_PARAM_BOUNCE :: 0;
		BODY_PARAM_FRICTION :: 1;
		BODY_PARAM_MASS :: 2;
		BODY_PARAM_INERTIA :: 3;
		BODY_PARAM_CENTER_OF_MASS :: 4;
		BODY_PARAM_GRAVITY_SCALE :: 5;
		BODY_PARAM_LINEAR_DAMP_MODE :: 6;
		BODY_PARAM_ANGULAR_DAMP_MODE :: 7;
		BODY_PARAM_LINEAR_DAMP :: 8;
		BODY_PARAM_ANGULAR_DAMP :: 9;
		BODY_PARAM_MAX :: 10;
	}
	BodyDampMode :: enum {
		BODY_DAMP_MODE_COMBINE :: 0;
		BODY_DAMP_MODE_REPLACE :: 1;
	}
	BodyState :: enum {
		BODY_STATE_TRANSFORM :: 0;
		BODY_STATE_LINEAR_VELOCITY :: 1;
		BODY_STATE_ANGULAR_VELOCITY :: 2;
		BODY_STATE_SLEEPING :: 3;
		BODY_STATE_CAN_SLEEP :: 4;
	}
	AreaBodyStatus :: enum {
		AREA_BODY_ADDED :: 0;
		AREA_BODY_REMOVED :: 1;
	}
	ProcessInfo :: enum {
		INFO_ACTIVE_OBJECTS :: 0;
		INFO_COLLISION_PAIRS :: 1;
		INFO_ISLAND_COUNT :: 2;
	}
	SpaceParameter :: enum {
		SPACE_PARAM_CONTACT_RECYCLE_RADIUS :: 0;
		SPACE_PARAM_CONTACT_MAX_SEPARATION :: 1;
		SPACE_PARAM_CONTACT_MAX_ALLOWED_PENETRATION :: 2;
		SPACE_PARAM_CONTACT_DEFAULT_BIAS :: 3;
		SPACE_PARAM_BODY_LINEAR_VELOCITY_SLEEP_THRESHOLD :: 4;
		SPACE_PARAM_BODY_ANGULAR_VELOCITY_SLEEP_THRESHOLD :: 5;
		SPACE_PARAM_BODY_TIME_TO_SLEEP :: 6;
		SPACE_PARAM_SOLVER_ITERATIONS :: 7;
	}
	BodyAxis :: enum {
		BODY_AXIS_LINEAR_X :: 1;
		BODY_AXIS_LINEAR_Y :: 2;
		BODY_AXIS_LINEAR_Z :: 4;
		BODY_AXIS_ANGULAR_X :: 8;
		BODY_AXIS_ANGULAR_Y :: 16;
		BODY_AXIS_ANGULAR_Z :: 32;
	}
}

PhysicsServer3D_world_boundary_shape_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_separation_ray_shape_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_sphere_shape_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_box_shape_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_capsule_shape_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_cylinder_shape_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_convex_polygon_shape_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_concave_polygon_shape_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_heightmap_shape_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_custom_shape_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_shape_set_data :: (using self: *PhysicsServer3D, shape: RID, data: Variant) {
}
PhysicsServer3D_shape_set_margin :: (using self: *PhysicsServer3D, shape: RID, margin: float) {
}
PhysicsServer3D_shape_get_type :: (using self: *PhysicsServer3D, shape: RID) -> PhysicsServer3D.ShapeType {
}
PhysicsServer3D_shape_get_data :: (using self: *PhysicsServer3D, shape: RID) -> Variant {
}
PhysicsServer3D_shape_get_margin :: (using self: *PhysicsServer3D, shape: RID) -> float {
}
PhysicsServer3D_space_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_space_set_active :: (using self: *PhysicsServer3D, space: RID, active: bool) {
}
PhysicsServer3D_space_is_active :: (using self: *PhysicsServer3D, space: RID) -> bool {
}
PhysicsServer3D_space_set_param :: (using self: *PhysicsServer3D, space: RID, param: PhysicsServer3D.SpaceParameter, value: float) {
}
PhysicsServer3D_space_get_param :: (using self: *PhysicsServer3D, space: RID, param: PhysicsServer3D.SpaceParameter) -> float {
}
PhysicsServer3D_space_get_direct_state :: (using self: *PhysicsServer3D, space: RID) -> PhysicsDirectSpaceState3D {
}
PhysicsServer3D_area_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_area_set_space :: (using self: *PhysicsServer3D, area: RID, space: RID) {
}
PhysicsServer3D_area_get_space :: (using self: *PhysicsServer3D, area: RID) -> RID {
}
PhysicsServer3D_area_add_shape :: (using self: *PhysicsServer3D, area: RID, shape: RID, transform: Transform3D, disabled: bool) {
}
PhysicsServer3D_area_set_shape :: (using self: *PhysicsServer3D, area: RID, shape_idx: int, shape: RID) {
}
PhysicsServer3D_area_set_shape_transform :: (using self: *PhysicsServer3D, area: RID, shape_idx: int, transform: Transform3D) {
}
PhysicsServer3D_area_set_shape_disabled :: (using self: *PhysicsServer3D, area: RID, shape_idx: int, disabled: bool) {
}
PhysicsServer3D_area_get_shape_count :: (using self: *PhysicsServer3D, area: RID) -> int {
}
PhysicsServer3D_area_get_shape :: (using self: *PhysicsServer3D, area: RID, shape_idx: int) -> RID {
}
PhysicsServer3D_area_get_shape_transform :: (using self: *PhysicsServer3D, area: RID, shape_idx: int) -> Transform3D {
}
PhysicsServer3D_area_remove_shape :: (using self: *PhysicsServer3D, area: RID, shape_idx: int) {
}
PhysicsServer3D_area_clear_shapes :: (using self: *PhysicsServer3D, area: RID) {
}
PhysicsServer3D_area_set_collision_layer :: (using self: *PhysicsServer3D, area: RID, layer: int) {
}
PhysicsServer3D_area_get_collision_layer :: (using self: *PhysicsServer3D, area: RID) -> int {
}
PhysicsServer3D_area_set_collision_mask :: (using self: *PhysicsServer3D, area: RID, mask: int) {
}
PhysicsServer3D_area_get_collision_mask :: (using self: *PhysicsServer3D, area: RID) -> int {
}
PhysicsServer3D_area_set_param :: (using self: *PhysicsServer3D, area: RID, param: PhysicsServer3D.AreaParameter, value: Variant) {
}
PhysicsServer3D_area_set_transform :: (using self: *PhysicsServer3D, area: RID, transform: Transform3D) {
}
PhysicsServer3D_area_get_param :: (using self: *PhysicsServer3D, area: RID, param: PhysicsServer3D.AreaParameter) -> Variant {
}
PhysicsServer3D_area_get_transform :: (using self: *PhysicsServer3D, area: RID) -> Transform3D {
}
PhysicsServer3D_area_attach_object_instance_id :: (using self: *PhysicsServer3D, area: RID, id: int) {
}
PhysicsServer3D_area_get_object_instance_id :: (using self: *PhysicsServer3D, area: RID) -> int {
}
PhysicsServer3D_area_set_monitor_callback :: (using self: *PhysicsServer3D, area: RID, callback: Callable) {
}
PhysicsServer3D_area_set_area_monitor_callback :: (using self: *PhysicsServer3D, area: RID, callback: Callable) {
}
PhysicsServer3D_area_set_monitorable :: (using self: *PhysicsServer3D, area: RID, monitorable: bool) {
}
PhysicsServer3D_area_set_ray_pickable :: (using self: *PhysicsServer3D, area: RID, enable: bool) {
}
PhysicsServer3D_body_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_body_set_space :: (using self: *PhysicsServer3D, body: RID, space: RID) {
}
PhysicsServer3D_body_get_space :: (using self: *PhysicsServer3D, body: RID) -> RID {
}
PhysicsServer3D_body_set_mode :: (using self: *PhysicsServer3D, body: RID, mode: PhysicsServer3D.BodyMode) {
}
PhysicsServer3D_body_get_mode :: (using self: *PhysicsServer3D, body: RID) -> PhysicsServer3D.BodyMode {
}
PhysicsServer3D_body_set_collision_layer :: (using self: *PhysicsServer3D, body: RID, layer: int) {
}
PhysicsServer3D_body_get_collision_layer :: (using self: *PhysicsServer3D, body: RID) -> int {
}
PhysicsServer3D_body_set_collision_mask :: (using self: *PhysicsServer3D, body: RID, mask: int) {
}
PhysicsServer3D_body_get_collision_mask :: (using self: *PhysicsServer3D, body: RID) -> int {
}
PhysicsServer3D_body_set_collision_priority :: (using self: *PhysicsServer3D, body: RID, priority: float) {
}
PhysicsServer3D_body_get_collision_priority :: (using self: *PhysicsServer3D, body: RID) -> float {
}
PhysicsServer3D_body_add_shape :: (using self: *PhysicsServer3D, body: RID, shape: RID, transform: Transform3D, disabled: bool) {
}
PhysicsServer3D_body_set_shape :: (using self: *PhysicsServer3D, body: RID, shape_idx: int, shape: RID) {
}
PhysicsServer3D_body_set_shape_transform :: (using self: *PhysicsServer3D, body: RID, shape_idx: int, transform: Transform3D) {
}
PhysicsServer3D_body_set_shape_disabled :: (using self: *PhysicsServer3D, body: RID, shape_idx: int, disabled: bool) {
}
PhysicsServer3D_body_get_shape_count :: (using self: *PhysicsServer3D, body: RID) -> int {
}
PhysicsServer3D_body_get_shape :: (using self: *PhysicsServer3D, body: RID, shape_idx: int) -> RID {
}
PhysicsServer3D_body_get_shape_transform :: (using self: *PhysicsServer3D, body: RID, shape_idx: int) -> Transform3D {
}
PhysicsServer3D_body_remove_shape :: (using self: *PhysicsServer3D, body: RID, shape_idx: int) {
}
PhysicsServer3D_body_clear_shapes :: (using self: *PhysicsServer3D, body: RID) {
}
PhysicsServer3D_body_attach_object_instance_id :: (using self: *PhysicsServer3D, body: RID, id: int) {
}
PhysicsServer3D_body_get_object_instance_id :: (using self: *PhysicsServer3D, body: RID) -> int {
}
PhysicsServer3D_body_set_enable_continuous_collision_detection :: (using self: *PhysicsServer3D, body: RID, enable: bool) {
}
PhysicsServer3D_body_is_continuous_collision_detection_enabled :: (using self: *PhysicsServer3D, body: RID) -> bool {
}
PhysicsServer3D_body_set_param :: (using self: *PhysicsServer3D, body: RID, param: PhysicsServer3D.BodyParameter, value: Variant) {
}
PhysicsServer3D_body_get_param :: (using self: *PhysicsServer3D, body: RID, param: PhysicsServer3D.BodyParameter) -> Variant {
}
PhysicsServer3D_body_reset_mass_properties :: (using self: *PhysicsServer3D, body: RID) {
}
PhysicsServer3D_body_set_state :: (using self: *PhysicsServer3D, body: RID, state: PhysicsServer3D.BodyState, value: Variant) {
}
PhysicsServer3D_body_get_state :: (using self: *PhysicsServer3D, body: RID, state: PhysicsServer3D.BodyState) -> Variant {
}
PhysicsServer3D_body_apply_central_impulse :: (using self: *PhysicsServer3D, body: RID, impulse: Vector3) {
}
PhysicsServer3D_body_apply_impulse :: (using self: *PhysicsServer3D, body: RID, impulse: Vector3, position: Vector3) {
}
PhysicsServer3D_body_apply_torque_impulse :: (using self: *PhysicsServer3D, body: RID, impulse: Vector3) {
}
PhysicsServer3D_body_apply_central_force :: (using self: *PhysicsServer3D, body: RID, force: Vector3) {
}
PhysicsServer3D_body_apply_force :: (using self: *PhysicsServer3D, body: RID, force: Vector3, position: Vector3) {
}
PhysicsServer3D_body_apply_torque :: (using self: *PhysicsServer3D, body: RID, torque: Vector3) {
}
PhysicsServer3D_body_add_constant_central_force :: (using self: *PhysicsServer3D, body: RID, force: Vector3) {
}
PhysicsServer3D_body_add_constant_force :: (using self: *PhysicsServer3D, body: RID, force: Vector3, position: Vector3) {
}
PhysicsServer3D_body_add_constant_torque :: (using self: *PhysicsServer3D, body: RID, torque: Vector3) {
}
PhysicsServer3D_body_set_constant_force :: (using self: *PhysicsServer3D, body: RID, force: Vector3) {
}
PhysicsServer3D_body_get_constant_force :: (using self: *PhysicsServer3D, body: RID) -> Vector3 {
}
PhysicsServer3D_body_set_constant_torque :: (using self: *PhysicsServer3D, body: RID, torque: Vector3) {
}
PhysicsServer3D_body_get_constant_torque :: (using self: *PhysicsServer3D, body: RID) -> Vector3 {
}
PhysicsServer3D_body_set_axis_velocity :: (using self: *PhysicsServer3D, body: RID, axis_velocity: Vector3) {
}
PhysicsServer3D_body_set_axis_lock :: (using self: *PhysicsServer3D, body: RID, axis: PhysicsServer3D.BodyAxis, lock: bool) {
}
PhysicsServer3D_body_is_axis_locked :: (using self: *PhysicsServer3D, body: RID, axis: PhysicsServer3D.BodyAxis) -> bool {
}
PhysicsServer3D_body_add_collision_exception :: (using self: *PhysicsServer3D, body: RID, excepted_body: RID) {
}
PhysicsServer3D_body_remove_collision_exception :: (using self: *PhysicsServer3D, body: RID, excepted_body: RID) {
}
PhysicsServer3D_body_set_max_contacts_reported :: (using self: *PhysicsServer3D, body: RID, amount: int) {
}
PhysicsServer3D_body_get_max_contacts_reported :: (using self: *PhysicsServer3D, body: RID) -> int {
}
PhysicsServer3D_body_set_omit_force_integration :: (using self: *PhysicsServer3D, body: RID, enable: bool) {
}
PhysicsServer3D_body_is_omitting_force_integration :: (using self: *PhysicsServer3D, body: RID) -> bool {
}
PhysicsServer3D_body_set_state_sync_callback :: (using self: *PhysicsServer3D, body: RID, callable: Callable) {
}
PhysicsServer3D_body_set_force_integration_callback :: (using self: *PhysicsServer3D, body: RID, callable: Callable, userdata: Variant) {
}
PhysicsServer3D_body_set_ray_pickable :: (using self: *PhysicsServer3D, body: RID, enable: bool) {
}
PhysicsServer3D_body_test_motion :: (using self: *PhysicsServer3D, body: RID, parameters: PhysicsTestMotionParameters3D, result: PhysicsTestMotionResult3D) -> bool {
}
PhysicsServer3D_body_get_direct_state :: (using self: *PhysicsServer3D, body: RID) -> PhysicsDirectBodyState3D {
}
PhysicsServer3D_soft_body_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_soft_body_update_rendering_server :: (using self: *PhysicsServer3D, body: RID, rendering_server_handler: PhysicsServer3DRenderingServerHandler) {
}
PhysicsServer3D_soft_body_set_space :: (using self: *PhysicsServer3D, body: RID, space: RID) {
}
PhysicsServer3D_soft_body_get_space :: (using self: *PhysicsServer3D, body: RID) -> RID {
}
PhysicsServer3D_soft_body_set_mesh :: (using self: *PhysicsServer3D, body: RID, mesh: RID) {
}
PhysicsServer3D_soft_body_get_bounds :: (using self: *PhysicsServer3D, body: RID) -> AABB {
}
PhysicsServer3D_soft_body_set_collision_layer :: (using self: *PhysicsServer3D, body: RID, layer: int) {
}
PhysicsServer3D_soft_body_get_collision_layer :: (using self: *PhysicsServer3D, body: RID) -> int {
}
PhysicsServer3D_soft_body_set_collision_mask :: (using self: *PhysicsServer3D, body: RID, mask: int) {
}
PhysicsServer3D_soft_body_get_collision_mask :: (using self: *PhysicsServer3D, body: RID) -> int {
}
PhysicsServer3D_soft_body_add_collision_exception :: (using self: *PhysicsServer3D, body: RID, body_b: RID) {
}
PhysicsServer3D_soft_body_remove_collision_exception :: (using self: *PhysicsServer3D, body: RID, body_b: RID) {
}
PhysicsServer3D_soft_body_set_state :: (using self: *PhysicsServer3D, body: RID, state: PhysicsServer3D.BodyState, variant: Variant) {
}
PhysicsServer3D_soft_body_get_state :: (using self: *PhysicsServer3D, body: RID, state: PhysicsServer3D.BodyState) -> Variant {
}
PhysicsServer3D_soft_body_set_transform :: (using self: *PhysicsServer3D, body: RID, transform: Transform3D) {
}
PhysicsServer3D_soft_body_set_ray_pickable :: (using self: *PhysicsServer3D, body: RID, enable: bool) {
}
PhysicsServer3D_soft_body_set_simulation_precision :: (using self: *PhysicsServer3D, body: RID, simulation_precision: int) {
}
PhysicsServer3D_soft_body_get_simulation_precision :: (using self: *PhysicsServer3D, body: RID) -> int {
}
PhysicsServer3D_soft_body_set_total_mass :: (using self: *PhysicsServer3D, body: RID, total_mass: float) {
}
PhysicsServer3D_soft_body_get_total_mass :: (using self: *PhysicsServer3D, body: RID) -> float {
}
PhysicsServer3D_soft_body_set_linear_stiffness :: (using self: *PhysicsServer3D, body: RID, stiffness: float) {
}
PhysicsServer3D_soft_body_get_linear_stiffness :: (using self: *PhysicsServer3D, body: RID) -> float {
}
PhysicsServer3D_soft_body_set_pressure_coefficient :: (using self: *PhysicsServer3D, body: RID, pressure_coefficient: float) {
}
PhysicsServer3D_soft_body_get_pressure_coefficient :: (using self: *PhysicsServer3D, body: RID) -> float {
}
PhysicsServer3D_soft_body_set_damping_coefficient :: (using self: *PhysicsServer3D, body: RID, damping_coefficient: float) {
}
PhysicsServer3D_soft_body_get_damping_coefficient :: (using self: *PhysicsServer3D, body: RID) -> float {
}
PhysicsServer3D_soft_body_set_drag_coefficient :: (using self: *PhysicsServer3D, body: RID, drag_coefficient: float) {
}
PhysicsServer3D_soft_body_get_drag_coefficient :: (using self: *PhysicsServer3D, body: RID) -> float {
}
PhysicsServer3D_soft_body_move_point :: (using self: *PhysicsServer3D, body: RID, point_index: int, global_position: Vector3) {
}
PhysicsServer3D_soft_body_get_point_global_position :: (using self: *PhysicsServer3D, body: RID, point_index: int) -> Vector3 {
}
PhysicsServer3D_soft_body_remove_all_pinned_points :: (using self: *PhysicsServer3D, body: RID) {
}
PhysicsServer3D_soft_body_pin_point :: (using self: *PhysicsServer3D, body: RID, point_index: int, pin: bool) {
}
PhysicsServer3D_soft_body_is_point_pinned :: (using self: *PhysicsServer3D, body: RID, point_index: int) -> bool {
}
PhysicsServer3D_joint_create :: (using self: *PhysicsServer3D) -> RID {
}
PhysicsServer3D_joint_clear :: (using self: *PhysicsServer3D, joint: RID) {
}
PhysicsServer3D_joint_make_pin :: (using self: *PhysicsServer3D, joint: RID, body_A: RID, local_A: Vector3, body_B: RID, local_B: Vector3) {
}
PhysicsServer3D_pin_joint_set_param :: (using self: *PhysicsServer3D, joint: RID, param: PhysicsServer3D.PinJointParam, value: float) {
}
PhysicsServer3D_pin_joint_get_param :: (using self: *PhysicsServer3D, joint: RID, param: PhysicsServer3D.PinJointParam) -> float {
}
PhysicsServer3D_pin_joint_set_local_a :: (using self: *PhysicsServer3D, joint: RID, local_A: Vector3) {
}
PhysicsServer3D_pin_joint_get_local_a :: (using self: *PhysicsServer3D, joint: RID) -> Vector3 {
}
PhysicsServer3D_pin_joint_set_local_b :: (using self: *PhysicsServer3D, joint: RID, local_B: Vector3) {
}
PhysicsServer3D_pin_joint_get_local_b :: (using self: *PhysicsServer3D, joint: RID) -> Vector3 {
}
PhysicsServer3D_joint_make_hinge :: (using self: *PhysicsServer3D, joint: RID, body_A: RID, hinge_A: Transform3D, body_B: RID, hinge_B: Transform3D) {
}
PhysicsServer3D_hinge_joint_set_param :: (using self: *PhysicsServer3D, joint: RID, param: PhysicsServer3D.HingeJointParam, value: float) {
}
PhysicsServer3D_hinge_joint_get_param :: (using self: *PhysicsServer3D, joint: RID, param: PhysicsServer3D.HingeJointParam) -> float {
}
PhysicsServer3D_hinge_joint_set_flag :: (using self: *PhysicsServer3D, joint: RID, flag: PhysicsServer3D.HingeJointFlag, enabled: bool) {
}
PhysicsServer3D_hinge_joint_get_flag :: (using self: *PhysicsServer3D, joint: RID, flag: PhysicsServer3D.HingeJointFlag) -> bool {
}
PhysicsServer3D_joint_make_slider :: (using self: *PhysicsServer3D, joint: RID, body_A: RID, local_ref_A: Transform3D, body_B: RID, local_ref_B: Transform3D) {
}
PhysicsServer3D_slider_joint_set_param :: (using self: *PhysicsServer3D, joint: RID, param: PhysicsServer3D.SliderJointParam, value: float) {
}
PhysicsServer3D_slider_joint_get_param :: (using self: *PhysicsServer3D, joint: RID, param: PhysicsServer3D.SliderJointParam) -> float {
}
PhysicsServer3D_joint_make_cone_twist :: (using self: *PhysicsServer3D, joint: RID, body_A: RID, local_ref_A: Transform3D, body_B: RID, local_ref_B: Transform3D) {
}
PhysicsServer3D_cone_twist_joint_set_param :: (using self: *PhysicsServer3D, joint: RID, param: PhysicsServer3D.ConeTwistJointParam, value: float) {
}
PhysicsServer3D_cone_twist_joint_get_param :: (using self: *PhysicsServer3D, joint: RID, param: PhysicsServer3D.ConeTwistJointParam) -> float {
}
PhysicsServer3D_joint_get_type :: (using self: *PhysicsServer3D, joint: RID) -> PhysicsServer3D.JointType {
}
PhysicsServer3D_joint_set_solver_priority :: (using self: *PhysicsServer3D, joint: RID, priority: int) {
}
PhysicsServer3D_joint_get_solver_priority :: (using self: *PhysicsServer3D, joint: RID) -> int {
}
PhysicsServer3D_joint_disable_collisions_between_bodies :: (using self: *PhysicsServer3D, joint: RID, disable: bool) {
}
PhysicsServer3D_joint_is_disabled_collisions_between_bodies :: (using self: *PhysicsServer3D, joint: RID) -> bool {
}
PhysicsServer3D_joint_make_generic_6dof :: (using self: *PhysicsServer3D, joint: RID, body_A: RID, local_ref_A: Transform3D, body_B: RID, local_ref_B: Transform3D) {
}
PhysicsServer3D_generic_6dof_joint_set_param :: (using self: *PhysicsServer3D, joint: RID, axis: Vector3.Axis, param: PhysicsServer3D.G6DOFJointAxisParam, value: float) {
}
PhysicsServer3D_generic_6dof_joint_get_param :: (using self: *PhysicsServer3D, joint: RID, axis: Vector3.Axis, param: PhysicsServer3D.G6DOFJointAxisParam) -> float {
}
PhysicsServer3D_generic_6dof_joint_set_flag :: (using self: *PhysicsServer3D, joint: RID, axis: Vector3.Axis, flag: PhysicsServer3D.G6DOFJointAxisFlag, enable: bool) {
}
PhysicsServer3D_generic_6dof_joint_get_flag :: (using self: *PhysicsServer3D, joint: RID, axis: Vector3.Axis, flag: PhysicsServer3D.G6DOFJointAxisFlag) -> bool {
}
PhysicsServer3D_free_rid :: (using self: *PhysicsServer3D, rid: RID) {
}
PhysicsServer3D_set_active :: (using self: *PhysicsServer3D, active: bool) {
}
PhysicsServer3D_get_process_info :: (using self: *PhysicsServer3D, process_info: PhysicsServer3D.ProcessInfo) -> int {
}

// PhysicsServer3DExtension
PhysicsServer3DExtension :: struct {
	__private: *void;
}

PhysicsServer3DExtension__world_boundary_shape_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__separation_ray_shape_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__sphere_shape_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__box_shape_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__capsule_shape_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__cylinder_shape_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__convex_polygon_shape_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__concave_polygon_shape_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__heightmap_shape_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__custom_shape_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__shape_set_data :: (using self: *PhysicsServer3DExtension, shape: RID, data: Variant) {
}
PhysicsServer3DExtension__shape_set_custom_solver_bias :: (using self: *PhysicsServer3DExtension, shape: RID, bias: float) {
}
PhysicsServer3DExtension__shape_set_margin :: (using self: *PhysicsServer3DExtension, shape: RID, margin: float) {
}
PhysicsServer3DExtension__shape_get_margin :: (using self: *PhysicsServer3DExtension, shape: RID) -> float {
}
PhysicsServer3DExtension__shape_get_type :: (using self: *PhysicsServer3DExtension, shape: RID) -> PhysicsServer3D.ShapeType {
}
PhysicsServer3DExtension__shape_get_data :: (using self: *PhysicsServer3DExtension, shape: RID) -> Variant {
}
PhysicsServer3DExtension__shape_get_custom_solver_bias :: (using self: *PhysicsServer3DExtension, shape: RID) -> float {
}
PhysicsServer3DExtension__space_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__space_set_active :: (using self: *PhysicsServer3DExtension, space: RID, active: bool) {
}
PhysicsServer3DExtension__space_is_active :: (using self: *PhysicsServer3DExtension, space: RID) -> bool {
}
PhysicsServer3DExtension__space_set_param :: (using self: *PhysicsServer3DExtension, space: RID, param: PhysicsServer3D.SpaceParameter, value: float) {
}
PhysicsServer3DExtension__space_get_param :: (using self: *PhysicsServer3DExtension, space: RID, param: PhysicsServer3D.SpaceParameter) -> float {
}
PhysicsServer3DExtension__space_get_direct_state :: (using self: *PhysicsServer3DExtension, space: RID) -> PhysicsDirectSpaceState3D {
}
PhysicsServer3DExtension__space_set_debug_contacts :: (using self: *PhysicsServer3DExtension, space: RID, max_contacts: int) {
}
PhysicsServer3DExtension__space_get_contacts :: (using self: *PhysicsServer3DExtension, space: RID) -> PackedVector3Array {
}
PhysicsServer3DExtension__space_get_contact_count :: (using self: *PhysicsServer3DExtension, space: RID) -> int {
}
PhysicsServer3DExtension__area_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__area_set_space :: (using self: *PhysicsServer3DExtension, area: RID, space: RID) {
}
PhysicsServer3DExtension__area_get_space :: (using self: *PhysicsServer3DExtension, area: RID) -> RID {
}
PhysicsServer3DExtension__area_add_shape :: (using self: *PhysicsServer3DExtension, area: RID, shape: RID, transform: Transform3D, disabled: bool) {
}
PhysicsServer3DExtension__area_set_shape :: (using self: *PhysicsServer3DExtension, area: RID, shape_idx: int, shape: RID) {
}
PhysicsServer3DExtension__area_set_shape_transform :: (using self: *PhysicsServer3DExtension, area: RID, shape_idx: int, transform: Transform3D) {
}
PhysicsServer3DExtension__area_set_shape_disabled :: (using self: *PhysicsServer3DExtension, area: RID, shape_idx: int, disabled: bool) {
}
PhysicsServer3DExtension__area_get_shape_count :: (using self: *PhysicsServer3DExtension, area: RID) -> int {
}
PhysicsServer3DExtension__area_get_shape :: (using self: *PhysicsServer3DExtension, area: RID, shape_idx: int) -> RID {
}
PhysicsServer3DExtension__area_get_shape_transform :: (using self: *PhysicsServer3DExtension, area: RID, shape_idx: int) -> Transform3D {
}
PhysicsServer3DExtension__area_remove_shape :: (using self: *PhysicsServer3DExtension, area: RID, shape_idx: int) {
}
PhysicsServer3DExtension__area_clear_shapes :: (using self: *PhysicsServer3DExtension, area: RID) {
}
PhysicsServer3DExtension__area_attach_object_instance_id :: (using self: *PhysicsServer3DExtension, area: RID, id: int) {
}
PhysicsServer3DExtension__area_get_object_instance_id :: (using self: *PhysicsServer3DExtension, area: RID) -> int {
}
PhysicsServer3DExtension__area_set_param :: (using self: *PhysicsServer3DExtension, area: RID, param: PhysicsServer3D.AreaParameter, value: Variant) {
}
PhysicsServer3DExtension__area_set_transform :: (using self: *PhysicsServer3DExtension, area: RID, transform: Transform3D) {
}
PhysicsServer3DExtension__area_get_param :: (using self: *PhysicsServer3DExtension, area: RID, param: PhysicsServer3D.AreaParameter) -> Variant {
}
PhysicsServer3DExtension__area_get_transform :: (using self: *PhysicsServer3DExtension, area: RID) -> Transform3D {
}
PhysicsServer3DExtension__area_set_collision_layer :: (using self: *PhysicsServer3DExtension, area: RID, layer: int) {
}
PhysicsServer3DExtension__area_get_collision_layer :: (using self: *PhysicsServer3DExtension, area: RID) -> int {
}
PhysicsServer3DExtension__area_set_collision_mask :: (using self: *PhysicsServer3DExtension, area: RID, mask: int) {
}
PhysicsServer3DExtension__area_get_collision_mask :: (using self: *PhysicsServer3DExtension, area: RID) -> int {
}
PhysicsServer3DExtension__area_set_monitorable :: (using self: *PhysicsServer3DExtension, area: RID, monitorable: bool) {
}
PhysicsServer3DExtension__area_set_ray_pickable :: (using self: *PhysicsServer3DExtension, area: RID, enable: bool) {
}
PhysicsServer3DExtension__area_set_monitor_callback :: (using self: *PhysicsServer3DExtension, area: RID, callback: Callable) {
}
PhysicsServer3DExtension__area_set_area_monitor_callback :: (using self: *PhysicsServer3DExtension, area: RID, callback: Callable) {
}
PhysicsServer3DExtension__body_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__body_set_space :: (using self: *PhysicsServer3DExtension, body: RID, space: RID) {
}
PhysicsServer3DExtension__body_get_space :: (using self: *PhysicsServer3DExtension, body: RID) -> RID {
}
PhysicsServer3DExtension__body_set_mode :: (using self: *PhysicsServer3DExtension, body: RID, mode: PhysicsServer3D.BodyMode) {
}
PhysicsServer3DExtension__body_get_mode :: (using self: *PhysicsServer3DExtension, body: RID) -> PhysicsServer3D.BodyMode {
}
PhysicsServer3DExtension__body_add_shape :: (using self: *PhysicsServer3DExtension, body: RID, shape: RID, transform: Transform3D, disabled: bool) {
}
PhysicsServer3DExtension__body_set_shape :: (using self: *PhysicsServer3DExtension, body: RID, shape_idx: int, shape: RID) {
}
PhysicsServer3DExtension__body_set_shape_transform :: (using self: *PhysicsServer3DExtension, body: RID, shape_idx: int, transform: Transform3D) {
}
PhysicsServer3DExtension__body_set_shape_disabled :: (using self: *PhysicsServer3DExtension, body: RID, shape_idx: int, disabled: bool) {
}
PhysicsServer3DExtension__body_get_shape_count :: (using self: *PhysicsServer3DExtension, body: RID) -> int {
}
PhysicsServer3DExtension__body_get_shape :: (using self: *PhysicsServer3DExtension, body: RID, shape_idx: int) -> RID {
}
PhysicsServer3DExtension__body_get_shape_transform :: (using self: *PhysicsServer3DExtension, body: RID, shape_idx: int) -> Transform3D {
}
PhysicsServer3DExtension__body_remove_shape :: (using self: *PhysicsServer3DExtension, body: RID, shape_idx: int) {
}
PhysicsServer3DExtension__body_clear_shapes :: (using self: *PhysicsServer3DExtension, body: RID) {
}
PhysicsServer3DExtension__body_attach_object_instance_id :: (using self: *PhysicsServer3DExtension, body: RID, id: int) {
}
PhysicsServer3DExtension__body_get_object_instance_id :: (using self: *PhysicsServer3DExtension, body: RID) -> int {
}
PhysicsServer3DExtension__body_set_enable_continuous_collision_detection :: (using self: *PhysicsServer3DExtension, body: RID, enable: bool) {
}
PhysicsServer3DExtension__body_is_continuous_collision_detection_enabled :: (using self: *PhysicsServer3DExtension, body: RID) -> bool {
}
PhysicsServer3DExtension__body_set_collision_layer :: (using self: *PhysicsServer3DExtension, body: RID, layer: int) {
}
PhysicsServer3DExtension__body_get_collision_layer :: (using self: *PhysicsServer3DExtension, body: RID) -> int {
}
PhysicsServer3DExtension__body_set_collision_mask :: (using self: *PhysicsServer3DExtension, body: RID, mask: int) {
}
PhysicsServer3DExtension__body_get_collision_mask :: (using self: *PhysicsServer3DExtension, body: RID) -> int {
}
PhysicsServer3DExtension__body_set_collision_priority :: (using self: *PhysicsServer3DExtension, body: RID, priority: float) {
}
PhysicsServer3DExtension__body_get_collision_priority :: (using self: *PhysicsServer3DExtension, body: RID) -> float {
}
PhysicsServer3DExtension__body_set_user_flags :: (using self: *PhysicsServer3DExtension, body: RID, flags: int) {
}
PhysicsServer3DExtension__body_get_user_flags :: (using self: *PhysicsServer3DExtension, body: RID) -> int {
}
PhysicsServer3DExtension__body_set_param :: (using self: *PhysicsServer3DExtension, body: RID, param: PhysicsServer3D.BodyParameter, value: Variant) {
}
PhysicsServer3DExtension__body_get_param :: (using self: *PhysicsServer3DExtension, body: RID, param: PhysicsServer3D.BodyParameter) -> Variant {
}
PhysicsServer3DExtension__body_reset_mass_properties :: (using self: *PhysicsServer3DExtension, body: RID) {
}
PhysicsServer3DExtension__body_set_state :: (using self: *PhysicsServer3DExtension, body: RID, state: PhysicsServer3D.BodyState, value: Variant) {
}
PhysicsServer3DExtension__body_get_state :: (using self: *PhysicsServer3DExtension, body: RID, state: PhysicsServer3D.BodyState) -> Variant {
}
PhysicsServer3DExtension__body_apply_central_impulse :: (using self: *PhysicsServer3DExtension, body: RID, impulse: Vector3) {
}
PhysicsServer3DExtension__body_apply_impulse :: (using self: *PhysicsServer3DExtension, body: RID, impulse: Vector3, position: Vector3) {
}
PhysicsServer3DExtension__body_apply_torque_impulse :: (using self: *PhysicsServer3DExtension, body: RID, impulse: Vector3) {
}
PhysicsServer3DExtension__body_apply_central_force :: (using self: *PhysicsServer3DExtension, body: RID, force: Vector3) {
}
PhysicsServer3DExtension__body_apply_force :: (using self: *PhysicsServer3DExtension, body: RID, force: Vector3, position: Vector3) {
}
PhysicsServer3DExtension__body_apply_torque :: (using self: *PhysicsServer3DExtension, body: RID, torque: Vector3) {
}
PhysicsServer3DExtension__body_add_constant_central_force :: (using self: *PhysicsServer3DExtension, body: RID, force: Vector3) {
}
PhysicsServer3DExtension__body_add_constant_force :: (using self: *PhysicsServer3DExtension, body: RID, force: Vector3, position: Vector3) {
}
PhysicsServer3DExtension__body_add_constant_torque :: (using self: *PhysicsServer3DExtension, body: RID, torque: Vector3) {
}
PhysicsServer3DExtension__body_set_constant_force :: (using self: *PhysicsServer3DExtension, body: RID, force: Vector3) {
}
PhysicsServer3DExtension__body_get_constant_force :: (using self: *PhysicsServer3DExtension, body: RID) -> Vector3 {
}
PhysicsServer3DExtension__body_set_constant_torque :: (using self: *PhysicsServer3DExtension, body: RID, torque: Vector3) {
}
PhysicsServer3DExtension__body_get_constant_torque :: (using self: *PhysicsServer3DExtension, body: RID) -> Vector3 {
}
PhysicsServer3DExtension__body_set_axis_velocity :: (using self: *PhysicsServer3DExtension, body: RID, axis_velocity: Vector3) {
}
PhysicsServer3DExtension__body_set_axis_lock :: (using self: *PhysicsServer3DExtension, body: RID, axis: PhysicsServer3D.BodyAxis, lock: bool) {
}
PhysicsServer3DExtension__body_is_axis_locked :: (using self: *PhysicsServer3DExtension, body: RID, axis: PhysicsServer3D.BodyAxis) -> bool {
}
PhysicsServer3DExtension__body_add_collision_exception :: (using self: *PhysicsServer3DExtension, body: RID, excepted_body: RID) {
}
PhysicsServer3DExtension__body_remove_collision_exception :: (using self: *PhysicsServer3DExtension, body: RID, excepted_body: RID) {
}
PhysicsServer3DExtension__body_get_collision_exceptions :: (using self: *PhysicsServer3DExtension, body: RID) -> Array {
}
PhysicsServer3DExtension__body_set_max_contacts_reported :: (using self: *PhysicsServer3DExtension, body: RID, amount: int) {
}
PhysicsServer3DExtension__body_get_max_contacts_reported :: (using self: *PhysicsServer3DExtension, body: RID) -> int {
}
PhysicsServer3DExtension__body_set_contacts_reported_depth_threshold :: (using self: *PhysicsServer3DExtension, body: RID, threshold: float) {
}
PhysicsServer3DExtension__body_get_contacts_reported_depth_threshold :: (using self: *PhysicsServer3DExtension, body: RID) -> float {
}
PhysicsServer3DExtension__body_set_omit_force_integration :: (using self: *PhysicsServer3DExtension, body: RID, enable: bool) {
}
PhysicsServer3DExtension__body_is_omitting_force_integration :: (using self: *PhysicsServer3DExtension, body: RID) -> bool {
}
PhysicsServer3DExtension__body_set_state_sync_callback :: (using self: *PhysicsServer3DExtension, body: RID, callable: Callable) {
}
PhysicsServer3DExtension__body_set_force_integration_callback :: (using self: *PhysicsServer3DExtension, body: RID, callable: Callable, userdata: Variant) {
}
PhysicsServer3DExtension__body_set_ray_pickable :: (using self: *PhysicsServer3DExtension, body: RID, enable: bool) {
}
PhysicsServer3DExtension__body_test_motion :: (using self: *PhysicsServer3DExtension, body: RID, from: Transform3D, motion: Vector3, margin: float, max_collisions: int, collide_separation_ray: bool, recovery_as_collision: bool, result: *PhysicsServer3DExtensionMotionResult) -> bool {
}
PhysicsServer3DExtension__body_get_direct_state :: (using self: *PhysicsServer3DExtension, body: RID) -> PhysicsDirectBodyState3D {
}
PhysicsServer3DExtension__soft_body_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__soft_body_update_rendering_server :: (using self: *PhysicsServer3DExtension, body: RID, rendering_server_handler: PhysicsServer3DRenderingServerHandler) {
}
PhysicsServer3DExtension__soft_body_set_space :: (using self: *PhysicsServer3DExtension, body: RID, space: RID) {
}
PhysicsServer3DExtension__soft_body_get_space :: (using self: *PhysicsServer3DExtension, body: RID) -> RID {
}
PhysicsServer3DExtension__soft_body_set_ray_pickable :: (using self: *PhysicsServer3DExtension, body: RID, enable: bool) {
}
PhysicsServer3DExtension__soft_body_set_collision_layer :: (using self: *PhysicsServer3DExtension, body: RID, layer: int) {
}
PhysicsServer3DExtension__soft_body_get_collision_layer :: (using self: *PhysicsServer3DExtension, body: RID) -> int {
}
PhysicsServer3DExtension__soft_body_set_collision_mask :: (using self: *PhysicsServer3DExtension, body: RID, mask: int) {
}
PhysicsServer3DExtension__soft_body_get_collision_mask :: (using self: *PhysicsServer3DExtension, body: RID) -> int {
}
PhysicsServer3DExtension__soft_body_add_collision_exception :: (using self: *PhysicsServer3DExtension, body: RID, body_b: RID) {
}
PhysicsServer3DExtension__soft_body_remove_collision_exception :: (using self: *PhysicsServer3DExtension, body: RID, body_b: RID) {
}
PhysicsServer3DExtension__soft_body_get_collision_exceptions :: (using self: *PhysicsServer3DExtension, body: RID) -> Array {
}
PhysicsServer3DExtension__soft_body_set_state :: (using self: *PhysicsServer3DExtension, body: RID, state: PhysicsServer3D.BodyState, variant: Variant) {
}
PhysicsServer3DExtension__soft_body_get_state :: (using self: *PhysicsServer3DExtension, body: RID, state: PhysicsServer3D.BodyState) -> Variant {
}
PhysicsServer3DExtension__soft_body_set_transform :: (using self: *PhysicsServer3DExtension, body: RID, transform: Transform3D) {
}
PhysicsServer3DExtension__soft_body_set_simulation_precision :: (using self: *PhysicsServer3DExtension, body: RID, simulation_precision: int) {
}
PhysicsServer3DExtension__soft_body_get_simulation_precision :: (using self: *PhysicsServer3DExtension, body: RID) -> int {
}
PhysicsServer3DExtension__soft_body_set_total_mass :: (using self: *PhysicsServer3DExtension, body: RID, total_mass: float) {
}
PhysicsServer3DExtension__soft_body_get_total_mass :: (using self: *PhysicsServer3DExtension, body: RID) -> float {
}
PhysicsServer3DExtension__soft_body_set_linear_stiffness :: (using self: *PhysicsServer3DExtension, body: RID, linear_stiffness: float) {
}
PhysicsServer3DExtension__soft_body_get_linear_stiffness :: (using self: *PhysicsServer3DExtension, body: RID) -> float {
}
PhysicsServer3DExtension__soft_body_set_pressure_coefficient :: (using self: *PhysicsServer3DExtension, body: RID, pressure_coefficient: float) {
}
PhysicsServer3DExtension__soft_body_get_pressure_coefficient :: (using self: *PhysicsServer3DExtension, body: RID) -> float {
}
PhysicsServer3DExtension__soft_body_set_damping_coefficient :: (using self: *PhysicsServer3DExtension, body: RID, damping_coefficient: float) {
}
PhysicsServer3DExtension__soft_body_get_damping_coefficient :: (using self: *PhysicsServer3DExtension, body: RID) -> float {
}
PhysicsServer3DExtension__soft_body_set_drag_coefficient :: (using self: *PhysicsServer3DExtension, body: RID, drag_coefficient: float) {
}
PhysicsServer3DExtension__soft_body_get_drag_coefficient :: (using self: *PhysicsServer3DExtension, body: RID) -> float {
}
PhysicsServer3DExtension__soft_body_set_mesh :: (using self: *PhysicsServer3DExtension, body: RID, mesh: RID) {
}
PhysicsServer3DExtension__soft_body_get_bounds :: (using self: *PhysicsServer3DExtension, body: RID) -> AABB {
}
PhysicsServer3DExtension__soft_body_move_point :: (using self: *PhysicsServer3DExtension, body: RID, point_index: int, global_position: Vector3) {
}
PhysicsServer3DExtension__soft_body_get_point_global_position :: (using self: *PhysicsServer3DExtension, body: RID, point_index: int) -> Vector3 {
}
PhysicsServer3DExtension__soft_body_remove_all_pinned_points :: (using self: *PhysicsServer3DExtension, body: RID) {
}
PhysicsServer3DExtension__soft_body_pin_point :: (using self: *PhysicsServer3DExtension, body: RID, point_index: int, pin: bool) {
}
PhysicsServer3DExtension__soft_body_is_point_pinned :: (using self: *PhysicsServer3DExtension, body: RID, point_index: int) -> bool {
}
PhysicsServer3DExtension__joint_create :: (using self: *PhysicsServer3DExtension) -> RID {
}
PhysicsServer3DExtension__joint_clear :: (using self: *PhysicsServer3DExtension, joint: RID) {
}
PhysicsServer3DExtension__joint_make_pin :: (using self: *PhysicsServer3DExtension, joint: RID, body_A: RID, local_A: Vector3, body_B: RID, local_B: Vector3) {
}
PhysicsServer3DExtension__pin_joint_set_param :: (using self: *PhysicsServer3DExtension, joint: RID, param: PhysicsServer3D.PinJointParam, value: float) {
}
PhysicsServer3DExtension__pin_joint_get_param :: (using self: *PhysicsServer3DExtension, joint: RID, param: PhysicsServer3D.PinJointParam) -> float {
}
PhysicsServer3DExtension__pin_joint_set_local_a :: (using self: *PhysicsServer3DExtension, joint: RID, local_A: Vector3) {
}
PhysicsServer3DExtension__pin_joint_get_local_a :: (using self: *PhysicsServer3DExtension, joint: RID) -> Vector3 {
}
PhysicsServer3DExtension__pin_joint_set_local_b :: (using self: *PhysicsServer3DExtension, joint: RID, local_B: Vector3) {
}
PhysicsServer3DExtension__pin_joint_get_local_b :: (using self: *PhysicsServer3DExtension, joint: RID) -> Vector3 {
}
PhysicsServer3DExtension__joint_make_hinge :: (using self: *PhysicsServer3DExtension, joint: RID, body_A: RID, hinge_A: Transform3D, body_B: RID, hinge_B: Transform3D) {
}
PhysicsServer3DExtension__joint_make_hinge_simple :: (using self: *PhysicsServer3DExtension, joint: RID, body_A: RID, pivot_A: Vector3, axis_A: Vector3, body_B: RID, pivot_B: Vector3, axis_B: Vector3) {
}
PhysicsServer3DExtension__hinge_joint_set_param :: (using self: *PhysicsServer3DExtension, joint: RID, param: PhysicsServer3D.HingeJointParam, value: float) {
}
PhysicsServer3DExtension__hinge_joint_get_param :: (using self: *PhysicsServer3DExtension, joint: RID, param: PhysicsServer3D.HingeJointParam) -> float {
}
PhysicsServer3DExtension__hinge_joint_set_flag :: (using self: *PhysicsServer3DExtension, joint: RID, flag: PhysicsServer3D.HingeJointFlag, enabled: bool) {
}
PhysicsServer3DExtension__hinge_joint_get_flag :: (using self: *PhysicsServer3DExtension, joint: RID, flag: PhysicsServer3D.HingeJointFlag) -> bool {
}
PhysicsServer3DExtension__joint_make_slider :: (using self: *PhysicsServer3DExtension, joint: RID, body_A: RID, local_ref_A: Transform3D, body_B: RID, local_ref_B: Transform3D) {
}
PhysicsServer3DExtension__slider_joint_set_param :: (using self: *PhysicsServer3DExtension, joint: RID, param: PhysicsServer3D.SliderJointParam, value: float) {
}
PhysicsServer3DExtension__slider_joint_get_param :: (using self: *PhysicsServer3DExtension, joint: RID, param: PhysicsServer3D.SliderJointParam) -> float {
}
PhysicsServer3DExtension__joint_make_cone_twist :: (using self: *PhysicsServer3DExtension, joint: RID, body_A: RID, local_ref_A: Transform3D, body_B: RID, local_ref_B: Transform3D) {
}
PhysicsServer3DExtension__cone_twist_joint_set_param :: (using self: *PhysicsServer3DExtension, joint: RID, param: PhysicsServer3D.ConeTwistJointParam, value: float) {
}
PhysicsServer3DExtension__cone_twist_joint_get_param :: (using self: *PhysicsServer3DExtension, joint: RID, param: PhysicsServer3D.ConeTwistJointParam) -> float {
}
PhysicsServer3DExtension__joint_make_generic_6dof :: (using self: *PhysicsServer3DExtension, joint: RID, body_A: RID, local_ref_A: Transform3D, body_B: RID, local_ref_B: Transform3D) {
}
PhysicsServer3DExtension__generic_6dof_joint_set_param :: (using self: *PhysicsServer3DExtension, joint: RID, axis: Vector3.Axis, param: PhysicsServer3D.G6DOFJointAxisParam, value: float) {
}
PhysicsServer3DExtension__generic_6dof_joint_get_param :: (using self: *PhysicsServer3DExtension, joint: RID, axis: Vector3.Axis, param: PhysicsServer3D.G6DOFJointAxisParam) -> float {
}
PhysicsServer3DExtension__generic_6dof_joint_set_flag :: (using self: *PhysicsServer3DExtension, joint: RID, axis: Vector3.Axis, flag: PhysicsServer3D.G6DOFJointAxisFlag, enable: bool) {
}
PhysicsServer3DExtension__generic_6dof_joint_get_flag :: (using self: *PhysicsServer3DExtension, joint: RID, axis: Vector3.Axis, flag: PhysicsServer3D.G6DOFJointAxisFlag) -> bool {
}
PhysicsServer3DExtension__joint_get_type :: (using self: *PhysicsServer3DExtension, joint: RID) -> PhysicsServer3D.JointType {
}
PhysicsServer3DExtension__joint_set_solver_priority :: (using self: *PhysicsServer3DExtension, joint: RID, priority: int) {
}
PhysicsServer3DExtension__joint_get_solver_priority :: (using self: *PhysicsServer3DExtension, joint: RID) -> int {
}
PhysicsServer3DExtension__joint_disable_collisions_between_bodies :: (using self: *PhysicsServer3DExtension, joint: RID, disable: bool) {
}
PhysicsServer3DExtension__joint_is_disabled_collisions_between_bodies :: (using self: *PhysicsServer3DExtension, joint: RID) -> bool {
}
PhysicsServer3DExtension__free_rid :: (using self: *PhysicsServer3DExtension, rid: RID) {
}
PhysicsServer3DExtension__set_active :: (using self: *PhysicsServer3DExtension, active: bool) {
}
PhysicsServer3DExtension__init :: (using self: *PhysicsServer3DExtension) {
}
PhysicsServer3DExtension__step :: (using self: *PhysicsServer3DExtension, step: float) {
}
PhysicsServer3DExtension__sync :: (using self: *PhysicsServer3DExtension) {
}
PhysicsServer3DExtension__flush_queries :: (using self: *PhysicsServer3DExtension) {
}
PhysicsServer3DExtension__end_sync :: (using self: *PhysicsServer3DExtension) {
}
PhysicsServer3DExtension__finish :: (using self: *PhysicsServer3DExtension) {
}
PhysicsServer3DExtension__is_flushing_queries :: (using self: *PhysicsServer3DExtension) -> bool {
}
PhysicsServer3DExtension__get_process_info :: (using self: *PhysicsServer3DExtension, process_info: PhysicsServer3D.ProcessInfo) -> int {
}
PhysicsServer3DExtension_body_test_motion_is_excluding_body :: (using self: *PhysicsServer3DExtension, body: RID) -> bool {
}
PhysicsServer3DExtension_body_test_motion_is_excluding_object :: (using self: *PhysicsServer3DExtension, object: int) -> bool {
}

// PhysicsServer3DManager
PhysicsServer3DManager :: struct {
	__private: *void;
}

PhysicsServer3DManager_register_server :: (using self: *PhysicsServer3DManager, name: String, create_callback: Callable) {
}
PhysicsServer3DManager_set_default_server :: (using self: *PhysicsServer3DManager, name: String, priority: int) {
}

// PhysicsServer3DRenderingServerHandler
PhysicsServer3DRenderingServerHandler :: struct {
	__private: *void;
}

PhysicsServer3DRenderingServerHandler__set_vertex :: (using self: *PhysicsServer3DRenderingServerHandler, vertex_id: int, vertex: Vector3) {
}
PhysicsServer3DRenderingServerHandler__set_normal :: (using self: *PhysicsServer3DRenderingServerHandler, vertex_id: int, normal: Vector3) {
}
PhysicsServer3DRenderingServerHandler__set_aabb :: (using self: *PhysicsServer3DRenderingServerHandler, aabb: AABB) {
}
PhysicsServer3DRenderingServerHandler_set_vertex :: (using self: *PhysicsServer3DRenderingServerHandler, vertex_id: int, vertex: Vector3) {
}
PhysicsServer3DRenderingServerHandler_set_normal :: (using self: *PhysicsServer3DRenderingServerHandler, vertex_id: int, normal: Vector3) {
}
PhysicsServer3DRenderingServerHandler_set_aabb :: (using self: *PhysicsServer3DRenderingServerHandler, aabb: AABB) {
}

// PhysicsShapeQueryParameters2D
PhysicsShapeQueryParameters2D :: struct {
	__private: *void;
}

PhysicsShapeQueryParameters2D_set_shape :: (using self: *PhysicsShapeQueryParameters2D, shape: Resource) {
}
PhysicsShapeQueryParameters2D_get_shape :: (using self: *PhysicsShapeQueryParameters2D) -> Resource {
}
PhysicsShapeQueryParameters2D_set_shape_rid :: (using self: *PhysicsShapeQueryParameters2D, shape: RID) {
}
PhysicsShapeQueryParameters2D_get_shape_rid :: (using self: *PhysicsShapeQueryParameters2D) -> RID {
}
PhysicsShapeQueryParameters2D_set_transform :: (using self: *PhysicsShapeQueryParameters2D, transform: Transform2D) {
}
PhysicsShapeQueryParameters2D_get_transform :: (using self: *PhysicsShapeQueryParameters2D) -> Transform2D {
}
PhysicsShapeQueryParameters2D_set_motion :: (using self: *PhysicsShapeQueryParameters2D, motion: Vector2) {
}
PhysicsShapeQueryParameters2D_get_motion :: (using self: *PhysicsShapeQueryParameters2D) -> Vector2 {
}
PhysicsShapeQueryParameters2D_set_margin :: (using self: *PhysicsShapeQueryParameters2D, margin: float) {
}
PhysicsShapeQueryParameters2D_get_margin :: (using self: *PhysicsShapeQueryParameters2D) -> float {
}
PhysicsShapeQueryParameters2D_set_collision_mask :: (using self: *PhysicsShapeQueryParameters2D, collision_mask: int) {
}
PhysicsShapeQueryParameters2D_get_collision_mask :: (using self: *PhysicsShapeQueryParameters2D) -> int {
}
PhysicsShapeQueryParameters2D_set_exclude :: (using self: *PhysicsShapeQueryParameters2D, exclude: Array) {
}
PhysicsShapeQueryParameters2D_get_exclude :: (using self: *PhysicsShapeQueryParameters2D) -> Array {
}
PhysicsShapeQueryParameters2D_set_collide_with_bodies :: (using self: *PhysicsShapeQueryParameters2D, enable: bool) {
}
PhysicsShapeQueryParameters2D_is_collide_with_bodies_enabled :: (using self: *PhysicsShapeQueryParameters2D) -> bool {
}
PhysicsShapeQueryParameters2D_set_collide_with_areas :: (using self: *PhysicsShapeQueryParameters2D, enable: bool) {
}
PhysicsShapeQueryParameters2D_is_collide_with_areas_enabled :: (using self: *PhysicsShapeQueryParameters2D) -> bool {
}

// PhysicsShapeQueryParameters3D
PhysicsShapeQueryParameters3D :: struct {
	__private: *void;
}

PhysicsShapeQueryParameters3D_set_shape :: (using self: *PhysicsShapeQueryParameters3D, shape: Resource) {
}
PhysicsShapeQueryParameters3D_get_shape :: (using self: *PhysicsShapeQueryParameters3D) -> Resource {
}
PhysicsShapeQueryParameters3D_set_shape_rid :: (using self: *PhysicsShapeQueryParameters3D, shape: RID) {
}
PhysicsShapeQueryParameters3D_get_shape_rid :: (using self: *PhysicsShapeQueryParameters3D) -> RID {
}
PhysicsShapeQueryParameters3D_set_transform :: (using self: *PhysicsShapeQueryParameters3D, transform: Transform3D) {
}
PhysicsShapeQueryParameters3D_get_transform :: (using self: *PhysicsShapeQueryParameters3D) -> Transform3D {
}
PhysicsShapeQueryParameters3D_set_motion :: (using self: *PhysicsShapeQueryParameters3D, motion: Vector3) {
}
PhysicsShapeQueryParameters3D_get_motion :: (using self: *PhysicsShapeQueryParameters3D) -> Vector3 {
}
PhysicsShapeQueryParameters3D_set_margin :: (using self: *PhysicsShapeQueryParameters3D, margin: float) {
}
PhysicsShapeQueryParameters3D_get_margin :: (using self: *PhysicsShapeQueryParameters3D) -> float {
}
PhysicsShapeQueryParameters3D_set_collision_mask :: (using self: *PhysicsShapeQueryParameters3D, collision_mask: int) {
}
PhysicsShapeQueryParameters3D_get_collision_mask :: (using self: *PhysicsShapeQueryParameters3D) -> int {
}
PhysicsShapeQueryParameters3D_set_exclude :: (using self: *PhysicsShapeQueryParameters3D, exclude: Array) {
}
PhysicsShapeQueryParameters3D_get_exclude :: (using self: *PhysicsShapeQueryParameters3D) -> Array {
}
PhysicsShapeQueryParameters3D_set_collide_with_bodies :: (using self: *PhysicsShapeQueryParameters3D, enable: bool) {
}
PhysicsShapeQueryParameters3D_is_collide_with_bodies_enabled :: (using self: *PhysicsShapeQueryParameters3D) -> bool {
}
PhysicsShapeQueryParameters3D_set_collide_with_areas :: (using self: *PhysicsShapeQueryParameters3D, enable: bool) {
}
PhysicsShapeQueryParameters3D_is_collide_with_areas_enabled :: (using self: *PhysicsShapeQueryParameters3D) -> bool {
}

// PhysicsTestMotionParameters2D
PhysicsTestMotionParameters2D :: struct {
	__private: *void;
}

PhysicsTestMotionParameters2D_get_from :: (using self: *PhysicsTestMotionParameters2D) -> Transform2D {
}
PhysicsTestMotionParameters2D_set_from :: (using self: *PhysicsTestMotionParameters2D, from: Transform2D) {
}
PhysicsTestMotionParameters2D_get_motion :: (using self: *PhysicsTestMotionParameters2D) -> Vector2 {
}
PhysicsTestMotionParameters2D_set_motion :: (using self: *PhysicsTestMotionParameters2D, motion: Vector2) {
}
PhysicsTestMotionParameters2D_get_margin :: (using self: *PhysicsTestMotionParameters2D) -> float {
}
PhysicsTestMotionParameters2D_set_margin :: (using self: *PhysicsTestMotionParameters2D, margin: float) {
}
PhysicsTestMotionParameters2D_is_collide_separation_ray_enabled :: (using self: *PhysicsTestMotionParameters2D) -> bool {
}
PhysicsTestMotionParameters2D_set_collide_separation_ray_enabled :: (using self: *PhysicsTestMotionParameters2D, enabled: bool) {
}
PhysicsTestMotionParameters2D_get_exclude_bodies :: (using self: *PhysicsTestMotionParameters2D) -> Array {
}
PhysicsTestMotionParameters2D_set_exclude_bodies :: (using self: *PhysicsTestMotionParameters2D, exclude_list: Array) {
}
PhysicsTestMotionParameters2D_get_exclude_objects :: (using self: *PhysicsTestMotionParameters2D) -> Array {
}
PhysicsTestMotionParameters2D_set_exclude_objects :: (using self: *PhysicsTestMotionParameters2D, exclude_list: Array) {
}
PhysicsTestMotionParameters2D_is_recovery_as_collision_enabled :: (using self: *PhysicsTestMotionParameters2D) -> bool {
}
PhysicsTestMotionParameters2D_set_recovery_as_collision_enabled :: (using self: *PhysicsTestMotionParameters2D, enabled: bool) {
}

// PhysicsTestMotionParameters3D
PhysicsTestMotionParameters3D :: struct {
	__private: *void;
}

PhysicsTestMotionParameters3D_get_from :: (using self: *PhysicsTestMotionParameters3D) -> Transform3D {
}
PhysicsTestMotionParameters3D_set_from :: (using self: *PhysicsTestMotionParameters3D, from: Transform3D) {
}
PhysicsTestMotionParameters3D_get_motion :: (using self: *PhysicsTestMotionParameters3D) -> Vector3 {
}
PhysicsTestMotionParameters3D_set_motion :: (using self: *PhysicsTestMotionParameters3D, motion: Vector3) {
}
PhysicsTestMotionParameters3D_get_margin :: (using self: *PhysicsTestMotionParameters3D) -> float {
}
PhysicsTestMotionParameters3D_set_margin :: (using self: *PhysicsTestMotionParameters3D, margin: float) {
}
PhysicsTestMotionParameters3D_get_max_collisions :: (using self: *PhysicsTestMotionParameters3D) -> int {
}
PhysicsTestMotionParameters3D_set_max_collisions :: (using self: *PhysicsTestMotionParameters3D, max_collisions: int) {
}
PhysicsTestMotionParameters3D_is_collide_separation_ray_enabled :: (using self: *PhysicsTestMotionParameters3D) -> bool {
}
PhysicsTestMotionParameters3D_set_collide_separation_ray_enabled :: (using self: *PhysicsTestMotionParameters3D, enabled: bool) {
}
PhysicsTestMotionParameters3D_get_exclude_bodies :: (using self: *PhysicsTestMotionParameters3D) -> Array {
}
PhysicsTestMotionParameters3D_set_exclude_bodies :: (using self: *PhysicsTestMotionParameters3D, exclude_list: Array) {
}
PhysicsTestMotionParameters3D_get_exclude_objects :: (using self: *PhysicsTestMotionParameters3D) -> Array {
}
PhysicsTestMotionParameters3D_set_exclude_objects :: (using self: *PhysicsTestMotionParameters3D, exclude_list: Array) {
}
PhysicsTestMotionParameters3D_is_recovery_as_collision_enabled :: (using self: *PhysicsTestMotionParameters3D) -> bool {
}
PhysicsTestMotionParameters3D_set_recovery_as_collision_enabled :: (using self: *PhysicsTestMotionParameters3D, enabled: bool) {
}

// PhysicsTestMotionResult2D
PhysicsTestMotionResult2D :: struct {
	__private: *void;
}

PhysicsTestMotionResult2D_get_travel :: (using self: *PhysicsTestMotionResult2D) -> Vector2 {
}
PhysicsTestMotionResult2D_get_remainder :: (using self: *PhysicsTestMotionResult2D) -> Vector2 {
}
PhysicsTestMotionResult2D_get_collision_point :: (using self: *PhysicsTestMotionResult2D) -> Vector2 {
}
PhysicsTestMotionResult2D_get_collision_normal :: (using self: *PhysicsTestMotionResult2D) -> Vector2 {
}
PhysicsTestMotionResult2D_get_collider_velocity :: (using self: *PhysicsTestMotionResult2D) -> Vector2 {
}
PhysicsTestMotionResult2D_get_collider_id :: (using self: *PhysicsTestMotionResult2D) -> int {
}
PhysicsTestMotionResult2D_get_collider_rid :: (using self: *PhysicsTestMotionResult2D) -> RID {
}
PhysicsTestMotionResult2D_get_collider :: (using self: *PhysicsTestMotionResult2D) -> Object {
}
PhysicsTestMotionResult2D_get_collider_shape :: (using self: *PhysicsTestMotionResult2D) -> int {
}
PhysicsTestMotionResult2D_get_collision_local_shape :: (using self: *PhysicsTestMotionResult2D) -> int {
}
PhysicsTestMotionResult2D_get_collision_depth :: (using self: *PhysicsTestMotionResult2D) -> float {
}
PhysicsTestMotionResult2D_get_collision_safe_fraction :: (using self: *PhysicsTestMotionResult2D) -> float {
}
PhysicsTestMotionResult2D_get_collision_unsafe_fraction :: (using self: *PhysicsTestMotionResult2D) -> float {
}

// PhysicsTestMotionResult3D
PhysicsTestMotionResult3D :: struct {
	__private: *void;
}

PhysicsTestMotionResult3D_get_travel :: (using self: *PhysicsTestMotionResult3D) -> Vector3 {
}
PhysicsTestMotionResult3D_get_remainder :: (using self: *PhysicsTestMotionResult3D) -> Vector3 {
}
PhysicsTestMotionResult3D_get_collision_safe_fraction :: (using self: *PhysicsTestMotionResult3D) -> float {
}
PhysicsTestMotionResult3D_get_collision_unsafe_fraction :: (using self: *PhysicsTestMotionResult3D) -> float {
}
PhysicsTestMotionResult3D_get_collision_count :: (using self: *PhysicsTestMotionResult3D) -> int {
}
PhysicsTestMotionResult3D_get_collision_point :: (using self: *PhysicsTestMotionResult3D, collision_index: int) -> Vector3 {
}
PhysicsTestMotionResult3D_get_collision_normal :: (using self: *PhysicsTestMotionResult3D, collision_index: int) -> Vector3 {
}
PhysicsTestMotionResult3D_get_collider_velocity :: (using self: *PhysicsTestMotionResult3D, collision_index: int) -> Vector3 {
}
PhysicsTestMotionResult3D_get_collider_id :: (using self: *PhysicsTestMotionResult3D, collision_index: int) -> int {
}
PhysicsTestMotionResult3D_get_collider_rid :: (using self: *PhysicsTestMotionResult3D, collision_index: int) -> RID {
}
PhysicsTestMotionResult3D_get_collider :: (using self: *PhysicsTestMotionResult3D, collision_index: int) -> Object {
}
PhysicsTestMotionResult3D_get_collider_shape :: (using self: *PhysicsTestMotionResult3D, collision_index: int) -> int {
}
PhysicsTestMotionResult3D_get_collision_local_shape :: (using self: *PhysicsTestMotionResult3D, collision_index: int) -> int {
}
PhysicsTestMotionResult3D_get_collision_depth :: (using self: *PhysicsTestMotionResult3D, collision_index: int) -> float {
}

// PinJoint2D
PinJoint2D :: struct {
	__private: *void;
}

PinJoint2D_set_softness :: (using self: *PinJoint2D, softness: float) {
}
PinJoint2D_get_softness :: (using self: *PinJoint2D) -> float {
}
PinJoint2D_set_angular_limit_lower :: (using self: *PinJoint2D, angular_limit_lower: float) {
}
PinJoint2D_get_angular_limit_lower :: (using self: *PinJoint2D) -> float {
}
PinJoint2D_set_angular_limit_upper :: (using self: *PinJoint2D, angular_limit_upper: float) {
}
PinJoint2D_get_angular_limit_upper :: (using self: *PinJoint2D) -> float {
}
PinJoint2D_set_motor_target_velocity :: (using self: *PinJoint2D, motor_target_velocity: float) {
}
PinJoint2D_get_motor_target_velocity :: (using self: *PinJoint2D) -> float {
}
PinJoint2D_set_motor_enabled :: (using self: *PinJoint2D, enabled: bool) {
}
PinJoint2D_is_motor_enabled :: (using self: *PinJoint2D) -> bool {
}
PinJoint2D_set_angular_limit_enabled :: (using self: *PinJoint2D, enabled: bool) {
}
PinJoint2D_is_angular_limit_enabled :: (using self: *PinJoint2D) -> bool {
}

// PinJoint3D
PinJoint3D :: struct {
	__private: *void;

	Param :: enum {
		PARAM_BIAS :: 0;
		PARAM_DAMPING :: 1;
		PARAM_IMPULSE_CLAMP :: 2;
	}
}

PinJoint3D_set_param :: (using self: *PinJoint3D, param: PinJoint3D.Param, value: float) {
}
PinJoint3D_get_param :: (using self: *PinJoint3D, param: PinJoint3D.Param) -> float {
}

// PlaceholderCubemap
PlaceholderCubemap :: struct {
	__private: *void;
}

// PlaceholderCubemapArray
PlaceholderCubemapArray :: struct {
	__private: *void;
}

// PlaceholderMaterial
PlaceholderMaterial :: struct {
	__private: *void;
}

// PlaceholderMesh
PlaceholderMesh :: struct {
	__private: *void;
}

PlaceholderMesh_set_aabb :: (using self: *PlaceholderMesh, aabb: AABB) {
}

// PlaceholderTexture2D
PlaceholderTexture2D :: struct {
	__private: *void;
}

PlaceholderTexture2D_set_size :: (using self: *PlaceholderTexture2D, size: Vector2) {
}

// PlaceholderTexture2DArray
PlaceholderTexture2DArray :: struct {
	__private: *void;
}

// PlaceholderTexture3D
PlaceholderTexture3D :: struct {
	__private: *void;
}

PlaceholderTexture3D_set_size :: (using self: *PlaceholderTexture3D, size: Vector3i) {
}
PlaceholderTexture3D_get_size :: (using self: *PlaceholderTexture3D) -> Vector3i {
}

// PlaceholderTextureLayered
PlaceholderTextureLayered :: struct {
	__private: *void;
}

PlaceholderTextureLayered_set_size :: (using self: *PlaceholderTextureLayered, size: Vector2i) {
}
PlaceholderTextureLayered_get_size :: (using self: *PlaceholderTextureLayered) -> Vector2i {
}
PlaceholderTextureLayered_set_layers :: (using self: *PlaceholderTextureLayered, layers: int) {
}

// PlaneMesh
PlaneMesh :: struct {
	__private: *void;

	Orientation :: enum {
		FACE_X :: 0;
		FACE_Y :: 1;
		FACE_Z :: 2;
	}
}

PlaneMesh_set_size :: (using self: *PlaneMesh, size: Vector2) {
}
PlaneMesh_get_size :: (using self: *PlaneMesh) -> Vector2 {
}
PlaneMesh_set_subdivide_width :: (using self: *PlaneMesh, subdivide: int) {
}
PlaneMesh_get_subdivide_width :: (using self: *PlaneMesh) -> int {
}
PlaneMesh_set_subdivide_depth :: (using self: *PlaneMesh, subdivide: int) {
}
PlaneMesh_get_subdivide_depth :: (using self: *PlaneMesh) -> int {
}
PlaneMesh_set_center_offset :: (using self: *PlaneMesh, offset: Vector3) {
}
PlaneMesh_get_center_offset :: (using self: *PlaneMesh) -> Vector3 {
}
PlaneMesh_set_orientation :: (using self: *PlaneMesh, orientation: PlaneMesh.Orientation) {
}
PlaneMesh_get_orientation :: (using self: *PlaneMesh) -> PlaneMesh.Orientation {
}

// PointLight2D
PointLight2D :: struct {
	__private: *void;
}

PointLight2D_set_texture :: (using self: *PointLight2D, texture: Texture2D) {
}
PointLight2D_get_texture :: (using self: *PointLight2D) -> Texture2D {
}
PointLight2D_set_texture_offset :: (using self: *PointLight2D, texture_offset: Vector2) {
}
PointLight2D_get_texture_offset :: (using self: *PointLight2D) -> Vector2 {
}
PointLight2D_set_texture_scale :: (using self: *PointLight2D, texture_scale: float) {
}
PointLight2D_get_texture_scale :: (using self: *PointLight2D) -> float {
}

// PointMesh
PointMesh :: struct {
	__private: *void;
}

// Polygon2D
Polygon2D :: struct {
	__private: *void;
}

Polygon2D_set_polygon :: (using self: *Polygon2D, polygon: PackedVector2Array) {
}
Polygon2D_get_polygon :: (using self: *Polygon2D) -> PackedVector2Array {
}
Polygon2D_set_uv :: (using self: *Polygon2D, uv: PackedVector2Array) {
}
Polygon2D_get_uv :: (using self: *Polygon2D) -> PackedVector2Array {
}
Polygon2D_set_color :: (using self: *Polygon2D, color: Color) {
}
Polygon2D_get_color :: (using self: *Polygon2D) -> Color {
}
Polygon2D_set_polygons :: (using self: *Polygon2D, polygons: Array) {
}
Polygon2D_get_polygons :: (using self: *Polygon2D) -> Array {
}
Polygon2D_set_vertex_colors :: (using self: *Polygon2D, vertex_colors: PackedColorArray) {
}
Polygon2D_get_vertex_colors :: (using self: *Polygon2D) -> PackedColorArray {
}
Polygon2D_set_texture :: (using self: *Polygon2D, texture: Texture2D) {
}
Polygon2D_get_texture :: (using self: *Polygon2D) -> Texture2D {
}
Polygon2D_set_texture_offset :: (using self: *Polygon2D, texture_offset: Vector2) {
}
Polygon2D_get_texture_offset :: (using self: *Polygon2D) -> Vector2 {
}
Polygon2D_set_texture_rotation :: (using self: *Polygon2D, texture_rotation: float) {
}
Polygon2D_get_texture_rotation :: (using self: *Polygon2D) -> float {
}
Polygon2D_set_texture_scale :: (using self: *Polygon2D, texture_scale: Vector2) {
}
Polygon2D_get_texture_scale :: (using self: *Polygon2D) -> Vector2 {
}
Polygon2D_set_invert_enabled :: (using self: *Polygon2D, invert: bool) {
}
Polygon2D_get_invert_enabled :: (using self: *Polygon2D) -> bool {
}
Polygon2D_set_antialiased :: (using self: *Polygon2D, antialiased: bool) {
}
Polygon2D_get_antialiased :: (using self: *Polygon2D) -> bool {
}
Polygon2D_set_invert_border :: (using self: *Polygon2D, invert_border: float) {
}
Polygon2D_get_invert_border :: (using self: *Polygon2D) -> float {
}
Polygon2D_set_offset :: (using self: *Polygon2D, offset: Vector2) {
}
Polygon2D_get_offset :: (using self: *Polygon2D) -> Vector2 {
}
Polygon2D_add_bone :: (using self: *Polygon2D, path: NodePath, weights: PackedFloat32Array) {
}
Polygon2D_get_bone_count :: (using self: *Polygon2D) -> int {
}
Polygon2D_get_bone_path :: (using self: *Polygon2D, index: int) -> NodePath {
}
Polygon2D_get_bone_weights :: (using self: *Polygon2D, index: int) -> PackedFloat32Array {
}
Polygon2D_erase_bone :: (using self: *Polygon2D, index: int) {
}
Polygon2D_clear_bones :: (using self: *Polygon2D) {
}
Polygon2D_set_bone_path :: (using self: *Polygon2D, index: int, path: NodePath) {
}
Polygon2D_set_bone_weights :: (using self: *Polygon2D, index: int, weights: PackedFloat32Array) {
}
Polygon2D_set_skeleton :: (using self: *Polygon2D, skeleton: NodePath) {
}
Polygon2D_get_skeleton :: (using self: *Polygon2D) -> NodePath {
}
Polygon2D_set_internal_vertex_count :: (using self: *Polygon2D, internal_vertex_count: int) {
}
Polygon2D_get_internal_vertex_count :: (using self: *Polygon2D) -> int {
}

// PolygonOccluder3D
PolygonOccluder3D :: struct {
	__private: *void;
}

PolygonOccluder3D_set_polygon :: (using self: *PolygonOccluder3D, polygon: PackedVector2Array) {
}
PolygonOccluder3D_get_polygon :: (using self: *PolygonOccluder3D) -> PackedVector2Array {
}

// PolygonPathFinder
PolygonPathFinder :: struct {
	__private: *void;
}

PolygonPathFinder_setup :: (using self: *PolygonPathFinder, points: PackedVector2Array, connections: PackedInt32Array) {
}
PolygonPathFinder_find_path :: (using self: *PolygonPathFinder, from: Vector2, to: Vector2) -> PackedVector2Array {
}
PolygonPathFinder_get_intersections :: (using self: *PolygonPathFinder, from: Vector2, to: Vector2) -> PackedVector2Array {
}
PolygonPathFinder_get_closest_point :: (using self: *PolygonPathFinder, point: Vector2) -> Vector2 {
}
PolygonPathFinder_is_point_inside :: (using self: *PolygonPathFinder, point: Vector2) -> bool {
}
PolygonPathFinder_set_point_penalty :: (using self: *PolygonPathFinder, idx: int, penalty: float) {
}
PolygonPathFinder_get_point_penalty :: (using self: *PolygonPathFinder, idx: int) -> float {
}
PolygonPathFinder_get_bounds :: (using self: *PolygonPathFinder) -> Rect2 {
}

// Popup
Popup :: struct {
	__private: *void;
}

// PopupMenu
PopupMenu :: struct {
	__private: *void;
}

PopupMenu_activate_item_by_event :: (using self: *PopupMenu, event: InputEvent, for_global_only: bool) -> bool {
}
PopupMenu_set_prefer_native_menu :: (using self: *PopupMenu, enabled: bool) {
}
PopupMenu_is_prefer_native_menu :: (using self: *PopupMenu) -> bool {
}
PopupMenu_is_native_menu :: (using self: *PopupMenu) -> bool {
}
PopupMenu_add_item :: (using self: *PopupMenu, label: String, id: int, accel: Key) {
}
PopupMenu_add_icon_item :: (using self: *PopupMenu, texture: Texture2D, label: String, id: int, accel: Key) {
}
PopupMenu_add_check_item :: (using self: *PopupMenu, label: String, id: int, accel: Key) {
}
PopupMenu_add_icon_check_item :: (using self: *PopupMenu, texture: Texture2D, label: String, id: int, accel: Key) {
}
PopupMenu_add_radio_check_item :: (using self: *PopupMenu, label: String, id: int, accel: Key) {
}
PopupMenu_add_icon_radio_check_item :: (using self: *PopupMenu, texture: Texture2D, label: String, id: int, accel: Key) {
}
PopupMenu_add_multistate_item :: (using self: *PopupMenu, label: String, max_states: int, default_state: int, id: int, accel: Key) {
}
PopupMenu_add_shortcut :: (using self: *PopupMenu, shortcut: Shortcut, id: int, global: bool, allow_echo: bool) {
}
PopupMenu_add_icon_shortcut :: (using self: *PopupMenu, texture: Texture2D, shortcut: Shortcut, id: int, global: bool, allow_echo: bool) {
}
PopupMenu_add_check_shortcut :: (using self: *PopupMenu, shortcut: Shortcut, id: int, global: bool) {
}
PopupMenu_add_icon_check_shortcut :: (using self: *PopupMenu, texture: Texture2D, shortcut: Shortcut, id: int, global: bool) {
}
PopupMenu_add_radio_check_shortcut :: (using self: *PopupMenu, shortcut: Shortcut, id: int, global: bool) {
}
PopupMenu_add_icon_radio_check_shortcut :: (using self: *PopupMenu, texture: Texture2D, shortcut: Shortcut, id: int, global: bool) {
}
PopupMenu_add_submenu_item :: (using self: *PopupMenu, label: String, submenu: String, id: int) {
}
PopupMenu_add_submenu_node_item :: (using self: *PopupMenu, label: String, submenu: PopupMenu, id: int) {
}
PopupMenu_set_item_text :: (using self: *PopupMenu, index: int, text: String) {
}
PopupMenu_set_item_text_direction :: (using self: *PopupMenu, index: int, direction: Control.TextDirection) {
}
PopupMenu_set_item_language :: (using self: *PopupMenu, index: int, language: String) {
}
PopupMenu_set_item_icon :: (using self: *PopupMenu, index: int, icon: Texture2D) {
}
PopupMenu_set_item_icon_max_width :: (using self: *PopupMenu, index: int, width: int) {
}
PopupMenu_set_item_icon_modulate :: (using self: *PopupMenu, index: int, modulate: Color) {
}
PopupMenu_set_item_checked :: (using self: *PopupMenu, index: int, checked: bool) {
}
PopupMenu_set_item_id :: (using self: *PopupMenu, index: int, id: int) {
}
PopupMenu_set_item_accelerator :: (using self: *PopupMenu, index: int, accel: Key) {
}
PopupMenu_set_item_metadata :: (using self: *PopupMenu, index: int, metadata: Variant) {
}
PopupMenu_set_item_disabled :: (using self: *PopupMenu, index: int, disabled: bool) {
}
PopupMenu_set_item_submenu :: (using self: *PopupMenu, index: int, submenu: String) {
}
PopupMenu_set_item_submenu_node :: (using self: *PopupMenu, index: int, submenu: PopupMenu) {
}
PopupMenu_set_item_as_separator :: (using self: *PopupMenu, index: int, enable: bool) {
}
PopupMenu_set_item_as_checkable :: (using self: *PopupMenu, index: int, enable: bool) {
}
PopupMenu_set_item_as_radio_checkable :: (using self: *PopupMenu, index: int, enable: bool) {
}
PopupMenu_set_item_tooltip :: (using self: *PopupMenu, index: int, tooltip: String) {
}
PopupMenu_set_item_shortcut :: (using self: *PopupMenu, index: int, shortcut: Shortcut, global: bool) {
}
PopupMenu_set_item_indent :: (using self: *PopupMenu, index: int, indent: int) {
}
PopupMenu_set_item_multistate :: (using self: *PopupMenu, index: int, state: int) {
}
PopupMenu_set_item_multistate_max :: (using self: *PopupMenu, index: int, max_states: int) {
}
PopupMenu_set_item_shortcut_disabled :: (using self: *PopupMenu, index: int, disabled: bool) {
}
PopupMenu_toggle_item_checked :: (using self: *PopupMenu, index: int) {
}
PopupMenu_toggle_item_multistate :: (using self: *PopupMenu, index: int) {
}
PopupMenu_get_item_text :: (using self: *PopupMenu, index: int) -> String {
}
PopupMenu_get_item_text_direction :: (using self: *PopupMenu, index: int) -> Control.TextDirection {
}
PopupMenu_get_item_language :: (using self: *PopupMenu, index: int) -> String {
}
PopupMenu_get_item_icon :: (using self: *PopupMenu, index: int) -> Texture2D {
}
PopupMenu_get_item_icon_max_width :: (using self: *PopupMenu, index: int) -> int {
}
PopupMenu_get_item_icon_modulate :: (using self: *PopupMenu, index: int) -> Color {
}
PopupMenu_is_item_checked :: (using self: *PopupMenu, index: int) -> bool {
}
PopupMenu_get_item_id :: (using self: *PopupMenu, index: int) -> int {
}
PopupMenu_get_item_index :: (using self: *PopupMenu, id: int) -> int {
}
PopupMenu_get_item_accelerator :: (using self: *PopupMenu, index: int) -> Key {
}
PopupMenu_get_item_metadata :: (using self: *PopupMenu, index: int) -> Variant {
}
PopupMenu_is_item_disabled :: (using self: *PopupMenu, index: int) -> bool {
}
PopupMenu_get_item_submenu :: (using self: *PopupMenu, index: int) -> String {
}
PopupMenu_get_item_submenu_node :: (using self: *PopupMenu, index: int) -> PopupMenu {
}
PopupMenu_is_item_separator :: (using self: *PopupMenu, index: int) -> bool {
}
PopupMenu_is_item_checkable :: (using self: *PopupMenu, index: int) -> bool {
}
PopupMenu_is_item_radio_checkable :: (using self: *PopupMenu, index: int) -> bool {
}
PopupMenu_is_item_shortcut_disabled :: (using self: *PopupMenu, index: int) -> bool {
}
PopupMenu_get_item_tooltip :: (using self: *PopupMenu, index: int) -> String {
}
PopupMenu_get_item_shortcut :: (using self: *PopupMenu, index: int) -> Shortcut {
}
PopupMenu_get_item_indent :: (using self: *PopupMenu, index: int) -> int {
}
PopupMenu_get_item_multistate_max :: (using self: *PopupMenu, index: int) -> int {
}
PopupMenu_get_item_multistate :: (using self: *PopupMenu, index: int) -> int {
}
PopupMenu_set_focused_item :: (using self: *PopupMenu, index: int) {
}
PopupMenu_get_focused_item :: (using self: *PopupMenu) -> int {
}
PopupMenu_set_item_count :: (using self: *PopupMenu, count: int) {
}
PopupMenu_get_item_count :: (using self: *PopupMenu) -> int {
}
PopupMenu_scroll_to_item :: (using self: *PopupMenu, index: int) {
}
PopupMenu_remove_item :: (using self: *PopupMenu, index: int) {
}
PopupMenu_add_separator :: (using self: *PopupMenu, label: String, id: int) {
}
PopupMenu_clear :: (using self: *PopupMenu, free_submenus: bool) {
}
PopupMenu_set_hide_on_item_selection :: (using self: *PopupMenu, enable: bool) {
}
PopupMenu_is_hide_on_item_selection :: (using self: *PopupMenu) -> bool {
}
PopupMenu_set_hide_on_checkable_item_selection :: (using self: *PopupMenu, enable: bool) {
}
PopupMenu_is_hide_on_checkable_item_selection :: (using self: *PopupMenu) -> bool {
}
PopupMenu_set_hide_on_state_item_selection :: (using self: *PopupMenu, enable: bool) {
}
PopupMenu_is_hide_on_state_item_selection :: (using self: *PopupMenu) -> bool {
}
PopupMenu_set_submenu_popup_delay :: (using self: *PopupMenu, seconds: float) {
}
PopupMenu_get_submenu_popup_delay :: (using self: *PopupMenu) -> float {
}
PopupMenu_set_allow_search :: (using self: *PopupMenu, allow: bool) {
}
PopupMenu_get_allow_search :: (using self: *PopupMenu) -> bool {
}
PopupMenu_is_system_menu :: (using self: *PopupMenu) -> bool {
}
PopupMenu_set_system_menu :: (using self: *PopupMenu, system_menu_id: NativeMenu.SystemMenus) {
}
PopupMenu_get_system_menu :: (using self: *PopupMenu) -> NativeMenu.SystemMenus {
}

// PopupPanel
PopupPanel :: struct {
	__private: *void;
}

// PortableCompressedTexture2D
PortableCompressedTexture2D :: struct {
	__private: *void;

	CompressionMode :: enum {
		COMPRESSION_MODE_LOSSLESS :: 0;
		COMPRESSION_MODE_LOSSY :: 1;
		COMPRESSION_MODE_BASIS_UNIVERSAL :: 2;
		COMPRESSION_MODE_S3TC :: 3;
		COMPRESSION_MODE_ETC2 :: 4;
		COMPRESSION_MODE_BPTC :: 5;
	}
}

PortableCompressedTexture2D_create_from_image :: (using self: *PortableCompressedTexture2D, image: Image, compression_mode: PortableCompressedTexture2D.CompressionMode, normal_map: bool, lossy_quality: float) {
}
PortableCompressedTexture2D_get_format :: (using self: *PortableCompressedTexture2D) -> Image.Format {
}
PortableCompressedTexture2D_get_compression_mode :: (using self: *PortableCompressedTexture2D) -> PortableCompressedTexture2D.CompressionMode {
}
PortableCompressedTexture2D_set_size_override :: (using self: *PortableCompressedTexture2D, size: Vector2) {
}
PortableCompressedTexture2D_get_size_override :: (using self: *PortableCompressedTexture2D) -> Vector2 {
}
PortableCompressedTexture2D_set_keep_compressed_buffer :: (using self: *PortableCompressedTexture2D, keep: bool) {
}
PortableCompressedTexture2D_is_keeping_compressed_buffer :: (using self: *PortableCompressedTexture2D) -> bool {
}
PortableCompressedTexture2D_set_keep_all_compressed_buffers :: (using self: *PortableCompressedTexture2D, keep: bool) {
}
PortableCompressedTexture2D_is_keeping_all_compressed_buffers :: (using self: *PortableCompressedTexture2D) -> bool {
}

// PrimitiveMesh
PrimitiveMesh :: struct {
	__private: *void;
}

PrimitiveMesh__create_mesh_array :: (using self: *PrimitiveMesh) -> Array {
}
PrimitiveMesh_set_material :: (using self: *PrimitiveMesh, material: Material) {
}
PrimitiveMesh_get_material :: (using self: *PrimitiveMesh) -> Material {
}
PrimitiveMesh_get_mesh_arrays :: (using self: *PrimitiveMesh) -> Array {
}
PrimitiveMesh_set_custom_aabb :: (using self: *PrimitiveMesh, aabb: AABB) {
}
PrimitiveMesh_get_custom_aabb :: (using self: *PrimitiveMesh) -> AABB {
}
PrimitiveMesh_set_flip_faces :: (using self: *PrimitiveMesh, flip_faces: bool) {
}
PrimitiveMesh_get_flip_faces :: (using self: *PrimitiveMesh) -> bool {
}
PrimitiveMesh_set_add_uv2 :: (using self: *PrimitiveMesh, add_uv2: bool) {
}
PrimitiveMesh_get_add_uv2 :: (using self: *PrimitiveMesh) -> bool {
}
PrimitiveMesh_set_uv2_padding :: (using self: *PrimitiveMesh, uv2_padding: float) {
}
PrimitiveMesh_get_uv2_padding :: (using self: *PrimitiveMesh) -> float {
}
PrimitiveMesh_request_update :: (using self: *PrimitiveMesh) {
}

// PrismMesh
PrismMesh :: struct {
	__private: *void;
}

PrismMesh_set_left_to_right :: (using self: *PrismMesh, left_to_right: float) {
}
PrismMesh_get_left_to_right :: (using self: *PrismMesh) -> float {
}
PrismMesh_set_size :: (using self: *PrismMesh, size: Vector3) {
}
PrismMesh_get_size :: (using self: *PrismMesh) -> Vector3 {
}
PrismMesh_set_subdivide_width :: (using self: *PrismMesh, segments: int) {
}
PrismMesh_get_subdivide_width :: (using self: *PrismMesh) -> int {
}
PrismMesh_set_subdivide_height :: (using self: *PrismMesh, segments: int) {
}
PrismMesh_get_subdivide_height :: (using self: *PrismMesh) -> int {
}
PrismMesh_set_subdivide_depth :: (using self: *PrismMesh, segments: int) {
}
PrismMesh_get_subdivide_depth :: (using self: *PrismMesh) -> int {
}

// ProceduralSkyMaterial
ProceduralSkyMaterial :: struct {
	__private: *void;
}

ProceduralSkyMaterial_set_sky_top_color :: (using self: *ProceduralSkyMaterial, color: Color) {
}
ProceduralSkyMaterial_get_sky_top_color :: (using self: *ProceduralSkyMaterial) -> Color {
}
ProceduralSkyMaterial_set_sky_horizon_color :: (using self: *ProceduralSkyMaterial, color: Color) {
}
ProceduralSkyMaterial_get_sky_horizon_color :: (using self: *ProceduralSkyMaterial) -> Color {
}
ProceduralSkyMaterial_set_sky_curve :: (using self: *ProceduralSkyMaterial, curve: float) {
}
ProceduralSkyMaterial_get_sky_curve :: (using self: *ProceduralSkyMaterial) -> float {
}
ProceduralSkyMaterial_set_sky_energy_multiplier :: (using self: *ProceduralSkyMaterial, multiplier: float) {
}
ProceduralSkyMaterial_get_sky_energy_multiplier :: (using self: *ProceduralSkyMaterial) -> float {
}
ProceduralSkyMaterial_set_sky_cover :: (using self: *ProceduralSkyMaterial, sky_cover: Texture2D) {
}
ProceduralSkyMaterial_get_sky_cover :: (using self: *ProceduralSkyMaterial) -> Texture2D {
}
ProceduralSkyMaterial_set_sky_cover_modulate :: (using self: *ProceduralSkyMaterial, color: Color) {
}
ProceduralSkyMaterial_get_sky_cover_modulate :: (using self: *ProceduralSkyMaterial) -> Color {
}
ProceduralSkyMaterial_set_ground_bottom_color :: (using self: *ProceduralSkyMaterial, color: Color) {
}
ProceduralSkyMaterial_get_ground_bottom_color :: (using self: *ProceduralSkyMaterial) -> Color {
}
ProceduralSkyMaterial_set_ground_horizon_color :: (using self: *ProceduralSkyMaterial, color: Color) {
}
ProceduralSkyMaterial_get_ground_horizon_color :: (using self: *ProceduralSkyMaterial) -> Color {
}
ProceduralSkyMaterial_set_ground_curve :: (using self: *ProceduralSkyMaterial, curve: float) {
}
ProceduralSkyMaterial_get_ground_curve :: (using self: *ProceduralSkyMaterial) -> float {
}
ProceduralSkyMaterial_set_ground_energy_multiplier :: (using self: *ProceduralSkyMaterial, energy: float) {
}
ProceduralSkyMaterial_get_ground_energy_multiplier :: (using self: *ProceduralSkyMaterial) -> float {
}
ProceduralSkyMaterial_set_sun_angle_max :: (using self: *ProceduralSkyMaterial, degrees: float) {
}
ProceduralSkyMaterial_get_sun_angle_max :: (using self: *ProceduralSkyMaterial) -> float {
}
ProceduralSkyMaterial_set_sun_curve :: (using self: *ProceduralSkyMaterial, curve: float) {
}
ProceduralSkyMaterial_get_sun_curve :: (using self: *ProceduralSkyMaterial) -> float {
}
ProceduralSkyMaterial_set_use_debanding :: (using self: *ProceduralSkyMaterial, use_debanding: bool) {
}
ProceduralSkyMaterial_get_use_debanding :: (using self: *ProceduralSkyMaterial) -> bool {
}
ProceduralSkyMaterial_set_energy_multiplier :: (using self: *ProceduralSkyMaterial, multiplier: float) {
}
ProceduralSkyMaterial_get_energy_multiplier :: (using self: *ProceduralSkyMaterial) -> float {
}

// ProgressBar
ProgressBar :: struct {
	__private: *void;

	FillMode :: enum {
		FILL_BEGIN_TO_END :: 0;
		FILL_END_TO_BEGIN :: 1;
		FILL_TOP_TO_BOTTOM :: 2;
		FILL_BOTTOM_TO_TOP :: 3;
	}
}

ProgressBar_set_fill_mode :: (using self: *ProgressBar, mode: int) {
}
ProgressBar_get_fill_mode :: (using self: *ProgressBar) -> int {
}
ProgressBar_set_show_percentage :: (using self: *ProgressBar, visible: bool) {
}
ProgressBar_is_percentage_shown :: (using self: *ProgressBar) -> bool {
}
ProgressBar_set_indeterminate :: (using self: *ProgressBar, indeterminate: bool) {
}
ProgressBar_is_indeterminate :: (using self: *ProgressBar) -> bool {
}
ProgressBar_set_editor_preview_indeterminate :: (using self: *ProgressBar, preview_indeterminate: bool) {
}
ProgressBar_is_editor_preview_indeterminate_enabled :: (using self: *ProgressBar) -> bool {
}

// ProjectSettings
ProjectSettings :: struct {
	__private: *void;
}

ProjectSettings_has_setting :: (using self: *ProjectSettings, name: String) -> bool {
}
ProjectSettings_set_setting :: (using self: *ProjectSettings, name: String, value: Variant) {
}
ProjectSettings_get_setting :: (using self: *ProjectSettings, name: String, default_value: Variant) -> Variant {
}
ProjectSettings_get_setting_with_override :: (using self: *ProjectSettings, name: StringName) -> Variant {
}
ProjectSettings_get_global_class_list :: (using self: *ProjectSettings) -> Dictionary {
}
ProjectSettings_set_order :: (using self: *ProjectSettings, name: String, position: int) {
}
ProjectSettings_get_order :: (using self: *ProjectSettings, name: String) -> int {
}
ProjectSettings_set_initial_value :: (using self: *ProjectSettings, name: String, value: Variant) {
}
ProjectSettings_set_as_basic :: (using self: *ProjectSettings, name: String, basic: bool) {
}
ProjectSettings_set_as_internal :: (using self: *ProjectSettings, name: String, internal: bool) {
}
ProjectSettings_add_property_info :: (using self: *ProjectSettings, hint: Dictionary) {
}
ProjectSettings_set_restart_if_changed :: (using self: *ProjectSettings, name: String, restart: bool) {
}
ProjectSettings_clear :: (using self: *ProjectSettings, name: String) {
}
ProjectSettings_localize_path :: (using self: *ProjectSettings, path: String) -> String {
}
ProjectSettings_globalize_path :: (using self: *ProjectSettings, path: String) -> String {
}
ProjectSettings_save :: (using self: *ProjectSettings) -> Error {
}
ProjectSettings_load_resource_pack :: (using self: *ProjectSettings, pack: String, replace_files: bool, offset: int) -> bool {
}
ProjectSettings_save_custom :: (using self: *ProjectSettings, file: String) -> Error {
}

// PropertyTweener
PropertyTweener :: struct {
	__private: *void;
}

PropertyTweener_from :: (using self: *PropertyTweener, value: Variant) -> PropertyTweener {
}
PropertyTweener_from_current :: (using self: *PropertyTweener) -> PropertyTweener {
}
PropertyTweener_as_relative :: (using self: *PropertyTweener) -> PropertyTweener {
}
PropertyTweener_set_trans :: (using self: *PropertyTweener, trans: Tween.TransitionType) -> PropertyTweener {
}
PropertyTweener_set_ease :: (using self: *PropertyTweener, ease: Tween.EaseType) -> PropertyTweener {
}
PropertyTweener_set_custom_interpolator :: (using self: *PropertyTweener, interpolator_method: Callable) -> PropertyTweener {
}
PropertyTweener_set_delay :: (using self: *PropertyTweener, delay: float) -> PropertyTweener {
}

// QuadMesh
QuadMesh :: struct {
	__private: *void;
}

// QuadOccluder3D
QuadOccluder3D :: struct {
	__private: *void;
}

QuadOccluder3D_set_size :: (using self: *QuadOccluder3D, size: Vector2) {
}
QuadOccluder3D_get_size :: (using self: *QuadOccluder3D) -> Vector2 {
}

// RDAttachmentFormat
RDAttachmentFormat :: struct {
	__private: *void;
}

RDAttachmentFormat_set_format :: (using self: *RDAttachmentFormat, p_member: RenderingDevice.DataFormat) {
}
RDAttachmentFormat_get_format :: (using self: *RDAttachmentFormat) -> RenderingDevice.DataFormat {
}
RDAttachmentFormat_set_samples :: (using self: *RDAttachmentFormat, p_member: RenderingDevice.TextureSamples) {
}
RDAttachmentFormat_get_samples :: (using self: *RDAttachmentFormat) -> RenderingDevice.TextureSamples {
}
RDAttachmentFormat_set_usage_flags :: (using self: *RDAttachmentFormat, p_member: int) {
}
RDAttachmentFormat_get_usage_flags :: (using self: *RDAttachmentFormat) -> int {
}

// RDFramebufferPass
RDFramebufferPass :: struct {
	__private: *void;

	ATTACHMENT_UNUSED :: -1;
}

RDFramebufferPass_set_color_attachments :: (using self: *RDFramebufferPass, p_member: PackedInt32Array) {
}
RDFramebufferPass_get_color_attachments :: (using self: *RDFramebufferPass) -> PackedInt32Array {
}
RDFramebufferPass_set_input_attachments :: (using self: *RDFramebufferPass, p_member: PackedInt32Array) {
}
RDFramebufferPass_get_input_attachments :: (using self: *RDFramebufferPass) -> PackedInt32Array {
}
RDFramebufferPass_set_resolve_attachments :: (using self: *RDFramebufferPass, p_member: PackedInt32Array) {
}
RDFramebufferPass_get_resolve_attachments :: (using self: *RDFramebufferPass) -> PackedInt32Array {
}
RDFramebufferPass_set_preserve_attachments :: (using self: *RDFramebufferPass, p_member: PackedInt32Array) {
}
RDFramebufferPass_get_preserve_attachments :: (using self: *RDFramebufferPass) -> PackedInt32Array {
}
RDFramebufferPass_set_depth_attachment :: (using self: *RDFramebufferPass, p_member: int) {
}
RDFramebufferPass_get_depth_attachment :: (using self: *RDFramebufferPass) -> int {
}

// RDPipelineColorBlendState
RDPipelineColorBlendState :: struct {
	__private: *void;
}

RDPipelineColorBlendState_set_enable_logic_op :: (using self: *RDPipelineColorBlendState, p_member: bool) {
}
RDPipelineColorBlendState_get_enable_logic_op :: (using self: *RDPipelineColorBlendState) -> bool {
}
RDPipelineColorBlendState_set_logic_op :: (using self: *RDPipelineColorBlendState, p_member: RenderingDevice.LogicOperation) {
}
RDPipelineColorBlendState_get_logic_op :: (using self: *RDPipelineColorBlendState) -> RenderingDevice.LogicOperation {
}
RDPipelineColorBlendState_set_blend_constant :: (using self: *RDPipelineColorBlendState, p_member: Color) {
}
RDPipelineColorBlendState_get_blend_constant :: (using self: *RDPipelineColorBlendState) -> Color {
}
RDPipelineColorBlendState_set_attachments :: (using self: *RDPipelineColorBlendState, attachments: Array) {
}
RDPipelineColorBlendState_get_attachments :: (using self: *RDPipelineColorBlendState) -> Array {
}

// RDPipelineColorBlendStateAttachment
RDPipelineColorBlendStateAttachment :: struct {
	__private: *void;
}

RDPipelineColorBlendStateAttachment_set_as_mix :: (using self: *RDPipelineColorBlendStateAttachment) {
}
RDPipelineColorBlendStateAttachment_set_enable_blend :: (using self: *RDPipelineColorBlendStateAttachment, p_member: bool) {
}
RDPipelineColorBlendStateAttachment_get_enable_blend :: (using self: *RDPipelineColorBlendStateAttachment) -> bool {
}
RDPipelineColorBlendStateAttachment_set_src_color_blend_factor :: (using self: *RDPipelineColorBlendStateAttachment, p_member: RenderingDevice.BlendFactor) {
}
RDPipelineColorBlendStateAttachment_get_src_color_blend_factor :: (using self: *RDPipelineColorBlendStateAttachment) -> RenderingDevice.BlendFactor {
}
RDPipelineColorBlendStateAttachment_set_dst_color_blend_factor :: (using self: *RDPipelineColorBlendStateAttachment, p_member: RenderingDevice.BlendFactor) {
}
RDPipelineColorBlendStateAttachment_get_dst_color_blend_factor :: (using self: *RDPipelineColorBlendStateAttachment) -> RenderingDevice.BlendFactor {
}
RDPipelineColorBlendStateAttachment_set_color_blend_op :: (using self: *RDPipelineColorBlendStateAttachment, p_member: RenderingDevice.BlendOperation) {
}
RDPipelineColorBlendStateAttachment_get_color_blend_op :: (using self: *RDPipelineColorBlendStateAttachment) -> RenderingDevice.BlendOperation {
}
RDPipelineColorBlendStateAttachment_set_src_alpha_blend_factor :: (using self: *RDPipelineColorBlendStateAttachment, p_member: RenderingDevice.BlendFactor) {
}
RDPipelineColorBlendStateAttachment_get_src_alpha_blend_factor :: (using self: *RDPipelineColorBlendStateAttachment) -> RenderingDevice.BlendFactor {
}
RDPipelineColorBlendStateAttachment_set_dst_alpha_blend_factor :: (using self: *RDPipelineColorBlendStateAttachment, p_member: RenderingDevice.BlendFactor) {
}
RDPipelineColorBlendStateAttachment_get_dst_alpha_blend_factor :: (using self: *RDPipelineColorBlendStateAttachment) -> RenderingDevice.BlendFactor {
}
RDPipelineColorBlendStateAttachment_set_alpha_blend_op :: (using self: *RDPipelineColorBlendStateAttachment, p_member: RenderingDevice.BlendOperation) {
}
RDPipelineColorBlendStateAttachment_get_alpha_blend_op :: (using self: *RDPipelineColorBlendStateAttachment) -> RenderingDevice.BlendOperation {
}
RDPipelineColorBlendStateAttachment_set_write_r :: (using self: *RDPipelineColorBlendStateAttachment, p_member: bool) {
}
RDPipelineColorBlendStateAttachment_get_write_r :: (using self: *RDPipelineColorBlendStateAttachment) -> bool {
}
RDPipelineColorBlendStateAttachment_set_write_g :: (using self: *RDPipelineColorBlendStateAttachment, p_member: bool) {
}
RDPipelineColorBlendStateAttachment_get_write_g :: (using self: *RDPipelineColorBlendStateAttachment) -> bool {
}
RDPipelineColorBlendStateAttachment_set_write_b :: (using self: *RDPipelineColorBlendStateAttachment, p_member: bool) {
}
RDPipelineColorBlendStateAttachment_get_write_b :: (using self: *RDPipelineColorBlendStateAttachment) -> bool {
}
RDPipelineColorBlendStateAttachment_set_write_a :: (using self: *RDPipelineColorBlendStateAttachment, p_member: bool) {
}
RDPipelineColorBlendStateAttachment_get_write_a :: (using self: *RDPipelineColorBlendStateAttachment) -> bool {
}

// RDPipelineDepthStencilState
RDPipelineDepthStencilState :: struct {
	__private: *void;
}

RDPipelineDepthStencilState_set_enable_depth_test :: (using self: *RDPipelineDepthStencilState, p_member: bool) {
}
RDPipelineDepthStencilState_get_enable_depth_test :: (using self: *RDPipelineDepthStencilState) -> bool {
}
RDPipelineDepthStencilState_set_enable_depth_write :: (using self: *RDPipelineDepthStencilState, p_member: bool) {
}
RDPipelineDepthStencilState_get_enable_depth_write :: (using self: *RDPipelineDepthStencilState) -> bool {
}
RDPipelineDepthStencilState_set_depth_compare_operator :: (using self: *RDPipelineDepthStencilState, p_member: RenderingDevice.CompareOperator) {
}
RDPipelineDepthStencilState_get_depth_compare_operator :: (using self: *RDPipelineDepthStencilState) -> RenderingDevice.CompareOperator {
}
RDPipelineDepthStencilState_set_enable_depth_range :: (using self: *RDPipelineDepthStencilState, p_member: bool) {
}
RDPipelineDepthStencilState_get_enable_depth_range :: (using self: *RDPipelineDepthStencilState) -> bool {
}
RDPipelineDepthStencilState_set_depth_range_min :: (using self: *RDPipelineDepthStencilState, p_member: float) {
}
RDPipelineDepthStencilState_get_depth_range_min :: (using self: *RDPipelineDepthStencilState) -> float {
}
RDPipelineDepthStencilState_set_depth_range_max :: (using self: *RDPipelineDepthStencilState, p_member: float) {
}
RDPipelineDepthStencilState_get_depth_range_max :: (using self: *RDPipelineDepthStencilState) -> float {
}
RDPipelineDepthStencilState_set_enable_stencil :: (using self: *RDPipelineDepthStencilState, p_member: bool) {
}
RDPipelineDepthStencilState_get_enable_stencil :: (using self: *RDPipelineDepthStencilState) -> bool {
}
RDPipelineDepthStencilState_set_front_op_fail :: (using self: *RDPipelineDepthStencilState, p_member: RenderingDevice.StencilOperation) {
}
RDPipelineDepthStencilState_get_front_op_fail :: (using self: *RDPipelineDepthStencilState) -> RenderingDevice.StencilOperation {
}
RDPipelineDepthStencilState_set_front_op_pass :: (using self: *RDPipelineDepthStencilState, p_member: RenderingDevice.StencilOperation) {
}
RDPipelineDepthStencilState_get_front_op_pass :: (using self: *RDPipelineDepthStencilState) -> RenderingDevice.StencilOperation {
}
RDPipelineDepthStencilState_set_front_op_depth_fail :: (using self: *RDPipelineDepthStencilState, p_member: RenderingDevice.StencilOperation) {
}
RDPipelineDepthStencilState_get_front_op_depth_fail :: (using self: *RDPipelineDepthStencilState) -> RenderingDevice.StencilOperation {
}
RDPipelineDepthStencilState_set_front_op_compare :: (using self: *RDPipelineDepthStencilState, p_member: RenderingDevice.CompareOperator) {
}
RDPipelineDepthStencilState_get_front_op_compare :: (using self: *RDPipelineDepthStencilState) -> RenderingDevice.CompareOperator {
}
RDPipelineDepthStencilState_set_front_op_compare_mask :: (using self: *RDPipelineDepthStencilState, p_member: int) {
}
RDPipelineDepthStencilState_get_front_op_compare_mask :: (using self: *RDPipelineDepthStencilState) -> int {
}
RDPipelineDepthStencilState_set_front_op_write_mask :: (using self: *RDPipelineDepthStencilState, p_member: int) {
}
RDPipelineDepthStencilState_get_front_op_write_mask :: (using self: *RDPipelineDepthStencilState) -> int {
}
RDPipelineDepthStencilState_set_front_op_reference :: (using self: *RDPipelineDepthStencilState, p_member: int) {
}
RDPipelineDepthStencilState_get_front_op_reference :: (using self: *RDPipelineDepthStencilState) -> int {
}
RDPipelineDepthStencilState_set_back_op_fail :: (using self: *RDPipelineDepthStencilState, p_member: RenderingDevice.StencilOperation) {
}
RDPipelineDepthStencilState_get_back_op_fail :: (using self: *RDPipelineDepthStencilState) -> RenderingDevice.StencilOperation {
}
RDPipelineDepthStencilState_set_back_op_pass :: (using self: *RDPipelineDepthStencilState, p_member: RenderingDevice.StencilOperation) {
}
RDPipelineDepthStencilState_get_back_op_pass :: (using self: *RDPipelineDepthStencilState) -> RenderingDevice.StencilOperation {
}
RDPipelineDepthStencilState_set_back_op_depth_fail :: (using self: *RDPipelineDepthStencilState, p_member: RenderingDevice.StencilOperation) {
}
RDPipelineDepthStencilState_get_back_op_depth_fail :: (using self: *RDPipelineDepthStencilState) -> RenderingDevice.StencilOperation {
}
RDPipelineDepthStencilState_set_back_op_compare :: (using self: *RDPipelineDepthStencilState, p_member: RenderingDevice.CompareOperator) {
}
RDPipelineDepthStencilState_get_back_op_compare :: (using self: *RDPipelineDepthStencilState) -> RenderingDevice.CompareOperator {
}
RDPipelineDepthStencilState_set_back_op_compare_mask :: (using self: *RDPipelineDepthStencilState, p_member: int) {
}
RDPipelineDepthStencilState_get_back_op_compare_mask :: (using self: *RDPipelineDepthStencilState) -> int {
}
RDPipelineDepthStencilState_set_back_op_write_mask :: (using self: *RDPipelineDepthStencilState, p_member: int) {
}
RDPipelineDepthStencilState_get_back_op_write_mask :: (using self: *RDPipelineDepthStencilState) -> int {
}
RDPipelineDepthStencilState_set_back_op_reference :: (using self: *RDPipelineDepthStencilState, p_member: int) {
}
RDPipelineDepthStencilState_get_back_op_reference :: (using self: *RDPipelineDepthStencilState) -> int {
}

// RDPipelineMultisampleState
RDPipelineMultisampleState :: struct {
	__private: *void;
}

RDPipelineMultisampleState_set_sample_count :: (using self: *RDPipelineMultisampleState, p_member: RenderingDevice.TextureSamples) {
}
RDPipelineMultisampleState_get_sample_count :: (using self: *RDPipelineMultisampleState) -> RenderingDevice.TextureSamples {
}
RDPipelineMultisampleState_set_enable_sample_shading :: (using self: *RDPipelineMultisampleState, p_member: bool) {
}
RDPipelineMultisampleState_get_enable_sample_shading :: (using self: *RDPipelineMultisampleState) -> bool {
}
RDPipelineMultisampleState_set_min_sample_shading :: (using self: *RDPipelineMultisampleState, p_member: float) {
}
RDPipelineMultisampleState_get_min_sample_shading :: (using self: *RDPipelineMultisampleState) -> float {
}
RDPipelineMultisampleState_set_enable_alpha_to_coverage :: (using self: *RDPipelineMultisampleState, p_member: bool) {
}
RDPipelineMultisampleState_get_enable_alpha_to_coverage :: (using self: *RDPipelineMultisampleState) -> bool {
}
RDPipelineMultisampleState_set_enable_alpha_to_one :: (using self: *RDPipelineMultisampleState, p_member: bool) {
}
RDPipelineMultisampleState_get_enable_alpha_to_one :: (using self: *RDPipelineMultisampleState) -> bool {
}
RDPipelineMultisampleState_set_sample_masks :: (using self: *RDPipelineMultisampleState, masks: Array) {
}
RDPipelineMultisampleState_get_sample_masks :: (using self: *RDPipelineMultisampleState) -> Array {
}

// RDPipelineRasterizationState
RDPipelineRasterizationState :: struct {
	__private: *void;
}

RDPipelineRasterizationState_set_enable_depth_clamp :: (using self: *RDPipelineRasterizationState, p_member: bool) {
}
RDPipelineRasterizationState_get_enable_depth_clamp :: (using self: *RDPipelineRasterizationState) -> bool {
}
RDPipelineRasterizationState_set_discard_primitives :: (using self: *RDPipelineRasterizationState, p_member: bool) {
}
RDPipelineRasterizationState_get_discard_primitives :: (using self: *RDPipelineRasterizationState) -> bool {
}
RDPipelineRasterizationState_set_wireframe :: (using self: *RDPipelineRasterizationState, p_member: bool) {
}
RDPipelineRasterizationState_get_wireframe :: (using self: *RDPipelineRasterizationState) -> bool {
}
RDPipelineRasterizationState_set_cull_mode :: (using self: *RDPipelineRasterizationState, p_member: RenderingDevice.PolygonCullMode) {
}
RDPipelineRasterizationState_get_cull_mode :: (using self: *RDPipelineRasterizationState) -> RenderingDevice.PolygonCullMode {
}
RDPipelineRasterizationState_set_front_face :: (using self: *RDPipelineRasterizationState, p_member: RenderingDevice.PolygonFrontFace) {
}
RDPipelineRasterizationState_get_front_face :: (using self: *RDPipelineRasterizationState) -> RenderingDevice.PolygonFrontFace {
}
RDPipelineRasterizationState_set_depth_bias_enabled :: (using self: *RDPipelineRasterizationState, p_member: bool) {
}
RDPipelineRasterizationState_get_depth_bias_enabled :: (using self: *RDPipelineRasterizationState) -> bool {
}
RDPipelineRasterizationState_set_depth_bias_constant_factor :: (using self: *RDPipelineRasterizationState, p_member: float) {
}
RDPipelineRasterizationState_get_depth_bias_constant_factor :: (using self: *RDPipelineRasterizationState) -> float {
}
RDPipelineRasterizationState_set_depth_bias_clamp :: (using self: *RDPipelineRasterizationState, p_member: float) {
}
RDPipelineRasterizationState_get_depth_bias_clamp :: (using self: *RDPipelineRasterizationState) -> float {
}
RDPipelineRasterizationState_set_depth_bias_slope_factor :: (using self: *RDPipelineRasterizationState, p_member: float) {
}
RDPipelineRasterizationState_get_depth_bias_slope_factor :: (using self: *RDPipelineRasterizationState) -> float {
}
RDPipelineRasterizationState_set_line_width :: (using self: *RDPipelineRasterizationState, p_member: float) {
}
RDPipelineRasterizationState_get_line_width :: (using self: *RDPipelineRasterizationState) -> float {
}
RDPipelineRasterizationState_set_patch_control_points :: (using self: *RDPipelineRasterizationState, p_member: int) {
}
RDPipelineRasterizationState_get_patch_control_points :: (using self: *RDPipelineRasterizationState) -> int {
}

// RDPipelineSpecializationConstant
RDPipelineSpecializationConstant :: struct {
	__private: *void;
}

RDPipelineSpecializationConstant_set_value :: (using self: *RDPipelineSpecializationConstant, value: Variant) {
}
RDPipelineSpecializationConstant_get_value :: (using self: *RDPipelineSpecializationConstant) -> Variant {
}
RDPipelineSpecializationConstant_set_constant_id :: (using self: *RDPipelineSpecializationConstant, constant_id: int) {
}
RDPipelineSpecializationConstant_get_constant_id :: (using self: *RDPipelineSpecializationConstant) -> int {
}

// RDSamplerState
RDSamplerState :: struct {
	__private: *void;
}

RDSamplerState_set_mag_filter :: (using self: *RDSamplerState, p_member: RenderingDevice.SamplerFilter) {
}
RDSamplerState_get_mag_filter :: (using self: *RDSamplerState) -> RenderingDevice.SamplerFilter {
}
RDSamplerState_set_min_filter :: (using self: *RDSamplerState, p_member: RenderingDevice.SamplerFilter) {
}
RDSamplerState_get_min_filter :: (using self: *RDSamplerState) -> RenderingDevice.SamplerFilter {
}
RDSamplerState_set_mip_filter :: (using self: *RDSamplerState, p_member: RenderingDevice.SamplerFilter) {
}
RDSamplerState_get_mip_filter :: (using self: *RDSamplerState) -> RenderingDevice.SamplerFilter {
}
RDSamplerState_set_repeat_u :: (using self: *RDSamplerState, p_member: RenderingDevice.SamplerRepeatMode) {
}
RDSamplerState_get_repeat_u :: (using self: *RDSamplerState) -> RenderingDevice.SamplerRepeatMode {
}
RDSamplerState_set_repeat_v :: (using self: *RDSamplerState, p_member: RenderingDevice.SamplerRepeatMode) {
}
RDSamplerState_get_repeat_v :: (using self: *RDSamplerState) -> RenderingDevice.SamplerRepeatMode {
}
RDSamplerState_set_repeat_w :: (using self: *RDSamplerState, p_member: RenderingDevice.SamplerRepeatMode) {
}
RDSamplerState_get_repeat_w :: (using self: *RDSamplerState) -> RenderingDevice.SamplerRepeatMode {
}
RDSamplerState_set_lod_bias :: (using self: *RDSamplerState, p_member: float) {
}
RDSamplerState_get_lod_bias :: (using self: *RDSamplerState) -> float {
}
RDSamplerState_set_use_anisotropy :: (using self: *RDSamplerState, p_member: bool) {
}
RDSamplerState_get_use_anisotropy :: (using self: *RDSamplerState) -> bool {
}
RDSamplerState_set_anisotropy_max :: (using self: *RDSamplerState, p_member: float) {
}
RDSamplerState_get_anisotropy_max :: (using self: *RDSamplerState) -> float {
}
RDSamplerState_set_enable_compare :: (using self: *RDSamplerState, p_member: bool) {
}
RDSamplerState_get_enable_compare :: (using self: *RDSamplerState) -> bool {
}
RDSamplerState_set_compare_op :: (using self: *RDSamplerState, p_member: RenderingDevice.CompareOperator) {
}
RDSamplerState_get_compare_op :: (using self: *RDSamplerState) -> RenderingDevice.CompareOperator {
}
RDSamplerState_set_min_lod :: (using self: *RDSamplerState, p_member: float) {
}
RDSamplerState_get_min_lod :: (using self: *RDSamplerState) -> float {
}
RDSamplerState_set_max_lod :: (using self: *RDSamplerState, p_member: float) {
}
RDSamplerState_get_max_lod :: (using self: *RDSamplerState) -> float {
}
RDSamplerState_set_border_color :: (using self: *RDSamplerState, p_member: RenderingDevice.SamplerBorderColor) {
}
RDSamplerState_get_border_color :: (using self: *RDSamplerState) -> RenderingDevice.SamplerBorderColor {
}
RDSamplerState_set_unnormalized_uvw :: (using self: *RDSamplerState, p_member: bool) {
}
RDSamplerState_get_unnormalized_uvw :: (using self: *RDSamplerState) -> bool {
}

// RDShaderFile
RDShaderFile :: struct {
	__private: *void;
}

RDShaderFile_set_bytecode :: (using self: *RDShaderFile, bytecode: RDShaderSPIRV, version: StringName) {
}
RDShaderFile_get_spirv :: (using self: *RDShaderFile, version: StringName) -> RDShaderSPIRV {
}
RDShaderFile_get_version_list :: (using self: *RDShaderFile) -> Array {
}
RDShaderFile_set_base_error :: (using self: *RDShaderFile, error: String) {
}
RDShaderFile_get_base_error :: (using self: *RDShaderFile) -> String {
}

// RDShaderSPIRV
RDShaderSPIRV :: struct {
	__private: *void;
}

RDShaderSPIRV_set_stage_bytecode :: (using self: *RDShaderSPIRV, stage: RenderingDevice.ShaderStage, bytecode: PackedByteArray) {
}
RDShaderSPIRV_get_stage_bytecode :: (using self: *RDShaderSPIRV, stage: RenderingDevice.ShaderStage) -> PackedByteArray {
}
RDShaderSPIRV_set_stage_compile_error :: (using self: *RDShaderSPIRV, stage: RenderingDevice.ShaderStage, compile_error: String) {
}
RDShaderSPIRV_get_stage_compile_error :: (using self: *RDShaderSPIRV, stage: RenderingDevice.ShaderStage) -> String {
}

// RDShaderSource
RDShaderSource :: struct {
	__private: *void;
}

RDShaderSource_set_stage_source :: (using self: *RDShaderSource, stage: RenderingDevice.ShaderStage, source: String) {
}
RDShaderSource_get_stage_source :: (using self: *RDShaderSource, stage: RenderingDevice.ShaderStage) -> String {
}
RDShaderSource_set_language :: (using self: *RDShaderSource, language: RenderingDevice.ShaderLanguage) {
}
RDShaderSource_get_language :: (using self: *RDShaderSource) -> RenderingDevice.ShaderLanguage {
}

// RDTextureFormat
RDTextureFormat :: struct {
	__private: *void;
}

RDTextureFormat_set_format :: (using self: *RDTextureFormat, p_member: RenderingDevice.DataFormat) {
}
RDTextureFormat_get_format :: (using self: *RDTextureFormat) -> RenderingDevice.DataFormat {
}
RDTextureFormat_set_width :: (using self: *RDTextureFormat, p_member: int) {
}
RDTextureFormat_get_width :: (using self: *RDTextureFormat) -> int {
}
RDTextureFormat_set_height :: (using self: *RDTextureFormat, p_member: int) {
}
RDTextureFormat_get_height :: (using self: *RDTextureFormat) -> int {
}
RDTextureFormat_set_depth :: (using self: *RDTextureFormat, p_member: int) {
}
RDTextureFormat_get_depth :: (using self: *RDTextureFormat) -> int {
}
RDTextureFormat_set_array_layers :: (using self: *RDTextureFormat, p_member: int) {
}
RDTextureFormat_get_array_layers :: (using self: *RDTextureFormat) -> int {
}
RDTextureFormat_set_mipmaps :: (using self: *RDTextureFormat, p_member: int) {
}
RDTextureFormat_get_mipmaps :: (using self: *RDTextureFormat) -> int {
}
RDTextureFormat_set_texture_type :: (using self: *RDTextureFormat, p_member: RenderingDevice.TextureType) {
}
RDTextureFormat_get_texture_type :: (using self: *RDTextureFormat) -> RenderingDevice.TextureType {
}
RDTextureFormat_set_samples :: (using self: *RDTextureFormat, p_member: RenderingDevice.TextureSamples) {
}
RDTextureFormat_get_samples :: (using self: *RDTextureFormat) -> RenderingDevice.TextureSamples {
}
RDTextureFormat_set_usage_bits :: (using self: *RDTextureFormat, p_member: RenderingDevice.TextureUsageBits) {
}
RDTextureFormat_get_usage_bits :: (using self: *RDTextureFormat) -> RenderingDevice.TextureUsageBits {
}
RDTextureFormat_add_shareable_format :: (using self: *RDTextureFormat, format: RenderingDevice.DataFormat) {
}
RDTextureFormat_remove_shareable_format :: (using self: *RDTextureFormat, format: RenderingDevice.DataFormat) {
}

// RDTextureView
RDTextureView :: struct {
	__private: *void;
}

RDTextureView_set_format_override :: (using self: *RDTextureView, p_member: RenderingDevice.DataFormat) {
}
RDTextureView_get_format_override :: (using self: *RDTextureView) -> RenderingDevice.DataFormat {
}
RDTextureView_set_swizzle_r :: (using self: *RDTextureView, p_member: RenderingDevice.TextureSwizzle) {
}
RDTextureView_get_swizzle_r :: (using self: *RDTextureView) -> RenderingDevice.TextureSwizzle {
}
RDTextureView_set_swizzle_g :: (using self: *RDTextureView, p_member: RenderingDevice.TextureSwizzle) {
}
RDTextureView_get_swizzle_g :: (using self: *RDTextureView) -> RenderingDevice.TextureSwizzle {
}
RDTextureView_set_swizzle_b :: (using self: *RDTextureView, p_member: RenderingDevice.TextureSwizzle) {
}
RDTextureView_get_swizzle_b :: (using self: *RDTextureView) -> RenderingDevice.TextureSwizzle {
}
RDTextureView_set_swizzle_a :: (using self: *RDTextureView, p_member: RenderingDevice.TextureSwizzle) {
}
RDTextureView_get_swizzle_a :: (using self: *RDTextureView) -> RenderingDevice.TextureSwizzle {
}

// RDUniform
RDUniform :: struct {
	__private: *void;
}

RDUniform_set_uniform_type :: (using self: *RDUniform, p_member: RenderingDevice.UniformType) {
}
RDUniform_get_uniform_type :: (using self: *RDUniform) -> RenderingDevice.UniformType {
}
RDUniform_set_binding :: (using self: *RDUniform, p_member: int) {
}
RDUniform_get_binding :: (using self: *RDUniform) -> int {
}
RDUniform_add_id :: (using self: *RDUniform, id: RID) {
}
RDUniform_clear_ids :: (using self: *RDUniform) {
}
RDUniform_get_ids :: (using self: *RDUniform) -> Array {
}

// RDVertexAttribute
RDVertexAttribute :: struct {
	__private: *void;
}

RDVertexAttribute_set_location :: (using self: *RDVertexAttribute, p_member: int) {
}
RDVertexAttribute_get_location :: (using self: *RDVertexAttribute) -> int {
}
RDVertexAttribute_set_offset :: (using self: *RDVertexAttribute, p_member: int) {
}
RDVertexAttribute_get_offset :: (using self: *RDVertexAttribute) -> int {
}
RDVertexAttribute_set_format :: (using self: *RDVertexAttribute, p_member: RenderingDevice.DataFormat) {
}
RDVertexAttribute_get_format :: (using self: *RDVertexAttribute) -> RenderingDevice.DataFormat {
}
RDVertexAttribute_set_stride :: (using self: *RDVertexAttribute, p_member: int) {
}
RDVertexAttribute_get_stride :: (using self: *RDVertexAttribute) -> int {
}
RDVertexAttribute_set_frequency :: (using self: *RDVertexAttribute, p_member: RenderingDevice.VertexFrequency) {
}
RDVertexAttribute_get_frequency :: (using self: *RDVertexAttribute) -> RenderingDevice.VertexFrequency {
}

// RandomNumberGenerator
RandomNumberGenerator :: struct {
	__private: *void;
}

RandomNumberGenerator_set_seed :: (using self: *RandomNumberGenerator, seed: int) {
}
RandomNumberGenerator_get_seed :: (using self: *RandomNumberGenerator) -> int {
}
RandomNumberGenerator_set_state :: (using self: *RandomNumberGenerator, state: int) {
}
RandomNumberGenerator_get_state :: (using self: *RandomNumberGenerator) -> int {
}
RandomNumberGenerator_randi :: (using self: *RandomNumberGenerator) -> int {
}
RandomNumberGenerator_randf :: (using self: *RandomNumberGenerator) -> float {
}
RandomNumberGenerator_randfn :: (using self: *RandomNumberGenerator, mean: float, deviation: float) -> float {
}
RandomNumberGenerator_randf_range :: (using self: *RandomNumberGenerator, from: float, to: float) -> float {
}
RandomNumberGenerator_randi_range :: (using self: *RandomNumberGenerator, from: int, to: int) -> int {
}
RandomNumberGenerator_rand_weighted :: (using self: *RandomNumberGenerator, weights: PackedFloat32Array) -> int {
}
RandomNumberGenerator_randomize :: (using self: *RandomNumberGenerator) {
}

// Range
Range :: struct {
	__private: *void;
}

Range__value_changed :: (using self: *Range, new_value: float) {
}
Range_get_value :: (using self: *Range) -> float {
}
Range_get_min :: (using self: *Range) -> float {
}
Range_get_max :: (using self: *Range) -> float {
}
Range_get_step :: (using self: *Range) -> float {
}
Range_get_page :: (using self: *Range) -> float {
}
Range_get_as_ratio :: (using self: *Range) -> float {
}
Range_set_value :: (using self: *Range, value: float) {
}
Range_set_value_no_signal :: (using self: *Range, value: float) {
}
Range_set_min :: (using self: *Range, minimum: float) {
}
Range_set_max :: (using self: *Range, maximum: float) {
}
Range_set_step :: (using self: *Range, step: float) {
}
Range_set_page :: (using self: *Range, pagesize: float) {
}
Range_set_as_ratio :: (using self: *Range, value: float) {
}
Range_set_use_rounded_values :: (using self: *Range, enabled: bool) {
}
Range_is_using_rounded_values :: (using self: *Range) -> bool {
}
Range_set_exp_ratio :: (using self: *Range, enabled: bool) {
}
Range_is_ratio_exp :: (using self: *Range) -> bool {
}
Range_set_allow_greater :: (using self: *Range, allow: bool) {
}
Range_is_greater_allowed :: (using self: *Range) -> bool {
}
Range_set_allow_lesser :: (using self: *Range, allow: bool) {
}
Range_is_lesser_allowed :: (using self: *Range) -> bool {
}
Range_share :: (using self: *Range, with: Node) {
}
Range_unshare :: (using self: *Range) {
}

// RayCast2D
RayCast2D :: struct {
	__private: *void;
}

RayCast2D_set_enabled :: (using self: *RayCast2D, enabled: bool) {
}
RayCast2D_is_enabled :: (using self: *RayCast2D) -> bool {
}
RayCast2D_set_target_position :: (using self: *RayCast2D, local_point: Vector2) {
}
RayCast2D_get_target_position :: (using self: *RayCast2D) -> Vector2 {
}
RayCast2D_is_colliding :: (using self: *RayCast2D) -> bool {
}
RayCast2D_force_raycast_update :: (using self: *RayCast2D) {
}
RayCast2D_get_collider :: (using self: *RayCast2D) -> Object {
}
RayCast2D_get_collider_rid :: (using self: *RayCast2D) -> RID {
}
RayCast2D_get_collider_shape :: (using self: *RayCast2D) -> int {
}
RayCast2D_get_collision_point :: (using self: *RayCast2D) -> Vector2 {
}
RayCast2D_get_collision_normal :: (using self: *RayCast2D) -> Vector2 {
}
RayCast2D_add_exception_rid :: (using self: *RayCast2D, rid: RID) {
}
RayCast2D_add_exception :: (using self: *RayCast2D, node: CollisionObject2D) {
}
RayCast2D_remove_exception_rid :: (using self: *RayCast2D, rid: RID) {
}
RayCast2D_remove_exception :: (using self: *RayCast2D, node: CollisionObject2D) {
}
RayCast2D_clear_exceptions :: (using self: *RayCast2D) {
}
RayCast2D_set_collision_mask :: (using self: *RayCast2D, mask: int) {
}
RayCast2D_get_collision_mask :: (using self: *RayCast2D) -> int {
}
RayCast2D_set_collision_mask_value :: (using self: *RayCast2D, layer_number: int, value: bool) {
}
RayCast2D_get_collision_mask_value :: (using self: *RayCast2D, layer_number: int) -> bool {
}
RayCast2D_set_exclude_parent_body :: (using self: *RayCast2D, mask: bool) {
}
RayCast2D_get_exclude_parent_body :: (using self: *RayCast2D) -> bool {
}
RayCast2D_set_collide_with_areas :: (using self: *RayCast2D, enable: bool) {
}
RayCast2D_is_collide_with_areas_enabled :: (using self: *RayCast2D) -> bool {
}
RayCast2D_set_collide_with_bodies :: (using self: *RayCast2D, enable: bool) {
}
RayCast2D_is_collide_with_bodies_enabled :: (using self: *RayCast2D) -> bool {
}
RayCast2D_set_hit_from_inside :: (using self: *RayCast2D, enable: bool) {
}
RayCast2D_is_hit_from_inside_enabled :: (using self: *RayCast2D) -> bool {
}

// RayCast3D
RayCast3D :: struct {
	__private: *void;
}

RayCast3D_set_enabled :: (using self: *RayCast3D, enabled: bool) {
}
RayCast3D_is_enabled :: (using self: *RayCast3D) -> bool {
}
RayCast3D_set_target_position :: (using self: *RayCast3D, local_point: Vector3) {
}
RayCast3D_get_target_position :: (using self: *RayCast3D) -> Vector3 {
}
RayCast3D_is_colliding :: (using self: *RayCast3D) -> bool {
}
RayCast3D_force_raycast_update :: (using self: *RayCast3D) {
}
RayCast3D_get_collider :: (using self: *RayCast3D) -> Object {
}
RayCast3D_get_collider_rid :: (using self: *RayCast3D) -> RID {
}
RayCast3D_get_collider_shape :: (using self: *RayCast3D) -> int {
}
RayCast3D_get_collision_point :: (using self: *RayCast3D) -> Vector3 {
}
RayCast3D_get_collision_normal :: (using self: *RayCast3D) -> Vector3 {
}
RayCast3D_get_collision_face_index :: (using self: *RayCast3D) -> int {
}
RayCast3D_add_exception_rid :: (using self: *RayCast3D, rid: RID) {
}
RayCast3D_add_exception :: (using self: *RayCast3D, node: CollisionObject3D) {
}
RayCast3D_remove_exception_rid :: (using self: *RayCast3D, rid: RID) {
}
RayCast3D_remove_exception :: (using self: *RayCast3D, node: CollisionObject3D) {
}
RayCast3D_clear_exceptions :: (using self: *RayCast3D) {
}
RayCast3D_set_collision_mask :: (using self: *RayCast3D, mask: int) {
}
RayCast3D_get_collision_mask :: (using self: *RayCast3D) -> int {
}
RayCast3D_set_collision_mask_value :: (using self: *RayCast3D, layer_number: int, value: bool) {
}
RayCast3D_get_collision_mask_value :: (using self: *RayCast3D, layer_number: int) -> bool {
}
RayCast3D_set_exclude_parent_body :: (using self: *RayCast3D, mask: bool) {
}
RayCast3D_get_exclude_parent_body :: (using self: *RayCast3D) -> bool {
}
RayCast3D_set_collide_with_areas :: (using self: *RayCast3D, enable: bool) {
}
RayCast3D_is_collide_with_areas_enabled :: (using self: *RayCast3D) -> bool {
}
RayCast3D_set_collide_with_bodies :: (using self: *RayCast3D, enable: bool) {
}
RayCast3D_is_collide_with_bodies_enabled :: (using self: *RayCast3D) -> bool {
}
RayCast3D_set_hit_from_inside :: (using self: *RayCast3D, enable: bool) {
}
RayCast3D_is_hit_from_inside_enabled :: (using self: *RayCast3D) -> bool {
}
RayCast3D_set_hit_back_faces :: (using self: *RayCast3D, enable: bool) {
}
RayCast3D_is_hit_back_faces_enabled :: (using self: *RayCast3D) -> bool {
}
RayCast3D_set_debug_shape_custom_color :: (using self: *RayCast3D, debug_shape_custom_color: Color) {
}
RayCast3D_get_debug_shape_custom_color :: (using self: *RayCast3D) -> Color {
}
RayCast3D_set_debug_shape_thickness :: (using self: *RayCast3D, debug_shape_thickness: int) {
}
RayCast3D_get_debug_shape_thickness :: (using self: *RayCast3D) -> int {
}

// RectangleShape2D
RectangleShape2D :: struct {
	__private: *void;
}

RectangleShape2D_set_size :: (using self: *RectangleShape2D, size: Vector2) {
}
RectangleShape2D_get_size :: (using self: *RectangleShape2D) -> Vector2 {
}

// RefCounted
RefCounted :: struct {
	__private: *void;
}

RefCounted_init_ref :: (using self: *RefCounted) -> bool {
}
RefCounted_reference :: (using self: *RefCounted) -> bool {
}
RefCounted_unreference :: (using self: *RefCounted) -> bool {
}
RefCounted_get_reference_count :: (using self: *RefCounted) -> int {
}

// ReferenceRect
ReferenceRect :: struct {
	__private: *void;
}

ReferenceRect_get_border_color :: (using self: *ReferenceRect) -> Color {
}
ReferenceRect_set_border_color :: (using self: *ReferenceRect, color: Color) {
}
ReferenceRect_get_border_width :: (using self: *ReferenceRect) -> float {
}
ReferenceRect_set_border_width :: (using self: *ReferenceRect, width: float) {
}
ReferenceRect_get_editor_only :: (using self: *ReferenceRect) -> bool {
}
ReferenceRect_set_editor_only :: (using self: *ReferenceRect, enabled: bool) {
}

// ReflectionProbe
ReflectionProbe :: struct {
	__private: *void;

	UpdateMode :: enum {
		UPDATE_ONCE :: 0;
		UPDATE_ALWAYS :: 1;
	}
	AmbientMode :: enum {
		AMBIENT_DISABLED :: 0;
		AMBIENT_ENVIRONMENT :: 1;
		AMBIENT_COLOR :: 2;
	}
}

ReflectionProbe_set_intensity :: (using self: *ReflectionProbe, intensity: float) {
}
ReflectionProbe_get_intensity :: (using self: *ReflectionProbe) -> float {
}
ReflectionProbe_set_ambient_mode :: (using self: *ReflectionProbe, ambient: ReflectionProbe.AmbientMode) {
}
ReflectionProbe_get_ambient_mode :: (using self: *ReflectionProbe) -> ReflectionProbe.AmbientMode {
}
ReflectionProbe_set_ambient_color :: (using self: *ReflectionProbe, ambient: Color) {
}
ReflectionProbe_get_ambient_color :: (using self: *ReflectionProbe) -> Color {
}
ReflectionProbe_set_ambient_color_energy :: (using self: *ReflectionProbe, ambient_energy: float) {
}
ReflectionProbe_get_ambient_color_energy :: (using self: *ReflectionProbe) -> float {
}
ReflectionProbe_set_max_distance :: (using self: *ReflectionProbe, max_distance: float) {
}
ReflectionProbe_get_max_distance :: (using self: *ReflectionProbe) -> float {
}
ReflectionProbe_set_mesh_lod_threshold :: (using self: *ReflectionProbe, ratio: float) {
}
ReflectionProbe_get_mesh_lod_threshold :: (using self: *ReflectionProbe) -> float {
}
ReflectionProbe_set_size :: (using self: *ReflectionProbe, size: Vector3) {
}
ReflectionProbe_get_size :: (using self: *ReflectionProbe) -> Vector3 {
}
ReflectionProbe_set_origin_offset :: (using self: *ReflectionProbe, origin_offset: Vector3) {
}
ReflectionProbe_get_origin_offset :: (using self: *ReflectionProbe) -> Vector3 {
}
ReflectionProbe_set_as_interior :: (using self: *ReflectionProbe, enable: bool) {
}
ReflectionProbe_is_set_as_interior :: (using self: *ReflectionProbe) -> bool {
}
ReflectionProbe_set_enable_box_projection :: (using self: *ReflectionProbe, enable: bool) {
}
ReflectionProbe_is_box_projection_enabled :: (using self: *ReflectionProbe) -> bool {
}
ReflectionProbe_set_enable_shadows :: (using self: *ReflectionProbe, enable: bool) {
}
ReflectionProbe_are_shadows_enabled :: (using self: *ReflectionProbe) -> bool {
}
ReflectionProbe_set_cull_mask :: (using self: *ReflectionProbe, layers: int) {
}
ReflectionProbe_get_cull_mask :: (using self: *ReflectionProbe) -> int {
}
ReflectionProbe_set_reflection_mask :: (using self: *ReflectionProbe, layers: int) {
}
ReflectionProbe_get_reflection_mask :: (using self: *ReflectionProbe) -> int {
}
ReflectionProbe_set_update_mode :: (using self: *ReflectionProbe, mode: ReflectionProbe.UpdateMode) {
}
ReflectionProbe_get_update_mode :: (using self: *ReflectionProbe) -> ReflectionProbe.UpdateMode {
}

// RegEx
RegEx :: struct {
	__private: *void;
}

RegEx_create_from_string :: (using self: *RegEx, pattern: String) -> RegEx {
}
RegEx_clear :: (using self: *RegEx) {
}
RegEx_compile :: (using self: *RegEx, pattern: String) -> Error {
}
RegEx_search :: (using self: *RegEx, subject: String, offset: int, end: int) -> RegExMatch {
}
RegEx_search_all :: (using self: *RegEx, subject: String, offset: int, end: int) -> Array {
}
RegEx_sub :: (using self: *RegEx, subject: String, replacement: String, all: bool, offset: int, end: int) -> String {
}
RegEx_is_valid :: (using self: *RegEx) -> bool {
}
RegEx_get_pattern :: (using self: *RegEx) -> String {
}
RegEx_get_group_count :: (using self: *RegEx) -> int {
}
RegEx_get_names :: (using self: *RegEx) -> PackedStringArray {
}

// RegExMatch
RegExMatch :: struct {
	__private: *void;
}

RegExMatch_get_subject :: (using self: *RegExMatch) -> String {
}
RegExMatch_get_group_count :: (using self: *RegExMatch) -> int {
}
RegExMatch_get_names :: (using self: *RegExMatch) -> Dictionary {
}
RegExMatch_get_strings :: (using self: *RegExMatch) -> PackedStringArray {
}
RegExMatch_get_string :: (using self: *RegExMatch, name: Variant) -> String {
}
RegExMatch_get_start :: (using self: *RegExMatch, name: Variant) -> int {
}
RegExMatch_get_end :: (using self: *RegExMatch, name: Variant) -> int {
}

// RemoteTransform2D
RemoteTransform2D :: struct {
	__private: *void;
}

RemoteTransform2D_set_remote_node :: (using self: *RemoteTransform2D, path: NodePath) {
}
RemoteTransform2D_get_remote_node :: (using self: *RemoteTransform2D) -> NodePath {
}
RemoteTransform2D_force_update_cache :: (using self: *RemoteTransform2D) {
}
RemoteTransform2D_set_use_global_coordinates :: (using self: *RemoteTransform2D, use_global_coordinates: bool) {
}
RemoteTransform2D_get_use_global_coordinates :: (using self: *RemoteTransform2D) -> bool {
}
RemoteTransform2D_set_update_position :: (using self: *RemoteTransform2D, update_remote_position: bool) {
}
RemoteTransform2D_get_update_position :: (using self: *RemoteTransform2D) -> bool {
}
RemoteTransform2D_set_update_rotation :: (using self: *RemoteTransform2D, update_remote_rotation: bool) {
}
RemoteTransform2D_get_update_rotation :: (using self: *RemoteTransform2D) -> bool {
}
RemoteTransform2D_set_update_scale :: (using self: *RemoteTransform2D, update_remote_scale: bool) {
}
RemoteTransform2D_get_update_scale :: (using self: *RemoteTransform2D) -> bool {
}

// RemoteTransform3D
RemoteTransform3D :: struct {
	__private: *void;
}

RemoteTransform3D_set_remote_node :: (using self: *RemoteTransform3D, path: NodePath) {
}
RemoteTransform3D_get_remote_node :: (using self: *RemoteTransform3D) -> NodePath {
}
RemoteTransform3D_force_update_cache :: (using self: *RemoteTransform3D) {
}
RemoteTransform3D_set_use_global_coordinates :: (using self: *RemoteTransform3D, use_global_coordinates: bool) {
}
RemoteTransform3D_get_use_global_coordinates :: (using self: *RemoteTransform3D) -> bool {
}
RemoteTransform3D_set_update_position :: (using self: *RemoteTransform3D, update_remote_position: bool) {
}
RemoteTransform3D_get_update_position :: (using self: *RemoteTransform3D) -> bool {
}
RemoteTransform3D_set_update_rotation :: (using self: *RemoteTransform3D, update_remote_rotation: bool) {
}
RemoteTransform3D_get_update_rotation :: (using self: *RemoteTransform3D) -> bool {
}
RemoteTransform3D_set_update_scale :: (using self: *RemoteTransform3D, update_remote_scale: bool) {
}
RemoteTransform3D_get_update_scale :: (using self: *RemoteTransform3D) -> bool {
}

// RenderData
RenderData :: struct {
	__private: *void;
}

RenderData_get_render_scene_buffers :: (using self: *RenderData) -> RenderSceneBuffers {
}
RenderData_get_render_scene_data :: (using self: *RenderData) -> RenderSceneData {
}
RenderData_get_environment :: (using self: *RenderData) -> RID {
}
RenderData_get_camera_attributes :: (using self: *RenderData) -> RID {
}

// RenderDataExtension
RenderDataExtension :: struct {
	__private: *void;
}

RenderDataExtension__get_render_scene_buffers :: (using self: *RenderDataExtension) -> RenderSceneBuffers {
}
RenderDataExtension__get_render_scene_data :: (using self: *RenderDataExtension) -> RenderSceneData {
}
RenderDataExtension__get_environment :: (using self: *RenderDataExtension) -> RID {
}
RenderDataExtension__get_camera_attributes :: (using self: *RenderDataExtension) -> RID {
}

// RenderDataRD
RenderDataRD :: struct {
	__private: *void;
}

// RenderSceneBuffers
RenderSceneBuffers :: struct {
	__private: *void;
}

RenderSceneBuffers_configure :: (using self: *RenderSceneBuffers, config: RenderSceneBuffersConfiguration) {
}

// RenderSceneBuffersConfiguration
RenderSceneBuffersConfiguration :: struct {
	__private: *void;
}

RenderSceneBuffersConfiguration_get_render_target :: (using self: *RenderSceneBuffersConfiguration) -> RID {
}
RenderSceneBuffersConfiguration_set_render_target :: (using self: *RenderSceneBuffersConfiguration, render_target: RID) {
}
RenderSceneBuffersConfiguration_get_internal_size :: (using self: *RenderSceneBuffersConfiguration) -> Vector2i {
}
RenderSceneBuffersConfiguration_set_internal_size :: (using self: *RenderSceneBuffersConfiguration, internal_size: Vector2i) {
}
RenderSceneBuffersConfiguration_get_target_size :: (using self: *RenderSceneBuffersConfiguration) -> Vector2i {
}
RenderSceneBuffersConfiguration_set_target_size :: (using self: *RenderSceneBuffersConfiguration, target_size: Vector2i) {
}
RenderSceneBuffersConfiguration_get_view_count :: (using self: *RenderSceneBuffersConfiguration) -> int {
}
RenderSceneBuffersConfiguration_set_view_count :: (using self: *RenderSceneBuffersConfiguration, view_count: int) {
}
RenderSceneBuffersConfiguration_get_scaling_3d_mode :: (using self: *RenderSceneBuffersConfiguration) -> RenderingServer.ViewportScaling3DMode {
}
RenderSceneBuffersConfiguration_set_scaling_3d_mode :: (using self: *RenderSceneBuffersConfiguration, scaling_3d_mode: RenderingServer.ViewportScaling3DMode) {
}
RenderSceneBuffersConfiguration_get_msaa_3d :: (using self: *RenderSceneBuffersConfiguration) -> RenderingServer.ViewportMSAA {
}
RenderSceneBuffersConfiguration_set_msaa_3d :: (using self: *RenderSceneBuffersConfiguration, msaa_3d: RenderingServer.ViewportMSAA) {
}
RenderSceneBuffersConfiguration_get_screen_space_aa :: (using self: *RenderSceneBuffersConfiguration) -> RenderingServer.ViewportScreenSpaceAA {
}
RenderSceneBuffersConfiguration_set_screen_space_aa :: (using self: *RenderSceneBuffersConfiguration, screen_space_aa: RenderingServer.ViewportScreenSpaceAA) {
}
RenderSceneBuffersConfiguration_get_fsr_sharpness :: (using self: *RenderSceneBuffersConfiguration) -> float {
}
RenderSceneBuffersConfiguration_set_fsr_sharpness :: (using self: *RenderSceneBuffersConfiguration, fsr_sharpness: float) {
}
RenderSceneBuffersConfiguration_get_texture_mipmap_bias :: (using self: *RenderSceneBuffersConfiguration) -> float {
}
RenderSceneBuffersConfiguration_set_texture_mipmap_bias :: (using self: *RenderSceneBuffersConfiguration, texture_mipmap_bias: float) {
}

// RenderSceneBuffersExtension
RenderSceneBuffersExtension :: struct {
	__private: *void;
}

RenderSceneBuffersExtension__configure :: (using self: *RenderSceneBuffersExtension, config: RenderSceneBuffersConfiguration) {
}
RenderSceneBuffersExtension__set_fsr_sharpness :: (using self: *RenderSceneBuffersExtension, fsr_sharpness: float) {
}
RenderSceneBuffersExtension__set_texture_mipmap_bias :: (using self: *RenderSceneBuffersExtension, texture_mipmap_bias: float) {
}
RenderSceneBuffersExtension__set_use_debanding :: (using self: *RenderSceneBuffersExtension, use_debanding: bool) {
}

// RenderSceneBuffersRD
RenderSceneBuffersRD :: struct {
	__private: *void;
}

RenderSceneBuffersRD_has_texture :: (using self: *RenderSceneBuffersRD, _context: StringName, name: StringName) -> bool {
}
RenderSceneBuffersRD_create_texture :: (using self: *RenderSceneBuffersRD, _context: StringName, name: StringName, data_format: RenderingDevice.DataFormat, usage_bits: int, texture_samples: RenderingDevice.TextureSamples, size: Vector2i, layers: int, mipmaps: int, unique: bool) -> RID {
}
RenderSceneBuffersRD_create_texture_from_format :: (using self: *RenderSceneBuffersRD, _context: StringName, name: StringName, format: RDTextureFormat, view: RDTextureView, unique: bool) -> RID {
}
RenderSceneBuffersRD_create_texture_view :: (using self: *RenderSceneBuffersRD, _context: StringName, name: StringName, view_name: StringName, view: RDTextureView) -> RID {
}
RenderSceneBuffersRD_get_texture :: (using self: *RenderSceneBuffersRD, _context: StringName, name: StringName) -> RID {
}
RenderSceneBuffersRD_get_texture_format :: (using self: *RenderSceneBuffersRD, _context: StringName, name: StringName) -> RDTextureFormat {
}
RenderSceneBuffersRD_get_texture_slice :: (using self: *RenderSceneBuffersRD, _context: StringName, name: StringName, layer: int, mipmap: int, layers: int, mipmaps: int) -> RID {
}
RenderSceneBuffersRD_get_texture_slice_view :: (using self: *RenderSceneBuffersRD, _context: StringName, name: StringName, layer: int, mipmap: int, layers: int, mipmaps: int, view: RDTextureView) -> RID {
}
RenderSceneBuffersRD_get_texture_slice_size :: (using self: *RenderSceneBuffersRD, _context: StringName, name: StringName, mipmap: int) -> Vector2i {
}
RenderSceneBuffersRD_clear_context :: (using self: *RenderSceneBuffersRD, _context: StringName) {
}
RenderSceneBuffersRD_get_color_texture :: (using self: *RenderSceneBuffersRD, msaa: bool) -> RID {
}
RenderSceneBuffersRD_get_color_layer :: (using self: *RenderSceneBuffersRD, layer: int, msaa: bool) -> RID {
}
RenderSceneBuffersRD_get_depth_texture :: (using self: *RenderSceneBuffersRD, msaa: bool) -> RID {
}
RenderSceneBuffersRD_get_depth_layer :: (using self: *RenderSceneBuffersRD, layer: int, msaa: bool) -> RID {
}
RenderSceneBuffersRD_get_velocity_texture :: (using self: *RenderSceneBuffersRD, msaa: bool) -> RID {
}
RenderSceneBuffersRD_get_velocity_layer :: (using self: *RenderSceneBuffersRD, layer: int, msaa: bool) -> RID {
}
RenderSceneBuffersRD_get_render_target :: (using self: *RenderSceneBuffersRD) -> RID {
}
RenderSceneBuffersRD_get_view_count :: (using self: *RenderSceneBuffersRD) -> int {
}
RenderSceneBuffersRD_get_internal_size :: (using self: *RenderSceneBuffersRD) -> Vector2i {
}
RenderSceneBuffersRD_get_target_size :: (using self: *RenderSceneBuffersRD) -> Vector2i {
}
RenderSceneBuffersRD_get_scaling_3d_mode :: (using self: *RenderSceneBuffersRD) -> RenderingServer.ViewportScaling3DMode {
}
RenderSceneBuffersRD_get_fsr_sharpness :: (using self: *RenderSceneBuffersRD) -> float {
}
RenderSceneBuffersRD_get_msaa_3d :: (using self: *RenderSceneBuffersRD) -> RenderingServer.ViewportMSAA {
}
RenderSceneBuffersRD_get_texture_samples :: (using self: *RenderSceneBuffersRD) -> RenderingDevice.TextureSamples {
}
RenderSceneBuffersRD_get_screen_space_aa :: (using self: *RenderSceneBuffersRD) -> RenderingServer.ViewportScreenSpaceAA {
}
RenderSceneBuffersRD_get_use_taa :: (using self: *RenderSceneBuffersRD) -> bool {
}
RenderSceneBuffersRD_get_use_debanding :: (using self: *RenderSceneBuffersRD) -> bool {
}

// RenderSceneData
RenderSceneData :: struct {
	__private: *void;
}

RenderSceneData_get_cam_transform :: (using self: *RenderSceneData) -> Transform3D {
}
RenderSceneData_get_cam_projection :: (using self: *RenderSceneData) -> Projection {
}
RenderSceneData_get_view_count :: (using self: *RenderSceneData) -> int {
}
RenderSceneData_get_view_eye_offset :: (using self: *RenderSceneData, view: int) -> Vector3 {
}
RenderSceneData_get_view_projection :: (using self: *RenderSceneData, view: int) -> Projection {
}
RenderSceneData_get_uniform_buffer :: (using self: *RenderSceneData) -> RID {
}

// RenderSceneDataExtension
RenderSceneDataExtension :: struct {
	__private: *void;
}

RenderSceneDataExtension__get_cam_transform :: (using self: *RenderSceneDataExtension) -> Transform3D {
}
RenderSceneDataExtension__get_cam_projection :: (using self: *RenderSceneDataExtension) -> Projection {
}
RenderSceneDataExtension__get_view_count :: (using self: *RenderSceneDataExtension) -> int {
}
RenderSceneDataExtension__get_view_eye_offset :: (using self: *RenderSceneDataExtension, view: int) -> Vector3 {
}
RenderSceneDataExtension__get_view_projection :: (using self: *RenderSceneDataExtension, view: int) -> Projection {
}
RenderSceneDataExtension__get_uniform_buffer :: (using self: *RenderSceneDataExtension) -> RID {
}

// RenderSceneDataRD
RenderSceneDataRD :: struct {
	__private: *void;
}

// RenderingDevice
RenderingDevice :: struct {
	__private: *void;

	INVALID_ID :: -1;
	INVALID_FORMAT_ID :: -1;

	DeviceType :: enum {
		DEVICE_TYPE_OTHER :: 0;
		DEVICE_TYPE_INTEGRATED_GPU :: 1;
		DEVICE_TYPE_DISCRETE_GPU :: 2;
		DEVICE_TYPE_VIRTUAL_GPU :: 3;
		DEVICE_TYPE_CPU :: 4;
		DEVICE_TYPE_MAX :: 5;
	}
	DriverResource :: enum {
		DRIVER_RESOURCE_LOGICAL_DEVICE :: 0;
		DRIVER_RESOURCE_PHYSICAL_DEVICE :: 1;
		DRIVER_RESOURCE_TOPMOST_OBJECT :: 2;
		DRIVER_RESOURCE_COMMAND_QUEUE :: 3;
		DRIVER_RESOURCE_QUEUE_FAMILY :: 4;
		DRIVER_RESOURCE_TEXTURE :: 5;
		DRIVER_RESOURCE_TEXTURE_VIEW :: 6;
		DRIVER_RESOURCE_TEXTURE_DATA_FORMAT :: 7;
		DRIVER_RESOURCE_SAMPLER :: 8;
		DRIVER_RESOURCE_UNIFORM_SET :: 9;
		DRIVER_RESOURCE_BUFFER :: 10;
		DRIVER_RESOURCE_COMPUTE_PIPELINE :: 11;
		DRIVER_RESOURCE_RENDER_PIPELINE :: 12;
		DRIVER_RESOURCE_VULKAN_DEVICE :: 0;
		DRIVER_RESOURCE_VULKAN_PHYSICAL_DEVICE :: 1;
		DRIVER_RESOURCE_VULKAN_INSTANCE :: 2;
		DRIVER_RESOURCE_VULKAN_QUEUE :: 3;
		DRIVER_RESOURCE_VULKAN_QUEUE_FAMILY_INDEX :: 4;
		DRIVER_RESOURCE_VULKAN_IMAGE :: 5;
		DRIVER_RESOURCE_VULKAN_IMAGE_VIEW :: 6;
		DRIVER_RESOURCE_VULKAN_IMAGE_NATIVE_TEXTURE_FORMAT :: 7;
		DRIVER_RESOURCE_VULKAN_SAMPLER :: 8;
		DRIVER_RESOURCE_VULKAN_DESCRIPTOR_SET :: 9;
		DRIVER_RESOURCE_VULKAN_BUFFER :: 10;
		DRIVER_RESOURCE_VULKAN_COMPUTE_PIPELINE :: 11;
		DRIVER_RESOURCE_VULKAN_RENDER_PIPELINE :: 12;
	}
	DataFormat :: enum {
		DATA_FORMAT_R4G4_UNORM_PACK8 :: 0;
		DATA_FORMAT_R4G4B4A4_UNORM_PACK16 :: 1;
		DATA_FORMAT_B4G4R4A4_UNORM_PACK16 :: 2;
		DATA_FORMAT_R5G6B5_UNORM_PACK16 :: 3;
		DATA_FORMAT_B5G6R5_UNORM_PACK16 :: 4;
		DATA_FORMAT_R5G5B5A1_UNORM_PACK16 :: 5;
		DATA_FORMAT_B5G5R5A1_UNORM_PACK16 :: 6;
		DATA_FORMAT_A1R5G5B5_UNORM_PACK16 :: 7;
		DATA_FORMAT_R8_UNORM :: 8;
		DATA_FORMAT_R8_SNORM :: 9;
		DATA_FORMAT_R8_USCALED :: 10;
		DATA_FORMAT_R8_SSCALED :: 11;
		DATA_FORMAT_R8_UINT :: 12;
		DATA_FORMAT_R8_SINT :: 13;
		DATA_FORMAT_R8_SRGB :: 14;
		DATA_FORMAT_R8G8_UNORM :: 15;
		DATA_FORMAT_R8G8_SNORM :: 16;
		DATA_FORMAT_R8G8_USCALED :: 17;
		DATA_FORMAT_R8G8_SSCALED :: 18;
		DATA_FORMAT_R8G8_UINT :: 19;
		DATA_FORMAT_R8G8_SINT :: 20;
		DATA_FORMAT_R8G8_SRGB :: 21;
		DATA_FORMAT_R8G8B8_UNORM :: 22;
		DATA_FORMAT_R8G8B8_SNORM :: 23;
		DATA_FORMAT_R8G8B8_USCALED :: 24;
		DATA_FORMAT_R8G8B8_SSCALED :: 25;
		DATA_FORMAT_R8G8B8_UINT :: 26;
		DATA_FORMAT_R8G8B8_SINT :: 27;
		DATA_FORMAT_R8G8B8_SRGB :: 28;
		DATA_FORMAT_B8G8R8_UNORM :: 29;
		DATA_FORMAT_B8G8R8_SNORM :: 30;
		DATA_FORMAT_B8G8R8_USCALED :: 31;
		DATA_FORMAT_B8G8R8_SSCALED :: 32;
		DATA_FORMAT_B8G8R8_UINT :: 33;
		DATA_FORMAT_B8G8R8_SINT :: 34;
		DATA_FORMAT_B8G8R8_SRGB :: 35;
		DATA_FORMAT_R8G8B8A8_UNORM :: 36;
		DATA_FORMAT_R8G8B8A8_SNORM :: 37;
		DATA_FORMAT_R8G8B8A8_USCALED :: 38;
		DATA_FORMAT_R8G8B8A8_SSCALED :: 39;
		DATA_FORMAT_R8G8B8A8_UINT :: 40;
		DATA_FORMAT_R8G8B8A8_SINT :: 41;
		DATA_FORMAT_R8G8B8A8_SRGB :: 42;
		DATA_FORMAT_B8G8R8A8_UNORM :: 43;
		DATA_FORMAT_B8G8R8A8_SNORM :: 44;
		DATA_FORMAT_B8G8R8A8_USCALED :: 45;
		DATA_FORMAT_B8G8R8A8_SSCALED :: 46;
		DATA_FORMAT_B8G8R8A8_UINT :: 47;
		DATA_FORMAT_B8G8R8A8_SINT :: 48;
		DATA_FORMAT_B8G8R8A8_SRGB :: 49;
		DATA_FORMAT_A8B8G8R8_UNORM_PACK32 :: 50;
		DATA_FORMAT_A8B8G8R8_SNORM_PACK32 :: 51;
		DATA_FORMAT_A8B8G8R8_USCALED_PACK32 :: 52;
		DATA_FORMAT_A8B8G8R8_SSCALED_PACK32 :: 53;
		DATA_FORMAT_A8B8G8R8_UINT_PACK32 :: 54;
		DATA_FORMAT_A8B8G8R8_SINT_PACK32 :: 55;
		DATA_FORMAT_A8B8G8R8_SRGB_PACK32 :: 56;
		DATA_FORMAT_A2R10G10B10_UNORM_PACK32 :: 57;
		DATA_FORMAT_A2R10G10B10_SNORM_PACK32 :: 58;
		DATA_FORMAT_A2R10G10B10_USCALED_PACK32 :: 59;
		DATA_FORMAT_A2R10G10B10_SSCALED_PACK32 :: 60;
		DATA_FORMAT_A2R10G10B10_UINT_PACK32 :: 61;
		DATA_FORMAT_A2R10G10B10_SINT_PACK32 :: 62;
		DATA_FORMAT_A2B10G10R10_UNORM_PACK32 :: 63;
		DATA_FORMAT_A2B10G10R10_SNORM_PACK32 :: 64;
		DATA_FORMAT_A2B10G10R10_USCALED_PACK32 :: 65;
		DATA_FORMAT_A2B10G10R10_SSCALED_PACK32 :: 66;
		DATA_FORMAT_A2B10G10R10_UINT_PACK32 :: 67;
		DATA_FORMAT_A2B10G10R10_SINT_PACK32 :: 68;
		DATA_FORMAT_R16_UNORM :: 69;
		DATA_FORMAT_R16_SNORM :: 70;
		DATA_FORMAT_R16_USCALED :: 71;
		DATA_FORMAT_R16_SSCALED :: 72;
		DATA_FORMAT_R16_UINT :: 73;
		DATA_FORMAT_R16_SINT :: 74;
		DATA_FORMAT_R16_SFLOAT :: 75;
		DATA_FORMAT_R16G16_UNORM :: 76;
		DATA_FORMAT_R16G16_SNORM :: 77;
		DATA_FORMAT_R16G16_USCALED :: 78;
		DATA_FORMAT_R16G16_SSCALED :: 79;
		DATA_FORMAT_R16G16_UINT :: 80;
		DATA_FORMAT_R16G16_SINT :: 81;
		DATA_FORMAT_R16G16_SFLOAT :: 82;
		DATA_FORMAT_R16G16B16_UNORM :: 83;
		DATA_FORMAT_R16G16B16_SNORM :: 84;
		DATA_FORMAT_R16G16B16_USCALED :: 85;
		DATA_FORMAT_R16G16B16_SSCALED :: 86;
		DATA_FORMAT_R16G16B16_UINT :: 87;
		DATA_FORMAT_R16G16B16_SINT :: 88;
		DATA_FORMAT_R16G16B16_SFLOAT :: 89;
		DATA_FORMAT_R16G16B16A16_UNORM :: 90;
		DATA_FORMAT_R16G16B16A16_SNORM :: 91;
		DATA_FORMAT_R16G16B16A16_USCALED :: 92;
		DATA_FORMAT_R16G16B16A16_SSCALED :: 93;
		DATA_FORMAT_R16G16B16A16_UINT :: 94;
		DATA_FORMAT_R16G16B16A16_SINT :: 95;
		DATA_FORMAT_R16G16B16A16_SFLOAT :: 96;
		DATA_FORMAT_R32_UINT :: 97;
		DATA_FORMAT_R32_SINT :: 98;
		DATA_FORMAT_R32_SFLOAT :: 99;
		DATA_FORMAT_R32G32_UINT :: 100;
		DATA_FORMAT_R32G32_SINT :: 101;
		DATA_FORMAT_R32G32_SFLOAT :: 102;
		DATA_FORMAT_R32G32B32_UINT :: 103;
		DATA_FORMAT_R32G32B32_SINT :: 104;
		DATA_FORMAT_R32G32B32_SFLOAT :: 105;
		DATA_FORMAT_R32G32B32A32_UINT :: 106;
		DATA_FORMAT_R32G32B32A32_SINT :: 107;
		DATA_FORMAT_R32G32B32A32_SFLOAT :: 108;
		DATA_FORMAT_R64_UINT :: 109;
		DATA_FORMAT_R64_SINT :: 110;
		DATA_FORMAT_R64_SFLOAT :: 111;
		DATA_FORMAT_R64G64_UINT :: 112;
		DATA_FORMAT_R64G64_SINT :: 113;
		DATA_FORMAT_R64G64_SFLOAT :: 114;
		DATA_FORMAT_R64G64B64_UINT :: 115;
		DATA_FORMAT_R64G64B64_SINT :: 116;
		DATA_FORMAT_R64G64B64_SFLOAT :: 117;
		DATA_FORMAT_R64G64B64A64_UINT :: 118;
		DATA_FORMAT_R64G64B64A64_SINT :: 119;
		DATA_FORMAT_R64G64B64A64_SFLOAT :: 120;
		DATA_FORMAT_B10G11R11_UFLOAT_PACK32 :: 121;
		DATA_FORMAT_E5B9G9R9_UFLOAT_PACK32 :: 122;
		DATA_FORMAT_D16_UNORM :: 123;
		DATA_FORMAT_X8_D24_UNORM_PACK32 :: 124;
		DATA_FORMAT_D32_SFLOAT :: 125;
		DATA_FORMAT_S8_UINT :: 126;
		DATA_FORMAT_D16_UNORM_S8_UINT :: 127;
		DATA_FORMAT_D24_UNORM_S8_UINT :: 128;
		DATA_FORMAT_D32_SFLOAT_S8_UINT :: 129;
		DATA_FORMAT_BC1_RGB_UNORM_BLOCK :: 130;
		DATA_FORMAT_BC1_RGB_SRGB_BLOCK :: 131;
		DATA_FORMAT_BC1_RGBA_UNORM_BLOCK :: 132;
		DATA_FORMAT_BC1_RGBA_SRGB_BLOCK :: 133;
		DATA_FORMAT_BC2_UNORM_BLOCK :: 134;
		DATA_FORMAT_BC2_SRGB_BLOCK :: 135;
		DATA_FORMAT_BC3_UNORM_BLOCK :: 136;
		DATA_FORMAT_BC3_SRGB_BLOCK :: 137;
		DATA_FORMAT_BC4_UNORM_BLOCK :: 138;
		DATA_FORMAT_BC4_SNORM_BLOCK :: 139;
		DATA_FORMAT_BC5_UNORM_BLOCK :: 140;
		DATA_FORMAT_BC5_SNORM_BLOCK :: 141;
		DATA_FORMAT_BC6H_UFLOAT_BLOCK :: 142;
		DATA_FORMAT_BC6H_SFLOAT_BLOCK :: 143;
		DATA_FORMAT_BC7_UNORM_BLOCK :: 144;
		DATA_FORMAT_BC7_SRGB_BLOCK :: 145;
		DATA_FORMAT_ETC2_R8G8B8_UNORM_BLOCK :: 146;
		DATA_FORMAT_ETC2_R8G8B8_SRGB_BLOCK :: 147;
		DATA_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK :: 148;
		DATA_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK :: 149;
		DATA_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK :: 150;
		DATA_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK :: 151;
		DATA_FORMAT_EAC_R11_UNORM_BLOCK :: 152;
		DATA_FORMAT_EAC_R11_SNORM_BLOCK :: 153;
		DATA_FORMAT_EAC_R11G11_UNORM_BLOCK :: 154;
		DATA_FORMAT_EAC_R11G11_SNORM_BLOCK :: 155;
		DATA_FORMAT_ASTC_4x4_UNORM_BLOCK :: 156;
		DATA_FORMAT_ASTC_4x4_SRGB_BLOCK :: 157;
		DATA_FORMAT_ASTC_5x4_UNORM_BLOCK :: 158;
		DATA_FORMAT_ASTC_5x4_SRGB_BLOCK :: 159;
		DATA_FORMAT_ASTC_5x5_UNORM_BLOCK :: 160;
		DATA_FORMAT_ASTC_5x5_SRGB_BLOCK :: 161;
		DATA_FORMAT_ASTC_6x5_UNORM_BLOCK :: 162;
		DATA_FORMAT_ASTC_6x5_SRGB_BLOCK :: 163;
		DATA_FORMAT_ASTC_6x6_UNORM_BLOCK :: 164;
		DATA_FORMAT_ASTC_6x6_SRGB_BLOCK :: 165;
		DATA_FORMAT_ASTC_8x5_UNORM_BLOCK :: 166;
		DATA_FORMAT_ASTC_8x5_SRGB_BLOCK :: 167;
		DATA_FORMAT_ASTC_8x6_UNORM_BLOCK :: 168;
		DATA_FORMAT_ASTC_8x6_SRGB_BLOCK :: 169;
		DATA_FORMAT_ASTC_8x8_UNORM_BLOCK :: 170;
		DATA_FORMAT_ASTC_8x8_SRGB_BLOCK :: 171;
		DATA_FORMAT_ASTC_10x5_UNORM_BLOCK :: 172;
		DATA_FORMAT_ASTC_10x5_SRGB_BLOCK :: 173;
		DATA_FORMAT_ASTC_10x6_UNORM_BLOCK :: 174;
		DATA_FORMAT_ASTC_10x6_SRGB_BLOCK :: 175;
		DATA_FORMAT_ASTC_10x8_UNORM_BLOCK :: 176;
		DATA_FORMAT_ASTC_10x8_SRGB_BLOCK :: 177;
		DATA_FORMAT_ASTC_10x10_UNORM_BLOCK :: 178;
		DATA_FORMAT_ASTC_10x10_SRGB_BLOCK :: 179;
		DATA_FORMAT_ASTC_12x10_UNORM_BLOCK :: 180;
		DATA_FORMAT_ASTC_12x10_SRGB_BLOCK :: 181;
		DATA_FORMAT_ASTC_12x12_UNORM_BLOCK :: 182;
		DATA_FORMAT_ASTC_12x12_SRGB_BLOCK :: 183;
		DATA_FORMAT_G8B8G8R8_422_UNORM :: 184;
		DATA_FORMAT_B8G8R8G8_422_UNORM :: 185;
		DATA_FORMAT_G8_B8_R8_3PLANE_420_UNORM :: 186;
		DATA_FORMAT_G8_B8R8_2PLANE_420_UNORM :: 187;
		DATA_FORMAT_G8_B8_R8_3PLANE_422_UNORM :: 188;
		DATA_FORMAT_G8_B8R8_2PLANE_422_UNORM :: 189;
		DATA_FORMAT_G8_B8_R8_3PLANE_444_UNORM :: 190;
		DATA_FORMAT_R10X6_UNORM_PACK16 :: 191;
		DATA_FORMAT_R10X6G10X6_UNORM_2PACK16 :: 192;
		DATA_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 :: 193;
		DATA_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 :: 194;
		DATA_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 :: 195;
		DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 :: 196;
		DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 :: 197;
		DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 :: 198;
		DATA_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 :: 199;
		DATA_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 :: 200;
		DATA_FORMAT_R12X4_UNORM_PACK16 :: 201;
		DATA_FORMAT_R12X4G12X4_UNORM_2PACK16 :: 202;
		DATA_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 :: 203;
		DATA_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 :: 204;
		DATA_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 :: 205;
		DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 :: 206;
		DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 :: 207;
		DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 :: 208;
		DATA_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 :: 209;
		DATA_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 :: 210;
		DATA_FORMAT_G16B16G16R16_422_UNORM :: 211;
		DATA_FORMAT_B16G16R16G16_422_UNORM :: 212;
		DATA_FORMAT_G16_B16_R16_3PLANE_420_UNORM :: 213;
		DATA_FORMAT_G16_B16R16_2PLANE_420_UNORM :: 214;
		DATA_FORMAT_G16_B16_R16_3PLANE_422_UNORM :: 215;
		DATA_FORMAT_G16_B16R16_2PLANE_422_UNORM :: 216;
		DATA_FORMAT_G16_B16_R16_3PLANE_444_UNORM :: 217;
		DATA_FORMAT_MAX :: 218;
	}
	BarrierMask :: enum_flags {
		BARRIER_MASK_VERTEX :: 1;
		BARRIER_MASK_FRAGMENT :: 8;
		BARRIER_MASK_COMPUTE :: 2;
		BARRIER_MASK_TRANSFER :: 4;
		BARRIER_MASK_RASTER :: 9;
		BARRIER_MASK_ALL_BARRIERS :: 32767;
		BARRIER_MASK_NO_BARRIER :: 32768;
	}
	TextureType :: enum {
		TEXTURE_TYPE_1D :: 0;
		TEXTURE_TYPE_2D :: 1;
		TEXTURE_TYPE_3D :: 2;
		TEXTURE_TYPE_CUBE :: 3;
		TEXTURE_TYPE_1D_ARRAY :: 4;
		TEXTURE_TYPE_2D_ARRAY :: 5;
		TEXTURE_TYPE_CUBE_ARRAY :: 6;
		TEXTURE_TYPE_MAX :: 7;
	}
	TextureSamples :: enum {
		TEXTURE_SAMPLES_1 :: 0;
		TEXTURE_SAMPLES_2 :: 1;
		TEXTURE_SAMPLES_4 :: 2;
		TEXTURE_SAMPLES_8 :: 3;
		TEXTURE_SAMPLES_16 :: 4;
		TEXTURE_SAMPLES_32 :: 5;
		TEXTURE_SAMPLES_64 :: 6;
		TEXTURE_SAMPLES_MAX :: 7;
	}
	TextureUsageBits :: enum_flags {
		TEXTURE_USAGE_SAMPLING_BIT :: 1;
		TEXTURE_USAGE_COLOR_ATTACHMENT_BIT :: 2;
		TEXTURE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT :: 4;
		TEXTURE_USAGE_STORAGE_BIT :: 8;
		TEXTURE_USAGE_STORAGE_ATOMIC_BIT :: 16;
		TEXTURE_USAGE_CPU_READ_BIT :: 32;
		TEXTURE_USAGE_CAN_UPDATE_BIT :: 64;
		TEXTURE_USAGE_CAN_COPY_FROM_BIT :: 128;
		TEXTURE_USAGE_CAN_COPY_TO_BIT :: 256;
		TEXTURE_USAGE_INPUT_ATTACHMENT_BIT :: 512;
	}
	TextureSwizzle :: enum {
		TEXTURE_SWIZZLE_IDENTITY :: 0;
		TEXTURE_SWIZZLE_ZERO :: 1;
		TEXTURE_SWIZZLE_ONE :: 2;
		TEXTURE_SWIZZLE_R :: 3;
		TEXTURE_SWIZZLE_G :: 4;
		TEXTURE_SWIZZLE_B :: 5;
		TEXTURE_SWIZZLE_A :: 6;
		TEXTURE_SWIZZLE_MAX :: 7;
	}
	TextureSliceType :: enum {
		TEXTURE_SLICE_2D :: 0;
		TEXTURE_SLICE_CUBEMAP :: 1;
		TEXTURE_SLICE_3D :: 2;
	}
	SamplerFilter :: enum {
		SAMPLER_FILTER_NEAREST :: 0;
		SAMPLER_FILTER_LINEAR :: 1;
	}
	SamplerRepeatMode :: enum {
		SAMPLER_REPEAT_MODE_REPEAT :: 0;
		SAMPLER_REPEAT_MODE_MIRRORED_REPEAT :: 1;
		SAMPLER_REPEAT_MODE_CLAMP_TO_EDGE :: 2;
		SAMPLER_REPEAT_MODE_CLAMP_TO_BORDER :: 3;
		SAMPLER_REPEAT_MODE_MIRROR_CLAMP_TO_EDGE :: 4;
		SAMPLER_REPEAT_MODE_MAX :: 5;
	}
	SamplerBorderColor :: enum {
		SAMPLER_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK :: 0;
		SAMPLER_BORDER_COLOR_INT_TRANSPARENT_BLACK :: 1;
		SAMPLER_BORDER_COLOR_FLOAT_OPAQUE_BLACK :: 2;
		SAMPLER_BORDER_COLOR_INT_OPAQUE_BLACK :: 3;
		SAMPLER_BORDER_COLOR_FLOAT_OPAQUE_WHITE :: 4;
		SAMPLER_BORDER_COLOR_INT_OPAQUE_WHITE :: 5;
		SAMPLER_BORDER_COLOR_MAX :: 6;
	}
	VertexFrequency :: enum {
		VERTEX_FREQUENCY_VERTEX :: 0;
		VERTEX_FREQUENCY_INSTANCE :: 1;
	}
	IndexBufferFormat :: enum {
		INDEX_BUFFER_FORMAT_UINT16 :: 0;
		INDEX_BUFFER_FORMAT_UINT32 :: 1;
	}
	StorageBufferUsage :: enum_flags {
		STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT :: 1;
	}
	UniformType :: enum {
		UNIFORM_TYPE_SAMPLER :: 0;
		UNIFORM_TYPE_SAMPLER_WITH_TEXTURE :: 1;
		UNIFORM_TYPE_TEXTURE :: 2;
		UNIFORM_TYPE_IMAGE :: 3;
		UNIFORM_TYPE_TEXTURE_BUFFER :: 4;
		UNIFORM_TYPE_SAMPLER_WITH_TEXTURE_BUFFER :: 5;
		UNIFORM_TYPE_IMAGE_BUFFER :: 6;
		UNIFORM_TYPE_UNIFORM_BUFFER :: 7;
		UNIFORM_TYPE_STORAGE_BUFFER :: 8;
		UNIFORM_TYPE_INPUT_ATTACHMENT :: 9;
		UNIFORM_TYPE_MAX :: 10;
	}
	RenderPrimitive :: enum {
		RENDER_PRIMITIVE_POINTS :: 0;
		RENDER_PRIMITIVE_LINES :: 1;
		RENDER_PRIMITIVE_LINES_WITH_ADJACENCY :: 2;
		RENDER_PRIMITIVE_LINESTRIPS :: 3;
		RENDER_PRIMITIVE_LINESTRIPS_WITH_ADJACENCY :: 4;
		RENDER_PRIMITIVE_TRIANGLES :: 5;
		RENDER_PRIMITIVE_TRIANGLES_WITH_ADJACENCY :: 6;
		RENDER_PRIMITIVE_TRIANGLE_STRIPS :: 7;
		RENDER_PRIMITIVE_TRIANGLE_STRIPS_WITH_AJACENCY :: 8;
		RENDER_PRIMITIVE_TRIANGLE_STRIPS_WITH_RESTART_INDEX :: 9;
		RENDER_PRIMITIVE_TESSELATION_PATCH :: 10;
		RENDER_PRIMITIVE_MAX :: 11;
	}
	PolygonCullMode :: enum {
		POLYGON_CULL_DISABLED :: 0;
		POLYGON_CULL_FRONT :: 1;
		POLYGON_CULL_BACK :: 2;
	}
	PolygonFrontFace :: enum {
		POLYGON_FRONT_FACE_CLOCKWISE :: 0;
		POLYGON_FRONT_FACE_COUNTER_CLOCKWISE :: 1;
	}
	StencilOperation :: enum {
		STENCIL_OP_KEEP :: 0;
		STENCIL_OP_ZERO :: 1;
		STENCIL_OP_REPLACE :: 2;
		STENCIL_OP_INCREMENT_AND_CLAMP :: 3;
		STENCIL_OP_DECREMENT_AND_CLAMP :: 4;
		STENCIL_OP_INVERT :: 5;
		STENCIL_OP_INCREMENT_AND_WRAP :: 6;
		STENCIL_OP_DECREMENT_AND_WRAP :: 7;
		STENCIL_OP_MAX :: 8;
	}
	CompareOperator :: enum {
		COMPARE_OP_NEVER :: 0;
		COMPARE_OP_LESS :: 1;
		COMPARE_OP_EQUAL :: 2;
		COMPARE_OP_LESS_OR_EQUAL :: 3;
		COMPARE_OP_GREATER :: 4;
		COMPARE_OP_NOT_EQUAL :: 5;
		COMPARE_OP_GREATER_OR_EQUAL :: 6;
		COMPARE_OP_ALWAYS :: 7;
		COMPARE_OP_MAX :: 8;
	}
	LogicOperation :: enum {
		LOGIC_OP_CLEAR :: 0;
		LOGIC_OP_AND :: 1;
		LOGIC_OP_AND_REVERSE :: 2;
		LOGIC_OP_COPY :: 3;
		LOGIC_OP_AND_INVERTED :: 4;
		LOGIC_OP_NO_OP :: 5;
		LOGIC_OP_XOR :: 6;
		LOGIC_OP_OR :: 7;
		LOGIC_OP_NOR :: 8;
		LOGIC_OP_EQUIVALENT :: 9;
		LOGIC_OP_INVERT :: 10;
		LOGIC_OP_OR_REVERSE :: 11;
		LOGIC_OP_COPY_INVERTED :: 12;
		LOGIC_OP_OR_INVERTED :: 13;
		LOGIC_OP_NAND :: 14;
		LOGIC_OP_SET :: 15;
		LOGIC_OP_MAX :: 16;
	}
	BlendFactor :: enum {
		BLEND_FACTOR_ZERO :: 0;
		BLEND_FACTOR_ONE :: 1;
		BLEND_FACTOR_SRC_COLOR :: 2;
		BLEND_FACTOR_ONE_MINUS_SRC_COLOR :: 3;
		BLEND_FACTOR_DST_COLOR :: 4;
		BLEND_FACTOR_ONE_MINUS_DST_COLOR :: 5;
		BLEND_FACTOR_SRC_ALPHA :: 6;
		BLEND_FACTOR_ONE_MINUS_SRC_ALPHA :: 7;
		BLEND_FACTOR_DST_ALPHA :: 8;
		BLEND_FACTOR_ONE_MINUS_DST_ALPHA :: 9;
		BLEND_FACTOR_CONSTANT_COLOR :: 10;
		BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR :: 11;
		BLEND_FACTOR_CONSTANT_ALPHA :: 12;
		BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA :: 13;
		BLEND_FACTOR_SRC_ALPHA_SATURATE :: 14;
		BLEND_FACTOR_SRC1_COLOR :: 15;
		BLEND_FACTOR_ONE_MINUS_SRC1_COLOR :: 16;
		BLEND_FACTOR_SRC1_ALPHA :: 17;
		BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA :: 18;
		BLEND_FACTOR_MAX :: 19;
	}
	BlendOperation :: enum {
		BLEND_OP_ADD :: 0;
		BLEND_OP_SUBTRACT :: 1;
		BLEND_OP_REVERSE_SUBTRACT :: 2;
		BLEND_OP_MINIMUM :: 3;
		BLEND_OP_MAXIMUM :: 4;
		BLEND_OP_MAX :: 5;
	}
	PipelineDynamicStateFlags :: enum_flags {
		DYNAMIC_STATE_LINE_WIDTH :: 1;
		DYNAMIC_STATE_DEPTH_BIAS :: 2;
		DYNAMIC_STATE_BLEND_CONSTANTS :: 4;
		DYNAMIC_STATE_DEPTH_BOUNDS :: 8;
		DYNAMIC_STATE_STENCIL_COMPARE_MASK :: 16;
		DYNAMIC_STATE_STENCIL_WRITE_MASK :: 32;
		DYNAMIC_STATE_STENCIL_REFERENCE :: 64;
	}
	InitialAction :: enum {
		INITIAL_ACTION_LOAD :: 0;
		INITIAL_ACTION_CLEAR :: 1;
		INITIAL_ACTION_DISCARD :: 2;
		INITIAL_ACTION_MAX :: 3;
		INITIAL_ACTION_CLEAR_REGION :: 1;
		INITIAL_ACTION_CLEAR_REGION_CONTINUE :: 1;
		INITIAL_ACTION_KEEP :: 0;
		INITIAL_ACTION_DROP :: 2;
		INITIAL_ACTION_CONTINUE :: 0;
	}
	FinalAction :: enum {
		FINAL_ACTION_STORE :: 0;
		FINAL_ACTION_DISCARD :: 1;
		FINAL_ACTION_MAX :: 2;
		FINAL_ACTION_READ :: 0;
		FINAL_ACTION_CONTINUE :: 0;
	}
	ShaderStage :: enum {
		SHADER_STAGE_VERTEX :: 0;
		SHADER_STAGE_FRAGMENT :: 1;
		SHADER_STAGE_TESSELATION_CONTROL :: 2;
		SHADER_STAGE_TESSELATION_EVALUATION :: 3;
		SHADER_STAGE_COMPUTE :: 4;
		SHADER_STAGE_MAX :: 5;
		SHADER_STAGE_VERTEX_BIT :: 1;
		SHADER_STAGE_FRAGMENT_BIT :: 2;
		SHADER_STAGE_TESSELATION_CONTROL_BIT :: 4;
		SHADER_STAGE_TESSELATION_EVALUATION_BIT :: 8;
		SHADER_STAGE_COMPUTE_BIT :: 16;
	}
	ShaderLanguage :: enum {
		SHADER_LANGUAGE_GLSL :: 0;
		SHADER_LANGUAGE_HLSL :: 1;
	}
	PipelineSpecializationConstantType :: enum {
		PIPELINE_SPECIALIZATION_CONSTANT_TYPE_BOOL :: 0;
		PIPELINE_SPECIALIZATION_CONSTANT_TYPE_INT :: 1;
		PIPELINE_SPECIALIZATION_CONSTANT_TYPE_FLOAT :: 2;
	}
	Limit :: enum {
		LIMIT_MAX_BOUND_UNIFORM_SETS :: 0;
		LIMIT_MAX_FRAMEBUFFER_COLOR_ATTACHMENTS :: 1;
		LIMIT_MAX_TEXTURES_PER_UNIFORM_SET :: 2;
		LIMIT_MAX_SAMPLERS_PER_UNIFORM_SET :: 3;
		LIMIT_MAX_STORAGE_BUFFERS_PER_UNIFORM_SET :: 4;
		LIMIT_MAX_STORAGE_IMAGES_PER_UNIFORM_SET :: 5;
		LIMIT_MAX_UNIFORM_BUFFERS_PER_UNIFORM_SET :: 6;
		LIMIT_MAX_DRAW_INDEXED_INDEX :: 7;
		LIMIT_MAX_FRAMEBUFFER_HEIGHT :: 8;
		LIMIT_MAX_FRAMEBUFFER_WIDTH :: 9;
		LIMIT_MAX_TEXTURE_ARRAY_LAYERS :: 10;
		LIMIT_MAX_TEXTURE_SIZE_1D :: 11;
		LIMIT_MAX_TEXTURE_SIZE_2D :: 12;
		LIMIT_MAX_TEXTURE_SIZE_3D :: 13;
		LIMIT_MAX_TEXTURE_SIZE_CUBE :: 14;
		LIMIT_MAX_TEXTURES_PER_SHADER_STAGE :: 15;
		LIMIT_MAX_SAMPLERS_PER_SHADER_STAGE :: 16;
		LIMIT_MAX_STORAGE_BUFFERS_PER_SHADER_STAGE :: 17;
		LIMIT_MAX_STORAGE_IMAGES_PER_SHADER_STAGE :: 18;
		LIMIT_MAX_UNIFORM_BUFFERS_PER_SHADER_STAGE :: 19;
		LIMIT_MAX_PUSH_CONSTANT_SIZE :: 20;
		LIMIT_MAX_UNIFORM_BUFFER_SIZE :: 21;
		LIMIT_MAX_VERTEX_INPUT_ATTRIBUTE_OFFSET :: 22;
		LIMIT_MAX_VERTEX_INPUT_ATTRIBUTES :: 23;
		LIMIT_MAX_VERTEX_INPUT_BINDINGS :: 24;
		LIMIT_MAX_VERTEX_INPUT_BINDING_STRIDE :: 25;
		LIMIT_MIN_UNIFORM_BUFFER_OFFSET_ALIGNMENT :: 26;
		LIMIT_MAX_COMPUTE_SHARED_MEMORY_SIZE :: 27;
		LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_X :: 28;
		LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_Y :: 29;
		LIMIT_MAX_COMPUTE_WORKGROUP_COUNT_Z :: 30;
		LIMIT_MAX_COMPUTE_WORKGROUP_INVOCATIONS :: 31;
		LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_X :: 32;
		LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_Y :: 33;
		LIMIT_MAX_COMPUTE_WORKGROUP_SIZE_Z :: 34;
		LIMIT_MAX_VIEWPORT_DIMENSIONS_X :: 35;
		LIMIT_MAX_VIEWPORT_DIMENSIONS_Y :: 36;
	}
	MemoryType :: enum {
		MEMORY_TEXTURES :: 0;
		MEMORY_BUFFERS :: 1;
		MEMORY_TOTAL :: 2;
	}
}

RenderingDevice_texture_create :: (using self: *RenderingDevice, format: RDTextureFormat, view: RDTextureView, data: Array) -> RID {
}
RenderingDevice_texture_create_shared :: (using self: *RenderingDevice, view: RDTextureView, with_texture: RID) -> RID {
}
RenderingDevice_texture_create_shared_from_slice :: (using self: *RenderingDevice, view: RDTextureView, with_texture: RID, layer: int, mipmap: int, mipmaps: int, slice_type: RenderingDevice.TextureSliceType) -> RID {
}
RenderingDevice_texture_create_from_extension :: (using self: *RenderingDevice, type: RenderingDevice.TextureType, format: RenderingDevice.DataFormat, samples: RenderingDevice.TextureSamples, usage_flags: RenderingDevice.TextureUsageBits, image: int, width: int, height: int, depth: int, layers: int) -> RID {
}
RenderingDevice_texture_update :: (using self: *RenderingDevice, texture: RID, layer: int, data: PackedByteArray) -> Error {
}
RenderingDevice_texture_get_data :: (using self: *RenderingDevice, texture: RID, layer: int) -> PackedByteArray {
}
RenderingDevice_texture_is_format_supported_for_usage :: (using self: *RenderingDevice, format: RenderingDevice.DataFormat, usage_flags: RenderingDevice.TextureUsageBits) -> bool {
}
RenderingDevice_texture_is_shared :: (using self: *RenderingDevice, texture: RID) -> bool {
}
RenderingDevice_texture_is_valid :: (using self: *RenderingDevice, texture: RID) -> bool {
}
RenderingDevice_texture_copy :: (using self: *RenderingDevice, from_texture: RID, to_texture: RID, from_pos: Vector3, to_pos: Vector3, size: Vector3, src_mipmap: int, dst_mipmap: int, src_layer: int, dst_layer: int) -> Error {
}
RenderingDevice_texture_clear :: (using self: *RenderingDevice, texture: RID, color: Color, base_mipmap: int, mipmap_count: int, base_layer: int, layer_count: int) -> Error {
}
RenderingDevice_texture_resolve_multisample :: (using self: *RenderingDevice, from_texture: RID, to_texture: RID) -> Error {
}
RenderingDevice_texture_get_format :: (using self: *RenderingDevice, texture: RID) -> RDTextureFormat {
}
RenderingDevice_texture_get_native_handle :: (using self: *RenderingDevice, texture: RID) -> int {
}
RenderingDevice_framebuffer_format_create :: (using self: *RenderingDevice, attachments: Array, view_count: int) -> int {
}
RenderingDevice_framebuffer_format_create_multipass :: (using self: *RenderingDevice, attachments: Array, passes: Array, view_count: int) -> int {
}
RenderingDevice_framebuffer_format_create_empty :: (using self: *RenderingDevice, samples: RenderingDevice.TextureSamples) -> int {
}
RenderingDevice_framebuffer_format_get_texture_samples :: (using self: *RenderingDevice, format: int, render_pass: int) -> RenderingDevice.TextureSamples {
}
RenderingDevice_framebuffer_create :: (using self: *RenderingDevice, textures: Array, validate_with_format: int, view_count: int) -> RID {
}
RenderingDevice_framebuffer_create_multipass :: (using self: *RenderingDevice, textures: Array, passes: Array, validate_with_format: int, view_count: int) -> RID {
}
RenderingDevice_framebuffer_create_empty :: (using self: *RenderingDevice, size: Vector2i, samples: RenderingDevice.TextureSamples, validate_with_format: int) -> RID {
}
RenderingDevice_framebuffer_get_format :: (using self: *RenderingDevice, framebuffer: RID) -> int {
}
RenderingDevice_framebuffer_is_valid :: (using self: *RenderingDevice, framebuffer: RID) -> bool {
}
RenderingDevice_sampler_create :: (using self: *RenderingDevice, state: RDSamplerState) -> RID {
}
RenderingDevice_sampler_is_format_supported_for_filter :: (using self: *RenderingDevice, format: RenderingDevice.DataFormat, sampler_filter: RenderingDevice.SamplerFilter) -> bool {
}
RenderingDevice_vertex_buffer_create :: (using self: *RenderingDevice, size_bytes: int, data: PackedByteArray, use_as_storage: bool) -> RID {
}
RenderingDevice_vertex_format_create :: (using self: *RenderingDevice, vertex_descriptions: Array) -> int {
}
RenderingDevice_vertex_array_create :: (using self: *RenderingDevice, vertex_count: int, vertex_format: int, src_buffers: Array, offsets: PackedInt64Array) -> RID {
}
RenderingDevice_index_buffer_create :: (using self: *RenderingDevice, size_indices: int, format: RenderingDevice.IndexBufferFormat, data: PackedByteArray, use_restart_indices: bool) -> RID {
}
RenderingDevice_index_array_create :: (using self: *RenderingDevice, index_buffer: RID, index_offset: int, index_count: int) -> RID {
}
RenderingDevice_shader_compile_spirv_from_source :: (using self: *RenderingDevice, shader_source: RDShaderSource, allow_cache: bool) -> RDShaderSPIRV {
}
RenderingDevice_shader_compile_binary_from_spirv :: (using self: *RenderingDevice, spirv_data: RDShaderSPIRV, name: String) -> PackedByteArray {
}
RenderingDevice_shader_create_from_spirv :: (using self: *RenderingDevice, spirv_data: RDShaderSPIRV, name: String) -> RID {
}
RenderingDevice_shader_create_from_bytecode :: (using self: *RenderingDevice, binary_data: PackedByteArray, placeholder_rid: RID) -> RID {
}
RenderingDevice_shader_create_placeholder :: (using self: *RenderingDevice) -> RID {
}
RenderingDevice_shader_get_vertex_input_attribute_mask :: (using self: *RenderingDevice, shader: RID) -> int {
}
RenderingDevice_uniform_buffer_create :: (using self: *RenderingDevice, size_bytes: int, data: PackedByteArray) -> RID {
}
RenderingDevice_storage_buffer_create :: (using self: *RenderingDevice, size_bytes: int, data: PackedByteArray, usage: RenderingDevice.StorageBufferUsage) -> RID {
}
RenderingDevice_texture_buffer_create :: (using self: *RenderingDevice, size_bytes: int, format: RenderingDevice.DataFormat, data: PackedByteArray) -> RID {
}
RenderingDevice_uniform_set_create :: (using self: *RenderingDevice, uniforms: Array, shader: RID, shader_set: int) -> RID {
}
RenderingDevice_uniform_set_is_valid :: (using self: *RenderingDevice, uniform_set: RID) -> bool {
}
RenderingDevice_buffer_copy :: (using self: *RenderingDevice, src_buffer: RID, dst_buffer: RID, src_offset: int, dst_offset: int, size: int) -> Error {
}
RenderingDevice_buffer_update :: (using self: *RenderingDevice, buffer: RID, offset: int, size_bytes: int, data: PackedByteArray) -> Error {
}
RenderingDevice_buffer_clear :: (using self: *RenderingDevice, buffer: RID, offset: int, size_bytes: int) -> Error {
}
RenderingDevice_buffer_get_data :: (using self: *RenderingDevice, buffer: RID, offset_bytes: int, size_bytes: int) -> PackedByteArray {
}
RenderingDevice_render_pipeline_create :: (using self: *RenderingDevice, shader: RID, framebuffer_format: int, vertex_format: int, primitive: RenderingDevice.RenderPrimitive, rasterization_state: RDPipelineRasterizationState, multisample_state: RDPipelineMultisampleState, stencil_state: RDPipelineDepthStencilState, color_blend_state: RDPipelineColorBlendState, dynamic_state_flags: RenderingDevice.PipelineDynamicStateFlags, for_render_pass: int, specialization_constants: Array) -> RID {
}
RenderingDevice_render_pipeline_is_valid :: (using self: *RenderingDevice, render_pipeline: RID) -> bool {
}
RenderingDevice_compute_pipeline_create :: (using self: *RenderingDevice, shader: RID, specialization_constants: Array) -> RID {
}
RenderingDevice_compute_pipeline_is_valid :: (using self: *RenderingDevice, compute_pipeline: RID) -> bool {
}
RenderingDevice_screen_get_width :: (using self: *RenderingDevice, screen: int) -> int {
}
RenderingDevice_screen_get_height :: (using self: *RenderingDevice, screen: int) -> int {
}
RenderingDevice_screen_get_framebuffer_format :: (using self: *RenderingDevice, screen: int) -> int {
}
RenderingDevice_draw_list_begin_for_screen :: (using self: *RenderingDevice, screen: int, clear_color: Color) -> int {
}
RenderingDevice_draw_list_begin :: (using self: *RenderingDevice, framebuffer: RID, initial_color_action: RenderingDevice.InitialAction, final_color_action: RenderingDevice.FinalAction, initial_depth_action: RenderingDevice.InitialAction, final_depth_action: RenderingDevice.FinalAction, clear_color_values: PackedColorArray, clear_depth: float, clear_stencil: int, region: Rect2) -> int {
}
RenderingDevice_draw_list_begin_split :: (using self: *RenderingDevice, framebuffer: RID, splits: int, initial_color_action: RenderingDevice.InitialAction, final_color_action: RenderingDevice.FinalAction, initial_depth_action: RenderingDevice.InitialAction, final_depth_action: RenderingDevice.FinalAction, clear_color_values: PackedColorArray, clear_depth: float, clear_stencil: int, region: Rect2, storage_textures: Array) -> PackedInt64Array {
}
RenderingDevice_draw_list_set_blend_constants :: (using self: *RenderingDevice, draw_list: int, color: Color) {
}
RenderingDevice_draw_list_bind_render_pipeline :: (using self: *RenderingDevice, draw_list: int, render_pipeline: RID) {
}
RenderingDevice_draw_list_bind_uniform_set :: (using self: *RenderingDevice, draw_list: int, uniform_set: RID, set_index: int) {
}
RenderingDevice_draw_list_bind_vertex_array :: (using self: *RenderingDevice, draw_list: int, vertex_array: RID) {
}
RenderingDevice_draw_list_bind_index_array :: (using self: *RenderingDevice, draw_list: int, index_array: RID) {
}
RenderingDevice_draw_list_set_push_constant :: (using self: *RenderingDevice, draw_list: int, buffer: PackedByteArray, size_bytes: int) {
}
RenderingDevice_draw_list_draw :: (using self: *RenderingDevice, draw_list: int, use_indices: bool, instances: int, procedural_vertex_count: int) {
}
RenderingDevice_draw_list_enable_scissor :: (using self: *RenderingDevice, draw_list: int, rect: Rect2) {
}
RenderingDevice_draw_list_disable_scissor :: (using self: *RenderingDevice, draw_list: int) {
}
RenderingDevice_draw_list_switch_to_next_pass :: (using self: *RenderingDevice) -> int {
}
RenderingDevice_draw_list_switch_to_next_pass_split :: (using self: *RenderingDevice, splits: int) -> PackedInt64Array {
}
RenderingDevice_draw_list_end :: (using self: *RenderingDevice) {
}
RenderingDevice_compute_list_begin :: (using self: *RenderingDevice) -> int {
}
RenderingDevice_compute_list_bind_compute_pipeline :: (using self: *RenderingDevice, compute_list: int, compute_pipeline: RID) {
}
RenderingDevice_compute_list_set_push_constant :: (using self: *RenderingDevice, compute_list: int, buffer: PackedByteArray, size_bytes: int) {
}
RenderingDevice_compute_list_bind_uniform_set :: (using self: *RenderingDevice, compute_list: int, uniform_set: RID, set_index: int) {
}
RenderingDevice_compute_list_dispatch :: (using self: *RenderingDevice, compute_list: int, x_groups: int, y_groups: int, z_groups: int) {
}
RenderingDevice_compute_list_dispatch_indirect :: (using self: *RenderingDevice, compute_list: int, buffer: RID, offset: int) {
}
RenderingDevice_compute_list_add_barrier :: (using self: *RenderingDevice, compute_list: int) {
}
RenderingDevice_compute_list_end :: (using self: *RenderingDevice) {
}
RenderingDevice_free_rid :: (using self: *RenderingDevice, rid: RID) {
}
RenderingDevice_capture_timestamp :: (using self: *RenderingDevice, name: String) {
}
RenderingDevice_get_captured_timestamps_count :: (using self: *RenderingDevice) -> int {
}
RenderingDevice_get_captured_timestamps_frame :: (using self: *RenderingDevice) -> int {
}
RenderingDevice_get_captured_timestamp_gpu_time :: (using self: *RenderingDevice, index: int) -> int {
}
RenderingDevice_get_captured_timestamp_cpu_time :: (using self: *RenderingDevice, index: int) -> int {
}
RenderingDevice_get_captured_timestamp_name :: (using self: *RenderingDevice, index: int) -> String {
}
RenderingDevice_limit_get :: (using self: *RenderingDevice, limit: RenderingDevice.Limit) -> int {
}
RenderingDevice_get_frame_delay :: (using self: *RenderingDevice) -> int {
}
RenderingDevice_submit :: (using self: *RenderingDevice) {
}
RenderingDevice_sync :: (using self: *RenderingDevice) {
}
RenderingDevice_barrier :: (using self: *RenderingDevice, from: RenderingDevice.BarrierMask, to: RenderingDevice.BarrierMask) {
}
RenderingDevice_full_barrier :: (using self: *RenderingDevice) {
}
RenderingDevice_create_local_device :: (using self: *RenderingDevice) -> RenderingDevice {
}
RenderingDevice_set_resource_name :: (using self: *RenderingDevice, id: RID, name: String) {
}
RenderingDevice_draw_command_begin_label :: (using self: *RenderingDevice, name: String, color: Color) {
}
RenderingDevice_draw_command_insert_label :: (using self: *RenderingDevice, name: String, color: Color) {
}
RenderingDevice_draw_command_end_label :: (using self: *RenderingDevice) {
}
RenderingDevice_get_device_vendor_name :: (using self: *RenderingDevice) -> String {
}
RenderingDevice_get_device_name :: (using self: *RenderingDevice) -> String {
}
RenderingDevice_get_device_pipeline_cache_uuid :: (using self: *RenderingDevice) -> String {
}
RenderingDevice_get_memory_usage :: (using self: *RenderingDevice, type: RenderingDevice.MemoryType) -> int {
}
RenderingDevice_get_driver_resource :: (using self: *RenderingDevice, resource: RenderingDevice.DriverResource, rid: RID, index: int) -> int {
}

// RenderingServer
RenderingServer :: struct {
	__private: *void;

	NO_INDEX_ARRAY :: -1;
	ARRAY_WEIGHTS_SIZE :: 4;
	CANVAS_ITEM_Z_MIN :: -4096;
	CANVAS_ITEM_Z_MAX :: 4096;
	MAX_GLOW_LEVELS :: 7;
	MAX_CURSORS :: 8;
	MAX_2D_DIRECTIONAL_LIGHTS :: 8;
	MAX_MESH_SURFACES :: 256;
	MATERIAL_RENDER_PRIORITY_MIN :: -128;
	MATERIAL_RENDER_PRIORITY_MAX :: 127;
	ARRAY_CUSTOM_COUNT :: 4;
	PARTICLES_EMIT_FLAG_POSITION :: 1;
	PARTICLES_EMIT_FLAG_ROTATION_SCALE :: 2;
	PARTICLES_EMIT_FLAG_VELOCITY :: 4;
	PARTICLES_EMIT_FLAG_COLOR :: 8;
	PARTICLES_EMIT_FLAG_CUSTOM :: 16;

	TextureLayeredType :: enum {
		TEXTURE_LAYERED_2D_ARRAY :: 0;
		TEXTURE_LAYERED_CUBEMAP :: 1;
		TEXTURE_LAYERED_CUBEMAP_ARRAY :: 2;
	}
	CubeMapLayer :: enum {
		CUBEMAP_LAYER_LEFT :: 0;
		CUBEMAP_LAYER_RIGHT :: 1;
		CUBEMAP_LAYER_BOTTOM :: 2;
		CUBEMAP_LAYER_TOP :: 3;
		CUBEMAP_LAYER_FRONT :: 4;
		CUBEMAP_LAYER_BACK :: 5;
	}
	ShaderMode :: enum {
		SHADER_SPATIAL :: 0;
		SHADER_CANVAS_ITEM :: 1;
		SHADER_PARTICLES :: 2;
		SHADER_SKY :: 3;
		SHADER_FOG :: 4;
		SHADER_MAX :: 5;
	}
	ArrayType :: enum {
		ARRAY_VERTEX :: 0;
		ARRAY_NORMAL :: 1;
		ARRAY_TANGENT :: 2;
		ARRAY_COLOR :: 3;
		ARRAY_TEX_UV :: 4;
		ARRAY_TEX_UV2 :: 5;
		ARRAY_CUSTOM0 :: 6;
		ARRAY_CUSTOM1 :: 7;
		ARRAY_CUSTOM2 :: 8;
		ARRAY_CUSTOM3 :: 9;
		ARRAY_BONES :: 10;
		ARRAY_WEIGHTS :: 11;
		ARRAY_INDEX :: 12;
		ARRAY_MAX :: 13;
	}
	ArrayCustomFormat :: enum {
		ARRAY_CUSTOM_RGBA8_UNORM :: 0;
		ARRAY_CUSTOM_RGBA8_SNORM :: 1;
		ARRAY_CUSTOM_RG_HALF :: 2;
		ARRAY_CUSTOM_RGBA_HALF :: 3;
		ARRAY_CUSTOM_R_FLOAT :: 4;
		ARRAY_CUSTOM_RG_FLOAT :: 5;
		ARRAY_CUSTOM_RGB_FLOAT :: 6;
		ARRAY_CUSTOM_RGBA_FLOAT :: 7;
		ARRAY_CUSTOM_MAX :: 8;
	}
	ArrayFormat :: enum_flags {
		ARRAY_FORMAT_VERTEX :: 1;
		ARRAY_FORMAT_NORMAL :: 2;
		ARRAY_FORMAT_TANGENT :: 4;
		ARRAY_FORMAT_COLOR :: 8;
		ARRAY_FORMAT_TEX_UV :: 16;
		ARRAY_FORMAT_TEX_UV2 :: 32;
		ARRAY_FORMAT_CUSTOM0 :: 64;
		ARRAY_FORMAT_CUSTOM1 :: 128;
		ARRAY_FORMAT_CUSTOM2 :: 256;
		ARRAY_FORMAT_CUSTOM3 :: 512;
		ARRAY_FORMAT_BONES :: 1024;
		ARRAY_FORMAT_WEIGHTS :: 2048;
		ARRAY_FORMAT_INDEX :: 4096;
		ARRAY_FORMAT_BLEND_SHAPE_MASK :: 7;
		ARRAY_FORMAT_CUSTOM_BASE :: 13;
		ARRAY_FORMAT_CUSTOM_BITS :: 3;
		ARRAY_FORMAT_CUSTOM0_SHIFT :: 13;
		ARRAY_FORMAT_CUSTOM1_SHIFT :: 16;
		ARRAY_FORMAT_CUSTOM2_SHIFT :: 19;
		ARRAY_FORMAT_CUSTOM3_SHIFT :: 22;
		ARRAY_FORMAT_CUSTOM_MASK :: 7;
		ARRAY_COMPRESS_FLAGS_BASE :: 25;
		ARRAY_FLAG_USE_2D_VERTICES :: 33554432;
		ARRAY_FLAG_USE_DYNAMIC_UPDATE :: 67108864;
		ARRAY_FLAG_USE_8_BONE_WEIGHTS :: 134217728;
		ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY :: 268435456;
		ARRAY_FLAG_COMPRESS_ATTRIBUTES :: 536870912;
		ARRAY_FLAG_FORMAT_VERSION_BASE :: 35;
		ARRAY_FLAG_FORMAT_VERSION_SHIFT :: 35;
		ARRAY_FLAG_FORMAT_VERSION_1 :: 0;
		ARRAY_FLAG_FORMAT_VERSION_2 :: 34359738368;
		ARRAY_FLAG_FORMAT_CURRENT_VERSION :: 34359738368;
		ARRAY_FLAG_FORMAT_VERSION_MASK :: 255;
	}
	PrimitiveType :: enum {
		PRIMITIVE_POINTS :: 0;
		PRIMITIVE_LINES :: 1;
		PRIMITIVE_LINE_STRIP :: 2;
		PRIMITIVE_TRIANGLES :: 3;
		PRIMITIVE_TRIANGLE_STRIP :: 4;
		PRIMITIVE_MAX :: 5;
	}
	BlendShapeMode :: enum {
		BLEND_SHAPE_MODE_NORMALIZED :: 0;
		BLEND_SHAPE_MODE_RELATIVE :: 1;
	}
	MultimeshTransformFormat :: enum {
		MULTIMESH_TRANSFORM_2D :: 0;
		MULTIMESH_TRANSFORM_3D :: 1;
	}
	LightProjectorFilter :: enum {
		LIGHT_PROJECTOR_FILTER_NEAREST :: 0;
		LIGHT_PROJECTOR_FILTER_LINEAR :: 1;
		LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS :: 2;
		LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS :: 3;
		LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS_ANISOTROPIC :: 4;
		LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS_ANISOTROPIC :: 5;
	}
	LightType :: enum {
		LIGHT_DIRECTIONAL :: 0;
		LIGHT_OMNI :: 1;
		LIGHT_SPOT :: 2;
	}
	LightParam :: enum {
		LIGHT_PARAM_ENERGY :: 0;
		LIGHT_PARAM_INDIRECT_ENERGY :: 1;
		LIGHT_PARAM_VOLUMETRIC_FOG_ENERGY :: 2;
		LIGHT_PARAM_SPECULAR :: 3;
		LIGHT_PARAM_RANGE :: 4;
		LIGHT_PARAM_SIZE :: 5;
		LIGHT_PARAM_ATTENUATION :: 6;
		LIGHT_PARAM_SPOT_ANGLE :: 7;
		LIGHT_PARAM_SPOT_ATTENUATION :: 8;
		LIGHT_PARAM_SHADOW_MAX_DISTANCE :: 9;
		LIGHT_PARAM_SHADOW_SPLIT_1_OFFSET :: 10;
		LIGHT_PARAM_SHADOW_SPLIT_2_OFFSET :: 11;
		LIGHT_PARAM_SHADOW_SPLIT_3_OFFSET :: 12;
		LIGHT_PARAM_SHADOW_FADE_START :: 13;
		LIGHT_PARAM_SHADOW_NORMAL_BIAS :: 14;
		LIGHT_PARAM_SHADOW_BIAS :: 15;
		LIGHT_PARAM_SHADOW_PANCAKE_SIZE :: 16;
		LIGHT_PARAM_SHADOW_OPACITY :: 17;
		LIGHT_PARAM_SHADOW_BLUR :: 18;
		LIGHT_PARAM_TRANSMITTANCE_BIAS :: 19;
		LIGHT_PARAM_INTENSITY :: 20;
		LIGHT_PARAM_MAX :: 21;
	}
	LightBakeMode :: enum {
		LIGHT_BAKE_DISABLED :: 0;
		LIGHT_BAKE_STATIC :: 1;
		LIGHT_BAKE_DYNAMIC :: 2;
	}
	LightOmniShadowMode :: enum {
		LIGHT_OMNI_SHADOW_DUAL_PARABOLOID :: 0;
		LIGHT_OMNI_SHADOW_CUBE :: 1;
	}
	LightDirectionalShadowMode :: enum {
		LIGHT_DIRECTIONAL_SHADOW_ORTHOGONAL :: 0;
		LIGHT_DIRECTIONAL_SHADOW_PARALLEL_2_SPLITS :: 1;
		LIGHT_DIRECTIONAL_SHADOW_PARALLEL_4_SPLITS :: 2;
	}
	LightDirectionalSkyMode :: enum {
		LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_AND_SKY :: 0;
		LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_ONLY :: 1;
		LIGHT_DIRECTIONAL_SKY_MODE_SKY_ONLY :: 2;
	}
	ShadowQuality :: enum {
		SHADOW_QUALITY_HARD :: 0;
		SHADOW_QUALITY_SOFT_VERY_LOW :: 1;
		SHADOW_QUALITY_SOFT_LOW :: 2;
		SHADOW_QUALITY_SOFT_MEDIUM :: 3;
		SHADOW_QUALITY_SOFT_HIGH :: 4;
		SHADOW_QUALITY_SOFT_ULTRA :: 5;
		SHADOW_QUALITY_MAX :: 6;
	}
	ReflectionProbeUpdateMode :: enum {
		REFLECTION_PROBE_UPDATE_ONCE :: 0;
		REFLECTION_PROBE_UPDATE_ALWAYS :: 1;
	}
	ReflectionProbeAmbientMode :: enum {
		REFLECTION_PROBE_AMBIENT_DISABLED :: 0;
		REFLECTION_PROBE_AMBIENT_ENVIRONMENT :: 1;
		REFLECTION_PROBE_AMBIENT_COLOR :: 2;
	}
	DecalTexture :: enum {
		DECAL_TEXTURE_ALBEDO :: 0;
		DECAL_TEXTURE_NORMAL :: 1;
		DECAL_TEXTURE_ORM :: 2;
		DECAL_TEXTURE_EMISSION :: 3;
		DECAL_TEXTURE_MAX :: 4;
	}
	DecalFilter :: enum {
		DECAL_FILTER_NEAREST :: 0;
		DECAL_FILTER_LINEAR :: 1;
		DECAL_FILTER_NEAREST_MIPMAPS :: 2;
		DECAL_FILTER_LINEAR_MIPMAPS :: 3;
		DECAL_FILTER_NEAREST_MIPMAPS_ANISOTROPIC :: 4;
		DECAL_FILTER_LINEAR_MIPMAPS_ANISOTROPIC :: 5;
	}
	VoxelGIQuality :: enum {
		VOXEL_GI_QUALITY_LOW :: 0;
		VOXEL_GI_QUALITY_HIGH :: 1;
	}
	ParticlesMode :: enum {
		PARTICLES_MODE_2D :: 0;
		PARTICLES_MODE_3D :: 1;
	}
	ParticlesTransformAlign :: enum {
		PARTICLES_TRANSFORM_ALIGN_DISABLED :: 0;
		PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD :: 1;
		PARTICLES_TRANSFORM_ALIGN_Y_TO_VELOCITY :: 2;
		PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD_Y_TO_VELOCITY :: 3;
	}
	ParticlesDrawOrder :: enum {
		PARTICLES_DRAW_ORDER_INDEX :: 0;
		PARTICLES_DRAW_ORDER_LIFETIME :: 1;
		PARTICLES_DRAW_ORDER_REVERSE_LIFETIME :: 2;
		PARTICLES_DRAW_ORDER_VIEW_DEPTH :: 3;
	}
	ParticlesCollisionType :: enum {
		PARTICLES_COLLISION_TYPE_SPHERE_ATTRACT :: 0;
		PARTICLES_COLLISION_TYPE_BOX_ATTRACT :: 1;
		PARTICLES_COLLISION_TYPE_VECTOR_FIELD_ATTRACT :: 2;
		PARTICLES_COLLISION_TYPE_SPHERE_COLLIDE :: 3;
		PARTICLES_COLLISION_TYPE_BOX_COLLIDE :: 4;
		PARTICLES_COLLISION_TYPE_SDF_COLLIDE :: 5;
		PARTICLES_COLLISION_TYPE_HEIGHTFIELD_COLLIDE :: 6;
	}
	ParticlesCollisionHeightfieldResolution :: enum {
		PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_256 :: 0;
		PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_512 :: 1;
		PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_1024 :: 2;
		PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_2048 :: 3;
		PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_4096 :: 4;
		PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_8192 :: 5;
		PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_MAX :: 6;
	}
	FogVolumeShape :: enum {
		FOG_VOLUME_SHAPE_ELLIPSOID :: 0;
		FOG_VOLUME_SHAPE_CONE :: 1;
		FOG_VOLUME_SHAPE_CYLINDER :: 2;
		FOG_VOLUME_SHAPE_BOX :: 3;
		FOG_VOLUME_SHAPE_WORLD :: 4;
		FOG_VOLUME_SHAPE_MAX :: 5;
	}
	ViewportScaling3DMode :: enum {
		VIEWPORT_SCALING_3D_MODE_BILINEAR :: 0;
		VIEWPORT_SCALING_3D_MODE_FSR :: 1;
		VIEWPORT_SCALING_3D_MODE_FSR2 :: 2;
		VIEWPORT_SCALING_3D_MODE_MAX :: 3;
	}
	ViewportUpdateMode :: enum {
		VIEWPORT_UPDATE_DISABLED :: 0;
		VIEWPORT_UPDATE_ONCE :: 1;
		VIEWPORT_UPDATE_WHEN_VISIBLE :: 2;
		VIEWPORT_UPDATE_WHEN_PARENT_VISIBLE :: 3;
		VIEWPORT_UPDATE_ALWAYS :: 4;
	}
	ViewportClearMode :: enum {
		VIEWPORT_CLEAR_ALWAYS :: 0;
		VIEWPORT_CLEAR_NEVER :: 1;
		VIEWPORT_CLEAR_ONLY_NEXT_FRAME :: 2;
	}
	ViewportEnvironmentMode :: enum {
		VIEWPORT_ENVIRONMENT_DISABLED :: 0;
		VIEWPORT_ENVIRONMENT_ENABLED :: 1;
		VIEWPORT_ENVIRONMENT_INHERIT :: 2;
		VIEWPORT_ENVIRONMENT_MAX :: 3;
	}
	ViewportSDFOversize :: enum {
		VIEWPORT_SDF_OVERSIZE_100_PERCENT :: 0;
		VIEWPORT_SDF_OVERSIZE_120_PERCENT :: 1;
		VIEWPORT_SDF_OVERSIZE_150_PERCENT :: 2;
		VIEWPORT_SDF_OVERSIZE_200_PERCENT :: 3;
		VIEWPORT_SDF_OVERSIZE_MAX :: 4;
	}
	ViewportSDFScale :: enum {
		VIEWPORT_SDF_SCALE_100_PERCENT :: 0;
		VIEWPORT_SDF_SCALE_50_PERCENT :: 1;
		VIEWPORT_SDF_SCALE_25_PERCENT :: 2;
		VIEWPORT_SDF_SCALE_MAX :: 3;
	}
	ViewportMSAA :: enum {
		VIEWPORT_MSAA_DISABLED :: 0;
		VIEWPORT_MSAA_2X :: 1;
		VIEWPORT_MSAA_4X :: 2;
		VIEWPORT_MSAA_8X :: 3;
		VIEWPORT_MSAA_MAX :: 4;
	}
	ViewportScreenSpaceAA :: enum {
		VIEWPORT_SCREEN_SPACE_AA_DISABLED :: 0;
		VIEWPORT_SCREEN_SPACE_AA_FXAA :: 1;
		VIEWPORT_SCREEN_SPACE_AA_MAX :: 2;
	}
	ViewportOcclusionCullingBuildQuality :: enum {
		VIEWPORT_OCCLUSION_BUILD_QUALITY_LOW :: 0;
		VIEWPORT_OCCLUSION_BUILD_QUALITY_MEDIUM :: 1;
		VIEWPORT_OCCLUSION_BUILD_QUALITY_HIGH :: 2;
	}
	ViewportRenderInfo :: enum {
		VIEWPORT_RENDER_INFO_OBJECTS_IN_FRAME :: 0;
		VIEWPORT_RENDER_INFO_PRIMITIVES_IN_FRAME :: 1;
		VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME :: 2;
		VIEWPORT_RENDER_INFO_MAX :: 3;
	}
	ViewportRenderInfoType :: enum {
		VIEWPORT_RENDER_INFO_TYPE_VISIBLE :: 0;
		VIEWPORT_RENDER_INFO_TYPE_SHADOW :: 1;
		VIEWPORT_RENDER_INFO_TYPE_CANVAS :: 2;
		VIEWPORT_RENDER_INFO_TYPE_MAX :: 3;
	}
	ViewportDebugDraw :: enum {
		VIEWPORT_DEBUG_DRAW_DISABLED :: 0;
		VIEWPORT_DEBUG_DRAW_UNSHADED :: 1;
		VIEWPORT_DEBUG_DRAW_LIGHTING :: 2;
		VIEWPORT_DEBUG_DRAW_OVERDRAW :: 3;
		VIEWPORT_DEBUG_DRAW_WIREFRAME :: 4;
		VIEWPORT_DEBUG_DRAW_NORMAL_BUFFER :: 5;
		VIEWPORT_DEBUG_DRAW_VOXEL_GI_ALBEDO :: 6;
		VIEWPORT_DEBUG_DRAW_VOXEL_GI_LIGHTING :: 7;
		VIEWPORT_DEBUG_DRAW_VOXEL_GI_EMISSION :: 8;
		VIEWPORT_DEBUG_DRAW_SHADOW_ATLAS :: 9;
		VIEWPORT_DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS :: 10;
		VIEWPORT_DEBUG_DRAW_SCENE_LUMINANCE :: 11;
		VIEWPORT_DEBUG_DRAW_SSAO :: 12;
		VIEWPORT_DEBUG_DRAW_SSIL :: 13;
		VIEWPORT_DEBUG_DRAW_PSSM_SPLITS :: 14;
		VIEWPORT_DEBUG_DRAW_DECAL_ATLAS :: 15;
		VIEWPORT_DEBUG_DRAW_SDFGI :: 16;
		VIEWPORT_DEBUG_DRAW_SDFGI_PROBES :: 17;
		VIEWPORT_DEBUG_DRAW_GI_BUFFER :: 18;
		VIEWPORT_DEBUG_DRAW_DISABLE_LOD :: 19;
		VIEWPORT_DEBUG_DRAW_CLUSTER_OMNI_LIGHTS :: 20;
		VIEWPORT_DEBUG_DRAW_CLUSTER_SPOT_LIGHTS :: 21;
		VIEWPORT_DEBUG_DRAW_CLUSTER_DECALS :: 22;
		VIEWPORT_DEBUG_DRAW_CLUSTER_REFLECTION_PROBES :: 23;
		VIEWPORT_DEBUG_DRAW_OCCLUDERS :: 24;
		VIEWPORT_DEBUG_DRAW_MOTION_VECTORS :: 25;
		VIEWPORT_DEBUG_DRAW_INTERNAL_BUFFER :: 26;
	}
	ViewportVRSMode :: enum {
		VIEWPORT_VRS_DISABLED :: 0;
		VIEWPORT_VRS_TEXTURE :: 1;
		VIEWPORT_VRS_XR :: 2;
		VIEWPORT_VRS_MAX :: 3;
	}
	ViewportVRSUpdateMode :: enum {
		VIEWPORT_VRS_UPDATE_DISABLED :: 0;
		VIEWPORT_VRS_UPDATE_ONCE :: 1;
		VIEWPORT_VRS_UPDATE_ALWAYS :: 2;
		VIEWPORT_VRS_UPDATE_MAX :: 3;
	}
	SkyMode :: enum {
		SKY_MODE_AUTOMATIC :: 0;
		SKY_MODE_QUALITY :: 1;
		SKY_MODE_INCREMENTAL :: 2;
		SKY_MODE_REALTIME :: 3;
	}
	CompositorEffectFlags :: enum {
		COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_COLOR :: 1;
		COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_DEPTH :: 2;
		COMPOSITOR_EFFECT_FLAG_NEEDS_MOTION_VECTORS :: 4;
		COMPOSITOR_EFFECT_FLAG_NEEDS_ROUGHNESS :: 8;
		COMPOSITOR_EFFECT_FLAG_NEEDS_SEPARATE_SPECULAR :: 16;
	}
	CompositorEffectCallbackType :: enum {
		COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_OPAQUE :: 0;
		COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_OPAQUE :: 1;
		COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_SKY :: 2;
		COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_TRANSPARENT :: 3;
		COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_TRANSPARENT :: 4;
		COMPOSITOR_EFFECT_CALLBACK_TYPE_ANY :: -1;
	}
	EnvironmentBG :: enum {
		ENV_BG_CLEAR_COLOR :: 0;
		ENV_BG_COLOR :: 1;
		ENV_BG_SKY :: 2;
		ENV_BG_CANVAS :: 3;
		ENV_BG_KEEP :: 4;
		ENV_BG_CAMERA_FEED :: 5;
		ENV_BG_MAX :: 6;
	}
	EnvironmentAmbientSource :: enum {
		ENV_AMBIENT_SOURCE_BG :: 0;
		ENV_AMBIENT_SOURCE_DISABLED :: 1;
		ENV_AMBIENT_SOURCE_COLOR :: 2;
		ENV_AMBIENT_SOURCE_SKY :: 3;
	}
	EnvironmentReflectionSource :: enum {
		ENV_REFLECTION_SOURCE_BG :: 0;
		ENV_REFLECTION_SOURCE_DISABLED :: 1;
		ENV_REFLECTION_SOURCE_SKY :: 2;
	}
	EnvironmentGlowBlendMode :: enum {
		ENV_GLOW_BLEND_MODE_ADDITIVE :: 0;
		ENV_GLOW_BLEND_MODE_SCREEN :: 1;
		ENV_GLOW_BLEND_MODE_SOFTLIGHT :: 2;
		ENV_GLOW_BLEND_MODE_REPLACE :: 3;
		ENV_GLOW_BLEND_MODE_MIX :: 4;
	}
	EnvironmentFogMode :: enum {
		ENV_FOG_MODE_EXPONENTIAL :: 0;
		ENV_FOG_MODE_DEPTH :: 1;
	}
	EnvironmentToneMapper :: enum {
		ENV_TONE_MAPPER_LINEAR :: 0;
		ENV_TONE_MAPPER_REINHARD :: 1;
		ENV_TONE_MAPPER_FILMIC :: 2;
		ENV_TONE_MAPPER_ACES :: 3;
	}
	EnvironmentSSRRoughnessQuality :: enum {
		ENV_SSR_ROUGHNESS_QUALITY_DISABLED :: 0;
		ENV_SSR_ROUGHNESS_QUALITY_LOW :: 1;
		ENV_SSR_ROUGHNESS_QUALITY_MEDIUM :: 2;
		ENV_SSR_ROUGHNESS_QUALITY_HIGH :: 3;
	}
	EnvironmentSSAOQuality :: enum {
		ENV_SSAO_QUALITY_VERY_LOW :: 0;
		ENV_SSAO_QUALITY_LOW :: 1;
		ENV_SSAO_QUALITY_MEDIUM :: 2;
		ENV_SSAO_QUALITY_HIGH :: 3;
		ENV_SSAO_QUALITY_ULTRA :: 4;
	}
	EnvironmentSSILQuality :: enum {
		ENV_SSIL_QUALITY_VERY_LOW :: 0;
		ENV_SSIL_QUALITY_LOW :: 1;
		ENV_SSIL_QUALITY_MEDIUM :: 2;
		ENV_SSIL_QUALITY_HIGH :: 3;
		ENV_SSIL_QUALITY_ULTRA :: 4;
	}
	EnvironmentSDFGIYScale :: enum {
		ENV_SDFGI_Y_SCALE_50_PERCENT :: 0;
		ENV_SDFGI_Y_SCALE_75_PERCENT :: 1;
		ENV_SDFGI_Y_SCALE_100_PERCENT :: 2;
	}
	EnvironmentSDFGIRayCount :: enum {
		ENV_SDFGI_RAY_COUNT_4 :: 0;
		ENV_SDFGI_RAY_COUNT_8 :: 1;
		ENV_SDFGI_RAY_COUNT_16 :: 2;
		ENV_SDFGI_RAY_COUNT_32 :: 3;
		ENV_SDFGI_RAY_COUNT_64 :: 4;
		ENV_SDFGI_RAY_COUNT_96 :: 5;
		ENV_SDFGI_RAY_COUNT_128 :: 6;
		ENV_SDFGI_RAY_COUNT_MAX :: 7;
	}
	EnvironmentSDFGIFramesToConverge :: enum {
		ENV_SDFGI_CONVERGE_IN_5_FRAMES :: 0;
		ENV_SDFGI_CONVERGE_IN_10_FRAMES :: 1;
		ENV_SDFGI_CONVERGE_IN_15_FRAMES :: 2;
		ENV_SDFGI_CONVERGE_IN_20_FRAMES :: 3;
		ENV_SDFGI_CONVERGE_IN_25_FRAMES :: 4;
		ENV_SDFGI_CONVERGE_IN_30_FRAMES :: 5;
		ENV_SDFGI_CONVERGE_MAX :: 6;
	}
	EnvironmentSDFGIFramesToUpdateLight :: enum {
		ENV_SDFGI_UPDATE_LIGHT_IN_1_FRAME :: 0;
		ENV_SDFGI_UPDATE_LIGHT_IN_2_FRAMES :: 1;
		ENV_SDFGI_UPDATE_LIGHT_IN_4_FRAMES :: 2;
		ENV_SDFGI_UPDATE_LIGHT_IN_8_FRAMES :: 3;
		ENV_SDFGI_UPDATE_LIGHT_IN_16_FRAMES :: 4;
		ENV_SDFGI_UPDATE_LIGHT_MAX :: 5;
	}
	SubSurfaceScatteringQuality :: enum {
		SUB_SURFACE_SCATTERING_QUALITY_DISABLED :: 0;
		SUB_SURFACE_SCATTERING_QUALITY_LOW :: 1;
		SUB_SURFACE_SCATTERING_QUALITY_MEDIUM :: 2;
		SUB_SURFACE_SCATTERING_QUALITY_HIGH :: 3;
	}
	DOFBokehShape :: enum {
		DOF_BOKEH_BOX :: 0;
		DOF_BOKEH_HEXAGON :: 1;
		DOF_BOKEH_CIRCLE :: 2;
	}
	DOFBlurQuality :: enum {
		DOF_BLUR_QUALITY_VERY_LOW :: 0;
		DOF_BLUR_QUALITY_LOW :: 1;
		DOF_BLUR_QUALITY_MEDIUM :: 2;
		DOF_BLUR_QUALITY_HIGH :: 3;
	}
	InstanceType :: enum {
		INSTANCE_NONE :: 0;
		INSTANCE_MESH :: 1;
		INSTANCE_MULTIMESH :: 2;
		INSTANCE_PARTICLES :: 3;
		INSTANCE_PARTICLES_COLLISION :: 4;
		INSTANCE_LIGHT :: 5;
		INSTANCE_REFLECTION_PROBE :: 6;
		INSTANCE_DECAL :: 7;
		INSTANCE_VOXEL_GI :: 8;
		INSTANCE_LIGHTMAP :: 9;
		INSTANCE_OCCLUDER :: 10;
		INSTANCE_VISIBLITY_NOTIFIER :: 11;
		INSTANCE_FOG_VOLUME :: 12;
		INSTANCE_MAX :: 13;
		INSTANCE_GEOMETRY_MASK :: 14;
	}
	InstanceFlags :: enum {
		INSTANCE_FLAG_USE_BAKED_LIGHT :: 0;
		INSTANCE_FLAG_USE_DYNAMIC_GI :: 1;
		INSTANCE_FLAG_DRAW_NEXT_FRAME_IF_VISIBLE :: 2;
		INSTANCE_FLAG_IGNORE_OCCLUSION_CULLING :: 3;
		INSTANCE_FLAG_MAX :: 4;
	}
	ShadowCastingSetting :: enum {
		SHADOW_CASTING_SETTING_OFF :: 0;
		SHADOW_CASTING_SETTING_ON :: 1;
		SHADOW_CASTING_SETTING_DOUBLE_SIDED :: 2;
		SHADOW_CASTING_SETTING_SHADOWS_ONLY :: 3;
	}
	VisibilityRangeFadeMode :: enum {
		VISIBILITY_RANGE_FADE_DISABLED :: 0;
		VISIBILITY_RANGE_FADE_SELF :: 1;
		VISIBILITY_RANGE_FADE_DEPENDENCIES :: 2;
	}
	BakeChannels :: enum {
		BAKE_CHANNEL_ALBEDO_ALPHA :: 0;
		BAKE_CHANNEL_NORMAL :: 1;
		BAKE_CHANNEL_ORM :: 2;
		BAKE_CHANNEL_EMISSION :: 3;
	}
	CanvasTextureChannel :: enum {
		CANVAS_TEXTURE_CHANNEL_DIFFUSE :: 0;
		CANVAS_TEXTURE_CHANNEL_NORMAL :: 1;
		CANVAS_TEXTURE_CHANNEL_SPECULAR :: 2;
	}
	NinePatchAxisMode :: enum {
		NINE_PATCH_STRETCH :: 0;
		NINE_PATCH_TILE :: 1;
		NINE_PATCH_TILE_FIT :: 2;
	}
	CanvasItemTextureFilter :: enum {
		CANVAS_ITEM_TEXTURE_FILTER_DEFAULT :: 0;
		CANVAS_ITEM_TEXTURE_FILTER_NEAREST :: 1;
		CANVAS_ITEM_TEXTURE_FILTER_LINEAR :: 2;
		CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS :: 3;
		CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS :: 4;
		CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC :: 5;
		CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC :: 6;
		CANVAS_ITEM_TEXTURE_FILTER_MAX :: 7;
	}
	CanvasItemTextureRepeat :: enum {
		CANVAS_ITEM_TEXTURE_REPEAT_DEFAULT :: 0;
		CANVAS_ITEM_TEXTURE_REPEAT_DISABLED :: 1;
		CANVAS_ITEM_TEXTURE_REPEAT_ENABLED :: 2;
		CANVAS_ITEM_TEXTURE_REPEAT_MIRROR :: 3;
		CANVAS_ITEM_TEXTURE_REPEAT_MAX :: 4;
	}
	CanvasGroupMode :: enum {
		CANVAS_GROUP_MODE_DISABLED :: 0;
		CANVAS_GROUP_MODE_CLIP_ONLY :: 1;
		CANVAS_GROUP_MODE_CLIP_AND_DRAW :: 2;
		CANVAS_GROUP_MODE_TRANSPARENT :: 3;
	}
	CanvasLightMode :: enum {
		CANVAS_LIGHT_MODE_POINT :: 0;
		CANVAS_LIGHT_MODE_DIRECTIONAL :: 1;
	}
	CanvasLightBlendMode :: enum {
		CANVAS_LIGHT_BLEND_MODE_ADD :: 0;
		CANVAS_LIGHT_BLEND_MODE_SUB :: 1;
		CANVAS_LIGHT_BLEND_MODE_MIX :: 2;
	}
	CanvasLightShadowFilter :: enum {
		CANVAS_LIGHT_FILTER_NONE :: 0;
		CANVAS_LIGHT_FILTER_PCF5 :: 1;
		CANVAS_LIGHT_FILTER_PCF13 :: 2;
		CANVAS_LIGHT_FILTER_MAX :: 3;
	}
	CanvasOccluderPolygonCullMode :: enum {
		CANVAS_OCCLUDER_POLYGON_CULL_DISABLED :: 0;
		CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE :: 1;
		CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE :: 2;
	}
	GlobalShaderParameterType :: enum {
		GLOBAL_VAR_TYPE_BOOL :: 0;
		GLOBAL_VAR_TYPE_BVEC2 :: 1;
		GLOBAL_VAR_TYPE_BVEC3 :: 2;
		GLOBAL_VAR_TYPE_BVEC4 :: 3;
		GLOBAL_VAR_TYPE_INT :: 4;
		GLOBAL_VAR_TYPE_IVEC2 :: 5;
		GLOBAL_VAR_TYPE_IVEC3 :: 6;
		GLOBAL_VAR_TYPE_IVEC4 :: 7;
		GLOBAL_VAR_TYPE_RECT2I :: 8;
		GLOBAL_VAR_TYPE_UINT :: 9;
		GLOBAL_VAR_TYPE_UVEC2 :: 10;
		GLOBAL_VAR_TYPE_UVEC3 :: 11;
		GLOBAL_VAR_TYPE_UVEC4 :: 12;
		GLOBAL_VAR_TYPE_FLOAT :: 13;
		GLOBAL_VAR_TYPE_VEC2 :: 14;
		GLOBAL_VAR_TYPE_VEC3 :: 15;
		GLOBAL_VAR_TYPE_VEC4 :: 16;
		GLOBAL_VAR_TYPE_COLOR :: 17;
		GLOBAL_VAR_TYPE_RECT2 :: 18;
		GLOBAL_VAR_TYPE_MAT2 :: 19;
		GLOBAL_VAR_TYPE_MAT3 :: 20;
		GLOBAL_VAR_TYPE_MAT4 :: 21;
		GLOBAL_VAR_TYPE_TRANSFORM_2D :: 22;
		GLOBAL_VAR_TYPE_TRANSFORM :: 23;
		GLOBAL_VAR_TYPE_SAMPLER2D :: 24;
		GLOBAL_VAR_TYPE_SAMPLER2DARRAY :: 25;
		GLOBAL_VAR_TYPE_SAMPLER3D :: 26;
		GLOBAL_VAR_TYPE_SAMPLERCUBE :: 27;
		GLOBAL_VAR_TYPE_MAX :: 28;
	}
	RenderingInfo :: enum {
		RENDERING_INFO_TOTAL_OBJECTS_IN_FRAME :: 0;
		RENDERING_INFO_TOTAL_PRIMITIVES_IN_FRAME :: 1;
		RENDERING_INFO_TOTAL_DRAW_CALLS_IN_FRAME :: 2;
		RENDERING_INFO_TEXTURE_MEM_USED :: 3;
		RENDERING_INFO_BUFFER_MEM_USED :: 4;
		RENDERING_INFO_VIDEO_MEM_USED :: 5;
	}
	Features :: enum {
		FEATURE_SHADERS :: 0;
		FEATURE_MULTITHREADED :: 1;
	}
}

RenderingServer_texture_2d_create :: (using self: *RenderingServer, image: Image) -> RID {
}
RenderingServer_texture_2d_layered_create :: (using self: *RenderingServer, layers: Array, layered_type: RenderingServer.TextureLayeredType) -> RID {
}
RenderingServer_texture_3d_create :: (using self: *RenderingServer, format: Image.Format, width: int, height: int, depth: int, mipmaps: bool, data: Array) -> RID {
}
RenderingServer_texture_proxy_create :: (using self: *RenderingServer, base: RID) -> RID {
}
RenderingServer_texture_2d_update :: (using self: *RenderingServer, texture: RID, image: Image, layer: int) {
}
RenderingServer_texture_3d_update :: (using self: *RenderingServer, texture: RID, data: Array) {
}
RenderingServer_texture_proxy_update :: (using self: *RenderingServer, texture: RID, proxy_to: RID) {
}
RenderingServer_texture_2d_placeholder_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_texture_2d_layered_placeholder_create :: (using self: *RenderingServer, layered_type: RenderingServer.TextureLayeredType) -> RID {
}
RenderingServer_texture_3d_placeholder_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_texture_2d_get :: (using self: *RenderingServer, texture: RID) -> Image {
}
RenderingServer_texture_2d_layer_get :: (using self: *RenderingServer, texture: RID, layer: int) -> Image {
}
RenderingServer_texture_3d_get :: (using self: *RenderingServer, texture: RID) -> Array {
}
RenderingServer_texture_replace :: (using self: *RenderingServer, texture: RID, by_texture: RID) {
}
RenderingServer_texture_set_size_override :: (using self: *RenderingServer, texture: RID, width: int, height: int) {
}
RenderingServer_texture_set_path :: (using self: *RenderingServer, texture: RID, path: String) {
}
RenderingServer_texture_get_path :: (using self: *RenderingServer, texture: RID) -> String {
}
RenderingServer_texture_get_format :: (using self: *RenderingServer, texture: RID) -> Image.Format {
}
RenderingServer_texture_set_force_redraw_if_visible :: (using self: *RenderingServer, texture: RID, enable: bool) {
}
RenderingServer_texture_rd_create :: (using self: *RenderingServer, rd_texture: RID, layer_type: RenderingServer.TextureLayeredType) -> RID {
}
RenderingServer_texture_get_rd_texture :: (using self: *RenderingServer, texture: RID, srgb: bool) -> RID {
}
RenderingServer_texture_get_native_handle :: (using self: *RenderingServer, texture: RID, srgb: bool) -> int {
}
RenderingServer_shader_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_shader_set_code :: (using self: *RenderingServer, shader: RID, code: String) {
}
RenderingServer_shader_set_path_hint :: (using self: *RenderingServer, shader: RID, path: String) {
}
RenderingServer_shader_get_code :: (using self: *RenderingServer, shader: RID) -> String {
}
RenderingServer_get_shader_parameter_list :: (using self: *RenderingServer, shader: RID) -> Dictionary {
}
RenderingServer_shader_get_parameter_default :: (using self: *RenderingServer, shader: RID, name: StringName) -> Variant {
}
RenderingServer_shader_set_default_texture_parameter :: (using self: *RenderingServer, shader: RID, name: StringName, texture: RID, index: int) {
}
RenderingServer_shader_get_default_texture_parameter :: (using self: *RenderingServer, shader: RID, name: StringName, index: int) -> RID {
}
RenderingServer_material_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_material_set_shader :: (using self: *RenderingServer, shader_material: RID, shader: RID) {
}
RenderingServer_material_set_param :: (using self: *RenderingServer, material: RID, parameter: StringName, value: Variant) {
}
RenderingServer_material_get_param :: (using self: *RenderingServer, material: RID, parameter: StringName) -> Variant {
}
RenderingServer_material_set_render_priority :: (using self: *RenderingServer, material: RID, priority: int) {
}
RenderingServer_material_set_next_pass :: (using self: *RenderingServer, material: RID, next_material: RID) {
}
RenderingServer_mesh_create_from_surfaces :: (using self: *RenderingServer, surfaces: Dictionary, blend_shape_count: int) -> RID {
}
RenderingServer_mesh_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_mesh_surface_get_format_offset :: (using self: *RenderingServer, format: RenderingServer.ArrayFormat, vertex_count: int, array_index: int) -> int {
}
RenderingServer_mesh_surface_get_format_vertex_stride :: (using self: *RenderingServer, format: RenderingServer.ArrayFormat, vertex_count: int) -> int {
}
RenderingServer_mesh_surface_get_format_normal_tangent_stride :: (using self: *RenderingServer, format: RenderingServer.ArrayFormat, vertex_count: int) -> int {
}
RenderingServer_mesh_surface_get_format_attribute_stride :: (using self: *RenderingServer, format: RenderingServer.ArrayFormat, vertex_count: int) -> int {
}
RenderingServer_mesh_surface_get_format_skin_stride :: (using self: *RenderingServer, format: RenderingServer.ArrayFormat, vertex_count: int) -> int {
}
RenderingServer_mesh_add_surface :: (using self: *RenderingServer, mesh: RID, surface: Dictionary) {
}
RenderingServer_mesh_add_surface_from_arrays :: (using self: *RenderingServer, mesh: RID, primitive: RenderingServer.PrimitiveType, arrays: Array, blend_shapes: Array, lods: Dictionary, compress_format: RenderingServer.ArrayFormat) {
}
RenderingServer_mesh_get_blend_shape_count :: (using self: *RenderingServer, mesh: RID) -> int {
}
RenderingServer_mesh_set_blend_shape_mode :: (using self: *RenderingServer, mesh: RID, mode: RenderingServer.BlendShapeMode) {
}
RenderingServer_mesh_get_blend_shape_mode :: (using self: *RenderingServer, mesh: RID) -> RenderingServer.BlendShapeMode {
}
RenderingServer_mesh_surface_set_material :: (using self: *RenderingServer, mesh: RID, surface: int, material: RID) {
}
RenderingServer_mesh_surface_get_material :: (using self: *RenderingServer, mesh: RID, surface: int) -> RID {
}
RenderingServer_mesh_get_surface :: (using self: *RenderingServer, mesh: RID, surface: int) -> Dictionary {
}
RenderingServer_mesh_surface_get_arrays :: (using self: *RenderingServer, mesh: RID, surface: int) -> Array {
}
RenderingServer_mesh_surface_get_blend_shape_arrays :: (using self: *RenderingServer, mesh: RID, surface: int) -> Array {
}
RenderingServer_mesh_get_surface_count :: (using self: *RenderingServer, mesh: RID) -> int {
}
RenderingServer_mesh_set_custom_aabb :: (using self: *RenderingServer, mesh: RID, aabb: AABB) {
}
RenderingServer_mesh_get_custom_aabb :: (using self: *RenderingServer, mesh: RID) -> AABB {
}
RenderingServer_mesh_clear :: (using self: *RenderingServer, mesh: RID) {
}
RenderingServer_mesh_surface_update_vertex_region :: (using self: *RenderingServer, mesh: RID, surface: int, offset: int, data: PackedByteArray) {
}
RenderingServer_mesh_surface_update_attribute_region :: (using self: *RenderingServer, mesh: RID, surface: int, offset: int, data: PackedByteArray) {
}
RenderingServer_mesh_surface_update_skin_region :: (using self: *RenderingServer, mesh: RID, surface: int, offset: int, data: PackedByteArray) {
}
RenderingServer_mesh_set_shadow_mesh :: (using self: *RenderingServer, mesh: RID, shadow_mesh: RID) {
}
RenderingServer_multimesh_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_multimesh_allocate_data :: (using self: *RenderingServer, multimesh: RID, instances: int, transform_format: RenderingServer.MultimeshTransformFormat, color_format: bool, custom_data_format: bool) {
}
RenderingServer_multimesh_get_instance_count :: (using self: *RenderingServer, multimesh: RID) -> int {
}
RenderingServer_multimesh_set_mesh :: (using self: *RenderingServer, multimesh: RID, mesh: RID) {
}
RenderingServer_multimesh_instance_set_transform :: (using self: *RenderingServer, multimesh: RID, index: int, transform: Transform3D) {
}
RenderingServer_multimesh_instance_set_transform_2d :: (using self: *RenderingServer, multimesh: RID, index: int, transform: Transform2D) {
}
RenderingServer_multimesh_instance_set_color :: (using self: *RenderingServer, multimesh: RID, index: int, color: Color) {
}
RenderingServer_multimesh_instance_set_custom_data :: (using self: *RenderingServer, multimesh: RID, index: int, custom_data: Color) {
}
RenderingServer_multimesh_get_mesh :: (using self: *RenderingServer, multimesh: RID) -> RID {
}
RenderingServer_multimesh_get_aabb :: (using self: *RenderingServer, multimesh: RID) -> AABB {
}
RenderingServer_multimesh_set_custom_aabb :: (using self: *RenderingServer, multimesh: RID, aabb: AABB) {
}
RenderingServer_multimesh_get_custom_aabb :: (using self: *RenderingServer, multimesh: RID) -> AABB {
}
RenderingServer_multimesh_instance_get_transform :: (using self: *RenderingServer, multimesh: RID, index: int) -> Transform3D {
}
RenderingServer_multimesh_instance_get_transform_2d :: (using self: *RenderingServer, multimesh: RID, index: int) -> Transform2D {
}
RenderingServer_multimesh_instance_get_color :: (using self: *RenderingServer, multimesh: RID, index: int) -> Color {
}
RenderingServer_multimesh_instance_get_custom_data :: (using self: *RenderingServer, multimesh: RID, index: int) -> Color {
}
RenderingServer_multimesh_set_visible_instances :: (using self: *RenderingServer, multimesh: RID, visible: int) {
}
RenderingServer_multimesh_get_visible_instances :: (using self: *RenderingServer, multimesh: RID) -> int {
}
RenderingServer_multimesh_set_buffer :: (using self: *RenderingServer, multimesh: RID, buffer: PackedFloat32Array) {
}
RenderingServer_multimesh_get_buffer :: (using self: *RenderingServer, multimesh: RID) -> PackedFloat32Array {
}
RenderingServer_skeleton_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_skeleton_allocate_data :: (using self: *RenderingServer, skeleton: RID, bones: int, is_2d_skeleton: bool) {
}
RenderingServer_skeleton_get_bone_count :: (using self: *RenderingServer, skeleton: RID) -> int {
}
RenderingServer_skeleton_bone_set_transform :: (using self: *RenderingServer, skeleton: RID, bone: int, transform: Transform3D) {
}
RenderingServer_skeleton_bone_get_transform :: (using self: *RenderingServer, skeleton: RID, bone: int) -> Transform3D {
}
RenderingServer_skeleton_bone_set_transform_2d :: (using self: *RenderingServer, skeleton: RID, bone: int, transform: Transform2D) {
}
RenderingServer_skeleton_bone_get_transform_2d :: (using self: *RenderingServer, skeleton: RID, bone: int) -> Transform2D {
}
RenderingServer_skeleton_set_base_transform_2d :: (using self: *RenderingServer, skeleton: RID, base_transform: Transform2D) {
}
RenderingServer_directional_light_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_omni_light_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_spot_light_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_light_set_color :: (using self: *RenderingServer, light: RID, color: Color) {
}
RenderingServer_light_set_param :: (using self: *RenderingServer, light: RID, param: RenderingServer.LightParam, value: float) {
}
RenderingServer_light_set_shadow :: (using self: *RenderingServer, light: RID, enabled: bool) {
}
RenderingServer_light_set_projector :: (using self: *RenderingServer, light: RID, texture: RID) {
}
RenderingServer_light_set_negative :: (using self: *RenderingServer, light: RID, enable: bool) {
}
RenderingServer_light_set_cull_mask :: (using self: *RenderingServer, light: RID, mask: int) {
}
RenderingServer_light_set_distance_fade :: (using self: *RenderingServer, decal: RID, enabled: bool, begin: float, shadow: float, length: float) {
}
RenderingServer_light_set_reverse_cull_face_mode :: (using self: *RenderingServer, light: RID, enabled: bool) {
}
RenderingServer_light_set_bake_mode :: (using self: *RenderingServer, light: RID, bake_mode: RenderingServer.LightBakeMode) {
}
RenderingServer_light_set_max_sdfgi_cascade :: (using self: *RenderingServer, light: RID, cascade: int) {
}
RenderingServer_light_omni_set_shadow_mode :: (using self: *RenderingServer, light: RID, mode: RenderingServer.LightOmniShadowMode) {
}
RenderingServer_light_directional_set_shadow_mode :: (using self: *RenderingServer, light: RID, mode: RenderingServer.LightDirectionalShadowMode) {
}
RenderingServer_light_directional_set_blend_splits :: (using self: *RenderingServer, light: RID, enable: bool) {
}
RenderingServer_light_directional_set_sky_mode :: (using self: *RenderingServer, light: RID, mode: RenderingServer.LightDirectionalSkyMode) {
}
RenderingServer_light_projectors_set_filter :: (using self: *RenderingServer, filter: RenderingServer.LightProjectorFilter) {
}
RenderingServer_positional_soft_shadow_filter_set_quality :: (using self: *RenderingServer, quality: RenderingServer.ShadowQuality) {
}
RenderingServer_directional_soft_shadow_filter_set_quality :: (using self: *RenderingServer, quality: RenderingServer.ShadowQuality) {
}
RenderingServer_directional_shadow_atlas_set_size :: (using self: *RenderingServer, size: int, is_16bits: bool) {
}
RenderingServer_reflection_probe_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_reflection_probe_set_update_mode :: (using self: *RenderingServer, probe: RID, mode: RenderingServer.ReflectionProbeUpdateMode) {
}
RenderingServer_reflection_probe_set_intensity :: (using self: *RenderingServer, probe: RID, intensity: float) {
}
RenderingServer_reflection_probe_set_ambient_mode :: (using self: *RenderingServer, probe: RID, mode: RenderingServer.ReflectionProbeAmbientMode) {
}
RenderingServer_reflection_probe_set_ambient_color :: (using self: *RenderingServer, probe: RID, color: Color) {
}
RenderingServer_reflection_probe_set_ambient_energy :: (using self: *RenderingServer, probe: RID, energy: float) {
}
RenderingServer_reflection_probe_set_max_distance :: (using self: *RenderingServer, probe: RID, distance: float) {
}
RenderingServer_reflection_probe_set_size :: (using self: *RenderingServer, probe: RID, size: Vector3) {
}
RenderingServer_reflection_probe_set_origin_offset :: (using self: *RenderingServer, probe: RID, offset: Vector3) {
}
RenderingServer_reflection_probe_set_as_interior :: (using self: *RenderingServer, probe: RID, enable: bool) {
}
RenderingServer_reflection_probe_set_enable_box_projection :: (using self: *RenderingServer, probe: RID, enable: bool) {
}
RenderingServer_reflection_probe_set_enable_shadows :: (using self: *RenderingServer, probe: RID, enable: bool) {
}
RenderingServer_reflection_probe_set_cull_mask :: (using self: *RenderingServer, probe: RID, layers: int) {
}
RenderingServer_reflection_probe_set_reflection_mask :: (using self: *RenderingServer, probe: RID, layers: int) {
}
RenderingServer_reflection_probe_set_resolution :: (using self: *RenderingServer, probe: RID, resolution: int) {
}
RenderingServer_reflection_probe_set_mesh_lod_threshold :: (using self: *RenderingServer, probe: RID, pixels: float) {
}
RenderingServer_decal_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_decal_set_size :: (using self: *RenderingServer, decal: RID, size: Vector3) {
}
RenderingServer_decal_set_texture :: (using self: *RenderingServer, decal: RID, type: RenderingServer.DecalTexture, texture: RID) {
}
RenderingServer_decal_set_emission_energy :: (using self: *RenderingServer, decal: RID, energy: float) {
}
RenderingServer_decal_set_albedo_mix :: (using self: *RenderingServer, decal: RID, albedo_mix: float) {
}
RenderingServer_decal_set_modulate :: (using self: *RenderingServer, decal: RID, color: Color) {
}
RenderingServer_decal_set_cull_mask :: (using self: *RenderingServer, decal: RID, mask: int) {
}
RenderingServer_decal_set_distance_fade :: (using self: *RenderingServer, decal: RID, enabled: bool, begin: float, length: float) {
}
RenderingServer_decal_set_fade :: (using self: *RenderingServer, decal: RID, above: float, below: float) {
}
RenderingServer_decal_set_normal_fade :: (using self: *RenderingServer, decal: RID, fade: float) {
}
RenderingServer_decals_set_filter :: (using self: *RenderingServer, filter: RenderingServer.DecalFilter) {
}
RenderingServer_gi_set_use_half_resolution :: (using self: *RenderingServer, half_resolution: bool) {
}
RenderingServer_voxel_gi_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_voxel_gi_allocate_data :: (using self: *RenderingServer, voxel_gi: RID, to_cell_xform: Transform3D, aabb: AABB, octree_size: Vector3i, octree_cells: PackedByteArray, data_cells: PackedByteArray, distance_field: PackedByteArray, level_counts: PackedInt32Array) {
}
RenderingServer_voxel_gi_get_octree_size :: (using self: *RenderingServer, voxel_gi: RID) -> Vector3i {
}
RenderingServer_voxel_gi_get_octree_cells :: (using self: *RenderingServer, voxel_gi: RID) -> PackedByteArray {
}
RenderingServer_voxel_gi_get_data_cells :: (using self: *RenderingServer, voxel_gi: RID) -> PackedByteArray {
}
RenderingServer_voxel_gi_get_distance_field :: (using self: *RenderingServer, voxel_gi: RID) -> PackedByteArray {
}
RenderingServer_voxel_gi_get_level_counts :: (using self: *RenderingServer, voxel_gi: RID) -> PackedInt32Array {
}
RenderingServer_voxel_gi_get_to_cell_xform :: (using self: *RenderingServer, voxel_gi: RID) -> Transform3D {
}
RenderingServer_voxel_gi_set_dynamic_range :: (using self: *RenderingServer, voxel_gi: RID, range: float) {
}
RenderingServer_voxel_gi_set_propagation :: (using self: *RenderingServer, voxel_gi: RID, amount: float) {
}
RenderingServer_voxel_gi_set_energy :: (using self: *RenderingServer, voxel_gi: RID, energy: float) {
}
RenderingServer_voxel_gi_set_baked_exposure_normalization :: (using self: *RenderingServer, voxel_gi: RID, baked_exposure: float) {
}
RenderingServer_voxel_gi_set_bias :: (using self: *RenderingServer, voxel_gi: RID, bias: float) {
}
RenderingServer_voxel_gi_set_normal_bias :: (using self: *RenderingServer, voxel_gi: RID, bias: float) {
}
RenderingServer_voxel_gi_set_interior :: (using self: *RenderingServer, voxel_gi: RID, enable: bool) {
}
RenderingServer_voxel_gi_set_use_two_bounces :: (using self: *RenderingServer, voxel_gi: RID, enable: bool) {
}
RenderingServer_voxel_gi_set_quality :: (using self: *RenderingServer, quality: RenderingServer.VoxelGIQuality) {
}
RenderingServer_lightmap_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_lightmap_set_textures :: (using self: *RenderingServer, lightmap: RID, light: RID, uses_sh: bool) {
}
RenderingServer_lightmap_set_probe_bounds :: (using self: *RenderingServer, lightmap: RID, bounds: AABB) {
}
RenderingServer_lightmap_set_probe_interior :: (using self: *RenderingServer, lightmap: RID, interior: bool) {
}
RenderingServer_lightmap_set_probe_capture_data :: (using self: *RenderingServer, lightmap: RID, points: PackedVector3Array, point_sh: PackedColorArray, tetrahedra: PackedInt32Array, bsp_tree: PackedInt32Array) {
}
RenderingServer_lightmap_get_probe_capture_points :: (using self: *RenderingServer, lightmap: RID) -> PackedVector3Array {
}
RenderingServer_lightmap_get_probe_capture_sh :: (using self: *RenderingServer, lightmap: RID) -> PackedColorArray {
}
RenderingServer_lightmap_get_probe_capture_tetrahedra :: (using self: *RenderingServer, lightmap: RID) -> PackedInt32Array {
}
RenderingServer_lightmap_get_probe_capture_bsp_tree :: (using self: *RenderingServer, lightmap: RID) -> PackedInt32Array {
}
RenderingServer_lightmap_set_baked_exposure_normalization :: (using self: *RenderingServer, lightmap: RID, baked_exposure: float) {
}
RenderingServer_lightmap_set_probe_capture_update_speed :: (using self: *RenderingServer, speed: float) {
}
RenderingServer_particles_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_particles_set_mode :: (using self: *RenderingServer, particles: RID, mode: RenderingServer.ParticlesMode) {
}
RenderingServer_particles_set_emitting :: (using self: *RenderingServer, particles: RID, emitting: bool) {
}
RenderingServer_particles_get_emitting :: (using self: *RenderingServer, particles: RID) -> bool {
}
RenderingServer_particles_set_amount :: (using self: *RenderingServer, particles: RID, amount: int) {
}
RenderingServer_particles_set_amount_ratio :: (using self: *RenderingServer, particles: RID, ratio: float) {
}
RenderingServer_particles_set_lifetime :: (using self: *RenderingServer, particles: RID, lifetime: float) {
}
RenderingServer_particles_set_one_shot :: (using self: *RenderingServer, particles: RID, one_shot: bool) {
}
RenderingServer_particles_set_pre_process_time :: (using self: *RenderingServer, particles: RID, time: float) {
}
RenderingServer_particles_set_explosiveness_ratio :: (using self: *RenderingServer, particles: RID, ratio: float) {
}
RenderingServer_particles_set_randomness_ratio :: (using self: *RenderingServer, particles: RID, ratio: float) {
}
RenderingServer_particles_set_interp_to_end :: (using self: *RenderingServer, particles: RID, factor: float) {
}
RenderingServer_particles_set_emitter_velocity :: (using self: *RenderingServer, particles: RID, velocity: Vector3) {
}
RenderingServer_particles_set_custom_aabb :: (using self: *RenderingServer, particles: RID, aabb: AABB) {
}
RenderingServer_particles_set_speed_scale :: (using self: *RenderingServer, particles: RID, scale: float) {
}
RenderingServer_particles_set_use_local_coordinates :: (using self: *RenderingServer, particles: RID, enable: bool) {
}
RenderingServer_particles_set_process_material :: (using self: *RenderingServer, particles: RID, material: RID) {
}
RenderingServer_particles_set_fixed_fps :: (using self: *RenderingServer, particles: RID, fps: int) {
}
RenderingServer_particles_set_interpolate :: (using self: *RenderingServer, particles: RID, enable: bool) {
}
RenderingServer_particles_set_fractional_delta :: (using self: *RenderingServer, particles: RID, enable: bool) {
}
RenderingServer_particles_set_collision_base_size :: (using self: *RenderingServer, particles: RID, size: float) {
}
RenderingServer_particles_set_transform_align :: (using self: *RenderingServer, particles: RID, align: RenderingServer.ParticlesTransformAlign) {
}
RenderingServer_particles_set_trails :: (using self: *RenderingServer, particles: RID, enable: bool, length_sec: float) {
}
RenderingServer_particles_set_trail_bind_poses :: (using self: *RenderingServer, particles: RID, bind_poses: Array) {
}
RenderingServer_particles_is_inactive :: (using self: *RenderingServer, particles: RID) -> bool {
}
RenderingServer_particles_request_process :: (using self: *RenderingServer, particles: RID) {
}
RenderingServer_particles_restart :: (using self: *RenderingServer, particles: RID) {
}
RenderingServer_particles_set_subemitter :: (using self: *RenderingServer, particles: RID, subemitter_particles: RID) {
}
RenderingServer_particles_emit :: (using self: *RenderingServer, particles: RID, transform: Transform3D, velocity: Vector3, color: Color, custom: Color, emit_flags: int) {
}
RenderingServer_particles_set_draw_order :: (using self: *RenderingServer, particles: RID, order: RenderingServer.ParticlesDrawOrder) {
}
RenderingServer_particles_set_draw_passes :: (using self: *RenderingServer, particles: RID, count: int) {
}
RenderingServer_particles_set_draw_pass_mesh :: (using self: *RenderingServer, particles: RID, pass: int, mesh: RID) {
}
RenderingServer_particles_get_current_aabb :: (using self: *RenderingServer, particles: RID) -> AABB {
}
RenderingServer_particles_set_emission_transform :: (using self: *RenderingServer, particles: RID, transform: Transform3D) {
}
RenderingServer_particles_collision_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_particles_collision_set_collision_type :: (using self: *RenderingServer, particles_collision: RID, type: RenderingServer.ParticlesCollisionType) {
}
RenderingServer_particles_collision_set_cull_mask :: (using self: *RenderingServer, particles_collision: RID, mask: int) {
}
RenderingServer_particles_collision_set_sphere_radius :: (using self: *RenderingServer, particles_collision: RID, radius: float) {
}
RenderingServer_particles_collision_set_box_extents :: (using self: *RenderingServer, particles_collision: RID, extents: Vector3) {
}
RenderingServer_particles_collision_set_attractor_strength :: (using self: *RenderingServer, particles_collision: RID, strength: float) {
}
RenderingServer_particles_collision_set_attractor_directionality :: (using self: *RenderingServer, particles_collision: RID, amount: float) {
}
RenderingServer_particles_collision_set_attractor_attenuation :: (using self: *RenderingServer, particles_collision: RID, curve: float) {
}
RenderingServer_particles_collision_set_field_texture :: (using self: *RenderingServer, particles_collision: RID, texture: RID) {
}
RenderingServer_particles_collision_height_field_update :: (using self: *RenderingServer, particles_collision: RID) {
}
RenderingServer_particles_collision_set_height_field_resolution :: (using self: *RenderingServer, particles_collision: RID, resolution: RenderingServer.ParticlesCollisionHeightfieldResolution) {
}
RenderingServer_fog_volume_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_fog_volume_set_shape :: (using self: *RenderingServer, fog_volume: RID, shape: RenderingServer.FogVolumeShape) {
}
RenderingServer_fog_volume_set_size :: (using self: *RenderingServer, fog_volume: RID, size: Vector3) {
}
RenderingServer_fog_volume_set_material :: (using self: *RenderingServer, fog_volume: RID, material: RID) {
}
RenderingServer_visibility_notifier_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_visibility_notifier_set_aabb :: (using self: *RenderingServer, notifier: RID, aabb: AABB) {
}
RenderingServer_visibility_notifier_set_callbacks :: (using self: *RenderingServer, notifier: RID, enter_callable: Callable, exit_callable: Callable) {
}
RenderingServer_occluder_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_occluder_set_mesh :: (using self: *RenderingServer, occluder: RID, vertices: PackedVector3Array, indices: PackedInt32Array) {
}
RenderingServer_camera_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_camera_set_perspective :: (using self: *RenderingServer, camera: RID, fovy_degrees: float, z_near: float, z_far: float) {
}
RenderingServer_camera_set_orthogonal :: (using self: *RenderingServer, camera: RID, size: float, z_near: float, z_far: float) {
}
RenderingServer_camera_set_frustum :: (using self: *RenderingServer, camera: RID, size: float, offset: Vector2, z_near: float, z_far: float) {
}
RenderingServer_camera_set_transform :: (using self: *RenderingServer, camera: RID, transform: Transform3D) {
}
RenderingServer_camera_set_cull_mask :: (using self: *RenderingServer, camera: RID, layers: int) {
}
RenderingServer_camera_set_environment :: (using self: *RenderingServer, camera: RID, env: RID) {
}
RenderingServer_camera_set_camera_attributes :: (using self: *RenderingServer, camera: RID, effects: RID) {
}
RenderingServer_camera_set_compositor :: (using self: *RenderingServer, camera: RID, compositor: RID) {
}
RenderingServer_camera_set_use_vertical_aspect :: (using self: *RenderingServer, camera: RID, enable: bool) {
}
RenderingServer_viewport_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_viewport_set_use_xr :: (using self: *RenderingServer, viewport: RID, use_xr: bool) {
}
RenderingServer_viewport_set_size :: (using self: *RenderingServer, viewport: RID, width: int, height: int) {
}
RenderingServer_viewport_set_active :: (using self: *RenderingServer, viewport: RID, active: bool) {
}
RenderingServer_viewport_set_parent_viewport :: (using self: *RenderingServer, viewport: RID, parent_viewport: RID) {
}
RenderingServer_viewport_attach_to_screen :: (using self: *RenderingServer, viewport: RID, rect: Rect2, screen: int) {
}
RenderingServer_viewport_set_render_direct_to_screen :: (using self: *RenderingServer, viewport: RID, enabled: bool) {
}
RenderingServer_viewport_set_canvas_cull_mask :: (using self: *RenderingServer, viewport: RID, canvas_cull_mask: int) {
}
RenderingServer_viewport_set_scaling_3d_mode :: (using self: *RenderingServer, viewport: RID, scaling_3d_mode: RenderingServer.ViewportScaling3DMode) {
}
RenderingServer_viewport_set_scaling_3d_scale :: (using self: *RenderingServer, viewport: RID, scale: float) {
}
RenderingServer_viewport_set_fsr_sharpness :: (using self: *RenderingServer, viewport: RID, sharpness: float) {
}
RenderingServer_viewport_set_texture_mipmap_bias :: (using self: *RenderingServer, viewport: RID, mipmap_bias: float) {
}
RenderingServer_viewport_set_update_mode :: (using self: *RenderingServer, viewport: RID, update_mode: RenderingServer.ViewportUpdateMode) {
}
RenderingServer_viewport_get_update_mode :: (using self: *RenderingServer, viewport: RID) -> RenderingServer.ViewportUpdateMode {
}
RenderingServer_viewport_set_clear_mode :: (using self: *RenderingServer, viewport: RID, clear_mode: RenderingServer.ViewportClearMode) {
}
RenderingServer_viewport_get_render_target :: (using self: *RenderingServer, viewport: RID) -> RID {
}
RenderingServer_viewport_get_texture :: (using self: *RenderingServer, viewport: RID) -> RID {
}
RenderingServer_viewport_set_disable_3d :: (using self: *RenderingServer, viewport: RID, disable: bool) {
}
RenderingServer_viewport_set_disable_2d :: (using self: *RenderingServer, viewport: RID, disable: bool) {
}
RenderingServer_viewport_set_environment_mode :: (using self: *RenderingServer, viewport: RID, mode: RenderingServer.ViewportEnvironmentMode) {
}
RenderingServer_viewport_attach_camera :: (using self: *RenderingServer, viewport: RID, camera: RID) {
}
RenderingServer_viewport_set_scenario :: (using self: *RenderingServer, viewport: RID, scenario: RID) {
}
RenderingServer_viewport_attach_canvas :: (using self: *RenderingServer, viewport: RID, canvas: RID) {
}
RenderingServer_viewport_remove_canvas :: (using self: *RenderingServer, viewport: RID, canvas: RID) {
}
RenderingServer_viewport_set_snap_2d_transforms_to_pixel :: (using self: *RenderingServer, viewport: RID, enabled: bool) {
}
RenderingServer_viewport_set_snap_2d_vertices_to_pixel :: (using self: *RenderingServer, viewport: RID, enabled: bool) {
}
RenderingServer_viewport_set_default_canvas_item_texture_filter :: (using self: *RenderingServer, viewport: RID, filter: RenderingServer.CanvasItemTextureFilter) {
}
RenderingServer_viewport_set_default_canvas_item_texture_repeat :: (using self: *RenderingServer, viewport: RID, repeat: RenderingServer.CanvasItemTextureRepeat) {
}
RenderingServer_viewport_set_canvas_transform :: (using self: *RenderingServer, viewport: RID, canvas: RID, offset: Transform2D) {
}
RenderingServer_viewport_set_canvas_stacking :: (using self: *RenderingServer, viewport: RID, canvas: RID, layer: int, sublayer: int) {
}
RenderingServer_viewport_set_transparent_background :: (using self: *RenderingServer, viewport: RID, enabled: bool) {
}
RenderingServer_viewport_set_global_canvas_transform :: (using self: *RenderingServer, viewport: RID, transform: Transform2D) {
}
RenderingServer_viewport_set_sdf_oversize_and_scale :: (using self: *RenderingServer, viewport: RID, oversize: RenderingServer.ViewportSDFOversize, scale: RenderingServer.ViewportSDFScale) {
}
RenderingServer_viewport_set_positional_shadow_atlas_size :: (using self: *RenderingServer, viewport: RID, size: int, use_16_bits: bool) {
}
RenderingServer_viewport_set_positional_shadow_atlas_quadrant_subdivision :: (using self: *RenderingServer, viewport: RID, quadrant: int, subdivision: int) {
}
RenderingServer_viewport_set_msaa_3d :: (using self: *RenderingServer, viewport: RID, msaa: RenderingServer.ViewportMSAA) {
}
RenderingServer_viewport_set_msaa_2d :: (using self: *RenderingServer, viewport: RID, msaa: RenderingServer.ViewportMSAA) {
}
RenderingServer_viewport_set_use_hdr_2d :: (using self: *RenderingServer, viewport: RID, enabled: bool) {
}
RenderingServer_viewport_set_screen_space_aa :: (using self: *RenderingServer, viewport: RID, mode: RenderingServer.ViewportScreenSpaceAA) {
}
RenderingServer_viewport_set_use_taa :: (using self: *RenderingServer, viewport: RID, enable: bool) {
}
RenderingServer_viewport_set_use_debanding :: (using self: *RenderingServer, viewport: RID, enable: bool) {
}
RenderingServer_viewport_set_use_occlusion_culling :: (using self: *RenderingServer, viewport: RID, enable: bool) {
}
RenderingServer_viewport_set_occlusion_rays_per_thread :: (using self: *RenderingServer, rays_per_thread: int) {
}
RenderingServer_viewport_set_occlusion_culling_build_quality :: (using self: *RenderingServer, quality: RenderingServer.ViewportOcclusionCullingBuildQuality) {
}
RenderingServer_viewport_get_render_info :: (using self: *RenderingServer, viewport: RID, type: RenderingServer.ViewportRenderInfoType, info: RenderingServer.ViewportRenderInfo) -> int {
}
RenderingServer_viewport_set_debug_draw :: (using self: *RenderingServer, viewport: RID, draw: RenderingServer.ViewportDebugDraw) {
}
RenderingServer_viewport_set_measure_render_time :: (using self: *RenderingServer, viewport: RID, enable: bool) {
}
RenderingServer_viewport_get_measured_render_time_cpu :: (using self: *RenderingServer, viewport: RID) -> float {
}
RenderingServer_viewport_get_measured_render_time_gpu :: (using self: *RenderingServer, viewport: RID) -> float {
}
RenderingServer_viewport_set_vrs_mode :: (using self: *RenderingServer, viewport: RID, mode: RenderingServer.ViewportVRSMode) {
}
RenderingServer_viewport_set_vrs_update_mode :: (using self: *RenderingServer, viewport: RID, mode: RenderingServer.ViewportVRSUpdateMode) {
}
RenderingServer_viewport_set_vrs_texture :: (using self: *RenderingServer, viewport: RID, texture: RID) {
}
RenderingServer_sky_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_sky_set_radiance_size :: (using self: *RenderingServer, sky: RID, radiance_size: int) {
}
RenderingServer_sky_set_mode :: (using self: *RenderingServer, sky: RID, mode: RenderingServer.SkyMode) {
}
RenderingServer_sky_set_material :: (using self: *RenderingServer, sky: RID, material: RID) {
}
RenderingServer_sky_bake_panorama :: (using self: *RenderingServer, sky: RID, energy: float, bake_irradiance: bool, size: Vector2i) -> Image {
}
RenderingServer_compositor_effect_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_compositor_effect_set_enabled :: (using self: *RenderingServer, effect: RID, enabled: bool) {
}
RenderingServer_compositor_effect_set_callback :: (using self: *RenderingServer, effect: RID, callback_type: RenderingServer.CompositorEffectCallbackType, callback: Callable) {
}
RenderingServer_compositor_effect_set_flag :: (using self: *RenderingServer, effect: RID, flag: RenderingServer.CompositorEffectFlags, set: bool) {
}
RenderingServer_compositor_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_compositor_set_compositor_effects :: (using self: *RenderingServer, compositor: RID, effects: Array) {
}
RenderingServer_environment_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_environment_set_background :: (using self: *RenderingServer, env: RID, bg: RenderingServer.EnvironmentBG) {
}
RenderingServer_environment_set_sky :: (using self: *RenderingServer, env: RID, sky: RID) {
}
RenderingServer_environment_set_sky_custom_fov :: (using self: *RenderingServer, env: RID, scale: float) {
}
RenderingServer_environment_set_sky_orientation :: (using self: *RenderingServer, env: RID, orientation: Basis) {
}
RenderingServer_environment_set_bg_color :: (using self: *RenderingServer, env: RID, color: Color) {
}
RenderingServer_environment_set_bg_energy :: (using self: *RenderingServer, env: RID, multiplier: float, exposure_value: float) {
}
RenderingServer_environment_set_canvas_max_layer :: (using self: *RenderingServer, env: RID, max_layer: int) {
}
RenderingServer_environment_set_ambient_light :: (using self: *RenderingServer, env: RID, color: Color, ambient: RenderingServer.EnvironmentAmbientSource, energy: float, sky_contibution: float, reflection_source: RenderingServer.EnvironmentReflectionSource) {
}
RenderingServer_environment_set_glow :: (using self: *RenderingServer, env: RID, enable: bool, levels: PackedFloat32Array, intensity: float, strength: float, mix: float, bloom_threshold: float, blend_mode: RenderingServer.EnvironmentGlowBlendMode, hdr_bleed_threshold: float, hdr_bleed_scale: float, hdr_luminance_cap: float, glow_map_strength: float, glow_map: RID) {
}
RenderingServer_environment_set_tonemap :: (using self: *RenderingServer, env: RID, tone_mapper: RenderingServer.EnvironmentToneMapper, exposure: float, white: float) {
}
RenderingServer_environment_set_adjustment :: (using self: *RenderingServer, env: RID, enable: bool, brightness: float, contrast: float, saturation: float, use_1d_color_correction: bool, color_correction: RID) {
}
RenderingServer_environment_set_ssr :: (using self: *RenderingServer, env: RID, enable: bool, max_steps: int, fade_in: float, fade_out: float, depth_tolerance: float) {
}
RenderingServer_environment_set_ssao :: (using self: *RenderingServer, env: RID, enable: bool, radius: float, intensity: float, power: float, detail: float, horizon: float, sharpness: float, light_affect: float, ao_channel_affect: float) {
}
RenderingServer_environment_set_fog :: (using self: *RenderingServer, env: RID, enable: bool, light_color: Color, light_energy: float, sun_scatter: float, density: float, height: float, height_density: float, aerial_perspective: float, sky_affect: float, fog_mode: RenderingServer.EnvironmentFogMode) {
}
RenderingServer_environment_set_sdfgi :: (using self: *RenderingServer, env: RID, enable: bool, cascades: int, min_cell_size: float, y_scale: RenderingServer.EnvironmentSDFGIYScale, use_occlusion: bool, bounce_feedback: float, read_sky: bool, energy: float, normal_bias: float, probe_bias: float) {
}
RenderingServer_environment_set_volumetric_fog :: (using self: *RenderingServer, env: RID, enable: bool, density: float, albedo: Color, emission: Color, emission_energy: float, anisotropy: float, length: float, p_detail_spread: float, gi_inject: float, temporal_reprojection: bool, temporal_reprojection_amount: float, ambient_inject: float, sky_affect: float) {
}
RenderingServer_environment_glow_set_use_bicubic_upscale :: (using self: *RenderingServer, enable: bool) {
}
RenderingServer_environment_set_ssr_roughness_quality :: (using self: *RenderingServer, quality: RenderingServer.EnvironmentSSRRoughnessQuality) {
}
RenderingServer_environment_set_ssao_quality :: (using self: *RenderingServer, quality: RenderingServer.EnvironmentSSAOQuality, half_size: bool, adaptive_target: float, blur_passes: int, fadeout_from: float, fadeout_to: float) {
}
RenderingServer_environment_set_ssil_quality :: (using self: *RenderingServer, quality: RenderingServer.EnvironmentSSILQuality, half_size: bool, adaptive_target: float, blur_passes: int, fadeout_from: float, fadeout_to: float) {
}
RenderingServer_environment_set_sdfgi_ray_count :: (using self: *RenderingServer, ray_count: RenderingServer.EnvironmentSDFGIRayCount) {
}
RenderingServer_environment_set_sdfgi_frames_to_converge :: (using self: *RenderingServer, frames: RenderingServer.EnvironmentSDFGIFramesToConverge) {
}
RenderingServer_environment_set_sdfgi_frames_to_update_light :: (using self: *RenderingServer, frames: RenderingServer.EnvironmentSDFGIFramesToUpdateLight) {
}
RenderingServer_environment_set_volumetric_fog_volume_size :: (using self: *RenderingServer, size: int, depth: int) {
}
RenderingServer_environment_set_volumetric_fog_filter_active :: (using self: *RenderingServer, active: bool) {
}
RenderingServer_environment_bake_panorama :: (using self: *RenderingServer, environment: RID, bake_irradiance: bool, size: Vector2i) -> Image {
}
RenderingServer_screen_space_roughness_limiter_set_active :: (using self: *RenderingServer, enable: bool, amount: float, limit: float) {
}
RenderingServer_sub_surface_scattering_set_quality :: (using self: *RenderingServer, quality: RenderingServer.SubSurfaceScatteringQuality) {
}
RenderingServer_sub_surface_scattering_set_scale :: (using self: *RenderingServer, scale: float, depth_scale: float) {
}
RenderingServer_camera_attributes_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_camera_attributes_set_dof_blur_quality :: (using self: *RenderingServer, quality: RenderingServer.DOFBlurQuality, use_jitter: bool) {
}
RenderingServer_camera_attributes_set_dof_blur_bokeh_shape :: (using self: *RenderingServer, shape: RenderingServer.DOFBokehShape) {
}
RenderingServer_camera_attributes_set_dof_blur :: (using self: *RenderingServer, camera_attributes: RID, far_enable: bool, far_distance: float, far_transition: float, near_enable: bool, near_distance: float, near_transition: float, amount: float) {
}
RenderingServer_camera_attributes_set_exposure :: (using self: *RenderingServer, camera_attributes: RID, multiplier: float, normalization: float) {
}
RenderingServer_camera_attributes_set_auto_exposure :: (using self: *RenderingServer, camera_attributes: RID, enable: bool, min_sensitivity: float, max_sensitivity: float, speed: float, scale: float) {
}
RenderingServer_scenario_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_scenario_set_environment :: (using self: *RenderingServer, scenario: RID, environment: RID) {
}
RenderingServer_scenario_set_fallback_environment :: (using self: *RenderingServer, scenario: RID, environment: RID) {
}
RenderingServer_scenario_set_camera_attributes :: (using self: *RenderingServer, scenario: RID, effects: RID) {
}
RenderingServer_scenario_set_compositor :: (using self: *RenderingServer, scenario: RID, compositor: RID) {
}
RenderingServer_instance_create2 :: (using self: *RenderingServer, base: RID, scenario: RID) -> RID {
}
RenderingServer_instance_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_instance_set_base :: (using self: *RenderingServer, instance: RID, base: RID) {
}
RenderingServer_instance_set_scenario :: (using self: *RenderingServer, instance: RID, scenario: RID) {
}
RenderingServer_instance_set_layer_mask :: (using self: *RenderingServer, instance: RID, mask: int) {
}
RenderingServer_instance_set_pivot_data :: (using self: *RenderingServer, instance: RID, sorting_offset: float, use_aabb_center: bool) {
}
RenderingServer_instance_set_transform :: (using self: *RenderingServer, instance: RID, transform: Transform3D) {
}
RenderingServer_instance_attach_object_instance_id :: (using self: *RenderingServer, instance: RID, id: int) {
}
RenderingServer_instance_set_blend_shape_weight :: (using self: *RenderingServer, instance: RID, shape: int, weight: float) {
}
RenderingServer_instance_set_surface_override_material :: (using self: *RenderingServer, instance: RID, surface: int, material: RID) {
}
RenderingServer_instance_set_visible :: (using self: *RenderingServer, instance: RID, visible: bool) {
}
RenderingServer_instance_geometry_set_transparency :: (using self: *RenderingServer, instance: RID, transparency: float) {
}
RenderingServer_instance_set_custom_aabb :: (using self: *RenderingServer, instance: RID, aabb: AABB) {
}
RenderingServer_instance_attach_skeleton :: (using self: *RenderingServer, instance: RID, skeleton: RID) {
}
RenderingServer_instance_set_extra_visibility_margin :: (using self: *RenderingServer, instance: RID, margin: float) {
}
RenderingServer_instance_set_visibility_parent :: (using self: *RenderingServer, instance: RID, parent: RID) {
}
RenderingServer_instance_set_ignore_culling :: (using self: *RenderingServer, instance: RID, enabled: bool) {
}
RenderingServer_instance_geometry_set_flag :: (using self: *RenderingServer, instance: RID, flag: RenderingServer.InstanceFlags, enabled: bool) {
}
RenderingServer_instance_geometry_set_cast_shadows_setting :: (using self: *RenderingServer, instance: RID, shadow_casting_setting: RenderingServer.ShadowCastingSetting) {
}
RenderingServer_instance_geometry_set_material_override :: (using self: *RenderingServer, instance: RID, material: RID) {
}
RenderingServer_instance_geometry_set_material_overlay :: (using self: *RenderingServer, instance: RID, material: RID) {
}
RenderingServer_instance_geometry_set_visibility_range :: (using self: *RenderingServer, instance: RID, min: float, max: float, min_margin: float, max_margin: float, fade_mode: RenderingServer.VisibilityRangeFadeMode) {
}
RenderingServer_instance_geometry_set_lightmap :: (using self: *RenderingServer, instance: RID, lightmap: RID, lightmap_uv_scale: Rect2, lightmap_slice: int) {
}
RenderingServer_instance_geometry_set_lod_bias :: (using self: *RenderingServer, instance: RID, lod_bias: float) {
}
RenderingServer_instance_geometry_set_shader_parameter :: (using self: *RenderingServer, instance: RID, parameter: StringName, value: Variant) {
}
RenderingServer_instance_geometry_get_shader_parameter :: (using self: *RenderingServer, instance: RID, parameter: StringName) -> Variant {
}
RenderingServer_instance_geometry_get_shader_parameter_default_value :: (using self: *RenderingServer, instance: RID, parameter: StringName) -> Variant {
}
RenderingServer_instance_geometry_get_shader_parameter_list :: (using self: *RenderingServer, instance: RID) -> Dictionary {
}
RenderingServer_instances_cull_aabb :: (using self: *RenderingServer, aabb: AABB, scenario: RID) -> PackedInt64Array {
}
RenderingServer_instances_cull_ray :: (using self: *RenderingServer, from: Vector3, to: Vector3, scenario: RID) -> PackedInt64Array {
}
RenderingServer_instances_cull_convex :: (using self: *RenderingServer, convex: Array, scenario: RID) -> PackedInt64Array {
}
RenderingServer_bake_render_uv2 :: (using self: *RenderingServer, base: RID, material_overrides: Array, image_size: Vector2i) -> Array {
}
RenderingServer_canvas_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_canvas_set_item_mirroring :: (using self: *RenderingServer, canvas: RID, item: RID, mirroring: Vector2) {
}
RenderingServer_canvas_set_item_repeat :: (using self: *RenderingServer, item: RID, repeat_size: Vector2, repeat_times: int) {
}
RenderingServer_canvas_set_modulate :: (using self: *RenderingServer, canvas: RID, color: Color) {
}
RenderingServer_canvas_set_disable_scale :: (using self: *RenderingServer, disable: bool) {
}
RenderingServer_canvas_texture_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_canvas_texture_set_channel :: (using self: *RenderingServer, canvas_texture: RID, channel: RenderingServer.CanvasTextureChannel, texture: RID) {
}
RenderingServer_canvas_texture_set_shading_parameters :: (using self: *RenderingServer, canvas_texture: RID, base_color: Color, shininess: float) {
}
RenderingServer_canvas_texture_set_texture_filter :: (using self: *RenderingServer, canvas_texture: RID, filter: RenderingServer.CanvasItemTextureFilter) {
}
RenderingServer_canvas_texture_set_texture_repeat :: (using self: *RenderingServer, canvas_texture: RID, repeat: RenderingServer.CanvasItemTextureRepeat) {
}
RenderingServer_canvas_item_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_canvas_item_set_parent :: (using self: *RenderingServer, item: RID, parent: RID) {
}
RenderingServer_canvas_item_set_default_texture_filter :: (using self: *RenderingServer, item: RID, filter: RenderingServer.CanvasItemTextureFilter) {
}
RenderingServer_canvas_item_set_default_texture_repeat :: (using self: *RenderingServer, item: RID, repeat: RenderingServer.CanvasItemTextureRepeat) {
}
RenderingServer_canvas_item_set_visible :: (using self: *RenderingServer, item: RID, visible: bool) {
}
RenderingServer_canvas_item_set_light_mask :: (using self: *RenderingServer, item: RID, mask: int) {
}
RenderingServer_canvas_item_set_visibility_layer :: (using self: *RenderingServer, item: RID, visibility_layer: int) {
}
RenderingServer_canvas_item_set_transform :: (using self: *RenderingServer, item: RID, transform: Transform2D) {
}
RenderingServer_canvas_item_set_clip :: (using self: *RenderingServer, item: RID, clip: bool) {
}
RenderingServer_canvas_item_set_distance_field_mode :: (using self: *RenderingServer, item: RID, enabled: bool) {
}
RenderingServer_canvas_item_set_custom_rect :: (using self: *RenderingServer, item: RID, use_custom_rect: bool, rect: Rect2) {
}
RenderingServer_canvas_item_set_modulate :: (using self: *RenderingServer, item: RID, color: Color) {
}
RenderingServer_canvas_item_set_self_modulate :: (using self: *RenderingServer, item: RID, color: Color) {
}
RenderingServer_canvas_item_set_draw_behind_parent :: (using self: *RenderingServer, item: RID, enabled: bool) {
}
RenderingServer_canvas_item_set_interpolated :: (using self: *RenderingServer, item: RID, interpolated: bool) {
}
RenderingServer_canvas_item_reset_physics_interpolation :: (using self: *RenderingServer, item: RID) {
}
RenderingServer_canvas_item_transform_physics_interpolation :: (using self: *RenderingServer, item: RID, transform: Transform2D) {
}
RenderingServer_canvas_item_add_line :: (using self: *RenderingServer, item: RID, from: Vector2, to: Vector2, color: Color, width: float, antialiased: bool) {
}
RenderingServer_canvas_item_add_polyline :: (using self: *RenderingServer, item: RID, points: PackedVector2Array, colors: PackedColorArray, width: float, antialiased: bool) {
}
RenderingServer_canvas_item_add_multiline :: (using self: *RenderingServer, item: RID, points: PackedVector2Array, colors: PackedColorArray, width: float, antialiased: bool) {
}
RenderingServer_canvas_item_add_rect :: (using self: *RenderingServer, item: RID, rect: Rect2, color: Color, antialiased: bool) {
}
RenderingServer_canvas_item_add_circle :: (using self: *RenderingServer, item: RID, pos: Vector2, radius: float, color: Color, antialiased: bool) {
}
RenderingServer_canvas_item_add_texture_rect :: (using self: *RenderingServer, item: RID, rect: Rect2, texture: RID, tile: bool, modulate: Color, transpose: bool) {
}
RenderingServer_canvas_item_add_msdf_texture_rect_region :: (using self: *RenderingServer, item: RID, rect: Rect2, texture: RID, src_rect: Rect2, modulate: Color, outline_size: int, px_range: float, scale: float) {
}
RenderingServer_canvas_item_add_lcd_texture_rect_region :: (using self: *RenderingServer, item: RID, rect: Rect2, texture: RID, src_rect: Rect2, modulate: Color) {
}
RenderingServer_canvas_item_add_texture_rect_region :: (using self: *RenderingServer, item: RID, rect: Rect2, texture: RID, src_rect: Rect2, modulate: Color, transpose: bool, clip_uv: bool) {
}
RenderingServer_canvas_item_add_nine_patch :: (using self: *RenderingServer, item: RID, rect: Rect2, source: Rect2, texture: RID, topleft: Vector2, bottomright: Vector2, x_axis_mode: RenderingServer.NinePatchAxisMode, y_axis_mode: RenderingServer.NinePatchAxisMode, draw_center: bool, modulate: Color) {
}
RenderingServer_canvas_item_add_primitive :: (using self: *RenderingServer, item: RID, points: PackedVector2Array, colors: PackedColorArray, uvs: PackedVector2Array, texture: RID) {
}
RenderingServer_canvas_item_add_polygon :: (using self: *RenderingServer, item: RID, points: PackedVector2Array, colors: PackedColorArray, uvs: PackedVector2Array, texture: RID) {
}
RenderingServer_canvas_item_add_triangle_array :: (using self: *RenderingServer, item: RID, indices: PackedInt32Array, points: PackedVector2Array, colors: PackedColorArray, uvs: PackedVector2Array, bones: PackedInt32Array, weights: PackedFloat32Array, texture: RID, count: int) {
}
RenderingServer_canvas_item_add_mesh :: (using self: *RenderingServer, item: RID, mesh: RID, transform: Transform2D, modulate: Color, texture: RID) {
}
RenderingServer_canvas_item_add_multimesh :: (using self: *RenderingServer, item: RID, mesh: RID, texture: RID) {
}
RenderingServer_canvas_item_add_particles :: (using self: *RenderingServer, item: RID, particles: RID, texture: RID) {
}
RenderingServer_canvas_item_add_set_transform :: (using self: *RenderingServer, item: RID, transform: Transform2D) {
}
RenderingServer_canvas_item_add_clip_ignore :: (using self: *RenderingServer, item: RID, ignore: bool) {
}
RenderingServer_canvas_item_add_animation_slice :: (using self: *RenderingServer, item: RID, animation_length: float, slice_begin: float, slice_end: float, offset: float) {
}
RenderingServer_canvas_item_set_sort_children_by_y :: (using self: *RenderingServer, item: RID, enabled: bool) {
}
RenderingServer_canvas_item_set_z_index :: (using self: *RenderingServer, item: RID, z_index: int) {
}
RenderingServer_canvas_item_set_z_as_relative_to_parent :: (using self: *RenderingServer, item: RID, enabled: bool) {
}
RenderingServer_canvas_item_set_copy_to_backbuffer :: (using self: *RenderingServer, item: RID, enabled: bool, rect: Rect2) {
}
RenderingServer_canvas_item_clear :: (using self: *RenderingServer, item: RID) {
}
RenderingServer_canvas_item_set_draw_index :: (using self: *RenderingServer, item: RID, index: int) {
}
RenderingServer_canvas_item_set_material :: (using self: *RenderingServer, item: RID, material: RID) {
}
RenderingServer_canvas_item_set_use_parent_material :: (using self: *RenderingServer, item: RID, enabled: bool) {
}
RenderingServer_canvas_item_set_visibility_notifier :: (using self: *RenderingServer, item: RID, enable: bool, area: Rect2, enter_callable: Callable, exit_callable: Callable) {
}
RenderingServer_canvas_item_set_canvas_group_mode :: (using self: *RenderingServer, item: RID, mode: RenderingServer.CanvasGroupMode, clear_margin: float, fit_empty: bool, fit_margin: float, blur_mipmaps: bool) {
}
RenderingServer_debug_canvas_item_get_rect :: (using self: *RenderingServer, item: RID) -> Rect2 {
}
RenderingServer_canvas_light_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_canvas_light_attach_to_canvas :: (using self: *RenderingServer, light: RID, canvas: RID) {
}
RenderingServer_canvas_light_set_enabled :: (using self: *RenderingServer, light: RID, enabled: bool) {
}
RenderingServer_canvas_light_set_texture_scale :: (using self: *RenderingServer, light: RID, scale: float) {
}
RenderingServer_canvas_light_set_transform :: (using self: *RenderingServer, light: RID, transform: Transform2D) {
}
RenderingServer_canvas_light_set_texture :: (using self: *RenderingServer, light: RID, texture: RID) {
}
RenderingServer_canvas_light_set_texture_offset :: (using self: *RenderingServer, light: RID, offset: Vector2) {
}
RenderingServer_canvas_light_set_color :: (using self: *RenderingServer, light: RID, color: Color) {
}
RenderingServer_canvas_light_set_height :: (using self: *RenderingServer, light: RID, height: float) {
}
RenderingServer_canvas_light_set_energy :: (using self: *RenderingServer, light: RID, energy: float) {
}
RenderingServer_canvas_light_set_z_range :: (using self: *RenderingServer, light: RID, min_z: int, max_z: int) {
}
RenderingServer_canvas_light_set_layer_range :: (using self: *RenderingServer, light: RID, min_layer: int, max_layer: int) {
}
RenderingServer_canvas_light_set_item_cull_mask :: (using self: *RenderingServer, light: RID, mask: int) {
}
RenderingServer_canvas_light_set_item_shadow_cull_mask :: (using self: *RenderingServer, light: RID, mask: int) {
}
RenderingServer_canvas_light_set_mode :: (using self: *RenderingServer, light: RID, mode: RenderingServer.CanvasLightMode) {
}
RenderingServer_canvas_light_set_shadow_enabled :: (using self: *RenderingServer, light: RID, enabled: bool) {
}
RenderingServer_canvas_light_set_shadow_filter :: (using self: *RenderingServer, light: RID, filter: RenderingServer.CanvasLightShadowFilter) {
}
RenderingServer_canvas_light_set_shadow_color :: (using self: *RenderingServer, light: RID, color: Color) {
}
RenderingServer_canvas_light_set_shadow_smooth :: (using self: *RenderingServer, light: RID, smooth: float) {
}
RenderingServer_canvas_light_set_blend_mode :: (using self: *RenderingServer, light: RID, mode: RenderingServer.CanvasLightBlendMode) {
}
RenderingServer_canvas_light_set_interpolated :: (using self: *RenderingServer, light: RID, interpolated: bool) {
}
RenderingServer_canvas_light_reset_physics_interpolation :: (using self: *RenderingServer, light: RID) {
}
RenderingServer_canvas_light_transform_physics_interpolation :: (using self: *RenderingServer, light: RID, transform: Transform2D) {
}
RenderingServer_canvas_light_occluder_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_canvas_light_occluder_attach_to_canvas :: (using self: *RenderingServer, occluder: RID, canvas: RID) {
}
RenderingServer_canvas_light_occluder_set_enabled :: (using self: *RenderingServer, occluder: RID, enabled: bool) {
}
RenderingServer_canvas_light_occluder_set_polygon :: (using self: *RenderingServer, occluder: RID, polygon: RID) {
}
RenderingServer_canvas_light_occluder_set_as_sdf_collision :: (using self: *RenderingServer, occluder: RID, enable: bool) {
}
RenderingServer_canvas_light_occluder_set_transform :: (using self: *RenderingServer, occluder: RID, transform: Transform2D) {
}
RenderingServer_canvas_light_occluder_set_light_mask :: (using self: *RenderingServer, occluder: RID, mask: int) {
}
RenderingServer_canvas_light_occluder_set_interpolated :: (using self: *RenderingServer, occluder: RID, interpolated: bool) {
}
RenderingServer_canvas_light_occluder_reset_physics_interpolation :: (using self: *RenderingServer, occluder: RID) {
}
RenderingServer_canvas_light_occluder_transform_physics_interpolation :: (using self: *RenderingServer, occluder: RID, transform: Transform2D) {
}
RenderingServer_canvas_occluder_polygon_create :: (using self: *RenderingServer) -> RID {
}
RenderingServer_canvas_occluder_polygon_set_shape :: (using self: *RenderingServer, occluder_polygon: RID, shape: PackedVector2Array, closed: bool) {
}
RenderingServer_canvas_occluder_polygon_set_cull_mode :: (using self: *RenderingServer, occluder_polygon: RID, mode: RenderingServer.CanvasOccluderPolygonCullMode) {
}
RenderingServer_canvas_set_shadow_texture_size :: (using self: *RenderingServer, size: int) {
}
RenderingServer_global_shader_parameter_add :: (using self: *RenderingServer, name: StringName, type: RenderingServer.GlobalShaderParameterType, default_value: Variant) {
}
RenderingServer_global_shader_parameter_remove :: (using self: *RenderingServer, name: StringName) {
}
RenderingServer_global_shader_parameter_get_list :: (using self: *RenderingServer) -> Array {
}
RenderingServer_global_shader_parameter_set :: (using self: *RenderingServer, name: StringName, value: Variant) {
}
RenderingServer_global_shader_parameter_set_override :: (using self: *RenderingServer, name: StringName, value: Variant) {
}
RenderingServer_global_shader_parameter_get :: (using self: *RenderingServer, name: StringName) -> Variant {
}
RenderingServer_global_shader_parameter_get_type :: (using self: *RenderingServer, name: StringName) -> RenderingServer.GlobalShaderParameterType {
}
RenderingServer_free_rid :: (using self: *RenderingServer, rid: RID) {
}
RenderingServer_request_frame_drawn_callback :: (using self: *RenderingServer, callable: Callable) {
}
RenderingServer_has_changed :: (using self: *RenderingServer) -> bool {
}
RenderingServer_get_rendering_info :: (using self: *RenderingServer, info: RenderingServer.RenderingInfo) -> int {
}
RenderingServer_get_video_adapter_name :: (using self: *RenderingServer) -> String {
}
RenderingServer_get_video_adapter_vendor :: (using self: *RenderingServer) -> String {
}
RenderingServer_get_video_adapter_type :: (using self: *RenderingServer) -> RenderingDevice.DeviceType {
}
RenderingServer_get_video_adapter_api_version :: (using self: *RenderingServer) -> String {
}
RenderingServer_make_sphere_mesh :: (using self: *RenderingServer, latitudes: int, longitudes: int, radius: float) -> RID {
}
RenderingServer_get_test_cube :: (using self: *RenderingServer) -> RID {
}
RenderingServer_get_test_texture :: (using self: *RenderingServer) -> RID {
}
RenderingServer_get_white_texture :: (using self: *RenderingServer) -> RID {
}
RenderingServer_set_boot_image :: (using self: *RenderingServer, image: Image, color: Color, scale: bool, use_filter: bool) {
}
RenderingServer_get_default_clear_color :: (using self: *RenderingServer) -> Color {
}
RenderingServer_set_default_clear_color :: (using self: *RenderingServer, color: Color) {
}
RenderingServer_has_os_feature :: (using self: *RenderingServer, feature: String) -> bool {
}
RenderingServer_set_debug_generate_wireframes :: (using self: *RenderingServer, generate: bool) {
}
RenderingServer_is_render_loop_enabled :: (using self: *RenderingServer) -> bool {
}
RenderingServer_set_render_loop_enabled :: (using self: *RenderingServer, enabled: bool) {
}
RenderingServer_get_frame_setup_time_cpu :: (using self: *RenderingServer) -> float {
}
RenderingServer_force_sync :: (using self: *RenderingServer) {
}
RenderingServer_force_draw :: (using self: *RenderingServer, swap_buffers: bool, frame_step: float) {
}
RenderingServer_get_rendering_device :: (using self: *RenderingServer) -> RenderingDevice {
}
RenderingServer_create_local_rendering_device :: (using self: *RenderingServer) -> RenderingDevice {
}
RenderingServer_is_on_render_thread :: (using self: *RenderingServer) -> bool {
}
RenderingServer_call_on_render_thread :: (using self: *RenderingServer, callable: Callable) {
}
RenderingServer_has_feature :: (using self: *RenderingServer, feature: RenderingServer.Features) -> bool {
}

// Resource
Resource :: struct {
	__private: *void;
}

Resource__setup_local_to_scene :: (using self: *Resource) {
}
Resource_set_path :: (using self: *Resource, path: String) {
}
Resource_take_over_path :: (using self: *Resource, path: String) {
}
Resource_get_path :: (using self: *Resource) -> String {
}
Resource_set_name :: (using self: *Resource, name: String) {
}
Resource_get_name :: (using self: *Resource) -> String {
}
Resource_get_rid :: (using self: *Resource) -> RID {
}
Resource_set_local_to_scene :: (using self: *Resource, enable: bool) {
}
Resource_is_local_to_scene :: (using self: *Resource) -> bool {
}
Resource_get_local_scene :: (using self: *Resource) -> Node {
}
Resource_setup_local_to_scene :: (using self: *Resource) {
}
Resource_generate_scene_unique_id :: (using self: *Resource) -> String {
}
Resource_set_scene_unique_id :: (using self: *Resource, id: String) {
}
Resource_get_scene_unique_id :: (using self: *Resource) -> String {
}
Resource_emit_changed :: (using self: *Resource) {
}
Resource_duplicate :: (using self: *Resource, subresources: bool) -> Resource {
}

// ResourceFormatLoader
ResourceFormatLoader :: struct {
	__private: *void;

	CacheMode :: enum {
		CACHE_MODE_IGNORE :: 0;
		CACHE_MODE_REUSE :: 1;
		CACHE_MODE_REPLACE :: 2;
		CACHE_MODE_IGNORE_DEEP :: 3;
		CACHE_MODE_REPLACE_DEEP :: 4;
	}
}

ResourceFormatLoader__get_recognized_extensions :: (using self: *ResourceFormatLoader) -> PackedStringArray {
}
ResourceFormatLoader__recognize_path :: (using self: *ResourceFormatLoader, path: String, type: StringName) -> bool {
}
ResourceFormatLoader__handles_type :: (using self: *ResourceFormatLoader, type: StringName) -> bool {
}
ResourceFormatLoader__get_resource_type :: (using self: *ResourceFormatLoader, path: String) -> String {
}
ResourceFormatLoader__get_resource_script_class :: (using self: *ResourceFormatLoader, path: String) -> String {
}
ResourceFormatLoader__get_resource_uid :: (using self: *ResourceFormatLoader, path: String) -> int {
}
ResourceFormatLoader__get_dependencies :: (using self: *ResourceFormatLoader, path: String, add_types: bool) -> PackedStringArray {
}
ResourceFormatLoader__rename_dependencies :: (using self: *ResourceFormatLoader, path: String, renames: Dictionary) -> Error {
}
ResourceFormatLoader__exists :: (using self: *ResourceFormatLoader, path: String) -> bool {
}
ResourceFormatLoader__get_classes_used :: (using self: *ResourceFormatLoader, path: String) -> PackedStringArray {
}
ResourceFormatLoader__load :: (using self: *ResourceFormatLoader, path: String, original_path: String, use_sub_threads: bool, cache_mode: int) -> Variant {
}

// ResourceFormatSaver
ResourceFormatSaver :: struct {
	__private: *void;
}

ResourceFormatSaver__save :: (using self: *ResourceFormatSaver, resource: Resource, path: String, flags: int) -> Error {
}
ResourceFormatSaver__set_uid :: (using self: *ResourceFormatSaver, path: String, uid: int) -> Error {
}
ResourceFormatSaver__recognize :: (using self: *ResourceFormatSaver, resource: Resource) -> bool {
}
ResourceFormatSaver__get_recognized_extensions :: (using self: *ResourceFormatSaver, resource: Resource) -> PackedStringArray {
}
ResourceFormatSaver__recognize_path :: (using self: *ResourceFormatSaver, resource: Resource, path: String) -> bool {
}

// ResourceImporter
ResourceImporter :: struct {
	__private: *void;

	ImportOrder :: enum {
		IMPORT_ORDER_DEFAULT :: 0;
		IMPORT_ORDER_SCENE :: 100;
	}
}

// ResourceImporterBMFont
ResourceImporterBMFont :: struct {
	__private: *void;
}

// ResourceImporterBitMap
ResourceImporterBitMap :: struct {
	__private: *void;
}

// ResourceImporterCSVTranslation
ResourceImporterCSVTranslation :: struct {
	__private: *void;
}

// ResourceImporterDynamicFont
ResourceImporterDynamicFont :: struct {
	__private: *void;
}

// ResourceImporterImage
ResourceImporterImage :: struct {
	__private: *void;
}

// ResourceImporterImageFont
ResourceImporterImageFont :: struct {
	__private: *void;
}

// ResourceImporterLayeredTexture
ResourceImporterLayeredTexture :: struct {
	__private: *void;
}

// ResourceImporterMP3
ResourceImporterMP3 :: struct {
	__private: *void;
}

// ResourceImporterOBJ
ResourceImporterOBJ :: struct {
	__private: *void;
}

// ResourceImporterOggVorbis
ResourceImporterOggVorbis :: struct {
	__private: *void;
}

ResourceImporterOggVorbis_load_from_buffer :: (using self: *ResourceImporterOggVorbis, buffer: PackedByteArray) -> AudioStreamOggVorbis {
}
ResourceImporterOggVorbis_load_from_file :: (using self: *ResourceImporterOggVorbis, path: String) -> AudioStreamOggVorbis {
}

// ResourceImporterScene
ResourceImporterScene :: struct {
	__private: *void;
}

// ResourceImporterShaderFile
ResourceImporterShaderFile :: struct {
	__private: *void;
}

// ResourceImporterTexture
ResourceImporterTexture :: struct {
	__private: *void;
}

// ResourceImporterTextureAtlas
ResourceImporterTextureAtlas :: struct {
	__private: *void;
}

// ResourceImporterWAV
ResourceImporterWAV :: struct {
	__private: *void;
}

// ResourceLoader
ResourceLoader :: struct {
	__private: *void;

	ThreadLoadStatus :: enum {
		THREAD_LOAD_INVALID_RESOURCE :: 0;
		THREAD_LOAD_IN_PROGRESS :: 1;
		THREAD_LOAD_FAILED :: 2;
		THREAD_LOAD_LOADED :: 3;
	}
	CacheMode :: enum {
		CACHE_MODE_IGNORE :: 0;
		CACHE_MODE_REUSE :: 1;
		CACHE_MODE_REPLACE :: 2;
		CACHE_MODE_IGNORE_DEEP :: 3;
		CACHE_MODE_REPLACE_DEEP :: 4;
	}
}

ResourceLoader_load_threaded_request :: (using self: *ResourceLoader, path: String, type_hint: String, use_sub_threads: bool, cache_mode: ResourceLoader.CacheMode) -> Error {
}
ResourceLoader_load_threaded_get_status :: (using self: *ResourceLoader, path: String, progress: Array) -> ResourceLoader.ThreadLoadStatus {
}
ResourceLoader_load_threaded_get :: (using self: *ResourceLoader, path: String) -> Resource {
}
ResourceLoader_load :: (using self: *ResourceLoader, path: String, type_hint: String, cache_mode: ResourceLoader.CacheMode) -> Resource {
}
ResourceLoader_get_recognized_extensions_for_type :: (using self: *ResourceLoader, type: String) -> PackedStringArray {
}
ResourceLoader_add_resource_format_loader :: (using self: *ResourceLoader, format_loader: ResourceFormatLoader, at_front: bool) {
}
ResourceLoader_remove_resource_format_loader :: (using self: *ResourceLoader, format_loader: ResourceFormatLoader) {
}
ResourceLoader_set_abort_on_missing_resources :: (using self: *ResourceLoader, abort: bool) {
}
ResourceLoader_get_dependencies :: (using self: *ResourceLoader, path: String) -> PackedStringArray {
}
ResourceLoader_has_cached :: (using self: *ResourceLoader, path: String) -> bool {
}
ResourceLoader_exists :: (using self: *ResourceLoader, path: String, type_hint: String) -> bool {
}
ResourceLoader_get_resource_uid :: (using self: *ResourceLoader, path: String) -> int {
}

// ResourcePreloader
ResourcePreloader :: struct {
	__private: *void;
}

ResourcePreloader_add_resource :: (using self: *ResourcePreloader, name: StringName, resource: Resource) {
}
ResourcePreloader_remove_resource :: (using self: *ResourcePreloader, name: StringName) {
}
ResourcePreloader_rename_resource :: (using self: *ResourcePreloader, name: StringName, newname: StringName) {
}
ResourcePreloader_has_resource :: (using self: *ResourcePreloader, name: StringName) -> bool {
}
ResourcePreloader_get_resource :: (using self: *ResourcePreloader, name: StringName) -> Resource {
}
ResourcePreloader_get_resource_list :: (using self: *ResourcePreloader) -> PackedStringArray {
}

// ResourceSaver
ResourceSaver :: struct {
	__private: *void;

	SaverFlags :: enum_flags {
		FLAG_NONE :: 0;
		FLAG_RELATIVE_PATHS :: 1;
		FLAG_BUNDLE_RESOURCES :: 2;
		FLAG_CHANGE_PATH :: 4;
		FLAG_OMIT_EDITOR_PROPERTIES :: 8;
		FLAG_SAVE_BIG_ENDIAN :: 16;
		FLAG_COMPRESS :: 32;
		FLAG_REPLACE_SUBRESOURCE_PATHS :: 64;
	}
}

ResourceSaver_save :: (using self: *ResourceSaver, resource: Resource, path: String, flags: ResourceSaver.SaverFlags) -> Error {
}
ResourceSaver_get_recognized_extensions :: (using self: *ResourceSaver, type: Resource) -> PackedStringArray {
}
ResourceSaver_add_resource_format_saver :: (using self: *ResourceSaver, format_saver: ResourceFormatSaver, at_front: bool) {
}
ResourceSaver_remove_resource_format_saver :: (using self: *ResourceSaver, format_saver: ResourceFormatSaver) {
}

// ResourceUID
ResourceUID :: struct {
	__private: *void;

	INVALID_ID :: -1;
}

ResourceUID_id_to_text :: (using self: *ResourceUID, id: int) -> String {
}
ResourceUID_text_to_id :: (using self: *ResourceUID, text_id: String) -> int {
}
ResourceUID_create_id :: (using self: *ResourceUID) -> int {
}
ResourceUID_has_id :: (using self: *ResourceUID, id: int) -> bool {
}
ResourceUID_add_id :: (using self: *ResourceUID, id: int, path: String) {
}
ResourceUID_set_id :: (using self: *ResourceUID, id: int, path: String) {
}
ResourceUID_get_id_path :: (using self: *ResourceUID, id: int) -> String {
}
ResourceUID_remove_id :: (using self: *ResourceUID, id: int) {
}

// RibbonTrailMesh
RibbonTrailMesh :: struct {
	__private: *void;

	Shape :: enum {
		SHAPE_FLAT :: 0;
		SHAPE_CROSS :: 1;
	}
}

RibbonTrailMesh_set_size :: (using self: *RibbonTrailMesh, size: float) {
}
RibbonTrailMesh_get_size :: (using self: *RibbonTrailMesh) -> float {
}
RibbonTrailMesh_set_sections :: (using self: *RibbonTrailMesh, sections: int) {
}
RibbonTrailMesh_get_sections :: (using self: *RibbonTrailMesh) -> int {
}
RibbonTrailMesh_set_section_length :: (using self: *RibbonTrailMesh, section_length: float) {
}
RibbonTrailMesh_get_section_length :: (using self: *RibbonTrailMesh) -> float {
}
RibbonTrailMesh_set_section_segments :: (using self: *RibbonTrailMesh, section_segments: int) {
}
RibbonTrailMesh_get_section_segments :: (using self: *RibbonTrailMesh) -> int {
}
RibbonTrailMesh_set_curve :: (using self: *RibbonTrailMesh, curve: Curve) {
}
RibbonTrailMesh_get_curve :: (using self: *RibbonTrailMesh) -> Curve {
}
RibbonTrailMesh_set_shape :: (using self: *RibbonTrailMesh, shape: RibbonTrailMesh.Shape) {
}
RibbonTrailMesh_get_shape :: (using self: *RibbonTrailMesh) -> RibbonTrailMesh.Shape {
}

// RichTextEffect
RichTextEffect :: struct {
	__private: *void;
}

RichTextEffect__process_custom_fx :: (using self: *RichTextEffect, char_fx: CharFXTransform) -> bool {
}

// RichTextLabel
RichTextLabel :: struct {
	__private: *void;

	ListType :: enum {
		LIST_NUMBERS :: 0;
		LIST_LETTERS :: 1;
		LIST_ROMAN :: 2;
		LIST_DOTS :: 3;
	}
	MenuItems :: enum {
		MENU_COPY :: 0;
		MENU_SELECT_ALL :: 1;
		MENU_MAX :: 2;
	}
	MetaUnderline :: enum {
		META_UNDERLINE_NEVER :: 0;
		META_UNDERLINE_ALWAYS :: 1;
		META_UNDERLINE_ON_HOVER :: 2;
	}
	ImageUpdateMask :: enum_flags {
		UPDATE_TEXTURE :: 1;
		UPDATE_SIZE :: 2;
		UPDATE_COLOR :: 4;
		UPDATE_ALIGNMENT :: 8;
		UPDATE_REGION :: 16;
		UPDATE_PAD :: 32;
		UPDATE_TOOLTIP :: 64;
		UPDATE_WIDTH_IN_PERCENT :: 128;
	}
}

RichTextLabel_get_parsed_text :: (using self: *RichTextLabel) -> String {
}
RichTextLabel_add_text :: (using self: *RichTextLabel, text: String) {
}
RichTextLabel_set_text :: (using self: *RichTextLabel, text: String) {
}
RichTextLabel_add_image :: (using self: *RichTextLabel, image: Texture2D, width: int, height: int, color: Color, inline_align: InlineAlignment, region: Rect2, key: Variant, pad: bool, tooltip: String, size_in_percent: bool) {
}
RichTextLabel_update_image :: (using self: *RichTextLabel, key: Variant, mask: RichTextLabel.ImageUpdateMask, image: Texture2D, width: int, height: int, color: Color, inline_align: InlineAlignment, region: Rect2, pad: bool, tooltip: String, size_in_percent: bool) {
}
RichTextLabel_newline :: (using self: *RichTextLabel) {
}
RichTextLabel_remove_paragraph :: (using self: *RichTextLabel, paragraph: int, no_invalidate: bool) -> bool {
}
RichTextLabel_invalidate_paragraph :: (using self: *RichTextLabel, paragraph: int) -> bool {
}
RichTextLabel_push_font :: (using self: *RichTextLabel, font: Font, font_size: int) {
}
RichTextLabel_push_font_size :: (using self: *RichTextLabel, font_size: int) {
}
RichTextLabel_push_normal :: (using self: *RichTextLabel) {
}
RichTextLabel_push_bold :: (using self: *RichTextLabel) {
}
RichTextLabel_push_bold_italics :: (using self: *RichTextLabel) {
}
RichTextLabel_push_italics :: (using self: *RichTextLabel) {
}
RichTextLabel_push_mono :: (using self: *RichTextLabel) {
}
RichTextLabel_push_color :: (using self: *RichTextLabel, color: Color) {
}
RichTextLabel_push_outline_size :: (using self: *RichTextLabel, outline_size: int) {
}
RichTextLabel_push_outline_color :: (using self: *RichTextLabel, color: Color) {
}
RichTextLabel_push_paragraph :: (using self: *RichTextLabel, alignment: HorizontalAlignment, base_direction: Control.TextDirection, language: String, st_parser: TextServer.StructuredTextParser, justification_flags: TextServer.JustificationFlag, tab_stops: PackedFloat32Array) {
}
RichTextLabel_push_indent :: (using self: *RichTextLabel, level: int) {
}
RichTextLabel_push_list :: (using self: *RichTextLabel, level: int, type: RichTextLabel.ListType, capitalize: bool, bullet: String) {
}
RichTextLabel_push_meta :: (using self: *RichTextLabel, data: Variant, underline_mode: RichTextLabel.MetaUnderline) {
}
RichTextLabel_push_hint :: (using self: *RichTextLabel, description: String) {
}
RichTextLabel_push_language :: (using self: *RichTextLabel, language: String) {
}
RichTextLabel_push_underline :: (using self: *RichTextLabel) {
}
RichTextLabel_push_strikethrough :: (using self: *RichTextLabel) {
}
RichTextLabel_push_table :: (using self: *RichTextLabel, columns: int, inline_align: InlineAlignment, align_to_row: int) {
}
RichTextLabel_push_dropcap :: (using self: *RichTextLabel, _string: String, font: Font, size: int, dropcap_margins: Rect2, color: Color, outline_size: int, outline_color: Color) {
}
RichTextLabel_set_table_column_expand :: (using self: *RichTextLabel, column: int, expand: bool, ratio: int) {
}
RichTextLabel_set_cell_row_background_color :: (using self: *RichTextLabel, odd_row_bg: Color, even_row_bg: Color) {
}
RichTextLabel_set_cell_border_color :: (using self: *RichTextLabel, color: Color) {
}
RichTextLabel_set_cell_size_override :: (using self: *RichTextLabel, min_size: Vector2, max_size: Vector2) {
}
RichTextLabel_set_cell_padding :: (using self: *RichTextLabel, padding: Rect2) {
}
RichTextLabel_push_cell :: (using self: *RichTextLabel) {
}
RichTextLabel_push_fgcolor :: (using self: *RichTextLabel, fgcolor: Color) {
}
RichTextLabel_push_bgcolor :: (using self: *RichTextLabel, bgcolor: Color) {
}
RichTextLabel_push_customfx :: (using self: *RichTextLabel, effect: RichTextEffect, env: Dictionary) {
}
RichTextLabel__push_context :: (using self: *RichTextLabel) {
}
RichTextLabel_pop_context :: (using self: *RichTextLabel) {
}
RichTextLabel_pop :: (using self: *RichTextLabel) {
}
RichTextLabel_pop_all :: (using self: *RichTextLabel) {
}
RichTextLabel_clear :: (using self: *RichTextLabel) {
}
RichTextLabel_set_structured_text_bidi_override :: (using self: *RichTextLabel, parser: TextServer.StructuredTextParser) {
}
RichTextLabel_get_structured_text_bidi_override :: (using self: *RichTextLabel) -> TextServer.StructuredTextParser {
}
RichTextLabel_set_structured_text_bidi_override_options :: (using self: *RichTextLabel, args: Array) {
}
RichTextLabel_get_structured_text_bidi_override_options :: (using self: *RichTextLabel) -> Array {
}
RichTextLabel_set_text_direction :: (using self: *RichTextLabel, direction: Control.TextDirection) {
}
RichTextLabel_get_text_direction :: (using self: *RichTextLabel) -> Control.TextDirection {
}
RichTextLabel_set_language :: (using self: *RichTextLabel, language: String) {
}
RichTextLabel_get_language :: (using self: *RichTextLabel) -> String {
}
RichTextLabel_set_autowrap_mode :: (using self: *RichTextLabel, autowrap_mode: TextServer.AutowrapMode) {
}
RichTextLabel_get_autowrap_mode :: (using self: *RichTextLabel) -> TextServer.AutowrapMode {
}
RichTextLabel_set_meta_underline :: (using self: *RichTextLabel, enable: bool) {
}
RichTextLabel_is_meta_underlined :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_set_hint_underline :: (using self: *RichTextLabel, enable: bool) {
}
RichTextLabel_is_hint_underlined :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_set_scroll_active :: (using self: *RichTextLabel, active: bool) {
}
RichTextLabel_is_scroll_active :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_set_scroll_follow :: (using self: *RichTextLabel, follow: bool) {
}
RichTextLabel_is_scroll_following :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_get_v_scroll_bar :: (using self: *RichTextLabel) -> VScrollBar {
}
RichTextLabel_scroll_to_line :: (using self: *RichTextLabel, line: int) {
}
RichTextLabel_scroll_to_paragraph :: (using self: *RichTextLabel, paragraph: int) {
}
RichTextLabel_scroll_to_selection :: (using self: *RichTextLabel) {
}
RichTextLabel_set_tab_size :: (using self: *RichTextLabel, spaces: int) {
}
RichTextLabel_get_tab_size :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_set_fit_content :: (using self: *RichTextLabel, enabled: bool) {
}
RichTextLabel_is_fit_content_enabled :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_set_selection_enabled :: (using self: *RichTextLabel, enabled: bool) {
}
RichTextLabel_is_selection_enabled :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_set_context_menu_enabled :: (using self: *RichTextLabel, enabled: bool) {
}
RichTextLabel_is_context_menu_enabled :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_set_shortcut_keys_enabled :: (using self: *RichTextLabel, enabled: bool) {
}
RichTextLabel_is_shortcut_keys_enabled :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_set_deselect_on_focus_loss_enabled :: (using self: *RichTextLabel, enable: bool) {
}
RichTextLabel_is_deselect_on_focus_loss_enabled :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_set_drag_and_drop_selection_enabled :: (using self: *RichTextLabel, enable: bool) {
}
RichTextLabel_is_drag_and_drop_selection_enabled :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_get_selection_from :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_get_selection_to :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_select_all :: (using self: *RichTextLabel) {
}
RichTextLabel_get_selected_text :: (using self: *RichTextLabel) -> String {
}
RichTextLabel_deselect :: (using self: *RichTextLabel) {
}
RichTextLabel_parse_bbcode :: (using self: *RichTextLabel, bbcode: String) {
}
RichTextLabel_append_text :: (using self: *RichTextLabel, bbcode: String) {
}
RichTextLabel_get_text :: (using self: *RichTextLabel) -> String {
}
RichTextLabel_is_ready :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_set_threaded :: (using self: *RichTextLabel, threaded: bool) {
}
RichTextLabel_is_threaded :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_set_progress_bar_delay :: (using self: *RichTextLabel, delay_ms: int) {
}
RichTextLabel_get_progress_bar_delay :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_set_visible_characters :: (using self: *RichTextLabel, amount: int) {
}
RichTextLabel_get_visible_characters :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_get_visible_characters_behavior :: (using self: *RichTextLabel) -> TextServer.VisibleCharactersBehavior {
}
RichTextLabel_set_visible_characters_behavior :: (using self: *RichTextLabel, behavior: TextServer.VisibleCharactersBehavior) {
}
RichTextLabel_set_visible_ratio :: (using self: *RichTextLabel, ratio: float) {
}
RichTextLabel_get_visible_ratio :: (using self: *RichTextLabel) -> float {
}
RichTextLabel_get_character_line :: (using self: *RichTextLabel, character: int) -> int {
}
RichTextLabel_get_character_paragraph :: (using self: *RichTextLabel, character: int) -> int {
}
RichTextLabel_get_total_character_count :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_set_use_bbcode :: (using self: *RichTextLabel, enable: bool) {
}
RichTextLabel_is_using_bbcode :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_get_line_count :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_get_visible_line_count :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_get_paragraph_count :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_get_visible_paragraph_count :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_get_content_height :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_get_content_width :: (using self: *RichTextLabel) -> int {
}
RichTextLabel_get_line_offset :: (using self: *RichTextLabel, line: int) -> float {
}
RichTextLabel_get_paragraph_offset :: (using self: *RichTextLabel, paragraph: int) -> float {
}
RichTextLabel_parse_expressions_for_values :: (using self: *RichTextLabel, expressions: PackedStringArray) -> Dictionary {
}
RichTextLabel_set_effects :: (using self: *RichTextLabel, effects: Array) {
}
RichTextLabel_get_effects :: (using self: *RichTextLabel) -> Array {
}
RichTextLabel_install_effect :: (using self: *RichTextLabel, effect: Variant) {
}
RichTextLabel_get_menu :: (using self: *RichTextLabel) -> PopupMenu {
}
RichTextLabel_is_menu_visible :: (using self: *RichTextLabel) -> bool {
}
RichTextLabel_menu_option :: (using self: *RichTextLabel, option: int) {
}

// RigidBody2D
RigidBody2D :: struct {
	__private: *void;

	FreezeMode :: enum {
		FREEZE_MODE_STATIC :: 0;
		FREEZE_MODE_KINEMATIC :: 1;
	}
	CenterOfMassMode :: enum {
		CENTER_OF_MASS_MODE_AUTO :: 0;
		CENTER_OF_MASS_MODE_CUSTOM :: 1;
	}
	DampMode :: enum {
		DAMP_MODE_COMBINE :: 0;
		DAMP_MODE_REPLACE :: 1;
	}
	CCDMode :: enum {
		CCD_MODE_DISABLED :: 0;
		CCD_MODE_CAST_RAY :: 1;
		CCD_MODE_CAST_SHAPE :: 2;
	}
}

RigidBody2D__integrate_forces :: (using self: *RigidBody2D, state: PhysicsDirectBodyState2D) {
}
RigidBody2D_set_mass :: (using self: *RigidBody2D, mass: float) {
}
RigidBody2D_get_mass :: (using self: *RigidBody2D) -> float {
}
RigidBody2D_get_inertia :: (using self: *RigidBody2D) -> float {
}
RigidBody2D_set_inertia :: (using self: *RigidBody2D, inertia: float) {
}
RigidBody2D_set_center_of_mass_mode :: (using self: *RigidBody2D, mode: RigidBody2D.CenterOfMassMode) {
}
RigidBody2D_get_center_of_mass_mode :: (using self: *RigidBody2D) -> RigidBody2D.CenterOfMassMode {
}
RigidBody2D_set_center_of_mass :: (using self: *RigidBody2D, center_of_mass: Vector2) {
}
RigidBody2D_get_center_of_mass :: (using self: *RigidBody2D) -> Vector2 {
}
RigidBody2D_set_physics_material_override :: (using self: *RigidBody2D, physics_material_override: PhysicsMaterial) {
}
RigidBody2D_get_physics_material_override :: (using self: *RigidBody2D) -> PhysicsMaterial {
}
RigidBody2D_set_gravity_scale :: (using self: *RigidBody2D, gravity_scale: float) {
}
RigidBody2D_get_gravity_scale :: (using self: *RigidBody2D) -> float {
}
RigidBody2D_set_linear_damp_mode :: (using self: *RigidBody2D, linear_damp_mode: RigidBody2D.DampMode) {
}
RigidBody2D_get_linear_damp_mode :: (using self: *RigidBody2D) -> RigidBody2D.DampMode {
}
RigidBody2D_set_angular_damp_mode :: (using self: *RigidBody2D, angular_damp_mode: RigidBody2D.DampMode) {
}
RigidBody2D_get_angular_damp_mode :: (using self: *RigidBody2D) -> RigidBody2D.DampMode {
}
RigidBody2D_set_linear_damp :: (using self: *RigidBody2D, linear_damp: float) {
}
RigidBody2D_get_linear_damp :: (using self: *RigidBody2D) -> float {
}
RigidBody2D_set_angular_damp :: (using self: *RigidBody2D, angular_damp: float) {
}
RigidBody2D_get_angular_damp :: (using self: *RigidBody2D) -> float {
}
RigidBody2D_set_linear_velocity :: (using self: *RigidBody2D, linear_velocity: Vector2) {
}
RigidBody2D_get_linear_velocity :: (using self: *RigidBody2D) -> Vector2 {
}
RigidBody2D_set_angular_velocity :: (using self: *RigidBody2D, angular_velocity: float) {
}
RigidBody2D_get_angular_velocity :: (using self: *RigidBody2D) -> float {
}
RigidBody2D_set_max_contacts_reported :: (using self: *RigidBody2D, amount: int) {
}
RigidBody2D_get_max_contacts_reported :: (using self: *RigidBody2D) -> int {
}
RigidBody2D_get_contact_count :: (using self: *RigidBody2D) -> int {
}
RigidBody2D_set_use_custom_integrator :: (using self: *RigidBody2D, enable: bool) {
}
RigidBody2D_is_using_custom_integrator :: (using self: *RigidBody2D) -> bool {
}
RigidBody2D_set_contact_monitor :: (using self: *RigidBody2D, enabled: bool) {
}
RigidBody2D_is_contact_monitor_enabled :: (using self: *RigidBody2D) -> bool {
}
RigidBody2D_set_continuous_collision_detection_mode :: (using self: *RigidBody2D, mode: RigidBody2D.CCDMode) {
}
RigidBody2D_get_continuous_collision_detection_mode :: (using self: *RigidBody2D) -> RigidBody2D.CCDMode {
}
RigidBody2D_set_axis_velocity :: (using self: *RigidBody2D, axis_velocity: Vector2) {
}
RigidBody2D_apply_central_impulse :: (using self: *RigidBody2D, impulse: Vector2) {
}
RigidBody2D_apply_impulse :: (using self: *RigidBody2D, impulse: Vector2, position: Vector2) {
}
RigidBody2D_apply_torque_impulse :: (using self: *RigidBody2D, torque: float) {
}
RigidBody2D_apply_central_force :: (using self: *RigidBody2D, force: Vector2) {
}
RigidBody2D_apply_force :: (using self: *RigidBody2D, force: Vector2, position: Vector2) {
}
RigidBody2D_apply_torque :: (using self: *RigidBody2D, torque: float) {
}
RigidBody2D_add_constant_central_force :: (using self: *RigidBody2D, force: Vector2) {
}
RigidBody2D_add_constant_force :: (using self: *RigidBody2D, force: Vector2, position: Vector2) {
}
RigidBody2D_add_constant_torque :: (using self: *RigidBody2D, torque: float) {
}
RigidBody2D_set_constant_force :: (using self: *RigidBody2D, force: Vector2) {
}
RigidBody2D_get_constant_force :: (using self: *RigidBody2D) -> Vector2 {
}
RigidBody2D_set_constant_torque :: (using self: *RigidBody2D, torque: float) {
}
RigidBody2D_get_constant_torque :: (using self: *RigidBody2D) -> float {
}
RigidBody2D_set_sleeping :: (using self: *RigidBody2D, sleeping: bool) {
}
RigidBody2D_is_sleeping :: (using self: *RigidBody2D) -> bool {
}
RigidBody2D_set_can_sleep :: (using self: *RigidBody2D, able_to_sleep: bool) {
}
RigidBody2D_is_able_to_sleep :: (using self: *RigidBody2D) -> bool {
}
RigidBody2D_set_lock_rotation_enabled :: (using self: *RigidBody2D, lock_rotation: bool) {
}
RigidBody2D_is_lock_rotation_enabled :: (using self: *RigidBody2D) -> bool {
}
RigidBody2D_set_freeze_enabled :: (using self: *RigidBody2D, freeze_mode: bool) {
}
RigidBody2D_is_freeze_enabled :: (using self: *RigidBody2D) -> bool {
}
RigidBody2D_set_freeze_mode :: (using self: *RigidBody2D, freeze_mode: RigidBody2D.FreezeMode) {
}
RigidBody2D_get_freeze_mode :: (using self: *RigidBody2D) -> RigidBody2D.FreezeMode {
}
RigidBody2D_get_colliding_bodies :: (using self: *RigidBody2D) -> Array {
}

// RigidBody3D
RigidBody3D :: struct {
	__private: *void;

	FreezeMode :: enum {
		FREEZE_MODE_STATIC :: 0;
		FREEZE_MODE_KINEMATIC :: 1;
	}
	CenterOfMassMode :: enum {
		CENTER_OF_MASS_MODE_AUTO :: 0;
		CENTER_OF_MASS_MODE_CUSTOM :: 1;
	}
	DampMode :: enum {
		DAMP_MODE_COMBINE :: 0;
		DAMP_MODE_REPLACE :: 1;
	}
}

RigidBody3D__integrate_forces :: (using self: *RigidBody3D, state: PhysicsDirectBodyState3D) {
}
RigidBody3D_set_mass :: (using self: *RigidBody3D, mass: float) {
}
RigidBody3D_get_mass :: (using self: *RigidBody3D) -> float {
}
RigidBody3D_set_inertia :: (using self: *RigidBody3D, inertia: Vector3) {
}
RigidBody3D_get_inertia :: (using self: *RigidBody3D) -> Vector3 {
}
RigidBody3D_set_center_of_mass_mode :: (using self: *RigidBody3D, mode: RigidBody3D.CenterOfMassMode) {
}
RigidBody3D_get_center_of_mass_mode :: (using self: *RigidBody3D) -> RigidBody3D.CenterOfMassMode {
}
RigidBody3D_set_center_of_mass :: (using self: *RigidBody3D, center_of_mass: Vector3) {
}
RigidBody3D_get_center_of_mass :: (using self: *RigidBody3D) -> Vector3 {
}
RigidBody3D_set_physics_material_override :: (using self: *RigidBody3D, physics_material_override: PhysicsMaterial) {
}
RigidBody3D_get_physics_material_override :: (using self: *RigidBody3D) -> PhysicsMaterial {
}
RigidBody3D_set_linear_velocity :: (using self: *RigidBody3D, linear_velocity: Vector3) {
}
RigidBody3D_get_linear_velocity :: (using self: *RigidBody3D) -> Vector3 {
}
RigidBody3D_set_angular_velocity :: (using self: *RigidBody3D, angular_velocity: Vector3) {
}
RigidBody3D_get_angular_velocity :: (using self: *RigidBody3D) -> Vector3 {
}
RigidBody3D_get_inverse_inertia_tensor :: (using self: *RigidBody3D) -> Basis {
}
RigidBody3D_set_gravity_scale :: (using self: *RigidBody3D, gravity_scale: float) {
}
RigidBody3D_get_gravity_scale :: (using self: *RigidBody3D) -> float {
}
RigidBody3D_set_linear_damp_mode :: (using self: *RigidBody3D, linear_damp_mode: RigidBody3D.DampMode) {
}
RigidBody3D_get_linear_damp_mode :: (using self: *RigidBody3D) -> RigidBody3D.DampMode {
}
RigidBody3D_set_angular_damp_mode :: (using self: *RigidBody3D, angular_damp_mode: RigidBody3D.DampMode) {
}
RigidBody3D_get_angular_damp_mode :: (using self: *RigidBody3D) -> RigidBody3D.DampMode {
}
RigidBody3D_set_linear_damp :: (using self: *RigidBody3D, linear_damp: float) {
}
RigidBody3D_get_linear_damp :: (using self: *RigidBody3D) -> float {
}
RigidBody3D_set_angular_damp :: (using self: *RigidBody3D, angular_damp: float) {
}
RigidBody3D_get_angular_damp :: (using self: *RigidBody3D) -> float {
}
RigidBody3D_set_max_contacts_reported :: (using self: *RigidBody3D, amount: int) {
}
RigidBody3D_get_max_contacts_reported :: (using self: *RigidBody3D) -> int {
}
RigidBody3D_get_contact_count :: (using self: *RigidBody3D) -> int {
}
RigidBody3D_set_use_custom_integrator :: (using self: *RigidBody3D, enable: bool) {
}
RigidBody3D_is_using_custom_integrator :: (using self: *RigidBody3D) -> bool {
}
RigidBody3D_set_contact_monitor :: (using self: *RigidBody3D, enabled: bool) {
}
RigidBody3D_is_contact_monitor_enabled :: (using self: *RigidBody3D) -> bool {
}
RigidBody3D_set_use_continuous_collision_detection :: (using self: *RigidBody3D, enable: bool) {
}
RigidBody3D_is_using_continuous_collision_detection :: (using self: *RigidBody3D) -> bool {
}
RigidBody3D_set_axis_velocity :: (using self: *RigidBody3D, axis_velocity: Vector3) {
}
RigidBody3D_apply_central_impulse :: (using self: *RigidBody3D, impulse: Vector3) {
}
RigidBody3D_apply_impulse :: (using self: *RigidBody3D, impulse: Vector3, position: Vector3) {
}
RigidBody3D_apply_torque_impulse :: (using self: *RigidBody3D, impulse: Vector3) {
}
RigidBody3D_apply_central_force :: (using self: *RigidBody3D, force: Vector3) {
}
RigidBody3D_apply_force :: (using self: *RigidBody3D, force: Vector3, position: Vector3) {
}
RigidBody3D_apply_torque :: (using self: *RigidBody3D, torque: Vector3) {
}
RigidBody3D_add_constant_central_force :: (using self: *RigidBody3D, force: Vector3) {
}
RigidBody3D_add_constant_force :: (using self: *RigidBody3D, force: Vector3, position: Vector3) {
}
RigidBody3D_add_constant_torque :: (using self: *RigidBody3D, torque: Vector3) {
}
RigidBody3D_set_constant_force :: (using self: *RigidBody3D, force: Vector3) {
}
RigidBody3D_get_constant_force :: (using self: *RigidBody3D) -> Vector3 {
}
RigidBody3D_set_constant_torque :: (using self: *RigidBody3D, torque: Vector3) {
}
RigidBody3D_get_constant_torque :: (using self: *RigidBody3D) -> Vector3 {
}
RigidBody3D_set_sleeping :: (using self: *RigidBody3D, sleeping: bool) {
}
RigidBody3D_is_sleeping :: (using self: *RigidBody3D) -> bool {
}
RigidBody3D_set_can_sleep :: (using self: *RigidBody3D, able_to_sleep: bool) {
}
RigidBody3D_is_able_to_sleep :: (using self: *RigidBody3D) -> bool {
}
RigidBody3D_set_lock_rotation_enabled :: (using self: *RigidBody3D, lock_rotation: bool) {
}
RigidBody3D_is_lock_rotation_enabled :: (using self: *RigidBody3D) -> bool {
}
RigidBody3D_set_freeze_enabled :: (using self: *RigidBody3D, freeze_mode: bool) {
}
RigidBody3D_is_freeze_enabled :: (using self: *RigidBody3D) -> bool {
}
RigidBody3D_set_freeze_mode :: (using self: *RigidBody3D, freeze_mode: RigidBody3D.FreezeMode) {
}
RigidBody3D_get_freeze_mode :: (using self: *RigidBody3D) -> RigidBody3D.FreezeMode {
}
RigidBody3D_get_colliding_bodies :: (using self: *RigidBody3D) -> Array {
}

// RootMotionView
RootMotionView :: struct {
	__private: *void;
}

RootMotionView_set_animation_path :: (using self: *RootMotionView, path: NodePath) {
}
RootMotionView_get_animation_path :: (using self: *RootMotionView) -> NodePath {
}
RootMotionView_set_color :: (using self: *RootMotionView, color: Color) {
}
RootMotionView_get_color :: (using self: *RootMotionView) -> Color {
}
RootMotionView_set_cell_size :: (using self: *RootMotionView, size: float) {
}
RootMotionView_get_cell_size :: (using self: *RootMotionView) -> float {
}
RootMotionView_set_radius :: (using self: *RootMotionView, size: float) {
}
RootMotionView_get_radius :: (using self: *RootMotionView) -> float {
}
RootMotionView_set_zero_y :: (using self: *RootMotionView, enable: bool) {
}
RootMotionView_get_zero_y :: (using self: *RootMotionView) -> bool {
}

// SceneMultiplayer
SceneMultiplayer :: struct {
	__private: *void;
}

SceneMultiplayer_set_root_path :: (using self: *SceneMultiplayer, path: NodePath) {
}
SceneMultiplayer_get_root_path :: (using self: *SceneMultiplayer) -> NodePath {
}
SceneMultiplayer_clear :: (using self: *SceneMultiplayer) {
}
SceneMultiplayer_disconnect_peer :: (using self: *SceneMultiplayer, id: int) {
}
SceneMultiplayer_get_authenticating_peers :: (using self: *SceneMultiplayer) -> PackedInt32Array {
}
SceneMultiplayer_send_auth :: (using self: *SceneMultiplayer, id: int, data: PackedByteArray) -> Error {
}
SceneMultiplayer_complete_auth :: (using self: *SceneMultiplayer, id: int) -> Error {
}
SceneMultiplayer_set_auth_callback :: (using self: *SceneMultiplayer, callback: Callable) {
}
SceneMultiplayer_get_auth_callback :: (using self: *SceneMultiplayer) -> Callable {
}
SceneMultiplayer_set_auth_timeout :: (using self: *SceneMultiplayer, timeout: float) {
}
SceneMultiplayer_get_auth_timeout :: (using self: *SceneMultiplayer) -> float {
}
SceneMultiplayer_set_refuse_new_connections :: (using self: *SceneMultiplayer, refuse: bool) {
}
SceneMultiplayer_is_refusing_new_connections :: (using self: *SceneMultiplayer) -> bool {
}
SceneMultiplayer_set_allow_object_decoding :: (using self: *SceneMultiplayer, enable: bool) {
}
SceneMultiplayer_is_object_decoding_allowed :: (using self: *SceneMultiplayer) -> bool {
}
SceneMultiplayer_set_server_relay_enabled :: (using self: *SceneMultiplayer, enabled: bool) {
}
SceneMultiplayer_is_server_relay_enabled :: (using self: *SceneMultiplayer) -> bool {
}
SceneMultiplayer_send_bytes :: (using self: *SceneMultiplayer, bytes: PackedByteArray, id: int, mode: MultiplayerPeer.TransferMode, channel: int) -> Error {
}
SceneMultiplayer_get_max_sync_packet_size :: (using self: *SceneMultiplayer) -> int {
}
SceneMultiplayer_set_max_sync_packet_size :: (using self: *SceneMultiplayer, size: int) {
}
SceneMultiplayer_get_max_delta_packet_size :: (using self: *SceneMultiplayer) -> int {
}
SceneMultiplayer_set_max_delta_packet_size :: (using self: *SceneMultiplayer, size: int) {
}

// SceneReplicationConfig
SceneReplicationConfig :: struct {
	__private: *void;

	ReplicationMode :: enum {
		REPLICATION_MODE_NEVER :: 0;
		REPLICATION_MODE_ALWAYS :: 1;
		REPLICATION_MODE_ON_CHANGE :: 2;
	}
}

SceneReplicationConfig_get_properties :: (using self: *SceneReplicationConfig) -> Array {
}
SceneReplicationConfig_add_property :: (using self: *SceneReplicationConfig, path: NodePath, index: int) {
}
SceneReplicationConfig_has_property :: (using self: *SceneReplicationConfig, path: NodePath) -> bool {
}
SceneReplicationConfig_remove_property :: (using self: *SceneReplicationConfig, path: NodePath) {
}
SceneReplicationConfig_property_get_index :: (using self: *SceneReplicationConfig, path: NodePath) -> int {
}
SceneReplicationConfig_property_get_spawn :: (using self: *SceneReplicationConfig, path: NodePath) -> bool {
}
SceneReplicationConfig_property_set_spawn :: (using self: *SceneReplicationConfig, path: NodePath, enabled: bool) {
}
SceneReplicationConfig_property_get_replication_mode :: (using self: *SceneReplicationConfig, path: NodePath) -> SceneReplicationConfig.ReplicationMode {
}
SceneReplicationConfig_property_set_replication_mode :: (using self: *SceneReplicationConfig, path: NodePath, mode: SceneReplicationConfig.ReplicationMode) {
}
SceneReplicationConfig_property_get_sync :: (using self: *SceneReplicationConfig, path: NodePath) -> bool {
}
SceneReplicationConfig_property_set_sync :: (using self: *SceneReplicationConfig, path: NodePath, enabled: bool) {
}
SceneReplicationConfig_property_get_watch :: (using self: *SceneReplicationConfig, path: NodePath) -> bool {
}
SceneReplicationConfig_property_set_watch :: (using self: *SceneReplicationConfig, path: NodePath, enabled: bool) {
}

// SceneState
SceneState :: struct {
	__private: *void;

	GenEditState :: enum {
		GEN_EDIT_STATE_DISABLED :: 0;
		GEN_EDIT_STATE_INSTANCE :: 1;
		GEN_EDIT_STATE_MAIN :: 2;
		GEN_EDIT_STATE_MAIN_INHERITED :: 3;
	}
}

SceneState_get_node_count :: (using self: *SceneState) -> int {
}
SceneState_get_node_type :: (using self: *SceneState, idx: int) -> StringName {
}
SceneState_get_node_name :: (using self: *SceneState, idx: int) -> StringName {
}
SceneState_get_node_path :: (using self: *SceneState, idx: int, for_parent: bool) -> NodePath {
}
SceneState_get_node_owner_path :: (using self: *SceneState, idx: int) -> NodePath {
}
SceneState_is_node_instance_placeholder :: (using self: *SceneState, idx: int) -> bool {
}
SceneState_get_node_instance_placeholder :: (using self: *SceneState, idx: int) -> String {
}
SceneState_get_node_instance :: (using self: *SceneState, idx: int) -> PackedScene {
}
SceneState_get_node_groups :: (using self: *SceneState, idx: int) -> PackedStringArray {
}
SceneState_get_node_index :: (using self: *SceneState, idx: int) -> int {
}
SceneState_get_node_property_count :: (using self: *SceneState, idx: int) -> int {
}
SceneState_get_node_property_name :: (using self: *SceneState, idx: int, prop_idx: int) -> StringName {
}
SceneState_get_node_property_value :: (using self: *SceneState, idx: int, prop_idx: int) -> Variant {
}
SceneState_get_connection_count :: (using self: *SceneState) -> int {
}
SceneState_get_connection_source :: (using self: *SceneState, idx: int) -> NodePath {
}
SceneState_get_connection_signal :: (using self: *SceneState, idx: int) -> StringName {
}
SceneState_get_connection_target :: (using self: *SceneState, idx: int) -> NodePath {
}
SceneState_get_connection_method :: (using self: *SceneState, idx: int) -> StringName {
}
SceneState_get_connection_flags :: (using self: *SceneState, idx: int) -> int {
}
SceneState_get_connection_binds :: (using self: *SceneState, idx: int) -> Array {
}
SceneState_get_connection_unbinds :: (using self: *SceneState, idx: int) -> int {
}

// SceneTree
SceneTree :: struct {
	__private: *void;

	GroupCallFlags :: enum {
		GROUP_CALL_DEFAULT :: 0;
		GROUP_CALL_REVERSE :: 1;
		GROUP_CALL_DEFERRED :: 2;
		GROUP_CALL_UNIQUE :: 4;
	}
}

SceneTree_get_root :: (using self: *SceneTree) -> Window {
}
SceneTree_has_group :: (using self: *SceneTree, name: StringName) -> bool {
}
SceneTree_is_auto_accept_quit :: (using self: *SceneTree) -> bool {
}
SceneTree_set_auto_accept_quit :: (using self: *SceneTree, enabled: bool) {
}
SceneTree_is_quit_on_go_back :: (using self: *SceneTree) -> bool {
}
SceneTree_set_quit_on_go_back :: (using self: *SceneTree, enabled: bool) {
}
SceneTree_set_debug_collisions_hint :: (using self: *SceneTree, enable: bool) {
}
SceneTree_is_debugging_collisions_hint :: (using self: *SceneTree) -> bool {
}
SceneTree_set_debug_paths_hint :: (using self: *SceneTree, enable: bool) {
}
SceneTree_is_debugging_paths_hint :: (using self: *SceneTree) -> bool {
}
SceneTree_set_debug_navigation_hint :: (using self: *SceneTree, enable: bool) {
}
SceneTree_is_debugging_navigation_hint :: (using self: *SceneTree) -> bool {
}
SceneTree_set_edited_scene_root :: (using self: *SceneTree, scene: Node) {
}
SceneTree_get_edited_scene_root :: (using self: *SceneTree) -> Node {
}
SceneTree_set_pause :: (using self: *SceneTree, enable: bool) {
}
SceneTree_is_paused :: (using self: *SceneTree) -> bool {
}
SceneTree_create_timer :: (using self: *SceneTree, time_sec: float, process_always: bool, process_in_physics: bool, ignore_time_scale: bool) -> SceneTreeTimer {
}
SceneTree_create_tween :: (using self: *SceneTree) -> Tween {
}
SceneTree_get_processed_tweens :: (using self: *SceneTree) -> Array {
}
SceneTree_get_node_count :: (using self: *SceneTree) -> int {
}
SceneTree_get_frame :: (using self: *SceneTree) -> int {
}
SceneTree_quit :: (using self: *SceneTree, exit_code: int) {
}
SceneTree_set_physics_interpolation_enabled :: (using self: *SceneTree, enabled: bool) {
}
SceneTree_is_physics_interpolation_enabled :: (using self: *SceneTree) -> bool {
}
SceneTree_queue_delete :: (using self: *SceneTree, obj: Object) {
}
SceneTree_call_group_flags :: (using self: *SceneTree, flags: int, group: StringName, method: StringName) {
}
SceneTree_notify_group_flags :: (using self: *SceneTree, call_flags: int, group: StringName, notification: int) {
}
SceneTree_set_group_flags :: (using self: *SceneTree, call_flags: int, group: StringName, property: String, value: Variant) {
}
SceneTree_call_group :: (using self: *SceneTree, group: StringName, method: StringName) {
}
SceneTree_notify_group :: (using self: *SceneTree, group: StringName, notification: int) {
}
SceneTree_set_group :: (using self: *SceneTree, group: StringName, property: String, value: Variant) {
}
SceneTree_get_nodes_in_group :: (using self: *SceneTree, group: StringName) -> Array {
}
SceneTree_get_first_node_in_group :: (using self: *SceneTree, group: StringName) -> Node {
}
SceneTree_get_node_count_in_group :: (using self: *SceneTree, group: StringName) -> int {
}
SceneTree_set_current_scene :: (using self: *SceneTree, child_node: Node) {
}
SceneTree_get_current_scene :: (using self: *SceneTree) -> Node {
}
SceneTree_change_scene_to_file :: (using self: *SceneTree, path: String) -> Error {
}
SceneTree_change_scene_to_packed :: (using self: *SceneTree, packed_scene: PackedScene) -> Error {
}
SceneTree_reload_current_scene :: (using self: *SceneTree) -> Error {
}
SceneTree_unload_current_scene :: (using self: *SceneTree) {
}
SceneTree_set_multiplayer :: (using self: *SceneTree, multiplayer: MultiplayerAPI, root_path: NodePath) {
}
SceneTree_get_multiplayer :: (using self: *SceneTree, for_path: NodePath) -> MultiplayerAPI {
}
SceneTree_set_multiplayer_poll_enabled :: (using self: *SceneTree, enabled: bool) {
}
SceneTree_is_multiplayer_poll_enabled :: (using self: *SceneTree) -> bool {
}

// SceneTreeTimer
SceneTreeTimer :: struct {
	__private: *void;
}

SceneTreeTimer_set_time_left :: (using self: *SceneTreeTimer, time: float) {
}
SceneTreeTimer_get_time_left :: (using self: *SceneTreeTimer) -> float {
}

// Script
Script :: struct {
	__private: *void;
}

Script_can_instantiate :: (using self: *Script) -> bool {
}
Script_instance_has :: (using self: *Script, base_object: Object) -> bool {
}
Script_has_source_code :: (using self: *Script) -> bool {
}
Script_get_source_code :: (using self: *Script) -> String {
}
Script_set_source_code :: (using self: *Script, source: String) {
}
Script_reload :: (using self: *Script, keep_state: bool) -> Error {
}
Script_get_base_script :: (using self: *Script) -> Script {
}
Script_get_instance_base_type :: (using self: *Script) -> StringName {
}
Script_get_global_name :: (using self: *Script) -> StringName {
}
Script_has_script_signal :: (using self: *Script, signal_name: StringName) -> bool {
}
Script_get_script_property_list :: (using self: *Script) -> Dictionary {
}
Script_get_script_method_list :: (using self: *Script) -> Dictionary {
}
Script_get_script_signal_list :: (using self: *Script) -> Dictionary {
}
Script_get_script_constant_map :: (using self: *Script) -> Dictionary {
}
Script_get_property_default_value :: (using self: *Script, property: StringName) -> Variant {
}
Script_is_tool :: (using self: *Script) -> bool {
}
Script_is_abstract :: (using self: *Script) -> bool {
}

// ScriptCreateDialog
ScriptCreateDialog :: struct {
	__private: *void;
}

ScriptCreateDialog_config :: (using self: *ScriptCreateDialog, inherits: String, path: String, built_in_enabled: bool, load_enabled: bool) {
}

// ScriptEditor
ScriptEditor :: struct {
	__private: *void;
}

ScriptEditor_get_current_editor :: (using self: *ScriptEditor) -> ScriptEditorBase {
}
ScriptEditor_get_open_script_editors :: (using self: *ScriptEditor) -> Array {
}
ScriptEditor_register_syntax_highlighter :: (using self: *ScriptEditor, syntax_highlighter: EditorSyntaxHighlighter) {
}
ScriptEditor_unregister_syntax_highlighter :: (using self: *ScriptEditor, syntax_highlighter: EditorSyntaxHighlighter) {
}
ScriptEditor_goto_line :: (using self: *ScriptEditor, line_number: int) {
}
ScriptEditor_get_current_script :: (using self: *ScriptEditor) -> Script {
}
ScriptEditor_get_open_scripts :: (using self: *ScriptEditor) -> Array {
}
ScriptEditor_open_script_create_dialog :: (using self: *ScriptEditor, base_name: String, base_path: String) {
}
ScriptEditor_goto_help :: (using self: *ScriptEditor, topic: String) {
}

// ScriptEditorBase
ScriptEditorBase :: struct {
	__private: *void;
}

ScriptEditorBase_get_base_editor :: (using self: *ScriptEditorBase) -> Control {
}
ScriptEditorBase_add_syntax_highlighter :: (using self: *ScriptEditorBase, highlighter: EditorSyntaxHighlighter) {
}

// ScriptExtension
ScriptExtension :: struct {
	__private: *void;
}

ScriptExtension__editor_can_reload_from_file :: (using self: *ScriptExtension) -> bool {
}
ScriptExtension__placeholder_erased :: (using self: *ScriptExtension, placeholder: *void) {
}
ScriptExtension__can_instantiate :: (using self: *ScriptExtension) -> bool {
}
ScriptExtension__get_base_script :: (using self: *ScriptExtension) -> Script {
}
ScriptExtension__get_global_name :: (using self: *ScriptExtension) -> StringName {
}
ScriptExtension__inherits_script :: (using self: *ScriptExtension, script: Script) -> bool {
}
ScriptExtension__get_instance_base_type :: (using self: *ScriptExtension) -> StringName {
}
ScriptExtension__instance_create :: (using self: *ScriptExtension, for_object: Object) -> *void {
}
ScriptExtension__placeholder_instance_create :: (using self: *ScriptExtension, for_object: Object) -> *void {
}
ScriptExtension__instance_has :: (using self: *ScriptExtension, object: Object) -> bool {
}
ScriptExtension__has_source_code :: (using self: *ScriptExtension) -> bool {
}
ScriptExtension__get_source_code :: (using self: *ScriptExtension) -> String {
}
ScriptExtension__set_source_code :: (using self: *ScriptExtension, code: String) {
}
ScriptExtension__reload :: (using self: *ScriptExtension, keep_state: bool) -> Error {
}
ScriptExtension__get_documentation :: (using self: *ScriptExtension) -> Dictionary {
}
ScriptExtension__get_class_icon_path :: (using self: *ScriptExtension) -> String {
}
ScriptExtension__has_method :: (using self: *ScriptExtension, method: StringName) -> bool {
}
ScriptExtension__has_static_method :: (using self: *ScriptExtension, method: StringName) -> bool {
}
ScriptExtension__get_script_method_argument_count :: (using self: *ScriptExtension, method: StringName) -> Variant {
}
ScriptExtension__get_method_info :: (using self: *ScriptExtension, method: StringName) -> Dictionary {
}
ScriptExtension__is_tool :: (using self: *ScriptExtension) -> bool {
}
ScriptExtension__is_valid :: (using self: *ScriptExtension) -> bool {
}
ScriptExtension__is_abstract :: (using self: *ScriptExtension) -> bool {
}
ScriptExtension__get_language :: (using self: *ScriptExtension) -> ScriptLanguage {
}
ScriptExtension__has_script_signal :: (using self: *ScriptExtension, signal: StringName) -> bool {
}
ScriptExtension__get_script_signal_list :: (using self: *ScriptExtension) -> Dictionary {
}
ScriptExtension__has_property_default_value :: (using self: *ScriptExtension, property: StringName) -> bool {
}
ScriptExtension__get_property_default_value :: (using self: *ScriptExtension, property: StringName) -> Variant {
}
ScriptExtension__update_exports :: (using self: *ScriptExtension) {
}
ScriptExtension__get_script_method_list :: (using self: *ScriptExtension) -> Dictionary {
}
ScriptExtension__get_script_property_list :: (using self: *ScriptExtension) -> Dictionary {
}
ScriptExtension__get_member_line :: (using self: *ScriptExtension, member: StringName) -> int {
}
ScriptExtension__get_constants :: (using self: *ScriptExtension) -> Dictionary {
}
ScriptExtension__get_members :: (using self: *ScriptExtension) -> Array {
}
ScriptExtension__is_placeholder_fallback_enabled :: (using self: *ScriptExtension) -> bool {
}
ScriptExtension__get_rpc_config :: (using self: *ScriptExtension) -> Variant {
}

// ScriptLanguage
ScriptLanguage :: struct {
	__private: *void;

	ScriptNameCasing :: enum {
		SCRIPT_NAME_CASING_AUTO :: 0;
		SCRIPT_NAME_CASING_PASCAL_CASE :: 1;
		SCRIPT_NAME_CASING_SNAKE_CASE :: 2;
		SCRIPT_NAME_CASING_KEBAB_CASE :: 3;
	}
}

// ScriptLanguageExtension
ScriptLanguageExtension :: struct {
	__private: *void;

	LookupResultType :: enum {
		LOOKUP_RESULT_SCRIPT_LOCATION :: 0;
		LOOKUP_RESULT_CLASS :: 1;
		LOOKUP_RESULT_CLASS_CONSTANT :: 2;
		LOOKUP_RESULT_CLASS_PROPERTY :: 3;
		LOOKUP_RESULT_CLASS_METHOD :: 4;
		LOOKUP_RESULT_CLASS_SIGNAL :: 5;
		LOOKUP_RESULT_CLASS_ENUM :: 6;
		LOOKUP_RESULT_CLASS_TBD_GLOBALSCOPE :: 7;
		LOOKUP_RESULT_CLASS_ANNOTATION :: 8;
		LOOKUP_RESULT_MAX :: 9;
	}
	CodeCompletionLocation :: enum {
		LOCATION_LOCAL :: 0;
		LOCATION_PARENT_MASK :: 256;
		LOCATION_OTHER_USER_CODE :: 512;
		LOCATION_OTHER :: 1024;
	}
	CodeCompletionKind :: enum {
		CODE_COMPLETION_KIND_CLASS :: 0;
		CODE_COMPLETION_KIND_FUNCTION :: 1;
		CODE_COMPLETION_KIND_SIGNAL :: 2;
		CODE_COMPLETION_KIND_VARIABLE :: 3;
		CODE_COMPLETION_KIND_MEMBER :: 4;
		CODE_COMPLETION_KIND_ENUM :: 5;
		CODE_COMPLETION_KIND_CONSTANT :: 6;
		CODE_COMPLETION_KIND_NODE_PATH :: 7;
		CODE_COMPLETION_KIND_FILE_PATH :: 8;
		CODE_COMPLETION_KIND_PLAIN_TEXT :: 9;
		CODE_COMPLETION_KIND_MAX :: 10;
	}
}

ScriptLanguageExtension__get_name :: (using self: *ScriptLanguageExtension) -> String {
}
ScriptLanguageExtension__init :: (using self: *ScriptLanguageExtension) {
}
ScriptLanguageExtension__get_type :: (using self: *ScriptLanguageExtension) -> String {
}
ScriptLanguageExtension__get_extension :: (using self: *ScriptLanguageExtension) -> String {
}
ScriptLanguageExtension__finish :: (using self: *ScriptLanguageExtension) {
}
ScriptLanguageExtension__get_reserved_words :: (using self: *ScriptLanguageExtension) -> PackedStringArray {
}
ScriptLanguageExtension__is_control_flow_keyword :: (using self: *ScriptLanguageExtension, keyword: String) -> bool {
}
ScriptLanguageExtension__get_comment_delimiters :: (using self: *ScriptLanguageExtension) -> PackedStringArray {
}
ScriptLanguageExtension__get_doc_comment_delimiters :: (using self: *ScriptLanguageExtension) -> PackedStringArray {
}
ScriptLanguageExtension__get_string_delimiters :: (using self: *ScriptLanguageExtension) -> PackedStringArray {
}
ScriptLanguageExtension__make_template :: (using self: *ScriptLanguageExtension, template: String, class_name: String, base_class_name: String) -> Script {
}
ScriptLanguageExtension__get_built_in_templates :: (using self: *ScriptLanguageExtension, object: StringName) -> Dictionary {
}
ScriptLanguageExtension__is_using_templates :: (using self: *ScriptLanguageExtension) -> bool {
}
ScriptLanguageExtension__validate :: (using self: *ScriptLanguageExtension, script: String, path: String, validate_functions: bool, validate_errors: bool, validate_warnings: bool, validate_safe_lines: bool) -> Dictionary {
}
ScriptLanguageExtension__validate_path :: (using self: *ScriptLanguageExtension, path: String) -> String {
}
ScriptLanguageExtension__create_script :: (using self: *ScriptLanguageExtension) -> Object {
}
ScriptLanguageExtension__has_named_classes :: (using self: *ScriptLanguageExtension) -> bool {
}
ScriptLanguageExtension__supports_builtin_mode :: (using self: *ScriptLanguageExtension) -> bool {
}
ScriptLanguageExtension__supports_documentation :: (using self: *ScriptLanguageExtension) -> bool {
}
ScriptLanguageExtension__can_inherit_from_file :: (using self: *ScriptLanguageExtension) -> bool {
}
ScriptLanguageExtension__find_function :: (using self: *ScriptLanguageExtension, function: String, code: String) -> int {
}
ScriptLanguageExtension__make_function :: (using self: *ScriptLanguageExtension, class_name: String, function_name: String, function_args: PackedStringArray) -> String {
}
ScriptLanguageExtension__can_make_function :: (using self: *ScriptLanguageExtension) -> bool {
}
ScriptLanguageExtension__open_in_external_editor :: (using self: *ScriptLanguageExtension, script: Script, line: int, column: int) -> Error {
}
ScriptLanguageExtension__overrides_external_editor :: (using self: *ScriptLanguageExtension) -> bool {
}
ScriptLanguageExtension__preferred_file_name_casing :: (using self: *ScriptLanguageExtension) -> ScriptLanguage.ScriptNameCasing {
}
ScriptLanguageExtension__complete_code :: (using self: *ScriptLanguageExtension, code: String, path: String, owner: Object) -> Dictionary {
}
ScriptLanguageExtension__lookup_code :: (using self: *ScriptLanguageExtension, code: String, symbol: String, path: String, owner: Object) -> Dictionary {
}
ScriptLanguageExtension__auto_indent_code :: (using self: *ScriptLanguageExtension, code: String, from_line: int, to_line: int) -> String {
}
ScriptLanguageExtension__add_global_constant :: (using self: *ScriptLanguageExtension, name: StringName, value: Variant) {
}
ScriptLanguageExtension__add_named_global_constant :: (using self: *ScriptLanguageExtension, name: StringName, value: Variant) {
}
ScriptLanguageExtension__remove_named_global_constant :: (using self: *ScriptLanguageExtension, name: StringName) {
}
ScriptLanguageExtension__thread_enter :: (using self: *ScriptLanguageExtension) {
}
ScriptLanguageExtension__thread_exit :: (using self: *ScriptLanguageExtension) {
}
ScriptLanguageExtension__debug_get_error :: (using self: *ScriptLanguageExtension) -> String {
}
ScriptLanguageExtension__debug_get_stack_level_count :: (using self: *ScriptLanguageExtension) -> int {
}
ScriptLanguageExtension__debug_get_stack_level_line :: (using self: *ScriptLanguageExtension, level: int) -> int {
}
ScriptLanguageExtension__debug_get_stack_level_function :: (using self: *ScriptLanguageExtension, level: int) -> String {
}
ScriptLanguageExtension__debug_get_stack_level_source :: (using self: *ScriptLanguageExtension, level: int) -> String {
}
ScriptLanguageExtension__debug_get_stack_level_locals :: (using self: *ScriptLanguageExtension, level: int, max_subitems: int, max_depth: int) -> Dictionary {
}
ScriptLanguageExtension__debug_get_stack_level_members :: (using self: *ScriptLanguageExtension, level: int, max_subitems: int, max_depth: int) -> Dictionary {
}
ScriptLanguageExtension__debug_get_stack_level_instance :: (using self: *ScriptLanguageExtension, level: int) -> *void {
}
ScriptLanguageExtension__debug_get_globals :: (using self: *ScriptLanguageExtension, max_subitems: int, max_depth: int) -> Dictionary {
}
ScriptLanguageExtension__debug_parse_stack_level_expression :: (using self: *ScriptLanguageExtension, level: int, expression: String, max_subitems: int, max_depth: int) -> String {
}
ScriptLanguageExtension__debug_get_current_stack_info :: (using self: *ScriptLanguageExtension) -> Dictionary {
}
ScriptLanguageExtension__reload_all_scripts :: (using self: *ScriptLanguageExtension) {
}
ScriptLanguageExtension__reload_tool_script :: (using self: *ScriptLanguageExtension, script: Script, soft_reload: bool) {
}
ScriptLanguageExtension__get_recognized_extensions :: (using self: *ScriptLanguageExtension) -> PackedStringArray {
}
ScriptLanguageExtension__get_public_functions :: (using self: *ScriptLanguageExtension) -> Dictionary {
}
ScriptLanguageExtension__get_public_constants :: (using self: *ScriptLanguageExtension) -> Dictionary {
}
ScriptLanguageExtension__get_public_annotations :: (using self: *ScriptLanguageExtension) -> Dictionary {
}
ScriptLanguageExtension__profiling_start :: (using self: *ScriptLanguageExtension) {
}
ScriptLanguageExtension__profiling_stop :: (using self: *ScriptLanguageExtension) {
}
ScriptLanguageExtension__profiling_set_save_native_calls :: (using self: *ScriptLanguageExtension, enable: bool) {
}
ScriptLanguageExtension__profiling_get_accumulated_data :: (using self: *ScriptLanguageExtension, info_array: *ScriptLanguageExtensionProfilingInfo, info_max: int) -> int {
}
ScriptLanguageExtension__profiling_get_frame_data :: (using self: *ScriptLanguageExtension, info_array: *ScriptLanguageExtensionProfilingInfo, info_max: int) -> int {
}
ScriptLanguageExtension__frame :: (using self: *ScriptLanguageExtension) {
}
ScriptLanguageExtension__handles_global_class_type :: (using self: *ScriptLanguageExtension, type: String) -> bool {
}
ScriptLanguageExtension__get_global_class_name :: (using self: *ScriptLanguageExtension, path: String) -> Dictionary {
}

// ScrollBar
ScrollBar :: struct {
	__private: *void;
}

ScrollBar_set_custom_step :: (using self: *ScrollBar, step: float) {
}
ScrollBar_get_custom_step :: (using self: *ScrollBar) -> float {
}

// ScrollContainer
ScrollContainer :: struct {
	__private: *void;

	ScrollMode :: enum {
		SCROLL_MODE_DISABLED :: 0;
		SCROLL_MODE_AUTO :: 1;
		SCROLL_MODE_SHOW_ALWAYS :: 2;
		SCROLL_MODE_SHOW_NEVER :: 3;
	}
}

ScrollContainer_set_h_scroll :: (using self: *ScrollContainer, value: int) {
}
ScrollContainer_get_h_scroll :: (using self: *ScrollContainer) -> int {
}
ScrollContainer_set_v_scroll :: (using self: *ScrollContainer, value: int) {
}
ScrollContainer_get_v_scroll :: (using self: *ScrollContainer) -> int {
}
ScrollContainer_set_horizontal_custom_step :: (using self: *ScrollContainer, value: float) {
}
ScrollContainer_get_horizontal_custom_step :: (using self: *ScrollContainer) -> float {
}
ScrollContainer_set_vertical_custom_step :: (using self: *ScrollContainer, value: float) {
}
ScrollContainer_get_vertical_custom_step :: (using self: *ScrollContainer) -> float {
}
ScrollContainer_set_horizontal_scroll_mode :: (using self: *ScrollContainer, enable: ScrollContainer.ScrollMode) {
}
ScrollContainer_get_horizontal_scroll_mode :: (using self: *ScrollContainer) -> ScrollContainer.ScrollMode {
}
ScrollContainer_set_vertical_scroll_mode :: (using self: *ScrollContainer, enable: ScrollContainer.ScrollMode) {
}
ScrollContainer_get_vertical_scroll_mode :: (using self: *ScrollContainer) -> ScrollContainer.ScrollMode {
}
ScrollContainer_set_deadzone :: (using self: *ScrollContainer, deadzone: int) {
}
ScrollContainer_get_deadzone :: (using self: *ScrollContainer) -> int {
}
ScrollContainer_set_follow_focus :: (using self: *ScrollContainer, enabled: bool) {
}
ScrollContainer_is_following_focus :: (using self: *ScrollContainer) -> bool {
}
ScrollContainer_get_h_scroll_bar :: (using self: *ScrollContainer) -> HScrollBar {
}
ScrollContainer_get_v_scroll_bar :: (using self: *ScrollContainer) -> VScrollBar {
}
ScrollContainer_ensure_control_visible :: (using self: *ScrollContainer, control: Control) {
}

// SegmentShape2D
SegmentShape2D :: struct {
	__private: *void;
}

SegmentShape2D_set_a :: (using self: *SegmentShape2D, a: Vector2) {
}
SegmentShape2D_get_a :: (using self: *SegmentShape2D) -> Vector2 {
}
SegmentShape2D_set_b :: (using self: *SegmentShape2D, b: Vector2) {
}
SegmentShape2D_get_b :: (using self: *SegmentShape2D) -> Vector2 {
}

// Semaphore
Semaphore :: struct {
	__private: *void;
}

Semaphore_wait :: (using self: *Semaphore) {
}
Semaphore_try_wait :: (using self: *Semaphore) -> bool {
}
Semaphore_post :: (using self: *Semaphore) {
}

// SeparationRayShape2D
SeparationRayShape2D :: struct {
	__private: *void;
}

SeparationRayShape2D_set_length :: (using self: *SeparationRayShape2D, length: float) {
}
SeparationRayShape2D_get_length :: (using self: *SeparationRayShape2D) -> float {
}
SeparationRayShape2D_set_slide_on_slope :: (using self: *SeparationRayShape2D, active: bool) {
}
SeparationRayShape2D_get_slide_on_slope :: (using self: *SeparationRayShape2D) -> bool {
}

// SeparationRayShape3D
SeparationRayShape3D :: struct {
	__private: *void;
}

SeparationRayShape3D_set_length :: (using self: *SeparationRayShape3D, length: float) {
}
SeparationRayShape3D_get_length :: (using self: *SeparationRayShape3D) -> float {
}
SeparationRayShape3D_set_slide_on_slope :: (using self: *SeparationRayShape3D, active: bool) {
}
SeparationRayShape3D_get_slide_on_slope :: (using self: *SeparationRayShape3D) -> bool {
}

// Separator
Separator :: struct {
	__private: *void;
}

// Shader
Shader :: struct {
	__private: *void;

	Mode :: enum {
		MODE_SPATIAL :: 0;
		MODE_CANVAS_ITEM :: 1;
		MODE_PARTICLES :: 2;
		MODE_SKY :: 3;
		MODE_FOG :: 4;
	}
}

Shader_get_mode :: (using self: *Shader) -> Shader.Mode {
}
Shader_set_code :: (using self: *Shader, code: String) {
}
Shader_get_code :: (using self: *Shader) -> String {
}
Shader_set_default_texture_parameter :: (using self: *Shader, name: StringName, texture: Texture2D, index: int) {
}
Shader_get_default_texture_parameter :: (using self: *Shader, name: StringName, index: int) -> Texture2D {
}
Shader_get_shader_uniform_list :: (using self: *Shader, get_groups: bool) -> Array {
}

// ShaderGlobalsOverride
ShaderGlobalsOverride :: struct {
	__private: *void;
}

// ShaderInclude
ShaderInclude :: struct {
	__private: *void;
}

ShaderInclude_set_code :: (using self: *ShaderInclude, code: String) {
}
ShaderInclude_get_code :: (using self: *ShaderInclude) -> String {
}

// ShaderMaterial
ShaderMaterial :: struct {
	__private: *void;
}

ShaderMaterial_set_shader :: (using self: *ShaderMaterial, shader: Shader) {
}
ShaderMaterial_get_shader :: (using self: *ShaderMaterial) -> Shader {
}
ShaderMaterial_set_shader_parameter :: (using self: *ShaderMaterial, param: StringName, value: Variant) {
}
ShaderMaterial_get_shader_parameter :: (using self: *ShaderMaterial, param: StringName) -> Variant {
}

// Shape2D
Shape2D :: struct {
	__private: *void;
}

Shape2D_set_custom_solver_bias :: (using self: *Shape2D, bias: float) {
}
Shape2D_get_custom_solver_bias :: (using self: *Shape2D) -> float {
}
Shape2D_collide :: (using self: *Shape2D, local_xform: Transform2D, with_shape: Shape2D, shape_xform: Transform2D) -> bool {
}
Shape2D_collide_with_motion :: (using self: *Shape2D, local_xform: Transform2D, local_motion: Vector2, with_shape: Shape2D, shape_xform: Transform2D, shape_motion: Vector2) -> bool {
}
Shape2D_collide_and_get_contacts :: (using self: *Shape2D, local_xform: Transform2D, with_shape: Shape2D, shape_xform: Transform2D) -> PackedVector2Array {
}
Shape2D_collide_with_motion_and_get_contacts :: (using self: *Shape2D, local_xform: Transform2D, local_motion: Vector2, with_shape: Shape2D, shape_xform: Transform2D, shape_motion: Vector2) -> PackedVector2Array {
}
Shape2D_draw :: (using self: *Shape2D, canvas_item: RID, color: Color) {
}
Shape2D_get_rect :: (using self: *Shape2D) -> Rect2 {
}

// Shape3D
Shape3D :: struct {
	__private: *void;
}

Shape3D_set_custom_solver_bias :: (using self: *Shape3D, bias: float) {
}
Shape3D_get_custom_solver_bias :: (using self: *Shape3D) -> float {
}
Shape3D_set_margin :: (using self: *Shape3D, margin: float) {
}
Shape3D_get_margin :: (using self: *Shape3D) -> float {
}
Shape3D_get_debug_mesh :: (using self: *Shape3D) -> ArrayMesh {
}

// ShapeCast2D
ShapeCast2D :: struct {
	__private: *void;
}

ShapeCast2D_set_enabled :: (using self: *ShapeCast2D, enabled: bool) {
}
ShapeCast2D_is_enabled :: (using self: *ShapeCast2D) -> bool {
}
ShapeCast2D_set_shape :: (using self: *ShapeCast2D, shape: Shape2D) {
}
ShapeCast2D_get_shape :: (using self: *ShapeCast2D) -> Shape2D {
}
ShapeCast2D_set_target_position :: (using self: *ShapeCast2D, local_point: Vector2) {
}
ShapeCast2D_get_target_position :: (using self: *ShapeCast2D) -> Vector2 {
}
ShapeCast2D_set_margin :: (using self: *ShapeCast2D, margin: float) {
}
ShapeCast2D_get_margin :: (using self: *ShapeCast2D) -> float {
}
ShapeCast2D_set_max_results :: (using self: *ShapeCast2D, max_results: int) {
}
ShapeCast2D_get_max_results :: (using self: *ShapeCast2D) -> int {
}
ShapeCast2D_is_colliding :: (using self: *ShapeCast2D) -> bool {
}
ShapeCast2D_get_collision_count :: (using self: *ShapeCast2D) -> int {
}
ShapeCast2D_force_shapecast_update :: (using self: *ShapeCast2D) {
}
ShapeCast2D_get_collider :: (using self: *ShapeCast2D, index: int) -> Object {
}
ShapeCast2D_get_collider_rid :: (using self: *ShapeCast2D, index: int) -> RID {
}
ShapeCast2D_get_collider_shape :: (using self: *ShapeCast2D, index: int) -> int {
}
ShapeCast2D_get_collision_point :: (using self: *ShapeCast2D, index: int) -> Vector2 {
}
ShapeCast2D_get_collision_normal :: (using self: *ShapeCast2D, index: int) -> Vector2 {
}
ShapeCast2D_get_closest_collision_safe_fraction :: (using self: *ShapeCast2D) -> float {
}
ShapeCast2D_get_closest_collision_unsafe_fraction :: (using self: *ShapeCast2D) -> float {
}
ShapeCast2D_add_exception_rid :: (using self: *ShapeCast2D, rid: RID) {
}
ShapeCast2D_add_exception :: (using self: *ShapeCast2D, node: CollisionObject2D) {
}
ShapeCast2D_remove_exception_rid :: (using self: *ShapeCast2D, rid: RID) {
}
ShapeCast2D_remove_exception :: (using self: *ShapeCast2D, node: CollisionObject2D) {
}
ShapeCast2D_clear_exceptions :: (using self: *ShapeCast2D) {
}
ShapeCast2D_set_collision_mask :: (using self: *ShapeCast2D, mask: int) {
}
ShapeCast2D_get_collision_mask :: (using self: *ShapeCast2D) -> int {
}
ShapeCast2D_set_collision_mask_value :: (using self: *ShapeCast2D, layer_number: int, value: bool) {
}
ShapeCast2D_get_collision_mask_value :: (using self: *ShapeCast2D, layer_number: int) -> bool {
}
ShapeCast2D_set_exclude_parent_body :: (using self: *ShapeCast2D, mask: bool) {
}
ShapeCast2D_get_exclude_parent_body :: (using self: *ShapeCast2D) -> bool {
}
ShapeCast2D_set_collide_with_areas :: (using self: *ShapeCast2D, enable: bool) {
}
ShapeCast2D_is_collide_with_areas_enabled :: (using self: *ShapeCast2D) -> bool {
}
ShapeCast2D_set_collide_with_bodies :: (using self: *ShapeCast2D, enable: bool) {
}
ShapeCast2D_is_collide_with_bodies_enabled :: (using self: *ShapeCast2D) -> bool {
}

// ShapeCast3D
ShapeCast3D :: struct {
	__private: *void;
}

ShapeCast3D_resource_changed :: (using self: *ShapeCast3D, resource: Resource) {
}
ShapeCast3D_set_enabled :: (using self: *ShapeCast3D, enabled: bool) {
}
ShapeCast3D_is_enabled :: (using self: *ShapeCast3D) -> bool {
}
ShapeCast3D_set_shape :: (using self: *ShapeCast3D, shape: Shape3D) {
}
ShapeCast3D_get_shape :: (using self: *ShapeCast3D) -> Shape3D {
}
ShapeCast3D_set_target_position :: (using self: *ShapeCast3D, local_point: Vector3) {
}
ShapeCast3D_get_target_position :: (using self: *ShapeCast3D) -> Vector3 {
}
ShapeCast3D_set_margin :: (using self: *ShapeCast3D, margin: float) {
}
ShapeCast3D_get_margin :: (using self: *ShapeCast3D) -> float {
}
ShapeCast3D_set_max_results :: (using self: *ShapeCast3D, max_results: int) {
}
ShapeCast3D_get_max_results :: (using self: *ShapeCast3D) -> int {
}
ShapeCast3D_is_colliding :: (using self: *ShapeCast3D) -> bool {
}
ShapeCast3D_get_collision_count :: (using self: *ShapeCast3D) -> int {
}
ShapeCast3D_force_shapecast_update :: (using self: *ShapeCast3D) {
}
ShapeCast3D_get_collider :: (using self: *ShapeCast3D, index: int) -> Object {
}
ShapeCast3D_get_collider_rid :: (using self: *ShapeCast3D, index: int) -> RID {
}
ShapeCast3D_get_collider_shape :: (using self: *ShapeCast3D, index: int) -> int {
}
ShapeCast3D_get_collision_point :: (using self: *ShapeCast3D, index: int) -> Vector3 {
}
ShapeCast3D_get_collision_normal :: (using self: *ShapeCast3D, index: int) -> Vector3 {
}
ShapeCast3D_get_closest_collision_safe_fraction :: (using self: *ShapeCast3D) -> float {
}
ShapeCast3D_get_closest_collision_unsafe_fraction :: (using self: *ShapeCast3D) -> float {
}
ShapeCast3D_add_exception_rid :: (using self: *ShapeCast3D, rid: RID) {
}
ShapeCast3D_add_exception :: (using self: *ShapeCast3D, node: CollisionObject3D) {
}
ShapeCast3D_remove_exception_rid :: (using self: *ShapeCast3D, rid: RID) {
}
ShapeCast3D_remove_exception :: (using self: *ShapeCast3D, node: CollisionObject3D) {
}
ShapeCast3D_clear_exceptions :: (using self: *ShapeCast3D) {
}
ShapeCast3D_set_collision_mask :: (using self: *ShapeCast3D, mask: int) {
}
ShapeCast3D_get_collision_mask :: (using self: *ShapeCast3D) -> int {
}
ShapeCast3D_set_collision_mask_value :: (using self: *ShapeCast3D, layer_number: int, value: bool) {
}
ShapeCast3D_get_collision_mask_value :: (using self: *ShapeCast3D, layer_number: int) -> bool {
}
ShapeCast3D_set_exclude_parent_body :: (using self: *ShapeCast3D, mask: bool) {
}
ShapeCast3D_get_exclude_parent_body :: (using self: *ShapeCast3D) -> bool {
}
ShapeCast3D_set_collide_with_areas :: (using self: *ShapeCast3D, enable: bool) {
}
ShapeCast3D_is_collide_with_areas_enabled :: (using self: *ShapeCast3D) -> bool {
}
ShapeCast3D_set_collide_with_bodies :: (using self: *ShapeCast3D, enable: bool) {
}
ShapeCast3D_is_collide_with_bodies_enabled :: (using self: *ShapeCast3D) -> bool {
}
ShapeCast3D_set_debug_shape_custom_color :: (using self: *ShapeCast3D, debug_shape_custom_color: Color) {
}
ShapeCast3D_get_debug_shape_custom_color :: (using self: *ShapeCast3D) -> Color {
}

// Shortcut
Shortcut :: struct {
	__private: *void;
}

Shortcut_set_events :: (using self: *Shortcut, events: Array) {
}
Shortcut_get_events :: (using self: *Shortcut) -> Array {
}
Shortcut_has_valid_event :: (using self: *Shortcut) -> bool {
}
Shortcut_matches_event :: (using self: *Shortcut, event: InputEvent) -> bool {
}
Shortcut_get_as_text :: (using self: *Shortcut) -> String {
}

// Skeleton2D
Skeleton2D :: struct {
	__private: *void;
}

Skeleton2D_get_bone_count :: (using self: *Skeleton2D) -> int {
}
Skeleton2D_get_bone :: (using self: *Skeleton2D, idx: int) -> Bone2D {
}
Skeleton2D_get_skeleton :: (using self: *Skeleton2D) -> RID {
}
Skeleton2D_set_modification_stack :: (using self: *Skeleton2D, modification_stack: SkeletonModificationStack2D) {
}
Skeleton2D_get_modification_stack :: (using self: *Skeleton2D) -> SkeletonModificationStack2D {
}
Skeleton2D_execute_modifications :: (using self: *Skeleton2D, delta: float, execution_mode: int) {
}
Skeleton2D_set_bone_local_pose_override :: (using self: *Skeleton2D, bone_idx: int, override_pose: Transform2D, strength: float, persistent: bool) {
}
Skeleton2D_get_bone_local_pose_override :: (using self: *Skeleton2D, bone_idx: int) -> Transform2D {
}

// Skeleton3D
Skeleton3D :: struct {
	__private: *void;

	NOTIFICATION_UPDATE_SKELETON :: 50;

	ModifierCallbackModeProcess :: enum {
		MODIFIER_CALLBACK_MODE_PROCESS_PHYSICS :: 0;
		MODIFIER_CALLBACK_MODE_PROCESS_IDLE :: 1;
	}
}

Skeleton3D_add_bone :: (using self: *Skeleton3D, name: String) -> int {
}
Skeleton3D_find_bone :: (using self: *Skeleton3D, name: String) -> int {
}
Skeleton3D_get_bone_name :: (using self: *Skeleton3D, bone_idx: int) -> String {
}
Skeleton3D_set_bone_name :: (using self: *Skeleton3D, bone_idx: int, name: String) {
}
Skeleton3D_get_concatenated_bone_names :: (using self: *Skeleton3D) -> StringName {
}
Skeleton3D_get_bone_parent :: (using self: *Skeleton3D, bone_idx: int) -> int {
}
Skeleton3D_set_bone_parent :: (using self: *Skeleton3D, bone_idx: int, parent_idx: int) {
}
Skeleton3D_get_bone_count :: (using self: *Skeleton3D) -> int {
}
Skeleton3D_get_version :: (using self: *Skeleton3D) -> int {
}
Skeleton3D_unparent_bone_and_rest :: (using self: *Skeleton3D, bone_idx: int) {
}
Skeleton3D_get_bone_children :: (using self: *Skeleton3D, bone_idx: int) -> PackedInt32Array {
}
Skeleton3D_get_parentless_bones :: (using self: *Skeleton3D) -> PackedInt32Array {
}
Skeleton3D_get_bone_rest :: (using self: *Skeleton3D, bone_idx: int) -> Transform3D {
}
Skeleton3D_set_bone_rest :: (using self: *Skeleton3D, bone_idx: int, rest: Transform3D) {
}
Skeleton3D_get_bone_global_rest :: (using self: *Skeleton3D, bone_idx: int) -> Transform3D {
}
Skeleton3D_create_skin_from_rest_transforms :: (using self: *Skeleton3D) -> Skin {
}
Skeleton3D_register_skin :: (using self: *Skeleton3D, skin: Skin) -> SkinReference {
}
Skeleton3D_localize_rests :: (using self: *Skeleton3D) {
}
Skeleton3D_clear_bones :: (using self: *Skeleton3D) {
}
Skeleton3D_get_bone_pose :: (using self: *Skeleton3D, bone_idx: int) -> Transform3D {
}
Skeleton3D_set_bone_pose :: (using self: *Skeleton3D, bone_idx: int, pose: Transform3D) {
}
Skeleton3D_set_bone_pose_position :: (using self: *Skeleton3D, bone_idx: int, position: Vector3) {
}
Skeleton3D_set_bone_pose_rotation :: (using self: *Skeleton3D, bone_idx: int, rotation: Quaternion) {
}
Skeleton3D_set_bone_pose_scale :: (using self: *Skeleton3D, bone_idx: int, scale: Vector3) {
}
Skeleton3D_get_bone_pose_position :: (using self: *Skeleton3D, bone_idx: int) -> Vector3 {
}
Skeleton3D_get_bone_pose_rotation :: (using self: *Skeleton3D, bone_idx: int) -> Quaternion {
}
Skeleton3D_get_bone_pose_scale :: (using self: *Skeleton3D, bone_idx: int) -> Vector3 {
}
Skeleton3D_reset_bone_pose :: (using self: *Skeleton3D, bone_idx: int) {
}
Skeleton3D_reset_bone_poses :: (using self: *Skeleton3D) {
}
Skeleton3D_is_bone_enabled :: (using self: *Skeleton3D, bone_idx: int) -> bool {
}
Skeleton3D_set_bone_enabled :: (using self: *Skeleton3D, bone_idx: int, enabled: bool) {
}
Skeleton3D_get_bone_global_pose :: (using self: *Skeleton3D, bone_idx: int) -> Transform3D {
}
Skeleton3D_set_bone_global_pose :: (using self: *Skeleton3D, bone_idx: int, pose: Transform3D) {
}
Skeleton3D_force_update_all_bone_transforms :: (using self: *Skeleton3D) {
}
Skeleton3D_force_update_bone_child_transform :: (using self: *Skeleton3D, bone_idx: int) {
}
Skeleton3D_set_motion_scale :: (using self: *Skeleton3D, motion_scale: float) {
}
Skeleton3D_get_motion_scale :: (using self: *Skeleton3D) -> float {
}
Skeleton3D_set_show_rest_only :: (using self: *Skeleton3D, enabled: bool) {
}
Skeleton3D_is_show_rest_only :: (using self: *Skeleton3D) -> bool {
}
Skeleton3D_set_modifier_callback_mode_process :: (using self: *Skeleton3D, mode: Skeleton3D.ModifierCallbackModeProcess) {
}
Skeleton3D_get_modifier_callback_mode_process :: (using self: *Skeleton3D) -> Skeleton3D.ModifierCallbackModeProcess {
}
Skeleton3D_clear_bones_global_pose_override :: (using self: *Skeleton3D) {
}
Skeleton3D_set_bone_global_pose_override :: (using self: *Skeleton3D, bone_idx: int, pose: Transform3D, amount: float, persistent: bool) {
}
Skeleton3D_get_bone_global_pose_override :: (using self: *Skeleton3D, bone_idx: int) -> Transform3D {
}
Skeleton3D_get_bone_global_pose_no_override :: (using self: *Skeleton3D, bone_idx: int) -> Transform3D {
}
Skeleton3D_set_animate_physical_bones :: (using self: *Skeleton3D, enabled: bool) {
}
Skeleton3D_get_animate_physical_bones :: (using self: *Skeleton3D) -> bool {
}
Skeleton3D_physical_bones_stop_simulation :: (using self: *Skeleton3D) {
}
Skeleton3D_physical_bones_start_simulation :: (using self: *Skeleton3D, bones: Array) {
}
Skeleton3D_physical_bones_add_collision_exception :: (using self: *Skeleton3D, exception: RID) {
}
Skeleton3D_physical_bones_remove_collision_exception :: (using self: *Skeleton3D, exception: RID) {
}

// SkeletonIK3D
SkeletonIK3D :: struct {
	__private: *void;
}

SkeletonIK3D_set_root_bone :: (using self: *SkeletonIK3D, root_bone: StringName) {
}
SkeletonIK3D_get_root_bone :: (using self: *SkeletonIK3D) -> StringName {
}
SkeletonIK3D_set_tip_bone :: (using self: *SkeletonIK3D, tip_bone: StringName) {
}
SkeletonIK3D_get_tip_bone :: (using self: *SkeletonIK3D) -> StringName {
}
SkeletonIK3D_set_target_transform :: (using self: *SkeletonIK3D, target: Transform3D) {
}
SkeletonIK3D_get_target_transform :: (using self: *SkeletonIK3D) -> Transform3D {
}
SkeletonIK3D_set_target_node :: (using self: *SkeletonIK3D, node: NodePath) {
}
SkeletonIK3D_get_target_node :: (using self: *SkeletonIK3D) -> NodePath {
}
SkeletonIK3D_set_override_tip_basis :: (using self: *SkeletonIK3D, override: bool) {
}
SkeletonIK3D_is_override_tip_basis :: (using self: *SkeletonIK3D) -> bool {
}
SkeletonIK3D_set_use_magnet :: (using self: *SkeletonIK3D, use: bool) {
}
SkeletonIK3D_is_using_magnet :: (using self: *SkeletonIK3D) -> bool {
}
SkeletonIK3D_set_magnet_position :: (using self: *SkeletonIK3D, local_position: Vector3) {
}
SkeletonIK3D_get_magnet_position :: (using self: *SkeletonIK3D) -> Vector3 {
}
SkeletonIK3D_get_parent_skeleton :: (using self: *SkeletonIK3D) -> Skeleton3D {
}
SkeletonIK3D_is_running :: (using self: *SkeletonIK3D) -> bool {
}
SkeletonIK3D_set_min_distance :: (using self: *SkeletonIK3D, min_distance: float) {
}
SkeletonIK3D_get_min_distance :: (using self: *SkeletonIK3D) -> float {
}
SkeletonIK3D_set_max_iterations :: (using self: *SkeletonIK3D, iterations: int) {
}
SkeletonIK3D_get_max_iterations :: (using self: *SkeletonIK3D) -> int {
}
SkeletonIK3D_start :: (using self: *SkeletonIK3D, one_time: bool) {
}
SkeletonIK3D_stop :: (using self: *SkeletonIK3D) {
}
SkeletonIK3D_set_interpolation :: (using self: *SkeletonIK3D, interpolation: float) {
}
SkeletonIK3D_get_interpolation :: (using self: *SkeletonIK3D) -> float {
}

// SkeletonModification2D
SkeletonModification2D :: struct {
	__private: *void;
}

SkeletonModification2D__execute :: (using self: *SkeletonModification2D, delta: float) {
}
SkeletonModification2D__setup_modification :: (using self: *SkeletonModification2D, modification_stack: SkeletonModificationStack2D) {
}
SkeletonModification2D__draw_editor_gizmo :: (using self: *SkeletonModification2D) {
}
SkeletonModification2D_set_enabled :: (using self: *SkeletonModification2D, enabled: bool) {
}
SkeletonModification2D_get_enabled :: (using self: *SkeletonModification2D) -> bool {
}
SkeletonModification2D_get_modification_stack :: (using self: *SkeletonModification2D) -> SkeletonModificationStack2D {
}
SkeletonModification2D_set_is_setup :: (using self: *SkeletonModification2D, is_setup: bool) {
}
SkeletonModification2D_get_is_setup :: (using self: *SkeletonModification2D) -> bool {
}
SkeletonModification2D_set_execution_mode :: (using self: *SkeletonModification2D, execution_mode: int) {
}
SkeletonModification2D_get_execution_mode :: (using self: *SkeletonModification2D) -> int {
}
SkeletonModification2D_clamp_angle :: (using self: *SkeletonModification2D, angle: float, min: float, max: float, invert: bool) -> float {
}
SkeletonModification2D_set_editor_draw_gizmo :: (using self: *SkeletonModification2D, draw_gizmo: bool) {
}
SkeletonModification2D_get_editor_draw_gizmo :: (using self: *SkeletonModification2D) -> bool {
}

// SkeletonModification2DCCDIK
SkeletonModification2DCCDIK :: struct {
	__private: *void;
}

SkeletonModification2DCCDIK_set_target_node :: (using self: *SkeletonModification2DCCDIK, target_nodepath: NodePath) {
}
SkeletonModification2DCCDIK_get_target_node :: (using self: *SkeletonModification2DCCDIK) -> NodePath {
}
SkeletonModification2DCCDIK_set_tip_node :: (using self: *SkeletonModification2DCCDIK, tip_nodepath: NodePath) {
}
SkeletonModification2DCCDIK_get_tip_node :: (using self: *SkeletonModification2DCCDIK) -> NodePath {
}
SkeletonModification2DCCDIK_set_ccdik_data_chain_length :: (using self: *SkeletonModification2DCCDIK, length: int) {
}
SkeletonModification2DCCDIK_get_ccdik_data_chain_length :: (using self: *SkeletonModification2DCCDIK) -> int {
}
SkeletonModification2DCCDIK_set_ccdik_joint_bone2d_node :: (using self: *SkeletonModification2DCCDIK, joint_idx: int, bone2d_nodepath: NodePath) {
}
SkeletonModification2DCCDIK_get_ccdik_joint_bone2d_node :: (using self: *SkeletonModification2DCCDIK, joint_idx: int) -> NodePath {
}
SkeletonModification2DCCDIK_set_ccdik_joint_bone_index :: (using self: *SkeletonModification2DCCDIK, joint_idx: int, bone_idx: int) {
}
SkeletonModification2DCCDIK_get_ccdik_joint_bone_index :: (using self: *SkeletonModification2DCCDIK, joint_idx: int) -> int {
}
SkeletonModification2DCCDIK_set_ccdik_joint_rotate_from_joint :: (using self: *SkeletonModification2DCCDIK, joint_idx: int, rotate_from_joint: bool) {
}
SkeletonModification2DCCDIK_get_ccdik_joint_rotate_from_joint :: (using self: *SkeletonModification2DCCDIK, joint_idx: int) -> bool {
}
SkeletonModification2DCCDIK_set_ccdik_joint_enable_constraint :: (using self: *SkeletonModification2DCCDIK, joint_idx: int, enable_constraint: bool) {
}
SkeletonModification2DCCDIK_get_ccdik_joint_enable_constraint :: (using self: *SkeletonModification2DCCDIK, joint_idx: int) -> bool {
}
SkeletonModification2DCCDIK_set_ccdik_joint_constraint_angle_min :: (using self: *SkeletonModification2DCCDIK, joint_idx: int, angle_min: float) {
}
SkeletonModification2DCCDIK_get_ccdik_joint_constraint_angle_min :: (using self: *SkeletonModification2DCCDIK, joint_idx: int) -> float {
}
SkeletonModification2DCCDIK_set_ccdik_joint_constraint_angle_max :: (using self: *SkeletonModification2DCCDIK, joint_idx: int, angle_max: float) {
}
SkeletonModification2DCCDIK_get_ccdik_joint_constraint_angle_max :: (using self: *SkeletonModification2DCCDIK, joint_idx: int) -> float {
}
SkeletonModification2DCCDIK_set_ccdik_joint_constraint_angle_invert :: (using self: *SkeletonModification2DCCDIK, joint_idx: int, invert: bool) {
}
SkeletonModification2DCCDIK_get_ccdik_joint_constraint_angle_invert :: (using self: *SkeletonModification2DCCDIK, joint_idx: int) -> bool {
}

// SkeletonModification2DFABRIK
SkeletonModification2DFABRIK :: struct {
	__private: *void;
}

SkeletonModification2DFABRIK_set_target_node :: (using self: *SkeletonModification2DFABRIK, target_nodepath: NodePath) {
}
SkeletonModification2DFABRIK_get_target_node :: (using self: *SkeletonModification2DFABRIK) -> NodePath {
}
SkeletonModification2DFABRIK_set_fabrik_data_chain_length :: (using self: *SkeletonModification2DFABRIK, length: int) {
}
SkeletonModification2DFABRIK_get_fabrik_data_chain_length :: (using self: *SkeletonModification2DFABRIK) -> int {
}
SkeletonModification2DFABRIK_set_fabrik_joint_bone2d_node :: (using self: *SkeletonModification2DFABRIK, joint_idx: int, bone2d_nodepath: NodePath) {
}
SkeletonModification2DFABRIK_get_fabrik_joint_bone2d_node :: (using self: *SkeletonModification2DFABRIK, joint_idx: int) -> NodePath {
}
SkeletonModification2DFABRIK_set_fabrik_joint_bone_index :: (using self: *SkeletonModification2DFABRIK, joint_idx: int, bone_idx: int) {
}
SkeletonModification2DFABRIK_get_fabrik_joint_bone_index :: (using self: *SkeletonModification2DFABRIK, joint_idx: int) -> int {
}
SkeletonModification2DFABRIK_set_fabrik_joint_magnet_position :: (using self: *SkeletonModification2DFABRIK, joint_idx: int, magnet_position: Vector2) {
}
SkeletonModification2DFABRIK_get_fabrik_joint_magnet_position :: (using self: *SkeletonModification2DFABRIK, joint_idx: int) -> Vector2 {
}
SkeletonModification2DFABRIK_set_fabrik_joint_use_target_rotation :: (using self: *SkeletonModification2DFABRIK, joint_idx: int, use_target_rotation: bool) {
}
SkeletonModification2DFABRIK_get_fabrik_joint_use_target_rotation :: (using self: *SkeletonModification2DFABRIK, joint_idx: int) -> bool {
}

// SkeletonModification2DJiggle
SkeletonModification2DJiggle :: struct {
	__private: *void;
}

SkeletonModification2DJiggle_set_target_node :: (using self: *SkeletonModification2DJiggle, target_nodepath: NodePath) {
}
SkeletonModification2DJiggle_get_target_node :: (using self: *SkeletonModification2DJiggle) -> NodePath {
}
SkeletonModification2DJiggle_set_jiggle_data_chain_length :: (using self: *SkeletonModification2DJiggle, length: int) {
}
SkeletonModification2DJiggle_get_jiggle_data_chain_length :: (using self: *SkeletonModification2DJiggle) -> int {
}
SkeletonModification2DJiggle_set_stiffness :: (using self: *SkeletonModification2DJiggle, stiffness: float) {
}
SkeletonModification2DJiggle_get_stiffness :: (using self: *SkeletonModification2DJiggle) -> float {
}
SkeletonModification2DJiggle_set_mass :: (using self: *SkeletonModification2DJiggle, mass: float) {
}
SkeletonModification2DJiggle_get_mass :: (using self: *SkeletonModification2DJiggle) -> float {
}
SkeletonModification2DJiggle_set_damping :: (using self: *SkeletonModification2DJiggle, damping: float) {
}
SkeletonModification2DJiggle_get_damping :: (using self: *SkeletonModification2DJiggle) -> float {
}
SkeletonModification2DJiggle_set_use_gravity :: (using self: *SkeletonModification2DJiggle, use_gravity: bool) {
}
SkeletonModification2DJiggle_get_use_gravity :: (using self: *SkeletonModification2DJiggle) -> bool {
}
SkeletonModification2DJiggle_set_gravity :: (using self: *SkeletonModification2DJiggle, gravity: Vector2) {
}
SkeletonModification2DJiggle_get_gravity :: (using self: *SkeletonModification2DJiggle) -> Vector2 {
}
SkeletonModification2DJiggle_set_use_colliders :: (using self: *SkeletonModification2DJiggle, use_colliders: bool) {
}
SkeletonModification2DJiggle_get_use_colliders :: (using self: *SkeletonModification2DJiggle) -> bool {
}
SkeletonModification2DJiggle_set_collision_mask :: (using self: *SkeletonModification2DJiggle, collision_mask: int) {
}
SkeletonModification2DJiggle_get_collision_mask :: (using self: *SkeletonModification2DJiggle) -> int {
}
SkeletonModification2DJiggle_set_jiggle_joint_bone2d_node :: (using self: *SkeletonModification2DJiggle, joint_idx: int, bone2d_node: NodePath) {
}
SkeletonModification2DJiggle_get_jiggle_joint_bone2d_node :: (using self: *SkeletonModification2DJiggle, joint_idx: int) -> NodePath {
}
SkeletonModification2DJiggle_set_jiggle_joint_bone_index :: (using self: *SkeletonModification2DJiggle, joint_idx: int, bone_idx: int) {
}
SkeletonModification2DJiggle_get_jiggle_joint_bone_index :: (using self: *SkeletonModification2DJiggle, joint_idx: int) -> int {
}
SkeletonModification2DJiggle_set_jiggle_joint_override :: (using self: *SkeletonModification2DJiggle, joint_idx: int, override: bool) {
}
SkeletonModification2DJiggle_get_jiggle_joint_override :: (using self: *SkeletonModification2DJiggle, joint_idx: int) -> bool {
}
SkeletonModification2DJiggle_set_jiggle_joint_stiffness :: (using self: *SkeletonModification2DJiggle, joint_idx: int, stiffness: float) {
}
SkeletonModification2DJiggle_get_jiggle_joint_stiffness :: (using self: *SkeletonModification2DJiggle, joint_idx: int) -> float {
}
SkeletonModification2DJiggle_set_jiggle_joint_mass :: (using self: *SkeletonModification2DJiggle, joint_idx: int, mass: float) {
}
SkeletonModification2DJiggle_get_jiggle_joint_mass :: (using self: *SkeletonModification2DJiggle, joint_idx: int) -> float {
}
SkeletonModification2DJiggle_set_jiggle_joint_damping :: (using self: *SkeletonModification2DJiggle, joint_idx: int, damping: float) {
}
SkeletonModification2DJiggle_get_jiggle_joint_damping :: (using self: *SkeletonModification2DJiggle, joint_idx: int) -> float {
}
SkeletonModification2DJiggle_set_jiggle_joint_use_gravity :: (using self: *SkeletonModification2DJiggle, joint_idx: int, use_gravity: bool) {
}
SkeletonModification2DJiggle_get_jiggle_joint_use_gravity :: (using self: *SkeletonModification2DJiggle, joint_idx: int) -> bool {
}
SkeletonModification2DJiggle_set_jiggle_joint_gravity :: (using self: *SkeletonModification2DJiggle, joint_idx: int, gravity: Vector2) {
}
SkeletonModification2DJiggle_get_jiggle_joint_gravity :: (using self: *SkeletonModification2DJiggle, joint_idx: int) -> Vector2 {
}

// SkeletonModification2DLookAt
SkeletonModification2DLookAt :: struct {
	__private: *void;
}

SkeletonModification2DLookAt_set_bone2d_node :: (using self: *SkeletonModification2DLookAt, bone2d_nodepath: NodePath) {
}
SkeletonModification2DLookAt_get_bone2d_node :: (using self: *SkeletonModification2DLookAt) -> NodePath {
}
SkeletonModification2DLookAt_set_bone_index :: (using self: *SkeletonModification2DLookAt, bone_idx: int) {
}
SkeletonModification2DLookAt_get_bone_index :: (using self: *SkeletonModification2DLookAt) -> int {
}
SkeletonModification2DLookAt_set_target_node :: (using self: *SkeletonModification2DLookAt, target_nodepath: NodePath) {
}
SkeletonModification2DLookAt_get_target_node :: (using self: *SkeletonModification2DLookAt) -> NodePath {
}
SkeletonModification2DLookAt_set_additional_rotation :: (using self: *SkeletonModification2DLookAt, rotation: float) {
}
SkeletonModification2DLookAt_get_additional_rotation :: (using self: *SkeletonModification2DLookAt) -> float {
}
SkeletonModification2DLookAt_set_enable_constraint :: (using self: *SkeletonModification2DLookAt, enable_constraint: bool) {
}
SkeletonModification2DLookAt_get_enable_constraint :: (using self: *SkeletonModification2DLookAt) -> bool {
}
SkeletonModification2DLookAt_set_constraint_angle_min :: (using self: *SkeletonModification2DLookAt, angle_min: float) {
}
SkeletonModification2DLookAt_get_constraint_angle_min :: (using self: *SkeletonModification2DLookAt) -> float {
}
SkeletonModification2DLookAt_set_constraint_angle_max :: (using self: *SkeletonModification2DLookAt, angle_max: float) {
}
SkeletonModification2DLookAt_get_constraint_angle_max :: (using self: *SkeletonModification2DLookAt) -> float {
}
SkeletonModification2DLookAt_set_constraint_angle_invert :: (using self: *SkeletonModification2DLookAt, invert: bool) {
}
SkeletonModification2DLookAt_get_constraint_angle_invert :: (using self: *SkeletonModification2DLookAt) -> bool {
}

// SkeletonModification2DPhysicalBones
SkeletonModification2DPhysicalBones :: struct {
	__private: *void;
}

SkeletonModification2DPhysicalBones_set_physical_bone_chain_length :: (using self: *SkeletonModification2DPhysicalBones, length: int) {
}
SkeletonModification2DPhysicalBones_get_physical_bone_chain_length :: (using self: *SkeletonModification2DPhysicalBones) -> int {
}
SkeletonModification2DPhysicalBones_set_physical_bone_node :: (using self: *SkeletonModification2DPhysicalBones, joint_idx: int, physicalbone2d_node: NodePath) {
}
SkeletonModification2DPhysicalBones_get_physical_bone_node :: (using self: *SkeletonModification2DPhysicalBones, joint_idx: int) -> NodePath {
}
SkeletonModification2DPhysicalBones_fetch_physical_bones :: (using self: *SkeletonModification2DPhysicalBones) {
}
SkeletonModification2DPhysicalBones_start_simulation :: (using self: *SkeletonModification2DPhysicalBones, bones: Array) {
}
SkeletonModification2DPhysicalBones_stop_simulation :: (using self: *SkeletonModification2DPhysicalBones, bones: Array) {
}

// SkeletonModification2DStackHolder
SkeletonModification2DStackHolder :: struct {
	__private: *void;
}

SkeletonModification2DStackHolder_set_held_modification_stack :: (using self: *SkeletonModification2DStackHolder, held_modification_stack: SkeletonModificationStack2D) {
}
SkeletonModification2DStackHolder_get_held_modification_stack :: (using self: *SkeletonModification2DStackHolder) -> SkeletonModificationStack2D {
}

// SkeletonModification2DTwoBoneIK
SkeletonModification2DTwoBoneIK :: struct {
	__private: *void;
}

SkeletonModification2DTwoBoneIK_set_target_node :: (using self: *SkeletonModification2DTwoBoneIK, target_nodepath: NodePath) {
}
SkeletonModification2DTwoBoneIK_get_target_node :: (using self: *SkeletonModification2DTwoBoneIK) -> NodePath {
}
SkeletonModification2DTwoBoneIK_set_target_minimum_distance :: (using self: *SkeletonModification2DTwoBoneIK, minimum_distance: float) {
}
SkeletonModification2DTwoBoneIK_get_target_minimum_distance :: (using self: *SkeletonModification2DTwoBoneIK) -> float {
}
SkeletonModification2DTwoBoneIK_set_target_maximum_distance :: (using self: *SkeletonModification2DTwoBoneIK, maximum_distance: float) {
}
SkeletonModification2DTwoBoneIK_get_target_maximum_distance :: (using self: *SkeletonModification2DTwoBoneIK) -> float {
}
SkeletonModification2DTwoBoneIK_set_flip_bend_direction :: (using self: *SkeletonModification2DTwoBoneIK, flip_direction: bool) {
}
SkeletonModification2DTwoBoneIK_get_flip_bend_direction :: (using self: *SkeletonModification2DTwoBoneIK) -> bool {
}
SkeletonModification2DTwoBoneIK_set_joint_one_bone2d_node :: (using self: *SkeletonModification2DTwoBoneIK, bone2d_node: NodePath) {
}
SkeletonModification2DTwoBoneIK_get_joint_one_bone2d_node :: (using self: *SkeletonModification2DTwoBoneIK) -> NodePath {
}
SkeletonModification2DTwoBoneIK_set_joint_one_bone_idx :: (using self: *SkeletonModification2DTwoBoneIK, bone_idx: int) {
}
SkeletonModification2DTwoBoneIK_get_joint_one_bone_idx :: (using self: *SkeletonModification2DTwoBoneIK) -> int {
}
SkeletonModification2DTwoBoneIK_set_joint_two_bone2d_node :: (using self: *SkeletonModification2DTwoBoneIK, bone2d_node: NodePath) {
}
SkeletonModification2DTwoBoneIK_get_joint_two_bone2d_node :: (using self: *SkeletonModification2DTwoBoneIK) -> NodePath {
}
SkeletonModification2DTwoBoneIK_set_joint_two_bone_idx :: (using self: *SkeletonModification2DTwoBoneIK, bone_idx: int) {
}
SkeletonModification2DTwoBoneIK_get_joint_two_bone_idx :: (using self: *SkeletonModification2DTwoBoneIK) -> int {
}

// SkeletonModificationStack2D
SkeletonModificationStack2D :: struct {
	__private: *void;
}

SkeletonModificationStack2D_setup :: (using self: *SkeletonModificationStack2D) {
}
SkeletonModificationStack2D_execute :: (using self: *SkeletonModificationStack2D, delta: float, execution_mode: int) {
}
SkeletonModificationStack2D_enable_all_modifications :: (using self: *SkeletonModificationStack2D, enabled: bool) {
}
SkeletonModificationStack2D_get_modification :: (using self: *SkeletonModificationStack2D, mod_idx: int) -> SkeletonModification2D {
}
SkeletonModificationStack2D_add_modification :: (using self: *SkeletonModificationStack2D, modification: SkeletonModification2D) {
}
SkeletonModificationStack2D_delete_modification :: (using self: *SkeletonModificationStack2D, mod_idx: int) {
}
SkeletonModificationStack2D_set_modification :: (using self: *SkeletonModificationStack2D, mod_idx: int, modification: SkeletonModification2D) {
}
SkeletonModificationStack2D_set_modification_count :: (using self: *SkeletonModificationStack2D, count: int) {
}
SkeletonModificationStack2D_get_modification_count :: (using self: *SkeletonModificationStack2D) -> int {
}
SkeletonModificationStack2D_get_is_setup :: (using self: *SkeletonModificationStack2D) -> bool {
}
SkeletonModificationStack2D_set_enabled :: (using self: *SkeletonModificationStack2D, enabled: bool) {
}
SkeletonModificationStack2D_get_enabled :: (using self: *SkeletonModificationStack2D) -> bool {
}
SkeletonModificationStack2D_set_strength :: (using self: *SkeletonModificationStack2D, strength: float) {
}
SkeletonModificationStack2D_get_strength :: (using self: *SkeletonModificationStack2D) -> float {
}
SkeletonModificationStack2D_get_skeleton :: (using self: *SkeletonModificationStack2D) -> Skeleton2D {
}

// SkeletonModifier3D
SkeletonModifier3D :: struct {
	__private: *void;
}

SkeletonModifier3D__process_modification :: (using self: *SkeletonModifier3D) {
}
SkeletonModifier3D_get_skeleton :: (using self: *SkeletonModifier3D) -> Skeleton3D {
}
SkeletonModifier3D_set_active :: (using self: *SkeletonModifier3D, active: bool) {
}
SkeletonModifier3D_is_active :: (using self: *SkeletonModifier3D) -> bool {
}
SkeletonModifier3D_set_influence :: (using self: *SkeletonModifier3D, influence: float) {
}
SkeletonModifier3D_get_influence :: (using self: *SkeletonModifier3D) -> float {
}

// SkeletonProfile
SkeletonProfile :: struct {
	__private: *void;

	TailDirection :: enum {
		TAIL_DIRECTION_AVERAGE_CHILDREN :: 0;
		TAIL_DIRECTION_SPECIFIC_CHILD :: 1;
		TAIL_DIRECTION_END :: 2;
	}
}

SkeletonProfile_set_root_bone :: (using self: *SkeletonProfile, bone_name: StringName) {
}
SkeletonProfile_get_root_bone :: (using self: *SkeletonProfile) -> StringName {
}
SkeletonProfile_set_scale_base_bone :: (using self: *SkeletonProfile, bone_name: StringName) {
}
SkeletonProfile_get_scale_base_bone :: (using self: *SkeletonProfile) -> StringName {
}
SkeletonProfile_set_group_size :: (using self: *SkeletonProfile, size: int) {
}
SkeletonProfile_get_group_size :: (using self: *SkeletonProfile) -> int {
}
SkeletonProfile_get_group_name :: (using self: *SkeletonProfile, group_idx: int) -> StringName {
}
SkeletonProfile_set_group_name :: (using self: *SkeletonProfile, group_idx: int, group_name: StringName) {
}
SkeletonProfile_get_texture :: (using self: *SkeletonProfile, group_idx: int) -> Texture2D {
}
SkeletonProfile_set_texture :: (using self: *SkeletonProfile, group_idx: int, texture: Texture2D) {
}
SkeletonProfile_set_bone_size :: (using self: *SkeletonProfile, size: int) {
}
SkeletonProfile_get_bone_size :: (using self: *SkeletonProfile) -> int {
}
SkeletonProfile_find_bone :: (using self: *SkeletonProfile, bone_name: StringName) -> int {
}
SkeletonProfile_get_bone_name :: (using self: *SkeletonProfile, bone_idx: int) -> StringName {
}
SkeletonProfile_set_bone_name :: (using self: *SkeletonProfile, bone_idx: int, bone_name: StringName) {
}
SkeletonProfile_get_bone_parent :: (using self: *SkeletonProfile, bone_idx: int) -> StringName {
}
SkeletonProfile_set_bone_parent :: (using self: *SkeletonProfile, bone_idx: int, bone_parent: StringName) {
}
SkeletonProfile_get_tail_direction :: (using self: *SkeletonProfile, bone_idx: int) -> SkeletonProfile.TailDirection {
}
SkeletonProfile_set_tail_direction :: (using self: *SkeletonProfile, bone_idx: int, tail_direction: SkeletonProfile.TailDirection) {
}
SkeletonProfile_get_bone_tail :: (using self: *SkeletonProfile, bone_idx: int) -> StringName {
}
SkeletonProfile_set_bone_tail :: (using self: *SkeletonProfile, bone_idx: int, bone_tail: StringName) {
}
SkeletonProfile_get_reference_pose :: (using self: *SkeletonProfile, bone_idx: int) -> Transform3D {
}
SkeletonProfile_set_reference_pose :: (using self: *SkeletonProfile, bone_idx: int, bone_name: Transform3D) {
}
SkeletonProfile_get_handle_offset :: (using self: *SkeletonProfile, bone_idx: int) -> Vector2 {
}
SkeletonProfile_set_handle_offset :: (using self: *SkeletonProfile, bone_idx: int, handle_offset: Vector2) {
}
SkeletonProfile_get_group :: (using self: *SkeletonProfile, bone_idx: int) -> StringName {
}
SkeletonProfile_set_group :: (using self: *SkeletonProfile, bone_idx: int, group: StringName) {
}
SkeletonProfile_is_required :: (using self: *SkeletonProfile, bone_idx: int) -> bool {
}
SkeletonProfile_set_required :: (using self: *SkeletonProfile, bone_idx: int, required: bool) {
}

// SkeletonProfileHumanoid
SkeletonProfileHumanoid :: struct {
	__private: *void;
}

// Skin
Skin :: struct {
	__private: *void;
}

Skin_set_bind_count :: (using self: *Skin, bind_count: int) {
}
Skin_get_bind_count :: (using self: *Skin) -> int {
}
Skin_add_bind :: (using self: *Skin, bone: int, pose: Transform3D) {
}
Skin_add_named_bind :: (using self: *Skin, name: String, pose: Transform3D) {
}
Skin_set_bind_pose :: (using self: *Skin, bind_index: int, pose: Transform3D) {
}
Skin_get_bind_pose :: (using self: *Skin, bind_index: int) -> Transform3D {
}
Skin_set_bind_name :: (using self: *Skin, bind_index: int, name: StringName) {
}
Skin_get_bind_name :: (using self: *Skin, bind_index: int) -> StringName {
}
Skin_set_bind_bone :: (using self: *Skin, bind_index: int, bone: int) {
}
Skin_get_bind_bone :: (using self: *Skin, bind_index: int) -> int {
}
Skin_clear_binds :: (using self: *Skin) {
}

// SkinReference
SkinReference :: struct {
	__private: *void;
}

SkinReference_get_skeleton :: (using self: *SkinReference) -> RID {
}
SkinReference_get_skin :: (using self: *SkinReference) -> Skin {
}

// Sky
Sky :: struct {
	__private: *void;

	RadianceSize :: enum {
		RADIANCE_SIZE_32 :: 0;
		RADIANCE_SIZE_64 :: 1;
		RADIANCE_SIZE_128 :: 2;
		RADIANCE_SIZE_256 :: 3;
		RADIANCE_SIZE_512 :: 4;
		RADIANCE_SIZE_1024 :: 5;
		RADIANCE_SIZE_2048 :: 6;
		RADIANCE_SIZE_MAX :: 7;
	}
	ProcessMode :: enum {
		PROCESS_MODE_AUTOMATIC :: 0;
		PROCESS_MODE_QUALITY :: 1;
		PROCESS_MODE_INCREMENTAL :: 2;
		PROCESS_MODE_REALTIME :: 3;
	}
}

Sky_set_radiance_size :: (using self: *Sky, size: Sky.RadianceSize) {
}
Sky_get_radiance_size :: (using self: *Sky) -> Sky.RadianceSize {
}
Sky_set_process_mode :: (using self: *Sky, mode: Sky.ProcessMode) {
}
Sky_get_process_mode :: (using self: *Sky) -> Sky.ProcessMode {
}
Sky_set_material :: (using self: *Sky, material: Material) {
}
Sky_get_material :: (using self: *Sky) -> Material {
}

// Slider
Slider :: struct {
	__private: *void;
}

Slider_set_ticks :: (using self: *Slider, count: int) {
}
Slider_get_ticks :: (using self: *Slider) -> int {
}
Slider_get_ticks_on_borders :: (using self: *Slider) -> bool {
}
Slider_set_ticks_on_borders :: (using self: *Slider, ticks_on_border: bool) {
}
Slider_set_editable :: (using self: *Slider, editable: bool) {
}
Slider_is_editable :: (using self: *Slider) -> bool {
}
Slider_set_scrollable :: (using self: *Slider, scrollable: bool) {
}
Slider_is_scrollable :: (using self: *Slider) -> bool {
}

// SliderJoint3D
SliderJoint3D :: struct {
	__private: *void;

	Param :: enum {
		PARAM_LINEAR_LIMIT_UPPER :: 0;
		PARAM_LINEAR_LIMIT_LOWER :: 1;
		PARAM_LINEAR_LIMIT_SOFTNESS :: 2;
		PARAM_LINEAR_LIMIT_RESTITUTION :: 3;
		PARAM_LINEAR_LIMIT_DAMPING :: 4;
		PARAM_LINEAR_MOTION_SOFTNESS :: 5;
		PARAM_LINEAR_MOTION_RESTITUTION :: 6;
		PARAM_LINEAR_MOTION_DAMPING :: 7;
		PARAM_LINEAR_ORTHOGONAL_SOFTNESS :: 8;
		PARAM_LINEAR_ORTHOGONAL_RESTITUTION :: 9;
		PARAM_LINEAR_ORTHOGONAL_DAMPING :: 10;
		PARAM_ANGULAR_LIMIT_UPPER :: 11;
		PARAM_ANGULAR_LIMIT_LOWER :: 12;
		PARAM_ANGULAR_LIMIT_SOFTNESS :: 13;
		PARAM_ANGULAR_LIMIT_RESTITUTION :: 14;
		PARAM_ANGULAR_LIMIT_DAMPING :: 15;
		PARAM_ANGULAR_MOTION_SOFTNESS :: 16;
		PARAM_ANGULAR_MOTION_RESTITUTION :: 17;
		PARAM_ANGULAR_MOTION_DAMPING :: 18;
		PARAM_ANGULAR_ORTHOGONAL_SOFTNESS :: 19;
		PARAM_ANGULAR_ORTHOGONAL_RESTITUTION :: 20;
		PARAM_ANGULAR_ORTHOGONAL_DAMPING :: 21;
		PARAM_MAX :: 22;
	}
}

SliderJoint3D_set_param :: (using self: *SliderJoint3D, param: SliderJoint3D.Param, value: float) {
}
SliderJoint3D_get_param :: (using self: *SliderJoint3D, param: SliderJoint3D.Param) -> float {
}

// SoftBody3D
SoftBody3D :: struct {
	__private: *void;

	DisableMode :: enum {
		DISABLE_MODE_REMOVE :: 0;
		DISABLE_MODE_KEEP_ACTIVE :: 1;
	}
}

SoftBody3D_get_physics_rid :: (using self: *SoftBody3D) -> RID {
}
SoftBody3D_set_collision_mask :: (using self: *SoftBody3D, collision_mask: int) {
}
SoftBody3D_get_collision_mask :: (using self: *SoftBody3D) -> int {
}
SoftBody3D_set_collision_layer :: (using self: *SoftBody3D, collision_layer: int) {
}
SoftBody3D_get_collision_layer :: (using self: *SoftBody3D) -> int {
}
SoftBody3D_set_collision_mask_value :: (using self: *SoftBody3D, layer_number: int, value: bool) {
}
SoftBody3D_get_collision_mask_value :: (using self: *SoftBody3D, layer_number: int) -> bool {
}
SoftBody3D_set_collision_layer_value :: (using self: *SoftBody3D, layer_number: int, value: bool) {
}
SoftBody3D_get_collision_layer_value :: (using self: *SoftBody3D, layer_number: int) -> bool {
}
SoftBody3D_set_parent_collision_ignore :: (using self: *SoftBody3D, parent_collision_ignore: NodePath) {
}
SoftBody3D_get_parent_collision_ignore :: (using self: *SoftBody3D) -> NodePath {
}
SoftBody3D_set_disable_mode :: (using self: *SoftBody3D, mode: SoftBody3D.DisableMode) {
}
SoftBody3D_get_disable_mode :: (using self: *SoftBody3D) -> SoftBody3D.DisableMode {
}
SoftBody3D_get_collision_exceptions :: (using self: *SoftBody3D) -> Array {
}
SoftBody3D_add_collision_exception_with :: (using self: *SoftBody3D, body: Node) {
}
SoftBody3D_remove_collision_exception_with :: (using self: *SoftBody3D, body: Node) {
}
SoftBody3D_set_simulation_precision :: (using self: *SoftBody3D, simulation_precision: int) {
}
SoftBody3D_get_simulation_precision :: (using self: *SoftBody3D) -> int {
}
SoftBody3D_set_total_mass :: (using self: *SoftBody3D, mass: float) {
}
SoftBody3D_get_total_mass :: (using self: *SoftBody3D) -> float {
}
SoftBody3D_set_linear_stiffness :: (using self: *SoftBody3D, linear_stiffness: float) {
}
SoftBody3D_get_linear_stiffness :: (using self: *SoftBody3D) -> float {
}
SoftBody3D_set_pressure_coefficient :: (using self: *SoftBody3D, pressure_coefficient: float) {
}
SoftBody3D_get_pressure_coefficient :: (using self: *SoftBody3D) -> float {
}
SoftBody3D_set_damping_coefficient :: (using self: *SoftBody3D, damping_coefficient: float) {
}
SoftBody3D_get_damping_coefficient :: (using self: *SoftBody3D) -> float {
}
SoftBody3D_set_drag_coefficient :: (using self: *SoftBody3D, drag_coefficient: float) {
}
SoftBody3D_get_drag_coefficient :: (using self: *SoftBody3D) -> float {
}
SoftBody3D_get_point_transform :: (using self: *SoftBody3D, point_index: int) -> Vector3 {
}
SoftBody3D_set_point_pinned :: (using self: *SoftBody3D, point_index: int, pinned: bool, attachment_path: NodePath) {
}
SoftBody3D_is_point_pinned :: (using self: *SoftBody3D, point_index: int) -> bool {
}
SoftBody3D_set_ray_pickable :: (using self: *SoftBody3D, ray_pickable: bool) {
}
SoftBody3D_is_ray_pickable :: (using self: *SoftBody3D) -> bool {
}

// SphereMesh
SphereMesh :: struct {
	__private: *void;
}

SphereMesh_set_radius :: (using self: *SphereMesh, radius: float) {
}
SphereMesh_get_radius :: (using self: *SphereMesh) -> float {
}
SphereMesh_set_height :: (using self: *SphereMesh, height: float) {
}
SphereMesh_get_height :: (using self: *SphereMesh) -> float {
}
SphereMesh_set_radial_segments :: (using self: *SphereMesh, radial_segments: int) {
}
SphereMesh_get_radial_segments :: (using self: *SphereMesh) -> int {
}
SphereMesh_set_rings :: (using self: *SphereMesh, rings: int) {
}
SphereMesh_get_rings :: (using self: *SphereMesh) -> int {
}
SphereMesh_set_is_hemisphere :: (using self: *SphereMesh, is_hemisphere: bool) {
}
SphereMesh_get_is_hemisphere :: (using self: *SphereMesh) -> bool {
}

// SphereOccluder3D
SphereOccluder3D :: struct {
	__private: *void;
}

SphereOccluder3D_set_radius :: (using self: *SphereOccluder3D, radius: float) {
}
SphereOccluder3D_get_radius :: (using self: *SphereOccluder3D) -> float {
}

// SphereShape3D
SphereShape3D :: struct {
	__private: *void;
}

SphereShape3D_set_radius :: (using self: *SphereShape3D, radius: float) {
}
SphereShape3D_get_radius :: (using self: *SphereShape3D) -> float {
}

// SpinBox
SpinBox :: struct {
	__private: *void;
}

SpinBox_set_horizontal_alignment :: (using self: *SpinBox, alignment: HorizontalAlignment) {
}
SpinBox_get_horizontal_alignment :: (using self: *SpinBox) -> HorizontalAlignment {
}
SpinBox_set_suffix :: (using self: *SpinBox, suffix: String) {
}
SpinBox_get_suffix :: (using self: *SpinBox) -> String {
}
SpinBox_set_prefix :: (using self: *SpinBox, prefix: String) {
}
SpinBox_get_prefix :: (using self: *SpinBox) -> String {
}
SpinBox_set_editable :: (using self: *SpinBox, enabled: bool) {
}
SpinBox_set_custom_arrow_step :: (using self: *SpinBox, arrow_step: float) {
}
SpinBox_get_custom_arrow_step :: (using self: *SpinBox) -> float {
}
SpinBox_is_editable :: (using self: *SpinBox) -> bool {
}
SpinBox_set_update_on_text_changed :: (using self: *SpinBox, enabled: bool) {
}
SpinBox_get_update_on_text_changed :: (using self: *SpinBox) -> bool {
}
SpinBox_set_select_all_on_focus :: (using self: *SpinBox, enabled: bool) {
}
SpinBox_is_select_all_on_focus :: (using self: *SpinBox) -> bool {
}
SpinBox_apply :: (using self: *SpinBox) {
}
SpinBox_get_line_edit :: (using self: *SpinBox) -> LineEdit {
}

// SplitContainer
SplitContainer :: struct {
	__private: *void;

	DraggerVisibility :: enum {
		DRAGGER_VISIBLE :: 0;
		DRAGGER_HIDDEN :: 1;
		DRAGGER_HIDDEN_COLLAPSED :: 2;
	}
}

SplitContainer_set_split_offset :: (using self: *SplitContainer, offset: int) {
}
SplitContainer_get_split_offset :: (using self: *SplitContainer) -> int {
}
SplitContainer_clamp_split_offset :: (using self: *SplitContainer) {
}
SplitContainer_set_collapsed :: (using self: *SplitContainer, collapsed: bool) {
}
SplitContainer_is_collapsed :: (using self: *SplitContainer) -> bool {
}
SplitContainer_set_dragger_visibility :: (using self: *SplitContainer, mode: SplitContainer.DraggerVisibility) {
}
SplitContainer_get_dragger_visibility :: (using self: *SplitContainer) -> SplitContainer.DraggerVisibility {
}
SplitContainer_set_vertical :: (using self: *SplitContainer, vertical: bool) {
}
SplitContainer_is_vertical :: (using self: *SplitContainer) -> bool {
}

// SpotLight3D
SpotLight3D :: struct {
	__private: *void;
}

// SpringArm3D
SpringArm3D :: struct {
	__private: *void;
}

SpringArm3D_get_hit_length :: (using self: *SpringArm3D) -> float {
}
SpringArm3D_set_length :: (using self: *SpringArm3D, length: float) {
}
SpringArm3D_get_length :: (using self: *SpringArm3D) -> float {
}
SpringArm3D_set_shape :: (using self: *SpringArm3D, shape: Shape3D) {
}
SpringArm3D_get_shape :: (using self: *SpringArm3D) -> Shape3D {
}
SpringArm3D_add_excluded_object :: (using self: *SpringArm3D, rid: RID) {
}
SpringArm3D_remove_excluded_object :: (using self: *SpringArm3D, rid: RID) -> bool {
}
SpringArm3D_clear_excluded_objects :: (using self: *SpringArm3D) {
}
SpringArm3D_set_collision_mask :: (using self: *SpringArm3D, mask: int) {
}
SpringArm3D_get_collision_mask :: (using self: *SpringArm3D) -> int {
}
SpringArm3D_set_margin :: (using self: *SpringArm3D, margin: float) {
}
SpringArm3D_get_margin :: (using self: *SpringArm3D) -> float {
}

// Sprite2D
Sprite2D :: struct {
	__private: *void;
}

Sprite2D_set_texture :: (using self: *Sprite2D, texture: Texture2D) {
}
Sprite2D_get_texture :: (using self: *Sprite2D) -> Texture2D {
}
Sprite2D_set_centered :: (using self: *Sprite2D, centered: bool) {
}
Sprite2D_is_centered :: (using self: *Sprite2D) -> bool {
}
Sprite2D_set_offset :: (using self: *Sprite2D, offset: Vector2) {
}
Sprite2D_get_offset :: (using self: *Sprite2D) -> Vector2 {
}
Sprite2D_set_flip_h :: (using self: *Sprite2D, flip_h: bool) {
}
Sprite2D_is_flipped_h :: (using self: *Sprite2D) -> bool {
}
Sprite2D_set_flip_v :: (using self: *Sprite2D, flip_v: bool) {
}
Sprite2D_is_flipped_v :: (using self: *Sprite2D) -> bool {
}
Sprite2D_set_region_enabled :: (using self: *Sprite2D, enabled: bool) {
}
Sprite2D_is_region_enabled :: (using self: *Sprite2D) -> bool {
}
Sprite2D_is_pixel_opaque :: (using self: *Sprite2D, pos: Vector2) -> bool {
}
Sprite2D_set_region_rect :: (using self: *Sprite2D, rect: Rect2) {
}
Sprite2D_get_region_rect :: (using self: *Sprite2D) -> Rect2 {
}
Sprite2D_set_region_filter_clip_enabled :: (using self: *Sprite2D, enabled: bool) {
}
Sprite2D_is_region_filter_clip_enabled :: (using self: *Sprite2D) -> bool {
}
Sprite2D_set_frame :: (using self: *Sprite2D, frame: int) {
}
Sprite2D_get_frame :: (using self: *Sprite2D) -> int {
}
Sprite2D_set_frame_coords :: (using self: *Sprite2D, coords: Vector2i) {
}
Sprite2D_get_frame_coords :: (using self: *Sprite2D) -> Vector2i {
}
Sprite2D_set_vframes :: (using self: *Sprite2D, vframes: int) {
}
Sprite2D_get_vframes :: (using self: *Sprite2D) -> int {
}
Sprite2D_set_hframes :: (using self: *Sprite2D, hframes: int) {
}
Sprite2D_get_hframes :: (using self: *Sprite2D) -> int {
}
Sprite2D_get_rect :: (using self: *Sprite2D) -> Rect2 {
}

// Sprite3D
Sprite3D :: struct {
	__private: *void;
}

Sprite3D_set_texture :: (using self: *Sprite3D, texture: Texture2D) {
}
Sprite3D_get_texture :: (using self: *Sprite3D) -> Texture2D {
}
Sprite3D_set_region_enabled :: (using self: *Sprite3D, enabled: bool) {
}
Sprite3D_is_region_enabled :: (using self: *Sprite3D) -> bool {
}
Sprite3D_set_region_rect :: (using self: *Sprite3D, rect: Rect2) {
}
Sprite3D_get_region_rect :: (using self: *Sprite3D) -> Rect2 {
}
Sprite3D_set_frame :: (using self: *Sprite3D, frame: int) {
}
Sprite3D_get_frame :: (using self: *Sprite3D) -> int {
}
Sprite3D_set_frame_coords :: (using self: *Sprite3D, coords: Vector2i) {
}
Sprite3D_get_frame_coords :: (using self: *Sprite3D) -> Vector2i {
}
Sprite3D_set_vframes :: (using self: *Sprite3D, vframes: int) {
}
Sprite3D_get_vframes :: (using self: *Sprite3D) -> int {
}
Sprite3D_set_hframes :: (using self: *Sprite3D, hframes: int) {
}
Sprite3D_get_hframes :: (using self: *Sprite3D) -> int {
}

// SpriteBase3D
SpriteBase3D :: struct {
	__private: *void;

	DrawFlags :: enum {
		FLAG_TRANSPARENT :: 0;
		FLAG_SHADED :: 1;
		FLAG_DOUBLE_SIDED :: 2;
		FLAG_DISABLE_DEPTH_TEST :: 3;
		FLAG_FIXED_SIZE :: 4;
		FLAG_MAX :: 5;
	}
	AlphaCutMode :: enum {
		ALPHA_CUT_DISABLED :: 0;
		ALPHA_CUT_DISCARD :: 1;
		ALPHA_CUT_OPAQUE_PREPASS :: 2;
		ALPHA_CUT_HASH :: 3;
	}
}

SpriteBase3D_set_centered :: (using self: *SpriteBase3D, centered: bool) {
}
SpriteBase3D_is_centered :: (using self: *SpriteBase3D) -> bool {
}
SpriteBase3D_set_offset :: (using self: *SpriteBase3D, offset: Vector2) {
}
SpriteBase3D_get_offset :: (using self: *SpriteBase3D) -> Vector2 {
}
SpriteBase3D_set_flip_h :: (using self: *SpriteBase3D, flip_h: bool) {
}
SpriteBase3D_is_flipped_h :: (using self: *SpriteBase3D) -> bool {
}
SpriteBase3D_set_flip_v :: (using self: *SpriteBase3D, flip_v: bool) {
}
SpriteBase3D_is_flipped_v :: (using self: *SpriteBase3D) -> bool {
}
SpriteBase3D_set_modulate :: (using self: *SpriteBase3D, modulate: Color) {
}
SpriteBase3D_get_modulate :: (using self: *SpriteBase3D) -> Color {
}
SpriteBase3D_set_render_priority :: (using self: *SpriteBase3D, priority: int) {
}
SpriteBase3D_get_render_priority :: (using self: *SpriteBase3D) -> int {
}
SpriteBase3D_set_pixel_size :: (using self: *SpriteBase3D, pixel_size: float) {
}
SpriteBase3D_get_pixel_size :: (using self: *SpriteBase3D) -> float {
}
SpriteBase3D_set_axis :: (using self: *SpriteBase3D, axis: Vector3.Axis) {
}
SpriteBase3D_get_axis :: (using self: *SpriteBase3D) -> Vector3.Axis {
}
SpriteBase3D_set_draw_flag :: (using self: *SpriteBase3D, flag: SpriteBase3D.DrawFlags, enabled: bool) {
}
SpriteBase3D_get_draw_flag :: (using self: *SpriteBase3D, flag: SpriteBase3D.DrawFlags) -> bool {
}
SpriteBase3D_set_alpha_cut_mode :: (using self: *SpriteBase3D, mode: SpriteBase3D.AlphaCutMode) {
}
SpriteBase3D_get_alpha_cut_mode :: (using self: *SpriteBase3D) -> SpriteBase3D.AlphaCutMode {
}
SpriteBase3D_set_alpha_scissor_threshold :: (using self: *SpriteBase3D, threshold: float) {
}
SpriteBase3D_get_alpha_scissor_threshold :: (using self: *SpriteBase3D) -> float {
}
SpriteBase3D_set_alpha_hash_scale :: (using self: *SpriteBase3D, threshold: float) {
}
SpriteBase3D_get_alpha_hash_scale :: (using self: *SpriteBase3D) -> float {
}
SpriteBase3D_set_alpha_antialiasing :: (using self: *SpriteBase3D, alpha_aa: BaseMaterial3D.AlphaAntiAliasing) {
}
SpriteBase3D_get_alpha_antialiasing :: (using self: *SpriteBase3D) -> BaseMaterial3D.AlphaAntiAliasing {
}
SpriteBase3D_set_alpha_antialiasing_edge :: (using self: *SpriteBase3D, edge: float) {
}
SpriteBase3D_get_alpha_antialiasing_edge :: (using self: *SpriteBase3D) -> float {
}
SpriteBase3D_set_billboard_mode :: (using self: *SpriteBase3D, mode: BaseMaterial3D.BillboardMode) {
}
SpriteBase3D_get_billboard_mode :: (using self: *SpriteBase3D) -> BaseMaterial3D.BillboardMode {
}
SpriteBase3D_set_texture_filter :: (using self: *SpriteBase3D, mode: BaseMaterial3D.TextureFilter) {
}
SpriteBase3D_get_texture_filter :: (using self: *SpriteBase3D) -> BaseMaterial3D.TextureFilter {
}
SpriteBase3D_get_item_rect :: (using self: *SpriteBase3D) -> Rect2 {
}
SpriteBase3D_generate_triangle_mesh :: (using self: *SpriteBase3D) -> TriangleMesh {
}

// SpriteFrames
SpriteFrames :: struct {
	__private: *void;
}

SpriteFrames_add_animation :: (using self: *SpriteFrames, anim: StringName) {
}
SpriteFrames_has_animation :: (using self: *SpriteFrames, anim: StringName) -> bool {
}
SpriteFrames_remove_animation :: (using self: *SpriteFrames, anim: StringName) {
}
SpriteFrames_rename_animation :: (using self: *SpriteFrames, anim: StringName, newname: StringName) {
}
SpriteFrames_get_animation_names :: (using self: *SpriteFrames) -> PackedStringArray {
}
SpriteFrames_set_animation_speed :: (using self: *SpriteFrames, anim: StringName, fps: float) {
}
SpriteFrames_get_animation_speed :: (using self: *SpriteFrames, anim: StringName) -> float {
}
SpriteFrames_set_animation_loop :: (using self: *SpriteFrames, anim: StringName, loop: bool) {
}
SpriteFrames_get_animation_loop :: (using self: *SpriteFrames, anim: StringName) -> bool {
}
SpriteFrames_add_frame :: (using self: *SpriteFrames, anim: StringName, texture: Texture2D, duration: float, at_position: int) {
}
SpriteFrames_set_frame :: (using self: *SpriteFrames, anim: StringName, idx: int, texture: Texture2D, duration: float) {
}
SpriteFrames_remove_frame :: (using self: *SpriteFrames, anim: StringName, idx: int) {
}
SpriteFrames_get_frame_count :: (using self: *SpriteFrames, anim: StringName) -> int {
}
SpriteFrames_get_frame_texture :: (using self: *SpriteFrames, anim: StringName, idx: int) -> Texture2D {
}
SpriteFrames_get_frame_duration :: (using self: *SpriteFrames, anim: StringName, idx: int) -> float {
}
SpriteFrames_clear :: (using self: *SpriteFrames, anim: StringName) {
}
SpriteFrames_clear_all :: (using self: *SpriteFrames) {
}

// StandardMaterial3D
StandardMaterial3D :: struct {
	__private: *void;
}

// StaticBody2D
StaticBody2D :: struct {
	__private: *void;
}

StaticBody2D_set_constant_linear_velocity :: (using self: *StaticBody2D, vel: Vector2) {
}
StaticBody2D_set_constant_angular_velocity :: (using self: *StaticBody2D, vel: float) {
}
StaticBody2D_get_constant_linear_velocity :: (using self: *StaticBody2D) -> Vector2 {
}
StaticBody2D_get_constant_angular_velocity :: (using self: *StaticBody2D) -> float {
}
StaticBody2D_set_physics_material_override :: (using self: *StaticBody2D, physics_material_override: PhysicsMaterial) {
}
StaticBody2D_get_physics_material_override :: (using self: *StaticBody2D) -> PhysicsMaterial {
}

// StaticBody3D
StaticBody3D :: struct {
	__private: *void;
}

StaticBody3D_set_constant_linear_velocity :: (using self: *StaticBody3D, vel: Vector3) {
}
StaticBody3D_set_constant_angular_velocity :: (using self: *StaticBody3D, vel: Vector3) {
}
StaticBody3D_get_constant_linear_velocity :: (using self: *StaticBody3D) -> Vector3 {
}
StaticBody3D_get_constant_angular_velocity :: (using self: *StaticBody3D) -> Vector3 {
}
StaticBody3D_set_physics_material_override :: (using self: *StaticBody3D, physics_material_override: PhysicsMaterial) {
}
StaticBody3D_get_physics_material_override :: (using self: *StaticBody3D) -> PhysicsMaterial {
}

// StatusIndicator
StatusIndicator :: struct {
	__private: *void;
}

StatusIndicator_set_tooltip :: (using self: *StatusIndicator, tooltip: String) {
}
StatusIndicator_get_tooltip :: (using self: *StatusIndicator) -> String {
}
StatusIndicator_set_icon :: (using self: *StatusIndicator, texture: Texture2D) {
}
StatusIndicator_get_icon :: (using self: *StatusIndicator) -> Texture2D {
}
StatusIndicator_set_visible :: (using self: *StatusIndicator, visible: bool) {
}
StatusIndicator_is_visible :: (using self: *StatusIndicator) -> bool {
}
StatusIndicator_set_menu :: (using self: *StatusIndicator, menu: NodePath) {
}
StatusIndicator_get_menu :: (using self: *StatusIndicator) -> NodePath {
}
StatusIndicator_get_rect :: (using self: *StatusIndicator) -> Rect2 {
}

// StreamPeer
StreamPeer :: struct {
	__private: *void;
}

StreamPeer_put_data :: (using self: *StreamPeer, data: PackedByteArray) -> Error {
}
StreamPeer_put_partial_data :: (using self: *StreamPeer, data: PackedByteArray) -> Array {
}
StreamPeer_get_data :: (using self: *StreamPeer, bytes: int) -> Array {
}
StreamPeer_get_partial_data :: (using self: *StreamPeer, bytes: int) -> Array {
}
StreamPeer_get_available_bytes :: (using self: *StreamPeer) -> int {
}
StreamPeer_set_big_endian :: (using self: *StreamPeer, enable: bool) {
}
StreamPeer_is_big_endian_enabled :: (using self: *StreamPeer) -> bool {
}
StreamPeer_put_8 :: (using self: *StreamPeer, value: int) {
}
StreamPeer_put_u8 :: (using self: *StreamPeer, value: int) {
}
StreamPeer_put_16 :: (using self: *StreamPeer, value: int) {
}
StreamPeer_put_u16 :: (using self: *StreamPeer, value: int) {
}
StreamPeer_put_32 :: (using self: *StreamPeer, value: int) {
}
StreamPeer_put_u32 :: (using self: *StreamPeer, value: int) {
}
StreamPeer_put_64 :: (using self: *StreamPeer, value: int) {
}
StreamPeer_put_u64 :: (using self: *StreamPeer, value: int) {
}
StreamPeer_put_float :: (using self: *StreamPeer, value: float) {
}
StreamPeer_put_double :: (using self: *StreamPeer, value: float) {
}
StreamPeer_put_string :: (using self: *StreamPeer, value: String) {
}
StreamPeer_put_utf8_string :: (using self: *StreamPeer, value: String) {
}
StreamPeer_put_var :: (using self: *StreamPeer, value: Variant, full_objects: bool) {
}
StreamPeer_get_8 :: (using self: *StreamPeer) -> int {
}
StreamPeer_get_u8 :: (using self: *StreamPeer) -> int {
}
StreamPeer_get_16 :: (using self: *StreamPeer) -> int {
}
StreamPeer_get_u16 :: (using self: *StreamPeer) -> int {
}
StreamPeer_get_32 :: (using self: *StreamPeer) -> int {
}
StreamPeer_get_u32 :: (using self: *StreamPeer) -> int {
}
StreamPeer_get_64 :: (using self: *StreamPeer) -> int {
}
StreamPeer_get_u64 :: (using self: *StreamPeer) -> int {
}
StreamPeer_get_float :: (using self: *StreamPeer) -> float {
}
StreamPeer_get_double :: (using self: *StreamPeer) -> float {
}
StreamPeer_get_string :: (using self: *StreamPeer, bytes: int) -> String {
}
StreamPeer_get_utf8_string :: (using self: *StreamPeer, bytes: int) -> String {
}
StreamPeer_get_var :: (using self: *StreamPeer, allow_objects: bool) -> Variant {
}

// StreamPeerBuffer
StreamPeerBuffer :: struct {
	__private: *void;
}

StreamPeerBuffer_seek :: (using self: *StreamPeerBuffer, position: int) {
}
StreamPeerBuffer_get_size :: (using self: *StreamPeerBuffer) -> int {
}
StreamPeerBuffer_get_position :: (using self: *StreamPeerBuffer) -> int {
}
StreamPeerBuffer_resize :: (using self: *StreamPeerBuffer, size: int) {
}
StreamPeerBuffer_set_data_array :: (using self: *StreamPeerBuffer, data: PackedByteArray) {
}
StreamPeerBuffer_get_data_array :: (using self: *StreamPeerBuffer) -> PackedByteArray {
}
StreamPeerBuffer_clear :: (using self: *StreamPeerBuffer) {
}
StreamPeerBuffer_duplicate :: (using self: *StreamPeerBuffer) -> StreamPeerBuffer {
}

// StreamPeerExtension
StreamPeerExtension :: struct {
	__private: *void;
}

StreamPeerExtension__get_data :: (using self: *StreamPeerExtension, r_buffer: *u8, r_bytes: int, r_received: *s32) -> Error {
}
StreamPeerExtension__get_partial_data :: (using self: *StreamPeerExtension, r_buffer: *u8, r_bytes: int, r_received: *s32) -> Error {
}
StreamPeerExtension__put_data :: (using self: *StreamPeerExtension, p_data: *u8, p_bytes: int, r_sent: *s32) -> Error {
}
StreamPeerExtension__put_partial_data :: (using self: *StreamPeerExtension, p_data: *u8, p_bytes: int, r_sent: *s32) -> Error {
}
StreamPeerExtension__get_available_bytes :: (using self: *StreamPeerExtension) -> int {
}

// StreamPeerGZIP
StreamPeerGZIP :: struct {
	__private: *void;
}

StreamPeerGZIP_start_compression :: (using self: *StreamPeerGZIP, use_deflate: bool, buffer_size: int) -> Error {
}
StreamPeerGZIP_start_decompression :: (using self: *StreamPeerGZIP, use_deflate: bool, buffer_size: int) -> Error {
}
StreamPeerGZIP_finish :: (using self: *StreamPeerGZIP) -> Error {
}
StreamPeerGZIP_clear :: (using self: *StreamPeerGZIP) {
}

// StreamPeerTCP
StreamPeerTCP :: struct {
	__private: *void;

	Status :: enum {
		STATUS_NONE :: 0;
		STATUS_CONNECTING :: 1;
		STATUS_CONNECTED :: 2;
		STATUS_ERROR :: 3;
	}
}

StreamPeerTCP_bind :: (using self: *StreamPeerTCP, port: int, host: String) -> Error {
}
StreamPeerTCP_connect_to_host :: (using self: *StreamPeerTCP, host: String, port: int) -> Error {
}
StreamPeerTCP_poll :: (using self: *StreamPeerTCP) -> Error {
}
StreamPeerTCP_get_status :: (using self: *StreamPeerTCP) -> StreamPeerTCP.Status {
}
StreamPeerTCP_get_connected_host :: (using self: *StreamPeerTCP) -> String {
}
StreamPeerTCP_get_connected_port :: (using self: *StreamPeerTCP) -> int {
}
StreamPeerTCP_get_local_port :: (using self: *StreamPeerTCP) -> int {
}
StreamPeerTCP_disconnect_from_host :: (using self: *StreamPeerTCP) {
}
StreamPeerTCP_set_no_delay :: (using self: *StreamPeerTCP, enabled: bool) {
}

// StreamPeerTLS
StreamPeerTLS :: struct {
	__private: *void;

	Status :: enum {
		STATUS_DISCONNECTED :: 0;
		STATUS_HANDSHAKING :: 1;
		STATUS_CONNECTED :: 2;
		STATUS_ERROR :: 3;
		STATUS_ERROR_HOSTNAME_MISMATCH :: 4;
	}
}

StreamPeerTLS_poll :: (using self: *StreamPeerTLS) {
}
StreamPeerTLS_accept_stream :: (using self: *StreamPeerTLS, stream: StreamPeer, server_options: TLSOptions) -> Error {
}
StreamPeerTLS_connect_to_stream :: (using self: *StreamPeerTLS, stream: StreamPeer, common_name: String, client_options: TLSOptions) -> Error {
}
StreamPeerTLS_get_status :: (using self: *StreamPeerTLS) -> StreamPeerTLS.Status {
}
StreamPeerTLS_get_stream :: (using self: *StreamPeerTLS) -> StreamPeer {
}
StreamPeerTLS_disconnect_from_stream :: (using self: *StreamPeerTLS) {
}

// StyleBox
StyleBox :: struct {
	__private: *void;
}

StyleBox__draw :: (using self: *StyleBox, to_canvas_item: RID, rect: Rect2) {
}
StyleBox__get_draw_rect :: (using self: *StyleBox, rect: Rect2) -> Rect2 {
}
StyleBox__get_minimum_size :: (using self: *StyleBox) -> Vector2 {
}
StyleBox__test_mask :: (using self: *StyleBox, point: Vector2, rect: Rect2) -> bool {
}
StyleBox_get_minimum_size :: (using self: *StyleBox) -> Vector2 {
}
StyleBox_set_content_margin :: (using self: *StyleBox, margin: Side, offset: float) {
}
StyleBox_set_content_margin_all :: (using self: *StyleBox, offset: float) {
}
StyleBox_get_content_margin :: (using self: *StyleBox, margin: Side) -> float {
}
StyleBox_get_margin :: (using self: *StyleBox, margin: Side) -> float {
}
StyleBox_get_offset :: (using self: *StyleBox) -> Vector2 {
}
StyleBox_draw :: (using self: *StyleBox, canvas_item: RID, rect: Rect2) {
}
StyleBox_get_current_item_drawn :: (using self: *StyleBox) -> CanvasItem {
}
StyleBox_test_mask :: (using self: *StyleBox, point: Vector2, rect: Rect2) -> bool {
}

// StyleBoxEmpty
StyleBoxEmpty :: struct {
	__private: *void;
}

// StyleBoxFlat
StyleBoxFlat :: struct {
	__private: *void;
}

StyleBoxFlat_set_bg_color :: (using self: *StyleBoxFlat, color: Color) {
}
StyleBoxFlat_get_bg_color :: (using self: *StyleBoxFlat) -> Color {
}
StyleBoxFlat_set_border_color :: (using self: *StyleBoxFlat, color: Color) {
}
StyleBoxFlat_get_border_color :: (using self: *StyleBoxFlat) -> Color {
}
StyleBoxFlat_set_border_width_all :: (using self: *StyleBoxFlat, width: int) {
}
StyleBoxFlat_get_border_width_min :: (using self: *StyleBoxFlat) -> int {
}
StyleBoxFlat_set_border_width :: (using self: *StyleBoxFlat, margin: Side, width: int) {
}
StyleBoxFlat_get_border_width :: (using self: *StyleBoxFlat, margin: Side) -> int {
}
StyleBoxFlat_set_border_blend :: (using self: *StyleBoxFlat, blend: bool) {
}
StyleBoxFlat_get_border_blend :: (using self: *StyleBoxFlat) -> bool {
}
StyleBoxFlat_set_corner_radius_all :: (using self: *StyleBoxFlat, radius: int) {
}
StyleBoxFlat_set_corner_radius :: (using self: *StyleBoxFlat, corner: Corner, radius: int) {
}
StyleBoxFlat_get_corner_radius :: (using self: *StyleBoxFlat, corner: Corner) -> int {
}
StyleBoxFlat_set_expand_margin :: (using self: *StyleBoxFlat, margin: Side, size: float) {
}
StyleBoxFlat_set_expand_margin_all :: (using self: *StyleBoxFlat, size: float) {
}
StyleBoxFlat_get_expand_margin :: (using self: *StyleBoxFlat, margin: Side) -> float {
}
StyleBoxFlat_set_draw_center :: (using self: *StyleBoxFlat, draw_center: bool) {
}
StyleBoxFlat_is_draw_center_enabled :: (using self: *StyleBoxFlat) -> bool {
}
StyleBoxFlat_set_skew :: (using self: *StyleBoxFlat, skew: Vector2) {
}
StyleBoxFlat_get_skew :: (using self: *StyleBoxFlat) -> Vector2 {
}
StyleBoxFlat_set_shadow_color :: (using self: *StyleBoxFlat, color: Color) {
}
StyleBoxFlat_get_shadow_color :: (using self: *StyleBoxFlat) -> Color {
}
StyleBoxFlat_set_shadow_size :: (using self: *StyleBoxFlat, size: int) {
}
StyleBoxFlat_get_shadow_size :: (using self: *StyleBoxFlat) -> int {
}
StyleBoxFlat_set_shadow_offset :: (using self: *StyleBoxFlat, offset: Vector2) {
}
StyleBoxFlat_get_shadow_offset :: (using self: *StyleBoxFlat) -> Vector2 {
}
StyleBoxFlat_set_anti_aliased :: (using self: *StyleBoxFlat, anti_aliased: bool) {
}
StyleBoxFlat_is_anti_aliased :: (using self: *StyleBoxFlat) -> bool {
}
StyleBoxFlat_set_aa_size :: (using self: *StyleBoxFlat, size: float) {
}
StyleBoxFlat_get_aa_size :: (using self: *StyleBoxFlat) -> float {
}
StyleBoxFlat_set_corner_detail :: (using self: *StyleBoxFlat, detail: int) {
}
StyleBoxFlat_get_corner_detail :: (using self: *StyleBoxFlat) -> int {
}

// StyleBoxLine
StyleBoxLine :: struct {
	__private: *void;
}

StyleBoxLine_set_color :: (using self: *StyleBoxLine, color: Color) {
}
StyleBoxLine_get_color :: (using self: *StyleBoxLine) -> Color {
}
StyleBoxLine_set_thickness :: (using self: *StyleBoxLine, thickness: int) {
}
StyleBoxLine_get_thickness :: (using self: *StyleBoxLine) -> int {
}
StyleBoxLine_set_grow_begin :: (using self: *StyleBoxLine, offset: float) {
}
StyleBoxLine_get_grow_begin :: (using self: *StyleBoxLine) -> float {
}
StyleBoxLine_set_grow_end :: (using self: *StyleBoxLine, offset: float) {
}
StyleBoxLine_get_grow_end :: (using self: *StyleBoxLine) -> float {
}
StyleBoxLine_set_vertical :: (using self: *StyleBoxLine, vertical: bool) {
}
StyleBoxLine_is_vertical :: (using self: *StyleBoxLine) -> bool {
}

// StyleBoxTexture
StyleBoxTexture :: struct {
	__private: *void;

	AxisStretchMode :: enum {
		AXIS_STRETCH_MODE_STRETCH :: 0;
		AXIS_STRETCH_MODE_TILE :: 1;
		AXIS_STRETCH_MODE_TILE_FIT :: 2;
	}
}

StyleBoxTexture_set_texture :: (using self: *StyleBoxTexture, texture: Texture2D) {
}
StyleBoxTexture_get_texture :: (using self: *StyleBoxTexture) -> Texture2D {
}
StyleBoxTexture_set_texture_margin :: (using self: *StyleBoxTexture, margin: Side, size: float) {
}
StyleBoxTexture_set_texture_margin_all :: (using self: *StyleBoxTexture, size: float) {
}
StyleBoxTexture_get_texture_margin :: (using self: *StyleBoxTexture, margin: Side) -> float {
}
StyleBoxTexture_set_expand_margin :: (using self: *StyleBoxTexture, margin: Side, size: float) {
}
StyleBoxTexture_set_expand_margin_all :: (using self: *StyleBoxTexture, size: float) {
}
StyleBoxTexture_get_expand_margin :: (using self: *StyleBoxTexture, margin: Side) -> float {
}
StyleBoxTexture_set_region_rect :: (using self: *StyleBoxTexture, region: Rect2) {
}
StyleBoxTexture_get_region_rect :: (using self: *StyleBoxTexture) -> Rect2 {
}
StyleBoxTexture_set_draw_center :: (using self: *StyleBoxTexture, enable: bool) {
}
StyleBoxTexture_is_draw_center_enabled :: (using self: *StyleBoxTexture) -> bool {
}
StyleBoxTexture_set_modulate :: (using self: *StyleBoxTexture, color: Color) {
}
StyleBoxTexture_get_modulate :: (using self: *StyleBoxTexture) -> Color {
}
StyleBoxTexture_set_h_axis_stretch_mode :: (using self: *StyleBoxTexture, mode: StyleBoxTexture.AxisStretchMode) {
}
StyleBoxTexture_get_h_axis_stretch_mode :: (using self: *StyleBoxTexture) -> StyleBoxTexture.AxisStretchMode {
}
StyleBoxTexture_set_v_axis_stretch_mode :: (using self: *StyleBoxTexture, mode: StyleBoxTexture.AxisStretchMode) {
}
StyleBoxTexture_get_v_axis_stretch_mode :: (using self: *StyleBoxTexture) -> StyleBoxTexture.AxisStretchMode {
}

// SubViewport
SubViewport :: struct {
	__private: *void;

	ClearMode :: enum {
		CLEAR_MODE_ALWAYS :: 0;
		CLEAR_MODE_NEVER :: 1;
		CLEAR_MODE_ONCE :: 2;
	}
	UpdateMode :: enum {
		UPDATE_DISABLED :: 0;
		UPDATE_ONCE :: 1;
		UPDATE_WHEN_VISIBLE :: 2;
		UPDATE_WHEN_PARENT_VISIBLE :: 3;
		UPDATE_ALWAYS :: 4;
	}
}

SubViewport_set_size :: (using self: *SubViewport, size: Vector2i) {
}
SubViewport_get_size :: (using self: *SubViewport) -> Vector2i {
}
SubViewport_set_size_2d_override :: (using self: *SubViewport, size: Vector2i) {
}
SubViewport_get_size_2d_override :: (using self: *SubViewport) -> Vector2i {
}
SubViewport_set_size_2d_override_stretch :: (using self: *SubViewport, enable: bool) {
}
SubViewport_is_size_2d_override_stretch_enabled :: (using self: *SubViewport) -> bool {
}
SubViewport_set_update_mode :: (using self: *SubViewport, mode: SubViewport.UpdateMode) {
}
SubViewport_get_update_mode :: (using self: *SubViewport) -> SubViewport.UpdateMode {
}
SubViewport_set_clear_mode :: (using self: *SubViewport, mode: SubViewport.ClearMode) {
}
SubViewport_get_clear_mode :: (using self: *SubViewport) -> SubViewport.ClearMode {
}

// SubViewportContainer
SubViewportContainer :: struct {
	__private: *void;
}

SubViewportContainer__propagate_input_event :: (using self: *SubViewportContainer, event: InputEvent) -> bool {
}
SubViewportContainer_set_stretch :: (using self: *SubViewportContainer, enable: bool) {
}
SubViewportContainer_is_stretch_enabled :: (using self: *SubViewportContainer) -> bool {
}
SubViewportContainer_set_stretch_shrink :: (using self: *SubViewportContainer, amount: int) {
}
SubViewportContainer_get_stretch_shrink :: (using self: *SubViewportContainer) -> int {
}

// SurfaceTool
SurfaceTool :: struct {
	__private: *void;

	CustomFormat :: enum {
		CUSTOM_RGBA8_UNORM :: 0;
		CUSTOM_RGBA8_SNORM :: 1;
		CUSTOM_RG_HALF :: 2;
		CUSTOM_RGBA_HALF :: 3;
		CUSTOM_R_FLOAT :: 4;
		CUSTOM_RG_FLOAT :: 5;
		CUSTOM_RGB_FLOAT :: 6;
		CUSTOM_RGBA_FLOAT :: 7;
		CUSTOM_MAX :: 8;
	}
	SkinWeightCount :: enum {
		SKIN_4_WEIGHTS :: 0;
		SKIN_8_WEIGHTS :: 1;
	}
}

SurfaceTool_set_skin_weight_count :: (using self: *SurfaceTool, count: SurfaceTool.SkinWeightCount) {
}
SurfaceTool_get_skin_weight_count :: (using self: *SurfaceTool) -> SurfaceTool.SkinWeightCount {
}
SurfaceTool_set_custom_format :: (using self: *SurfaceTool, channel_index: int, format: SurfaceTool.CustomFormat) {
}
SurfaceTool_get_custom_format :: (using self: *SurfaceTool, channel_index: int) -> SurfaceTool.CustomFormat {
}
SurfaceTool_begin :: (using self: *SurfaceTool, primitive: Mesh.PrimitiveType) {
}
SurfaceTool_add_vertex :: (using self: *SurfaceTool, vertex: Vector3) {
}
SurfaceTool_set_color :: (using self: *SurfaceTool, color: Color) {
}
SurfaceTool_set_normal :: (using self: *SurfaceTool, normal: Vector3) {
}
SurfaceTool_set_tangent :: (using self: *SurfaceTool, tangent: Plane) {
}
SurfaceTool_set_uv :: (using self: *SurfaceTool, uv: Vector2) {
}
SurfaceTool_set_uv2 :: (using self: *SurfaceTool, uv2: Vector2) {
}
SurfaceTool_set_bones :: (using self: *SurfaceTool, bones: PackedInt32Array) {
}
SurfaceTool_set_weights :: (using self: *SurfaceTool, weights: PackedFloat32Array) {
}
SurfaceTool_set_custom :: (using self: *SurfaceTool, channel_index: int, custom_color: Color) {
}
SurfaceTool_set_smooth_group :: (using self: *SurfaceTool, index: int) {
}
SurfaceTool_add_triangle_fan :: (using self: *SurfaceTool, vertices: PackedVector3Array, uvs: PackedVector2Array, colors: PackedColorArray, uv2s: PackedVector2Array, normals: PackedVector3Array, tangents: Array) {
}
SurfaceTool_add_index :: (using self: *SurfaceTool, index: int) {
}
SurfaceTool_index :: (using self: *SurfaceTool) {
}
SurfaceTool_deindex :: (using self: *SurfaceTool) {
}
SurfaceTool_generate_normals :: (using self: *SurfaceTool, flip: bool) {
}
SurfaceTool_generate_tangents :: (using self: *SurfaceTool) {
}
SurfaceTool_optimize_indices_for_cache :: (using self: *SurfaceTool) {
}
SurfaceTool_get_aabb :: (using self: *SurfaceTool) -> AABB {
}
SurfaceTool_generate_lod :: (using self: *SurfaceTool, nd_threshold: float, target_index_count: int) -> PackedInt32Array {
}
SurfaceTool_set_material :: (using self: *SurfaceTool, material: Material) {
}
SurfaceTool_get_primitive_type :: (using self: *SurfaceTool) -> Mesh.PrimitiveType {
}
SurfaceTool_clear :: (using self: *SurfaceTool) {
}
SurfaceTool_create_from :: (using self: *SurfaceTool, existing: Mesh, surface: int) {
}
SurfaceTool_create_from_arrays :: (using self: *SurfaceTool, arrays: Array, primitive_type: Mesh.PrimitiveType) {
}
SurfaceTool_create_from_blend_shape :: (using self: *SurfaceTool, existing: Mesh, surface: int, blend_shape: String) {
}
SurfaceTool_append_from :: (using self: *SurfaceTool, existing: Mesh, surface: int, transform: Transform3D) {
}
SurfaceTool_commit :: (using self: *SurfaceTool, existing: ArrayMesh, flags: int) -> ArrayMesh {
}
SurfaceTool_commit_to_arrays :: (using self: *SurfaceTool) -> Array {
}

// SyntaxHighlighter
SyntaxHighlighter :: struct {
	__private: *void;
}

SyntaxHighlighter__get_line_syntax_highlighting :: (using self: *SyntaxHighlighter, line: int) -> Dictionary {
}
SyntaxHighlighter__clear_highlighting_cache :: (using self: *SyntaxHighlighter) {
}
SyntaxHighlighter__update_cache :: (using self: *SyntaxHighlighter) {
}
SyntaxHighlighter_get_line_syntax_highlighting :: (using self: *SyntaxHighlighter, line: int) -> Dictionary {
}
SyntaxHighlighter_update_cache :: (using self: *SyntaxHighlighter) {
}
SyntaxHighlighter_clear_highlighting_cache :: (using self: *SyntaxHighlighter) {
}
SyntaxHighlighter_get_text_edit :: (using self: *SyntaxHighlighter) -> TextEdit {
}

// SystemFont
SystemFont :: struct {
	__private: *void;
}

SystemFont_set_antialiasing :: (using self: *SystemFont, antialiasing: TextServer.FontAntialiasing) {
}
SystemFont_get_antialiasing :: (using self: *SystemFont) -> TextServer.FontAntialiasing {
}
SystemFont_set_disable_embedded_bitmaps :: (using self: *SystemFont, disable_embedded_bitmaps: bool) {
}
SystemFont_get_disable_embedded_bitmaps :: (using self: *SystemFont) -> bool {
}
SystemFont_set_generate_mipmaps :: (using self: *SystemFont, generate_mipmaps: bool) {
}
SystemFont_get_generate_mipmaps :: (using self: *SystemFont) -> bool {
}
SystemFont_set_allow_system_fallback :: (using self: *SystemFont, allow_system_fallback: bool) {
}
SystemFont_is_allow_system_fallback :: (using self: *SystemFont) -> bool {
}
SystemFont_set_force_autohinter :: (using self: *SystemFont, force_autohinter: bool) {
}
SystemFont_is_force_autohinter :: (using self: *SystemFont) -> bool {
}
SystemFont_set_hinting :: (using self: *SystemFont, hinting: TextServer.Hinting) {
}
SystemFont_get_hinting :: (using self: *SystemFont) -> TextServer.Hinting {
}
SystemFont_set_subpixel_positioning :: (using self: *SystemFont, subpixel_positioning: TextServer.SubpixelPositioning) {
}
SystemFont_get_subpixel_positioning :: (using self: *SystemFont) -> TextServer.SubpixelPositioning {
}
SystemFont_set_multichannel_signed_distance_field :: (using self: *SystemFont, msdf: bool) {
}
SystemFont_is_multichannel_signed_distance_field :: (using self: *SystemFont) -> bool {
}
SystemFont_set_msdf_pixel_range :: (using self: *SystemFont, msdf_pixel_range: int) {
}
SystemFont_get_msdf_pixel_range :: (using self: *SystemFont) -> int {
}
SystemFont_set_msdf_size :: (using self: *SystemFont, msdf_size: int) {
}
SystemFont_get_msdf_size :: (using self: *SystemFont) -> int {
}
SystemFont_set_oversampling :: (using self: *SystemFont, oversampling: float) {
}
SystemFont_get_oversampling :: (using self: *SystemFont) -> float {
}
SystemFont_get_font_names :: (using self: *SystemFont) -> PackedStringArray {
}
SystemFont_set_font_names :: (using self: *SystemFont, names: PackedStringArray) {
}
SystemFont_get_font_italic :: (using self: *SystemFont) -> bool {
}
SystemFont_set_font_italic :: (using self: *SystemFont, italic: bool) {
}
SystemFont_set_font_weight :: (using self: *SystemFont, weight: int) {
}
SystemFont_set_font_stretch :: (using self: *SystemFont, stretch: int) {
}

// TCPServer
TCPServer :: struct {
	__private: *void;
}

TCPServer_listen :: (using self: *TCPServer, port: int, bind_address: String) -> Error {
}
TCPServer_is_connection_available :: (using self: *TCPServer) -> bool {
}
TCPServer_is_listening :: (using self: *TCPServer) -> bool {
}
TCPServer_get_local_port :: (using self: *TCPServer) -> int {
}
TCPServer_take_connection :: (using self: *TCPServer) -> StreamPeerTCP {
}
TCPServer_stop :: (using self: *TCPServer) {
}

// TLSOptions
TLSOptions :: struct {
	__private: *void;
}

TLSOptions_client :: (using self: *TLSOptions, trusted_chain: X509Certificate, common_name_override: String) -> TLSOptions {
}
TLSOptions_client_unsafe :: (using self: *TLSOptions, trusted_chain: X509Certificate) -> TLSOptions {
}
TLSOptions_server :: (using self: *TLSOptions, key: CryptoKey, certificate: X509Certificate) -> TLSOptions {
}
TLSOptions_is_server :: (using self: *TLSOptions) -> bool {
}
TLSOptions_is_unsafe_client :: (using self: *TLSOptions) -> bool {
}
TLSOptions_get_common_name_override :: (using self: *TLSOptions) -> String {
}
TLSOptions_get_trusted_ca_chain :: (using self: *TLSOptions) -> X509Certificate {
}
TLSOptions_get_private_key :: (using self: *TLSOptions) -> CryptoKey {
}
TLSOptions_get_own_certificate :: (using self: *TLSOptions) -> X509Certificate {
}

// TabBar
TabBar :: struct {
	__private: *void;

	AlignmentMode :: enum {
		ALIGNMENT_LEFT :: 0;
		ALIGNMENT_CENTER :: 1;
		ALIGNMENT_RIGHT :: 2;
		ALIGNMENT_MAX :: 3;
	}
	CloseButtonDisplayPolicy :: enum {
		CLOSE_BUTTON_SHOW_NEVER :: 0;
		CLOSE_BUTTON_SHOW_ACTIVE_ONLY :: 1;
		CLOSE_BUTTON_SHOW_ALWAYS :: 2;
		CLOSE_BUTTON_MAX :: 3;
	}
}

TabBar_set_tab_count :: (using self: *TabBar, count: int) {
}
TabBar_get_tab_count :: (using self: *TabBar) -> int {
}
TabBar_set_current_tab :: (using self: *TabBar, tab_idx: int) {
}
TabBar_get_current_tab :: (using self: *TabBar) -> int {
}
TabBar_get_previous_tab :: (using self: *TabBar) -> int {
}
TabBar_select_previous_available :: (using self: *TabBar) -> bool {
}
TabBar_select_next_available :: (using self: *TabBar) -> bool {
}
TabBar_set_tab_title :: (using self: *TabBar, tab_idx: int, title: String) {
}
TabBar_get_tab_title :: (using self: *TabBar, tab_idx: int) -> String {
}
TabBar_set_tab_tooltip :: (using self: *TabBar, tab_idx: int, tooltip: String) {
}
TabBar_get_tab_tooltip :: (using self: *TabBar, tab_idx: int) -> String {
}
TabBar_set_tab_text_direction :: (using self: *TabBar, tab_idx: int, direction: Control.TextDirection) {
}
TabBar_get_tab_text_direction :: (using self: *TabBar, tab_idx: int) -> Control.TextDirection {
}
TabBar_set_tab_language :: (using self: *TabBar, tab_idx: int, language: String) {
}
TabBar_get_tab_language :: (using self: *TabBar, tab_idx: int) -> String {
}
TabBar_set_tab_icon :: (using self: *TabBar, tab_idx: int, icon: Texture2D) {
}
TabBar_get_tab_icon :: (using self: *TabBar, tab_idx: int) -> Texture2D {
}
TabBar_set_tab_icon_max_width :: (using self: *TabBar, tab_idx: int, width: int) {
}
TabBar_get_tab_icon_max_width :: (using self: *TabBar, tab_idx: int) -> int {
}
TabBar_set_tab_button_icon :: (using self: *TabBar, tab_idx: int, icon: Texture2D) {
}
TabBar_get_tab_button_icon :: (using self: *TabBar, tab_idx: int) -> Texture2D {
}
TabBar_set_tab_disabled :: (using self: *TabBar, tab_idx: int, disabled: bool) {
}
TabBar_is_tab_disabled :: (using self: *TabBar, tab_idx: int) -> bool {
}
TabBar_set_tab_hidden :: (using self: *TabBar, tab_idx: int, hidden: bool) {
}
TabBar_is_tab_hidden :: (using self: *TabBar, tab_idx: int) -> bool {
}
TabBar_set_tab_metadata :: (using self: *TabBar, tab_idx: int, metadata: Variant) {
}
TabBar_get_tab_metadata :: (using self: *TabBar, tab_idx: int) -> Variant {
}
TabBar_remove_tab :: (using self: *TabBar, tab_idx: int) {
}
TabBar_add_tab :: (using self: *TabBar, title: String, icon: Texture2D) {
}
TabBar_get_tab_idx_at_point :: (using self: *TabBar, point: Vector2) -> int {
}
TabBar_set_tab_alignment :: (using self: *TabBar, alignment: TabBar.AlignmentMode) {
}
TabBar_get_tab_alignment :: (using self: *TabBar) -> TabBar.AlignmentMode {
}
TabBar_set_clip_tabs :: (using self: *TabBar, clip_tabs: bool) {
}
TabBar_get_clip_tabs :: (using self: *TabBar) -> bool {
}
TabBar_get_tab_offset :: (using self: *TabBar) -> int {
}
TabBar_get_offset_buttons_visible :: (using self: *TabBar) -> bool {
}
TabBar_ensure_tab_visible :: (using self: *TabBar, idx: int) {
}
TabBar_get_tab_rect :: (using self: *TabBar, tab_idx: int) -> Rect2 {
}
TabBar_move_tab :: (using self: *TabBar, from: int, to: int) {
}
TabBar_set_tab_close_display_policy :: (using self: *TabBar, policy: TabBar.CloseButtonDisplayPolicy) {
}
TabBar_get_tab_close_display_policy :: (using self: *TabBar) -> TabBar.CloseButtonDisplayPolicy {
}
TabBar_set_max_tab_width :: (using self: *TabBar, width: int) {
}
TabBar_get_max_tab_width :: (using self: *TabBar) -> int {
}
TabBar_set_scrolling_enabled :: (using self: *TabBar, enabled: bool) {
}
TabBar_get_scrolling_enabled :: (using self: *TabBar) -> bool {
}
TabBar_set_drag_to_rearrange_enabled :: (using self: *TabBar, enabled: bool) {
}
TabBar_get_drag_to_rearrange_enabled :: (using self: *TabBar) -> bool {
}
TabBar_set_tabs_rearrange_group :: (using self: *TabBar, group_id: int) {
}
TabBar_get_tabs_rearrange_group :: (using self: *TabBar) -> int {
}
TabBar_set_scroll_to_selected :: (using self: *TabBar, enabled: bool) {
}
TabBar_get_scroll_to_selected :: (using self: *TabBar) -> bool {
}
TabBar_set_select_with_rmb :: (using self: *TabBar, enabled: bool) {
}
TabBar_get_select_with_rmb :: (using self: *TabBar) -> bool {
}
TabBar_set_deselect_enabled :: (using self: *TabBar, enabled: bool) {
}
TabBar_get_deselect_enabled :: (using self: *TabBar) -> bool {
}
TabBar_clear_tabs :: (using self: *TabBar) {
}

// TabContainer
TabContainer :: struct {
	__private: *void;

	TabPosition :: enum {
		POSITION_TOP :: 0;
		POSITION_BOTTOM :: 1;
		POSITION_MAX :: 2;
	}
}

TabContainer_get_tab_count :: (using self: *TabContainer) -> int {
}
TabContainer_set_current_tab :: (using self: *TabContainer, tab_idx: int) {
}
TabContainer_get_current_tab :: (using self: *TabContainer) -> int {
}
TabContainer_get_previous_tab :: (using self: *TabContainer) -> int {
}
TabContainer_select_previous_available :: (using self: *TabContainer) -> bool {
}
TabContainer_select_next_available :: (using self: *TabContainer) -> bool {
}
TabContainer_get_current_tab_control :: (using self: *TabContainer) -> Control {
}
TabContainer_get_tab_bar :: (using self: *TabContainer) -> TabBar {
}
TabContainer_get_tab_control :: (using self: *TabContainer, tab_idx: int) -> Control {
}
TabContainer_set_tab_alignment :: (using self: *TabContainer, alignment: TabBar.AlignmentMode) {
}
TabContainer_get_tab_alignment :: (using self: *TabContainer) -> TabBar.AlignmentMode {
}
TabContainer_set_tabs_position :: (using self: *TabContainer, tabs_position: TabContainer.TabPosition) {
}
TabContainer_get_tabs_position :: (using self: *TabContainer) -> TabContainer.TabPosition {
}
TabContainer_set_clip_tabs :: (using self: *TabContainer, clip_tabs: bool) {
}
TabContainer_get_clip_tabs :: (using self: *TabContainer) -> bool {
}
TabContainer_set_tabs_visible :: (using self: *TabContainer, visible: bool) {
}
TabContainer_are_tabs_visible :: (using self: *TabContainer) -> bool {
}
TabContainer_set_all_tabs_in_front :: (using self: *TabContainer, is_front: bool) {
}
TabContainer_is_all_tabs_in_front :: (using self: *TabContainer) -> bool {
}
TabContainer_set_tab_title :: (using self: *TabContainer, tab_idx: int, title: String) {
}
TabContainer_get_tab_title :: (using self: *TabContainer, tab_idx: int) -> String {
}
TabContainer_set_tab_tooltip :: (using self: *TabContainer, tab_idx: int, tooltip: String) {
}
TabContainer_get_tab_tooltip :: (using self: *TabContainer, tab_idx: int) -> String {
}
TabContainer_set_tab_icon :: (using self: *TabContainer, tab_idx: int, icon: Texture2D) {
}
TabContainer_get_tab_icon :: (using self: *TabContainer, tab_idx: int) -> Texture2D {
}
TabContainer_set_tab_icon_max_width :: (using self: *TabContainer, tab_idx: int, width: int) {
}
TabContainer_get_tab_icon_max_width :: (using self: *TabContainer, tab_idx: int) -> int {
}
TabContainer_set_tab_disabled :: (using self: *TabContainer, tab_idx: int, disabled: bool) {
}
TabContainer_is_tab_disabled :: (using self: *TabContainer, tab_idx: int) -> bool {
}
TabContainer_set_tab_hidden :: (using self: *TabContainer, tab_idx: int, hidden: bool) {
}
TabContainer_is_tab_hidden :: (using self: *TabContainer, tab_idx: int) -> bool {
}
TabContainer_set_tab_metadata :: (using self: *TabContainer, tab_idx: int, metadata: Variant) {
}
TabContainer_get_tab_metadata :: (using self: *TabContainer, tab_idx: int) -> Variant {
}
TabContainer_set_tab_button_icon :: (using self: *TabContainer, tab_idx: int, icon: Texture2D) {
}
TabContainer_get_tab_button_icon :: (using self: *TabContainer, tab_idx: int) -> Texture2D {
}
TabContainer_get_tab_idx_at_point :: (using self: *TabContainer, point: Vector2) -> int {
}
TabContainer_get_tab_idx_from_control :: (using self: *TabContainer, control: Control) -> int {
}
TabContainer_set_popup :: (using self: *TabContainer, popup: Node) {
}
TabContainer_get_popup :: (using self: *TabContainer) -> Popup {
}
TabContainer_set_drag_to_rearrange_enabled :: (using self: *TabContainer, enabled: bool) {
}
TabContainer_get_drag_to_rearrange_enabled :: (using self: *TabContainer) -> bool {
}
TabContainer_set_tabs_rearrange_group :: (using self: *TabContainer, group_id: int) {
}
TabContainer_get_tabs_rearrange_group :: (using self: *TabContainer) -> int {
}
TabContainer_set_use_hidden_tabs_for_min_size :: (using self: *TabContainer, enabled: bool) {
}
TabContainer_get_use_hidden_tabs_for_min_size :: (using self: *TabContainer) -> bool {
}
TabContainer_set_tab_focus_mode :: (using self: *TabContainer, focus_mode: Control.FocusMode) {
}
TabContainer_get_tab_focus_mode :: (using self: *TabContainer) -> Control.FocusMode {
}
TabContainer_set_deselect_enabled :: (using self: *TabContainer, enabled: bool) {
}
TabContainer_get_deselect_enabled :: (using self: *TabContainer) -> bool {
}

// TextEdit
TextEdit :: struct {
	__private: *void;

	MenuItems :: enum {
		MENU_CUT :: 0;
		MENU_COPY :: 1;
		MENU_PASTE :: 2;
		MENU_CLEAR :: 3;
		MENU_SELECT_ALL :: 4;
		MENU_UNDO :: 5;
		MENU_REDO :: 6;
		MENU_SUBMENU_TEXT_DIR :: 7;
		MENU_DIR_INHERITED :: 8;
		MENU_DIR_AUTO :: 9;
		MENU_DIR_LTR :: 10;
		MENU_DIR_RTL :: 11;
		MENU_DISPLAY_UCC :: 12;
		MENU_SUBMENU_INSERT_UCC :: 13;
		MENU_INSERT_LRM :: 14;
		MENU_INSERT_RLM :: 15;
		MENU_INSERT_LRE :: 16;
		MENU_INSERT_RLE :: 17;
		MENU_INSERT_LRO :: 18;
		MENU_INSERT_RLO :: 19;
		MENU_INSERT_PDF :: 20;
		MENU_INSERT_ALM :: 21;
		MENU_INSERT_LRI :: 22;
		MENU_INSERT_RLI :: 23;
		MENU_INSERT_FSI :: 24;
		MENU_INSERT_PDI :: 25;
		MENU_INSERT_ZWJ :: 26;
		MENU_INSERT_ZWNJ :: 27;
		MENU_INSERT_WJ :: 28;
		MENU_INSERT_SHY :: 29;
		MENU_MAX :: 30;
	}
	EditAction :: enum {
		ACTION_NONE :: 0;
		ACTION_TYPING :: 1;
		ACTION_BACKSPACE :: 2;
		ACTION_DELETE :: 3;
	}
	SearchFlags :: enum {
		SEARCH_MATCH_CASE :: 1;
		SEARCH_WHOLE_WORDS :: 2;
		SEARCH_BACKWARDS :: 4;
	}
	CaretType :: enum {
		CARET_TYPE_LINE :: 0;
		CARET_TYPE_BLOCK :: 1;
	}
	SelectionMode :: enum {
		SELECTION_MODE_NONE :: 0;
		SELECTION_MODE_SHIFT :: 1;
		SELECTION_MODE_POINTER :: 2;
		SELECTION_MODE_WORD :: 3;
		SELECTION_MODE_LINE :: 4;
	}
	LineWrappingMode :: enum {
		LINE_WRAPPING_NONE :: 0;
		LINE_WRAPPING_BOUNDARY :: 1;
	}
	GutterType :: enum {
		GUTTER_TYPE_STRING :: 0;
		GUTTER_TYPE_ICON :: 1;
		GUTTER_TYPE_CUSTOM :: 2;
	}
}

TextEdit__handle_unicode_input :: (using self: *TextEdit, unicode_char: int, caret_index: int) {
}
TextEdit__backspace :: (using self: *TextEdit, caret_index: int) {
}
TextEdit__cut :: (using self: *TextEdit, caret_index: int) {
}
TextEdit__copy :: (using self: *TextEdit, caret_index: int) {
}
TextEdit__paste :: (using self: *TextEdit, caret_index: int) {
}
TextEdit__paste_primary_clipboard :: (using self: *TextEdit, caret_index: int) {
}
TextEdit_has_ime_text :: (using self: *TextEdit) -> bool {
}
TextEdit_cancel_ime :: (using self: *TextEdit) {
}
TextEdit_apply_ime :: (using self: *TextEdit) {
}
TextEdit_set_editable :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_editable :: (using self: *TextEdit) -> bool {
}
TextEdit_set_text_direction :: (using self: *TextEdit, direction: Control.TextDirection) {
}
TextEdit_get_text_direction :: (using self: *TextEdit) -> Control.TextDirection {
}
TextEdit_set_language :: (using self: *TextEdit, language: String) {
}
TextEdit_get_language :: (using self: *TextEdit) -> String {
}
TextEdit_set_structured_text_bidi_override :: (using self: *TextEdit, parser: TextServer.StructuredTextParser) {
}
TextEdit_get_structured_text_bidi_override :: (using self: *TextEdit) -> TextServer.StructuredTextParser {
}
TextEdit_set_structured_text_bidi_override_options :: (using self: *TextEdit, args: Array) {
}
TextEdit_get_structured_text_bidi_override_options :: (using self: *TextEdit) -> Array {
}
TextEdit_set_tab_size :: (using self: *TextEdit, size: int) {
}
TextEdit_get_tab_size :: (using self: *TextEdit) -> int {
}
TextEdit_set_indent_wrapped_lines :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_indent_wrapped_lines :: (using self: *TextEdit) -> bool {
}
TextEdit_set_overtype_mode_enabled :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_overtype_mode_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_context_menu_enabled :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_context_menu_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_shortcut_keys_enabled :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_shortcut_keys_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_virtual_keyboard_enabled :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_virtual_keyboard_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_middle_mouse_paste_enabled :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_middle_mouse_paste_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_clear :: (using self: *TextEdit) {
}
TextEdit_set_text :: (using self: *TextEdit, text: String) {
}
TextEdit_get_text :: (using self: *TextEdit) -> String {
}
TextEdit_get_line_count :: (using self: *TextEdit) -> int {
}
TextEdit_set_placeholder :: (using self: *TextEdit, text: String) {
}
TextEdit_get_placeholder :: (using self: *TextEdit) -> String {
}
TextEdit_set_line :: (using self: *TextEdit, line: int, new_text: String) {
}
TextEdit_get_line :: (using self: *TextEdit, line: int) -> String {
}
TextEdit_get_line_width :: (using self: *TextEdit, line: int, wrap_index: int) -> int {
}
TextEdit_get_line_height :: (using self: *TextEdit) -> int {
}
TextEdit_get_indent_level :: (using self: *TextEdit, line: int) -> int {
}
TextEdit_get_first_non_whitespace_column :: (using self: *TextEdit, line: int) -> int {
}
TextEdit_swap_lines :: (using self: *TextEdit, from_line: int, to_line: int) {
}
TextEdit_insert_line_at :: (using self: *TextEdit, line: int, text: String) {
}
TextEdit_remove_line_at :: (using self: *TextEdit, line: int, move_carets_down: bool) {
}
TextEdit_insert_text_at_caret :: (using self: *TextEdit, text: String, caret_index: int) {
}
TextEdit_insert_text :: (using self: *TextEdit, text: String, line: int, column: int, before_selection_begin: bool, before_selection_end: bool) {
}
TextEdit_remove_text :: (using self: *TextEdit, from_line: int, from_column: int, to_line: int, to_column: int) {
}
TextEdit_get_last_unhidden_line :: (using self: *TextEdit) -> int {
}
TextEdit_get_next_visible_line_offset_from :: (using self: *TextEdit, line: int, visible_amount: int) -> int {
}
TextEdit_get_next_visible_line_index_offset_from :: (using self: *TextEdit, line: int, wrap_index: int, visible_amount: int) -> Vector2i {
}
TextEdit_backspace :: (using self: *TextEdit, caret_index: int) {
}
TextEdit_cut :: (using self: *TextEdit, caret_index: int) {
}
TextEdit_copy :: (using self: *TextEdit, caret_index: int) {
}
TextEdit_paste :: (using self: *TextEdit, caret_index: int) {
}
TextEdit_paste_primary_clipboard :: (using self: *TextEdit, caret_index: int) {
}
TextEdit_start_action :: (using self: *TextEdit, action: TextEdit.EditAction) {
}
TextEdit_end_action :: (using self: *TextEdit) {
}
TextEdit_begin_complex_operation :: (using self: *TextEdit) {
}
TextEdit_end_complex_operation :: (using self: *TextEdit) {
}
TextEdit_has_undo :: (using self: *TextEdit) -> bool {
}
TextEdit_has_redo :: (using self: *TextEdit) -> bool {
}
TextEdit_undo :: (using self: *TextEdit) {
}
TextEdit_redo :: (using self: *TextEdit) {
}
TextEdit_clear_undo_history :: (using self: *TextEdit) {
}
TextEdit_tag_saved_version :: (using self: *TextEdit) {
}
TextEdit_get_version :: (using self: *TextEdit) -> int {
}
TextEdit_get_saved_version :: (using self: *TextEdit) -> int {
}
TextEdit_set_search_text :: (using self: *TextEdit, search_text: String) {
}
TextEdit_set_search_flags :: (using self: *TextEdit, flags: int) {
}
TextEdit_search :: (using self: *TextEdit, text: String, flags: int, from_line: int, from_column: int) -> Vector2i {
}
TextEdit_set_tooltip_request_func :: (using self: *TextEdit, callback: Callable) {
}
TextEdit_get_local_mouse_pos :: (using self: *TextEdit) -> Vector2 {
}
TextEdit_get_word_at_pos :: (using self: *TextEdit, position: Vector2) -> String {
}
TextEdit_get_line_column_at_pos :: (using self: *TextEdit, position: Vector2i, allow_out_of_bounds: bool) -> Vector2i {
}
TextEdit_get_pos_at_line_column :: (using self: *TextEdit, line: int, column: int) -> Vector2i {
}
TextEdit_get_rect_at_line_column :: (using self: *TextEdit, line: int, column: int) -> Rect2i {
}
TextEdit_get_minimap_line_at_pos :: (using self: *TextEdit, position: Vector2i) -> int {
}
TextEdit_is_dragging_cursor :: (using self: *TextEdit) -> bool {
}
TextEdit_is_mouse_over_selection :: (using self: *TextEdit, edges: bool, caret_index: int) -> bool {
}
TextEdit_set_caret_type :: (using self: *TextEdit, type: TextEdit.CaretType) {
}
TextEdit_get_caret_type :: (using self: *TextEdit) -> TextEdit.CaretType {
}
TextEdit_set_caret_blink_enabled :: (using self: *TextEdit, enable: bool) {
}
TextEdit_is_caret_blink_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_caret_blink_interval :: (using self: *TextEdit, interval: float) {
}
TextEdit_get_caret_blink_interval :: (using self: *TextEdit) -> float {
}
TextEdit_set_draw_caret_when_editable_disabled :: (using self: *TextEdit, enable: bool) {
}
TextEdit_is_drawing_caret_when_editable_disabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_move_caret_on_right_click_enabled :: (using self: *TextEdit, enable: bool) {
}
TextEdit_is_move_caret_on_right_click_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_caret_mid_grapheme_enabled :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_caret_mid_grapheme_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_multiple_carets_enabled :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_multiple_carets_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_add_caret :: (using self: *TextEdit, line: int, column: int) -> int {
}
TextEdit_remove_caret :: (using self: *TextEdit, caret: int) {
}
TextEdit_remove_secondary_carets :: (using self: *TextEdit) {
}
TextEdit_get_caret_count :: (using self: *TextEdit) -> int {
}
TextEdit_add_caret_at_carets :: (using self: *TextEdit, below: bool) {
}
TextEdit_get_sorted_carets :: (using self: *TextEdit, include_ignored_carets: bool) -> PackedInt32Array {
}
TextEdit_collapse_carets :: (using self: *TextEdit, from_line: int, from_column: int, to_line: int, to_column: int, inclusive: bool) {
}
TextEdit_merge_overlapping_carets :: (using self: *TextEdit) {
}
TextEdit_begin_multicaret_edit :: (using self: *TextEdit) {
}
TextEdit_end_multicaret_edit :: (using self: *TextEdit) {
}
TextEdit_is_in_mulitcaret_edit :: (using self: *TextEdit) -> bool {
}
TextEdit_multicaret_edit_ignore_caret :: (using self: *TextEdit, caret_index: int) -> bool {
}
TextEdit_is_caret_visible :: (using self: *TextEdit, caret_index: int) -> bool {
}
TextEdit_get_caret_draw_pos :: (using self: *TextEdit, caret_index: int) -> Vector2 {
}
TextEdit_set_caret_line :: (using self: *TextEdit, line: int, adjust_viewport: bool, can_be_hidden: bool, wrap_index: int, caret_index: int) {
}
TextEdit_get_caret_line :: (using self: *TextEdit, caret_index: int) -> int {
}
TextEdit_set_caret_column :: (using self: *TextEdit, column: int, adjust_viewport: bool, caret_index: int) {
}
TextEdit_get_caret_column :: (using self: *TextEdit, caret_index: int) -> int {
}
TextEdit_get_caret_wrap_index :: (using self: *TextEdit, caret_index: int) -> int {
}
TextEdit_get_word_under_caret :: (using self: *TextEdit, caret_index: int) -> String {
}
TextEdit_set_use_default_word_separators :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_default_word_separators_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_use_custom_word_separators :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_custom_word_separators_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_custom_word_separators :: (using self: *TextEdit, custom_word_separators: String) {
}
TextEdit_get_custom_word_separators :: (using self: *TextEdit) -> String {
}
TextEdit_set_selecting_enabled :: (using self: *TextEdit, enable: bool) {
}
TextEdit_is_selecting_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_deselect_on_focus_loss_enabled :: (using self: *TextEdit, enable: bool) {
}
TextEdit_is_deselect_on_focus_loss_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_drag_and_drop_selection_enabled :: (using self: *TextEdit, enable: bool) {
}
TextEdit_is_drag_and_drop_selection_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_selection_mode :: (using self: *TextEdit, mode: TextEdit.SelectionMode) {
}
TextEdit_get_selection_mode :: (using self: *TextEdit) -> TextEdit.SelectionMode {
}
TextEdit_select_all :: (using self: *TextEdit) {
}
TextEdit_select_word_under_caret :: (using self: *TextEdit, caret_index: int) {
}
TextEdit_add_selection_for_next_occurrence :: (using self: *TextEdit) {
}
TextEdit_skip_selection_for_next_occurrence :: (using self: *TextEdit) {
}
TextEdit_select :: (using self: *TextEdit, origin_line: int, origin_column: int, caret_line: int, caret_column: int, caret_index: int) {
}
TextEdit_has_selection :: (using self: *TextEdit, caret_index: int) -> bool {
}
TextEdit_get_selected_text :: (using self: *TextEdit, caret_index: int) -> String {
}
TextEdit_get_selection_at_line_column :: (using self: *TextEdit, line: int, column: int, include_edges: bool, only_selections: bool) -> int {
}
TextEdit_get_line_ranges_from_carets :: (using self: *TextEdit, only_selections: bool, merge_adjacent: bool) -> Array {
}
TextEdit_get_selection_origin_line :: (using self: *TextEdit, caret_index: int) -> int {
}
TextEdit_get_selection_origin_column :: (using self: *TextEdit, caret_index: int) -> int {
}
TextEdit_set_selection_origin_line :: (using self: *TextEdit, line: int, can_be_hidden: bool, wrap_index: int, caret_index: int) {
}
TextEdit_set_selection_origin_column :: (using self: *TextEdit, column: int, caret_index: int) {
}
TextEdit_get_selection_from_line :: (using self: *TextEdit, caret_index: int) -> int {
}
TextEdit_get_selection_from_column :: (using self: *TextEdit, caret_index: int) -> int {
}
TextEdit_get_selection_to_line :: (using self: *TextEdit, caret_index: int) -> int {
}
TextEdit_get_selection_to_column :: (using self: *TextEdit, caret_index: int) -> int {
}
TextEdit_is_caret_after_selection_origin :: (using self: *TextEdit, caret_index: int) -> bool {
}
TextEdit_deselect :: (using self: *TextEdit, caret_index: int) {
}
TextEdit_delete_selection :: (using self: *TextEdit, caret_index: int) {
}
TextEdit_set_line_wrapping_mode :: (using self: *TextEdit, mode: TextEdit.LineWrappingMode) {
}
TextEdit_get_line_wrapping_mode :: (using self: *TextEdit) -> TextEdit.LineWrappingMode {
}
TextEdit_set_autowrap_mode :: (using self: *TextEdit, autowrap_mode: TextServer.AutowrapMode) {
}
TextEdit_get_autowrap_mode :: (using self: *TextEdit) -> TextServer.AutowrapMode {
}
TextEdit_is_line_wrapped :: (using self: *TextEdit, line: int) -> bool {
}
TextEdit_get_line_wrap_count :: (using self: *TextEdit, line: int) -> int {
}
TextEdit_get_line_wrap_index_at_column :: (using self: *TextEdit, line: int, column: int) -> int {
}
TextEdit_get_line_wrapped_text :: (using self: *TextEdit, line: int) -> PackedStringArray {
}
TextEdit_set_smooth_scroll_enabled :: (using self: *TextEdit, enable: bool) {
}
TextEdit_is_smooth_scroll_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_get_v_scroll_bar :: (using self: *TextEdit) -> VScrollBar {
}
TextEdit_get_h_scroll_bar :: (using self: *TextEdit) -> HScrollBar {
}
TextEdit_set_v_scroll :: (using self: *TextEdit, value: float) {
}
TextEdit_get_v_scroll :: (using self: *TextEdit) -> float {
}
TextEdit_set_h_scroll :: (using self: *TextEdit, value: int) {
}
TextEdit_get_h_scroll :: (using self: *TextEdit) -> int {
}
TextEdit_set_scroll_past_end_of_file_enabled :: (using self: *TextEdit, enable: bool) {
}
TextEdit_is_scroll_past_end_of_file_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_v_scroll_speed :: (using self: *TextEdit, speed: float) {
}
TextEdit_get_v_scroll_speed :: (using self: *TextEdit) -> float {
}
TextEdit_set_fit_content_height_enabled :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_fit_content_height_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_get_scroll_pos_for_line :: (using self: *TextEdit, line: int, wrap_index: int) -> float {
}
TextEdit_set_line_as_first_visible :: (using self: *TextEdit, line: int, wrap_index: int) {
}
TextEdit_get_first_visible_line :: (using self: *TextEdit) -> int {
}
TextEdit_set_line_as_center_visible :: (using self: *TextEdit, line: int, wrap_index: int) {
}
TextEdit_set_line_as_last_visible :: (using self: *TextEdit, line: int, wrap_index: int) {
}
TextEdit_get_last_full_visible_line :: (using self: *TextEdit) -> int {
}
TextEdit_get_last_full_visible_line_wrap_index :: (using self: *TextEdit) -> int {
}
TextEdit_get_visible_line_count :: (using self: *TextEdit) -> int {
}
TextEdit_get_visible_line_count_in_range :: (using self: *TextEdit, from_line: int, to_line: int) -> int {
}
TextEdit_get_total_visible_line_count :: (using self: *TextEdit) -> int {
}
TextEdit_adjust_viewport_to_caret :: (using self: *TextEdit, caret_index: int) {
}
TextEdit_center_viewport_to_caret :: (using self: *TextEdit, caret_index: int) {
}
TextEdit_set_draw_minimap :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_drawing_minimap :: (using self: *TextEdit) -> bool {
}
TextEdit_set_minimap_width :: (using self: *TextEdit, width: int) {
}
TextEdit_get_minimap_width :: (using self: *TextEdit) -> int {
}
TextEdit_get_minimap_visible_lines :: (using self: *TextEdit) -> int {
}
TextEdit_add_gutter :: (using self: *TextEdit, at: int) {
}
TextEdit_remove_gutter :: (using self: *TextEdit, gutter: int) {
}
TextEdit_get_gutter_count :: (using self: *TextEdit) -> int {
}
TextEdit_set_gutter_name :: (using self: *TextEdit, gutter: int, name: String) {
}
TextEdit_get_gutter_name :: (using self: *TextEdit, gutter: int) -> String {
}
TextEdit_set_gutter_type :: (using self: *TextEdit, gutter: int, type: TextEdit.GutterType) {
}
TextEdit_get_gutter_type :: (using self: *TextEdit, gutter: int) -> TextEdit.GutterType {
}
TextEdit_set_gutter_width :: (using self: *TextEdit, gutter: int, width: int) {
}
TextEdit_get_gutter_width :: (using self: *TextEdit, gutter: int) -> int {
}
TextEdit_set_gutter_draw :: (using self: *TextEdit, gutter: int, draw: bool) {
}
TextEdit_is_gutter_drawn :: (using self: *TextEdit, gutter: int) -> bool {
}
TextEdit_set_gutter_clickable :: (using self: *TextEdit, gutter: int, clickable: bool) {
}
TextEdit_is_gutter_clickable :: (using self: *TextEdit, gutter: int) -> bool {
}
TextEdit_set_gutter_overwritable :: (using self: *TextEdit, gutter: int, overwritable: bool) {
}
TextEdit_is_gutter_overwritable :: (using self: *TextEdit, gutter: int) -> bool {
}
TextEdit_merge_gutters :: (using self: *TextEdit, from_line: int, to_line: int) {
}
TextEdit_set_gutter_custom_draw :: (using self: *TextEdit, column: int, draw_callback: Callable) {
}
TextEdit_get_total_gutter_width :: (using self: *TextEdit) -> int {
}
TextEdit_set_line_gutter_metadata :: (using self: *TextEdit, line: int, gutter: int, metadata: Variant) {
}
TextEdit_get_line_gutter_metadata :: (using self: *TextEdit, line: int, gutter: int) -> Variant {
}
TextEdit_set_line_gutter_text :: (using self: *TextEdit, line: int, gutter: int, text: String) {
}
TextEdit_get_line_gutter_text :: (using self: *TextEdit, line: int, gutter: int) -> String {
}
TextEdit_set_line_gutter_icon :: (using self: *TextEdit, line: int, gutter: int, icon: Texture2D) {
}
TextEdit_get_line_gutter_icon :: (using self: *TextEdit, line: int, gutter: int) -> Texture2D {
}
TextEdit_set_line_gutter_item_color :: (using self: *TextEdit, line: int, gutter: int, color: Color) {
}
TextEdit_get_line_gutter_item_color :: (using self: *TextEdit, line: int, gutter: int) -> Color {
}
TextEdit_set_line_gutter_clickable :: (using self: *TextEdit, line: int, gutter: int, clickable: bool) {
}
TextEdit_is_line_gutter_clickable :: (using self: *TextEdit, line: int, gutter: int) -> bool {
}
TextEdit_set_line_background_color :: (using self: *TextEdit, line: int, color: Color) {
}
TextEdit_get_line_background_color :: (using self: *TextEdit, line: int) -> Color {
}
TextEdit_set_syntax_highlighter :: (using self: *TextEdit, syntax_highlighter: SyntaxHighlighter) {
}
TextEdit_get_syntax_highlighter :: (using self: *TextEdit) -> SyntaxHighlighter {
}
TextEdit_set_highlight_current_line :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_highlight_current_line_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_set_highlight_all_occurrences :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_highlight_all_occurrences_enabled :: (using self: *TextEdit) -> bool {
}
TextEdit_get_draw_control_chars :: (using self: *TextEdit) -> bool {
}
TextEdit_set_draw_control_chars :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_set_draw_tabs :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_drawing_tabs :: (using self: *TextEdit) -> bool {
}
TextEdit_set_draw_spaces :: (using self: *TextEdit, enabled: bool) {
}
TextEdit_is_drawing_spaces :: (using self: *TextEdit) -> bool {
}
TextEdit_get_menu :: (using self: *TextEdit) -> PopupMenu {
}
TextEdit_is_menu_visible :: (using self: *TextEdit) -> bool {
}
TextEdit_menu_option :: (using self: *TextEdit, option: int) {
}
TextEdit_adjust_carets_after_edit :: (using self: *TextEdit, caret: int, from_line: int, from_col: int, to_line: int, to_col: int) {
}
TextEdit_get_caret_index_edit_order :: (using self: *TextEdit) -> PackedInt32Array {
}
TextEdit_get_selection_line :: (using self: *TextEdit, caret_index: int) -> int {
}
TextEdit_get_selection_column :: (using self: *TextEdit, caret_index: int) -> int {
}

// TextLine
TextLine :: struct {
	__private: *void;
}

TextLine_clear :: (using self: *TextLine) {
}
TextLine_set_direction :: (using self: *TextLine, direction: TextServer.Direction) {
}
TextLine_get_direction :: (using self: *TextLine) -> TextServer.Direction {
}
TextLine_set_orientation :: (using self: *TextLine, orientation: TextServer.Orientation) {
}
TextLine_get_orientation :: (using self: *TextLine) -> TextServer.Orientation {
}
TextLine_set_preserve_invalid :: (using self: *TextLine, enabled: bool) {
}
TextLine_get_preserve_invalid :: (using self: *TextLine) -> bool {
}
TextLine_set_preserve_control :: (using self: *TextLine, enabled: bool) {
}
TextLine_get_preserve_control :: (using self: *TextLine) -> bool {
}
TextLine_set_bidi_override :: (using self: *TextLine, override: Array) {
}
TextLine_add_string :: (using self: *TextLine, text: String, font: Font, font_size: int, language: String, meta: Variant) -> bool {
}
TextLine_add_object :: (using self: *TextLine, key: Variant, size: Vector2, inline_align: InlineAlignment, length: int, baseline: float) -> bool {
}
TextLine_resize_object :: (using self: *TextLine, key: Variant, size: Vector2, inline_align: InlineAlignment, baseline: float) -> bool {
}
TextLine_set_width :: (using self: *TextLine, width: float) {
}
TextLine_get_width :: (using self: *TextLine) -> float {
}
TextLine_set_horizontal_alignment :: (using self: *TextLine, alignment: HorizontalAlignment) {
}
TextLine_get_horizontal_alignment :: (using self: *TextLine) -> HorizontalAlignment {
}
TextLine_tab_align :: (using self: *TextLine, tab_stops: PackedFloat32Array) {
}
TextLine_set_flags :: (using self: *TextLine, flags: TextServer.JustificationFlag) {
}
TextLine_get_flags :: (using self: *TextLine) -> TextServer.JustificationFlag {
}
TextLine_set_text_overrun_behavior :: (using self: *TextLine, overrun_behavior: TextServer.OverrunBehavior) {
}
TextLine_get_text_overrun_behavior :: (using self: *TextLine) -> TextServer.OverrunBehavior {
}
TextLine_set_ellipsis_char :: (using self: *TextLine, char: String) {
}
TextLine_get_ellipsis_char :: (using self: *TextLine) -> String {
}
TextLine_get_objects :: (using self: *TextLine) -> Array {
}
TextLine_get_object_rect :: (using self: *TextLine, key: Variant) -> Rect2 {
}
TextLine_get_size :: (using self: *TextLine) -> Vector2 {
}
TextLine_get_rid :: (using self: *TextLine) -> RID {
}
TextLine_get_line_ascent :: (using self: *TextLine) -> float {
}
TextLine_get_line_descent :: (using self: *TextLine) -> float {
}
TextLine_get_line_width :: (using self: *TextLine) -> float {
}
TextLine_get_line_underline_position :: (using self: *TextLine) -> float {
}
TextLine_get_line_underline_thickness :: (using self: *TextLine) -> float {
}
TextLine_draw :: (using self: *TextLine, canvas: RID, pos: Vector2, color: Color) {
}
TextLine_draw_outline :: (using self: *TextLine, canvas: RID, pos: Vector2, outline_size: int, color: Color) {
}
TextLine_hit_test :: (using self: *TextLine, coords: float) -> int {
}

// TextMesh
TextMesh :: struct {
	__private: *void;
}

TextMesh_set_horizontal_alignment :: (using self: *TextMesh, alignment: HorizontalAlignment) {
}
TextMesh_get_horizontal_alignment :: (using self: *TextMesh) -> HorizontalAlignment {
}
TextMesh_set_vertical_alignment :: (using self: *TextMesh, alignment: VerticalAlignment) {
}
TextMesh_get_vertical_alignment :: (using self: *TextMesh) -> VerticalAlignment {
}
TextMesh_set_text :: (using self: *TextMesh, text: String) {
}
TextMesh_get_text :: (using self: *TextMesh) -> String {
}
TextMesh_set_font :: (using self: *TextMesh, font: Font) {
}
TextMesh_get_font :: (using self: *TextMesh) -> Font {
}
TextMesh_set_font_size :: (using self: *TextMesh, font_size: int) {
}
TextMesh_get_font_size :: (using self: *TextMesh) -> int {
}
TextMesh_set_line_spacing :: (using self: *TextMesh, line_spacing: float) {
}
TextMesh_get_line_spacing :: (using self: *TextMesh) -> float {
}
TextMesh_set_autowrap_mode :: (using self: *TextMesh, autowrap_mode: TextServer.AutowrapMode) {
}
TextMesh_get_autowrap_mode :: (using self: *TextMesh) -> TextServer.AutowrapMode {
}
TextMesh_set_justification_flags :: (using self: *TextMesh, justification_flags: TextServer.JustificationFlag) {
}
TextMesh_get_justification_flags :: (using self: *TextMesh) -> TextServer.JustificationFlag {
}
TextMesh_set_depth :: (using self: *TextMesh, depth: float) {
}
TextMesh_get_depth :: (using self: *TextMesh) -> float {
}
TextMesh_set_width :: (using self: *TextMesh, width: float) {
}
TextMesh_get_width :: (using self: *TextMesh) -> float {
}
TextMesh_set_pixel_size :: (using self: *TextMesh, pixel_size: float) {
}
TextMesh_get_pixel_size :: (using self: *TextMesh) -> float {
}
TextMesh_set_offset :: (using self: *TextMesh, offset: Vector2) {
}
TextMesh_get_offset :: (using self: *TextMesh) -> Vector2 {
}
TextMesh_set_curve_step :: (using self: *TextMesh, curve_step: float) {
}
TextMesh_get_curve_step :: (using self: *TextMesh) -> float {
}
TextMesh_set_text_direction :: (using self: *TextMesh, direction: TextServer.Direction) {
}
TextMesh_get_text_direction :: (using self: *TextMesh) -> TextServer.Direction {
}
TextMesh_set_language :: (using self: *TextMesh, language: String) {
}
TextMesh_get_language :: (using self: *TextMesh) -> String {
}
TextMesh_set_structured_text_bidi_override :: (using self: *TextMesh, parser: TextServer.StructuredTextParser) {
}
TextMesh_get_structured_text_bidi_override :: (using self: *TextMesh) -> TextServer.StructuredTextParser {
}
TextMesh_set_structured_text_bidi_override_options :: (using self: *TextMesh, args: Array) {
}
TextMesh_get_structured_text_bidi_override_options :: (using self: *TextMesh) -> Array {
}
TextMesh_set_uppercase :: (using self: *TextMesh, enable: bool) {
}
TextMesh_is_uppercase :: (using self: *TextMesh) -> bool {
}

// TextParagraph
TextParagraph :: struct {
	__private: *void;
}

TextParagraph_clear :: (using self: *TextParagraph) {
}
TextParagraph_set_direction :: (using self: *TextParagraph, direction: TextServer.Direction) {
}
TextParagraph_get_direction :: (using self: *TextParagraph) -> TextServer.Direction {
}
TextParagraph_set_custom_punctuation :: (using self: *TextParagraph, custom_punctuation: String) {
}
TextParagraph_get_custom_punctuation :: (using self: *TextParagraph) -> String {
}
TextParagraph_set_orientation :: (using self: *TextParagraph, orientation: TextServer.Orientation) {
}
TextParagraph_get_orientation :: (using self: *TextParagraph) -> TextServer.Orientation {
}
TextParagraph_set_preserve_invalid :: (using self: *TextParagraph, enabled: bool) {
}
TextParagraph_get_preserve_invalid :: (using self: *TextParagraph) -> bool {
}
TextParagraph_set_preserve_control :: (using self: *TextParagraph, enabled: bool) {
}
TextParagraph_get_preserve_control :: (using self: *TextParagraph) -> bool {
}
TextParagraph_set_bidi_override :: (using self: *TextParagraph, override: Array) {
}
TextParagraph_set_dropcap :: (using self: *TextParagraph, text: String, font: Font, font_size: int, dropcap_margins: Rect2, language: String) -> bool {
}
TextParagraph_clear_dropcap :: (using self: *TextParagraph) {
}
TextParagraph_add_string :: (using self: *TextParagraph, text: String, font: Font, font_size: int, language: String, meta: Variant) -> bool {
}
TextParagraph_add_object :: (using self: *TextParagraph, key: Variant, size: Vector2, inline_align: InlineAlignment, length: int, baseline: float) -> bool {
}
TextParagraph_resize_object :: (using self: *TextParagraph, key: Variant, size: Vector2, inline_align: InlineAlignment, baseline: float) -> bool {
}
TextParagraph_set_alignment :: (using self: *TextParagraph, alignment: HorizontalAlignment) {
}
TextParagraph_get_alignment :: (using self: *TextParagraph) -> HorizontalAlignment {
}
TextParagraph_tab_align :: (using self: *TextParagraph, tab_stops: PackedFloat32Array) {
}
TextParagraph_set_break_flags :: (using self: *TextParagraph, flags: TextServer.LineBreakFlag) {
}
TextParagraph_get_break_flags :: (using self: *TextParagraph) -> TextServer.LineBreakFlag {
}
TextParagraph_set_justification_flags :: (using self: *TextParagraph, flags: TextServer.JustificationFlag) {
}
TextParagraph_get_justification_flags :: (using self: *TextParagraph) -> TextServer.JustificationFlag {
}
TextParagraph_set_text_overrun_behavior :: (using self: *TextParagraph, overrun_behavior: TextServer.OverrunBehavior) {
}
TextParagraph_get_text_overrun_behavior :: (using self: *TextParagraph) -> TextServer.OverrunBehavior {
}
TextParagraph_set_ellipsis_char :: (using self: *TextParagraph, char: String) {
}
TextParagraph_get_ellipsis_char :: (using self: *TextParagraph) -> String {
}
TextParagraph_set_width :: (using self: *TextParagraph, width: float) {
}
TextParagraph_get_width :: (using self: *TextParagraph) -> float {
}
TextParagraph_get_non_wrapped_size :: (using self: *TextParagraph) -> Vector2 {
}
TextParagraph_get_size :: (using self: *TextParagraph) -> Vector2 {
}
TextParagraph_get_rid :: (using self: *TextParagraph) -> RID {
}
TextParagraph_get_line_rid :: (using self: *TextParagraph, line: int) -> RID {
}
TextParagraph_get_dropcap_rid :: (using self: *TextParagraph) -> RID {
}
TextParagraph_get_line_count :: (using self: *TextParagraph) -> int {
}
TextParagraph_set_max_lines_visible :: (using self: *TextParagraph, max_lines_visible: int) {
}
TextParagraph_get_max_lines_visible :: (using self: *TextParagraph) -> int {
}
TextParagraph_get_line_objects :: (using self: *TextParagraph, line: int) -> Array {
}
TextParagraph_get_line_object_rect :: (using self: *TextParagraph, line: int, key: Variant) -> Rect2 {
}
TextParagraph_get_line_size :: (using self: *TextParagraph, line: int) -> Vector2 {
}
TextParagraph_get_line_range :: (using self: *TextParagraph, line: int) -> Vector2i {
}
TextParagraph_get_line_ascent :: (using self: *TextParagraph, line: int) -> float {
}
TextParagraph_get_line_descent :: (using self: *TextParagraph, line: int) -> float {
}
TextParagraph_get_line_width :: (using self: *TextParagraph, line: int) -> float {
}
TextParagraph_get_line_underline_position :: (using self: *TextParagraph, line: int) -> float {
}
TextParagraph_get_line_underline_thickness :: (using self: *TextParagraph, line: int) -> float {
}
TextParagraph_get_dropcap_size :: (using self: *TextParagraph) -> Vector2 {
}
TextParagraph_get_dropcap_lines :: (using self: *TextParagraph) -> int {
}
TextParagraph_draw :: (using self: *TextParagraph, canvas: RID, pos: Vector2, color: Color, dc_color: Color) {
}
TextParagraph_draw_outline :: (using self: *TextParagraph, canvas: RID, pos: Vector2, outline_size: int, color: Color, dc_color: Color) {
}
TextParagraph_draw_line :: (using self: *TextParagraph, canvas: RID, pos: Vector2, line: int, color: Color) {
}
TextParagraph_draw_line_outline :: (using self: *TextParagraph, canvas: RID, pos: Vector2, line: int, outline_size: int, color: Color) {
}
TextParagraph_draw_dropcap :: (using self: *TextParagraph, canvas: RID, pos: Vector2, color: Color) {
}
TextParagraph_draw_dropcap_outline :: (using self: *TextParagraph, canvas: RID, pos: Vector2, outline_size: int, color: Color) {
}
TextParagraph_hit_test :: (using self: *TextParagraph, coords: Vector2) -> int {
}

// TextServer
TextServer :: struct {
	__private: *void;

	FontAntialiasing :: enum {
		FONT_ANTIALIASING_NONE :: 0;
		FONT_ANTIALIASING_GRAY :: 1;
		FONT_ANTIALIASING_LCD :: 2;
	}
	FontLCDSubpixelLayout :: enum {
		FONT_LCD_SUBPIXEL_LAYOUT_NONE :: 0;
		FONT_LCD_SUBPIXEL_LAYOUT_HRGB :: 1;
		FONT_LCD_SUBPIXEL_LAYOUT_HBGR :: 2;
		FONT_LCD_SUBPIXEL_LAYOUT_VRGB :: 3;
		FONT_LCD_SUBPIXEL_LAYOUT_VBGR :: 4;
		FONT_LCD_SUBPIXEL_LAYOUT_MAX :: 5;
	}
	Direction :: enum {
		DIRECTION_AUTO :: 0;
		DIRECTION_LTR :: 1;
		DIRECTION_RTL :: 2;
		DIRECTION_INHERITED :: 3;
	}
	Orientation :: enum {
		ORIENTATION_HORIZONTAL :: 0;
		ORIENTATION_VERTICAL :: 1;
	}
	JustificationFlag :: enum_flags {
		JUSTIFICATION_NONE :: 0;
		JUSTIFICATION_KASHIDA :: 1;
		JUSTIFICATION_WORD_BOUND :: 2;
		JUSTIFICATION_TRIM_EDGE_SPACES :: 4;
		JUSTIFICATION_AFTER_LAST_TAB :: 8;
		JUSTIFICATION_CONSTRAIN_ELLIPSIS :: 16;
		JUSTIFICATION_SKIP_LAST_LINE :: 32;
		JUSTIFICATION_SKIP_LAST_LINE_WITH_VISIBLE_CHARS :: 64;
		JUSTIFICATION_DO_NOT_SKIP_SINGLE_LINE :: 128;
	}
	AutowrapMode :: enum {
		AUTOWRAP_OFF :: 0;
		AUTOWRAP_ARBITRARY :: 1;
		AUTOWRAP_WORD :: 2;
		AUTOWRAP_WORD_SMART :: 3;
	}
	LineBreakFlag :: enum_flags {
		BREAK_NONE :: 0;
		BREAK_MANDATORY :: 1;
		BREAK_WORD_BOUND :: 2;
		BREAK_GRAPHEME_BOUND :: 4;
		BREAK_ADAPTIVE :: 8;
		BREAK_TRIM_EDGE_SPACES :: 16;
		BREAK_TRIM_INDENT :: 32;
	}
	VisibleCharactersBehavior :: enum {
		VC_CHARS_BEFORE_SHAPING :: 0;
		VC_CHARS_AFTER_SHAPING :: 1;
		VC_GLYPHS_AUTO :: 2;
		VC_GLYPHS_LTR :: 3;
		VC_GLYPHS_RTL :: 4;
	}
	OverrunBehavior :: enum {
		OVERRUN_NO_TRIMMING :: 0;
		OVERRUN_TRIM_CHAR :: 1;
		OVERRUN_TRIM_WORD :: 2;
		OVERRUN_TRIM_ELLIPSIS :: 3;
		OVERRUN_TRIM_WORD_ELLIPSIS :: 4;
	}
	TextOverrunFlag :: enum_flags {
		OVERRUN_NO_TRIM :: 0;
		OVERRUN_TRIM :: 1;
		OVERRUN_TRIM_WORD_ONLY :: 2;
		OVERRUN_ADD_ELLIPSIS :: 4;
		OVERRUN_ENFORCE_ELLIPSIS :: 8;
		OVERRUN_JUSTIFICATION_AWARE :: 16;
	}
	GraphemeFlag :: enum_flags {
		GRAPHEME_IS_VALID :: 1;
		GRAPHEME_IS_RTL :: 2;
		GRAPHEME_IS_VIRTUAL :: 4;
		GRAPHEME_IS_SPACE :: 8;
		GRAPHEME_IS_BREAK_HARD :: 16;
		GRAPHEME_IS_BREAK_SOFT :: 32;
		GRAPHEME_IS_TAB :: 64;
		GRAPHEME_IS_ELONGATION :: 128;
		GRAPHEME_IS_PUNCTUATION :: 256;
		GRAPHEME_IS_UNDERSCORE :: 512;
		GRAPHEME_IS_CONNECTED :: 1024;
		GRAPHEME_IS_SAFE_TO_INSERT_TATWEEL :: 2048;
		GRAPHEME_IS_EMBEDDED_OBJECT :: 4096;
		GRAPHEME_IS_SOFT_HYPHEN :: 8192;
	}
	Hinting :: enum {
		HINTING_NONE :: 0;
		HINTING_LIGHT :: 1;
		HINTING_NORMAL :: 2;
	}
	SubpixelPositioning :: enum {
		SUBPIXEL_POSITIONING_DISABLED :: 0;
		SUBPIXEL_POSITIONING_AUTO :: 1;
		SUBPIXEL_POSITIONING_ONE_HALF :: 2;
		SUBPIXEL_POSITIONING_ONE_QUARTER :: 3;
		SUBPIXEL_POSITIONING_ONE_HALF_MAX_SIZE :: 20;
		SUBPIXEL_POSITIONING_ONE_QUARTER_MAX_SIZE :: 16;
	}
	Feature :: enum {
		FEATURE_SIMPLE_LAYOUT :: 1;
		FEATURE_BIDI_LAYOUT :: 2;
		FEATURE_VERTICAL_LAYOUT :: 4;
		FEATURE_SHAPING :: 8;
		FEATURE_KASHIDA_JUSTIFICATION :: 16;
		FEATURE_BREAK_ITERATORS :: 32;
		FEATURE_FONT_BITMAP :: 64;
		FEATURE_FONT_DYNAMIC :: 128;
		FEATURE_FONT_MSDF :: 256;
		FEATURE_FONT_SYSTEM :: 512;
		FEATURE_FONT_VARIABLE :: 1024;
		FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION :: 2048;
		FEATURE_USE_SUPPORT_DATA :: 4096;
		FEATURE_UNICODE_IDENTIFIERS :: 8192;
		FEATURE_UNICODE_SECURITY :: 16384;
	}
	ContourPointTag :: enum {
		CONTOUR_CURVE_TAG_ON :: 1;
		CONTOUR_CURVE_TAG_OFF_CONIC :: 0;
		CONTOUR_CURVE_TAG_OFF_CUBIC :: 2;
	}
	SpacingType :: enum {
		SPACING_GLYPH :: 0;
		SPACING_SPACE :: 1;
		SPACING_TOP :: 2;
		SPACING_BOTTOM :: 3;
		SPACING_MAX :: 4;
	}
	FontStyle :: enum_flags {
		FONT_BOLD :: 1;
		FONT_ITALIC :: 2;
		FONT_FIXED_WIDTH :: 4;
	}
	StructuredTextParser :: enum {
		STRUCTURED_TEXT_DEFAULT :: 0;
		STRUCTURED_TEXT_URI :: 1;
		STRUCTURED_TEXT_FILE :: 2;
		STRUCTURED_TEXT_EMAIL :: 3;
		STRUCTURED_TEXT_LIST :: 4;
		STRUCTURED_TEXT_GDSCRIPT :: 5;
		STRUCTURED_TEXT_CUSTOM :: 6;
	}
	FixedSizeScaleMode :: enum {
		FIXED_SIZE_SCALE_DISABLE :: 0;
		FIXED_SIZE_SCALE_INTEGER_ONLY :: 1;
		FIXED_SIZE_SCALE_ENABLED :: 2;
	}
}

TextServer_has_feature :: (using self: *TextServer, feature: TextServer.Feature) -> bool {
}
TextServer_get_name :: (using self: *TextServer) -> String {
}
TextServer_get_features :: (using self: *TextServer) -> int {
}
TextServer_load_support_data :: (using self: *TextServer, filename: String) -> bool {
}
TextServer_get_support_data_filename :: (using self: *TextServer) -> String {
}
TextServer_get_support_data_info :: (using self: *TextServer) -> String {
}
TextServer_save_support_data :: (using self: *TextServer, filename: String) -> bool {
}
TextServer_is_locale_right_to_left :: (using self: *TextServer, locale: String) -> bool {
}
TextServer_name_to_tag :: (using self: *TextServer, name: String) -> int {
}
TextServer_tag_to_name :: (using self: *TextServer, tag: int) -> String {
}
TextServer_has :: (using self: *TextServer, rid: RID) -> bool {
}
TextServer_free_rid :: (using self: *TextServer, rid: RID) {
}
TextServer_create_font :: (using self: *TextServer) -> RID {
}
TextServer_create_font_linked_variation :: (using self: *TextServer, font_rid: RID) -> RID {
}
TextServer_font_set_data :: (using self: *TextServer, font_rid: RID, data: PackedByteArray) {
}
TextServer_font_set_face_index :: (using self: *TextServer, font_rid: RID, face_index: int) {
}
TextServer_font_get_face_index :: (using self: *TextServer, font_rid: RID) -> int {
}
TextServer_font_get_face_count :: (using self: *TextServer, font_rid: RID) -> int {
}
TextServer_font_set_style :: (using self: *TextServer, font_rid: RID, style: TextServer.FontStyle) {
}
TextServer_font_get_style :: (using self: *TextServer, font_rid: RID) -> TextServer.FontStyle {
}
TextServer_font_set_name :: (using self: *TextServer, font_rid: RID, name: String) {
}
TextServer_font_get_name :: (using self: *TextServer, font_rid: RID) -> String {
}
TextServer_font_get_ot_name_strings :: (using self: *TextServer, font_rid: RID) -> Dictionary {
}
TextServer_font_set_style_name :: (using self: *TextServer, font_rid: RID, name: String) {
}
TextServer_font_get_style_name :: (using self: *TextServer, font_rid: RID) -> String {
}
TextServer_font_set_weight :: (using self: *TextServer, font_rid: RID, weight: int) {
}
TextServer_font_get_weight :: (using self: *TextServer, font_rid: RID) -> int {
}
TextServer_font_set_stretch :: (using self: *TextServer, font_rid: RID, weight: int) {
}
TextServer_font_get_stretch :: (using self: *TextServer, font_rid: RID) -> int {
}
TextServer_font_set_antialiasing :: (using self: *TextServer, font_rid: RID, antialiasing: TextServer.FontAntialiasing) {
}
TextServer_font_get_antialiasing :: (using self: *TextServer, font_rid: RID) -> TextServer.FontAntialiasing {
}
TextServer_font_set_disable_embedded_bitmaps :: (using self: *TextServer, font_rid: RID, disable_embedded_bitmaps: bool) {
}
TextServer_font_get_disable_embedded_bitmaps :: (using self: *TextServer, font_rid: RID) -> bool {
}
TextServer_font_set_generate_mipmaps :: (using self: *TextServer, font_rid: RID, generate_mipmaps: bool) {
}
TextServer_font_get_generate_mipmaps :: (using self: *TextServer, font_rid: RID) -> bool {
}
TextServer_font_set_multichannel_signed_distance_field :: (using self: *TextServer, font_rid: RID, msdf: bool) {
}
TextServer_font_is_multichannel_signed_distance_field :: (using self: *TextServer, font_rid: RID) -> bool {
}
TextServer_font_set_msdf_pixel_range :: (using self: *TextServer, font_rid: RID, msdf_pixel_range: int) {
}
TextServer_font_get_msdf_pixel_range :: (using self: *TextServer, font_rid: RID) -> int {
}
TextServer_font_set_msdf_size :: (using self: *TextServer, font_rid: RID, msdf_size: int) {
}
TextServer_font_get_msdf_size :: (using self: *TextServer, font_rid: RID) -> int {
}
TextServer_font_set_fixed_size :: (using self: *TextServer, font_rid: RID, fixed_size: int) {
}
TextServer_font_get_fixed_size :: (using self: *TextServer, font_rid: RID) -> int {
}
TextServer_font_set_fixed_size_scale_mode :: (using self: *TextServer, font_rid: RID, fixed_size_scale_mode: TextServer.FixedSizeScaleMode) {
}
TextServer_font_get_fixed_size_scale_mode :: (using self: *TextServer, font_rid: RID) -> TextServer.FixedSizeScaleMode {
}
TextServer_font_set_allow_system_fallback :: (using self: *TextServer, font_rid: RID, allow_system_fallback: bool) {
}
TextServer_font_is_allow_system_fallback :: (using self: *TextServer, font_rid: RID) -> bool {
}
TextServer_font_set_force_autohinter :: (using self: *TextServer, font_rid: RID, force_autohinter: bool) {
}
TextServer_font_is_force_autohinter :: (using self: *TextServer, font_rid: RID) -> bool {
}
TextServer_font_set_hinting :: (using self: *TextServer, font_rid: RID, hinting: TextServer.Hinting) {
}
TextServer_font_get_hinting :: (using self: *TextServer, font_rid: RID) -> TextServer.Hinting {
}
TextServer_font_set_subpixel_positioning :: (using self: *TextServer, font_rid: RID, subpixel_positioning: TextServer.SubpixelPositioning) {
}
TextServer_font_get_subpixel_positioning :: (using self: *TextServer, font_rid: RID) -> TextServer.SubpixelPositioning {
}
TextServer_font_set_embolden :: (using self: *TextServer, font_rid: RID, strength: float) {
}
TextServer_font_get_embolden :: (using self: *TextServer, font_rid: RID) -> float {
}
TextServer_font_set_spacing :: (using self: *TextServer, font_rid: RID, spacing: TextServer.SpacingType, value: int) {
}
TextServer_font_get_spacing :: (using self: *TextServer, font_rid: RID, spacing: TextServer.SpacingType) -> int {
}
TextServer_font_set_baseline_offset :: (using self: *TextServer, font_rid: RID, baseline_offset: float) {
}
TextServer_font_get_baseline_offset :: (using self: *TextServer, font_rid: RID) -> float {
}
TextServer_font_set_transform :: (using self: *TextServer, font_rid: RID, transform: Transform2D) {
}
TextServer_font_get_transform :: (using self: *TextServer, font_rid: RID) -> Transform2D {
}
TextServer_font_set_variation_coordinates :: (using self: *TextServer, font_rid: RID, variation_coordinates: Dictionary) {
}
TextServer_font_get_variation_coordinates :: (using self: *TextServer, font_rid: RID) -> Dictionary {
}
TextServer_font_set_oversampling :: (using self: *TextServer, font_rid: RID, oversampling: float) {
}
TextServer_font_get_oversampling :: (using self: *TextServer, font_rid: RID) -> float {
}
TextServer_font_get_size_cache_list :: (using self: *TextServer, font_rid: RID) -> Array {
}
TextServer_font_clear_size_cache :: (using self: *TextServer, font_rid: RID) {
}
TextServer_font_remove_size_cache :: (using self: *TextServer, font_rid: RID, size: Vector2i) {
}
TextServer_font_set_ascent :: (using self: *TextServer, font_rid: RID, size: int, ascent: float) {
}
TextServer_font_get_ascent :: (using self: *TextServer, font_rid: RID, size: int) -> float {
}
TextServer_font_set_descent :: (using self: *TextServer, font_rid: RID, size: int, descent: float) {
}
TextServer_font_get_descent :: (using self: *TextServer, font_rid: RID, size: int) -> float {
}
TextServer_font_set_underline_position :: (using self: *TextServer, font_rid: RID, size: int, underline_position: float) {
}
TextServer_font_get_underline_position :: (using self: *TextServer, font_rid: RID, size: int) -> float {
}
TextServer_font_set_underline_thickness :: (using self: *TextServer, font_rid: RID, size: int, underline_thickness: float) {
}
TextServer_font_get_underline_thickness :: (using self: *TextServer, font_rid: RID, size: int) -> float {
}
TextServer_font_set_scale :: (using self: *TextServer, font_rid: RID, size: int, scale: float) {
}
TextServer_font_get_scale :: (using self: *TextServer, font_rid: RID, size: int) -> float {
}
TextServer_font_get_texture_count :: (using self: *TextServer, font_rid: RID, size: Vector2i) -> int {
}
TextServer_font_clear_textures :: (using self: *TextServer, font_rid: RID, size: Vector2i) {
}
TextServer_font_remove_texture :: (using self: *TextServer, font_rid: RID, size: Vector2i, texture_index: int) {
}
TextServer_font_set_texture_image :: (using self: *TextServer, font_rid: RID, size: Vector2i, texture_index: int, image: Image) {
}
TextServer_font_get_texture_image :: (using self: *TextServer, font_rid: RID, size: Vector2i, texture_index: int) -> Image {
}
TextServer_font_set_texture_offsets :: (using self: *TextServer, font_rid: RID, size: Vector2i, texture_index: int, offset: PackedInt32Array) {
}
TextServer_font_get_texture_offsets :: (using self: *TextServer, font_rid: RID, size: Vector2i, texture_index: int) -> PackedInt32Array {
}
TextServer_font_get_glyph_list :: (using self: *TextServer, font_rid: RID, size: Vector2i) -> PackedInt32Array {
}
TextServer_font_clear_glyphs :: (using self: *TextServer, font_rid: RID, size: Vector2i) {
}
TextServer_font_remove_glyph :: (using self: *TextServer, font_rid: RID, size: Vector2i, glyph: int) {
}
TextServer_font_get_glyph_advance :: (using self: *TextServer, font_rid: RID, size: int, glyph: int) -> Vector2 {
}
TextServer_font_set_glyph_advance :: (using self: *TextServer, font_rid: RID, size: int, glyph: int, advance: Vector2) {
}
TextServer_font_get_glyph_offset :: (using self: *TextServer, font_rid: RID, size: Vector2i, glyph: int) -> Vector2 {
}
TextServer_font_set_glyph_offset :: (using self: *TextServer, font_rid: RID, size: Vector2i, glyph: int, offset: Vector2) {
}
TextServer_font_get_glyph_size :: (using self: *TextServer, font_rid: RID, size: Vector2i, glyph: int) -> Vector2 {
}
TextServer_font_set_glyph_size :: (using self: *TextServer, font_rid: RID, size: Vector2i, glyph: int, gl_size: Vector2) {
}
TextServer_font_get_glyph_uv_rect :: (using self: *TextServer, font_rid: RID, size: Vector2i, glyph: int) -> Rect2 {
}
TextServer_font_set_glyph_uv_rect :: (using self: *TextServer, font_rid: RID, size: Vector2i, glyph: int, uv_rect: Rect2) {
}
TextServer_font_get_glyph_texture_idx :: (using self: *TextServer, font_rid: RID, size: Vector2i, glyph: int) -> int {
}
TextServer_font_set_glyph_texture_idx :: (using self: *TextServer, font_rid: RID, size: Vector2i, glyph: int, texture_idx: int) {
}
TextServer_font_get_glyph_texture_rid :: (using self: *TextServer, font_rid: RID, size: Vector2i, glyph: int) -> RID {
}
TextServer_font_get_glyph_texture_size :: (using self: *TextServer, font_rid: RID, size: Vector2i, glyph: int) -> Vector2 {
}
TextServer_font_get_glyph_contours :: (using self: *TextServer, font: RID, size: int, index: int) -> Dictionary {
}
TextServer_font_get_kerning_list :: (using self: *TextServer, font_rid: RID, size: int) -> Array {
}
TextServer_font_clear_kerning_map :: (using self: *TextServer, font_rid: RID, size: int) {
}
TextServer_font_remove_kerning :: (using self: *TextServer, font_rid: RID, size: int, glyph_pair: Vector2i) {
}
TextServer_font_set_kerning :: (using self: *TextServer, font_rid: RID, size: int, glyph_pair: Vector2i, kerning: Vector2) {
}
TextServer_font_get_kerning :: (using self: *TextServer, font_rid: RID, size: int, glyph_pair: Vector2i) -> Vector2 {
}
TextServer_font_get_glyph_index :: (using self: *TextServer, font_rid: RID, size: int, char: int, variation_selector: int) -> int {
}
TextServer_font_get_char_from_glyph_index :: (using self: *TextServer, font_rid: RID, size: int, glyph_index: int) -> int {
}
TextServer_font_has_char :: (using self: *TextServer, font_rid: RID, char: int) -> bool {
}
TextServer_font_get_supported_chars :: (using self: *TextServer, font_rid: RID) -> String {
}
TextServer_font_render_range :: (using self: *TextServer, font_rid: RID, size: Vector2i, start: int, end: int) {
}
TextServer_font_render_glyph :: (using self: *TextServer, font_rid: RID, size: Vector2i, index: int) {
}
TextServer_font_draw_glyph :: (using self: *TextServer, font_rid: RID, canvas: RID, size: int, pos: Vector2, index: int, color: Color) {
}
TextServer_font_draw_glyph_outline :: (using self: *TextServer, font_rid: RID, canvas: RID, size: int, outline_size: int, pos: Vector2, index: int, color: Color) {
}
TextServer_font_is_language_supported :: (using self: *TextServer, font_rid: RID, language: String) -> bool {
}
TextServer_font_set_language_support_override :: (using self: *TextServer, font_rid: RID, language: String, supported: bool) {
}
TextServer_font_get_language_support_override :: (using self: *TextServer, font_rid: RID, language: String) -> bool {
}
TextServer_font_remove_language_support_override :: (using self: *TextServer, font_rid: RID, language: String) {
}
TextServer_font_get_language_support_overrides :: (using self: *TextServer, font_rid: RID) -> PackedStringArray {
}
TextServer_font_is_script_supported :: (using self: *TextServer, font_rid: RID, script: String) -> bool {
}
TextServer_font_set_script_support_override :: (using self: *TextServer, font_rid: RID, script: String, supported: bool) {
}
TextServer_font_get_script_support_override :: (using self: *TextServer, font_rid: RID, script: String) -> bool {
}
TextServer_font_remove_script_support_override :: (using self: *TextServer, font_rid: RID, script: String) {
}
TextServer_font_get_script_support_overrides :: (using self: *TextServer, font_rid: RID) -> PackedStringArray {
}
TextServer_font_set_opentype_feature_overrides :: (using self: *TextServer, font_rid: RID, overrides: Dictionary) {
}
TextServer_font_get_opentype_feature_overrides :: (using self: *TextServer, font_rid: RID) -> Dictionary {
}
TextServer_font_supported_feature_list :: (using self: *TextServer, font_rid: RID) -> Dictionary {
}
TextServer_font_supported_variation_list :: (using self: *TextServer, font_rid: RID) -> Dictionary {
}
TextServer_font_get_global_oversampling :: (using self: *TextServer) -> float {
}
TextServer_font_set_global_oversampling :: (using self: *TextServer, oversampling: float) {
}
TextServer_get_hex_code_box_size :: (using self: *TextServer, size: int, index: int) -> Vector2 {
}
TextServer_draw_hex_code_box :: (using self: *TextServer, canvas: RID, size: int, pos: Vector2, index: int, color: Color) {
}
TextServer_create_shaped_text :: (using self: *TextServer, direction: TextServer.Direction, orientation: TextServer.Orientation) -> RID {
}
TextServer_shaped_text_clear :: (using self: *TextServer, rid: RID) {
}
TextServer_shaped_text_set_direction :: (using self: *TextServer, shaped: RID, direction: TextServer.Direction) {
}
TextServer_shaped_text_get_direction :: (using self: *TextServer, shaped: RID) -> TextServer.Direction {
}
TextServer_shaped_text_get_inferred_direction :: (using self: *TextServer, shaped: RID) -> TextServer.Direction {
}
TextServer_shaped_text_set_bidi_override :: (using self: *TextServer, shaped: RID, override: Array) {
}
TextServer_shaped_text_set_custom_punctuation :: (using self: *TextServer, shaped: RID, punct: String) {
}
TextServer_shaped_text_get_custom_punctuation :: (using self: *TextServer, shaped: RID) -> String {
}
TextServer_shaped_text_set_custom_ellipsis :: (using self: *TextServer, shaped: RID, char: int) {
}
TextServer_shaped_text_get_custom_ellipsis :: (using self: *TextServer, shaped: RID) -> int {
}
TextServer_shaped_text_set_orientation :: (using self: *TextServer, shaped: RID, orientation: TextServer.Orientation) {
}
TextServer_shaped_text_get_orientation :: (using self: *TextServer, shaped: RID) -> TextServer.Orientation {
}
TextServer_shaped_text_set_preserve_invalid :: (using self: *TextServer, shaped: RID, enabled: bool) {
}
TextServer_shaped_text_get_preserve_invalid :: (using self: *TextServer, shaped: RID) -> bool {
}
TextServer_shaped_text_set_preserve_control :: (using self: *TextServer, shaped: RID, enabled: bool) {
}
TextServer_shaped_text_get_preserve_control :: (using self: *TextServer, shaped: RID) -> bool {
}
TextServer_shaped_text_set_spacing :: (using self: *TextServer, shaped: RID, spacing: TextServer.SpacingType, value: int) {
}
TextServer_shaped_text_get_spacing :: (using self: *TextServer, shaped: RID, spacing: TextServer.SpacingType) -> int {
}
TextServer_shaped_text_add_string :: (using self: *TextServer, shaped: RID, text: String, fonts: Array, size: int, opentype_features: Dictionary, language: String, meta: Variant) -> bool {
}
TextServer_shaped_text_add_object :: (using self: *TextServer, shaped: RID, key: Variant, size: Vector2, inline_align: InlineAlignment, length: int, baseline: float) -> bool {
}
TextServer_shaped_text_resize_object :: (using self: *TextServer, shaped: RID, key: Variant, size: Vector2, inline_align: InlineAlignment, baseline: float) -> bool {
}
TextServer_shaped_get_span_count :: (using self: *TextServer, shaped: RID) -> int {
}
TextServer_shaped_get_span_meta :: (using self: *TextServer, shaped: RID, index: int) -> Variant {
}
TextServer_shaped_set_span_update_font :: (using self: *TextServer, shaped: RID, index: int, fonts: Array, size: int, opentype_features: Dictionary) {
}
TextServer_shaped_text_substr :: (using self: *TextServer, shaped: RID, start: int, length: int) -> RID {
}
TextServer_shaped_text_get_parent :: (using self: *TextServer, shaped: RID) -> RID {
}
TextServer_shaped_text_fit_to_width :: (using self: *TextServer, shaped: RID, width: float, justification_flags: TextServer.JustificationFlag) -> float {
}
TextServer_shaped_text_tab_align :: (using self: *TextServer, shaped: RID, tab_stops: PackedFloat32Array) -> float {
}
TextServer_shaped_text_shape :: (using self: *TextServer, shaped: RID) -> bool {
}
TextServer_shaped_text_is_ready :: (using self: *TextServer, shaped: RID) -> bool {
}
TextServer_shaped_text_has_visible_chars :: (using self: *TextServer, shaped: RID) -> bool {
}
TextServer_shaped_text_get_glyphs :: (using self: *TextServer, shaped: RID) -> Dictionary {
}
TextServer_shaped_text_sort_logical :: (using self: *TextServer, shaped: RID) -> Dictionary {
}
TextServer_shaped_text_get_glyph_count :: (using self: *TextServer, shaped: RID) -> int {
}
TextServer_shaped_text_get_range :: (using self: *TextServer, shaped: RID) -> Vector2i {
}
TextServer_shaped_text_get_line_breaks_adv :: (using self: *TextServer, shaped: RID, width: PackedFloat32Array, start: int, once: bool, break_flags: TextServer.LineBreakFlag) -> PackedInt32Array {
}
TextServer_shaped_text_get_line_breaks :: (using self: *TextServer, shaped: RID, width: float, start: int, break_flags: TextServer.LineBreakFlag) -> PackedInt32Array {
}
TextServer_shaped_text_get_word_breaks :: (using self: *TextServer, shaped: RID, grapheme_flags: TextServer.GraphemeFlag, skip_grapheme_flags: TextServer.GraphemeFlag) -> PackedInt32Array {
}
TextServer_shaped_text_get_trim_pos :: (using self: *TextServer, shaped: RID) -> int {
}
TextServer_shaped_text_get_ellipsis_pos :: (using self: *TextServer, shaped: RID) -> int {
}
TextServer_shaped_text_get_ellipsis_glyphs :: (using self: *TextServer, shaped: RID) -> Dictionary {
}
TextServer_shaped_text_get_ellipsis_glyph_count :: (using self: *TextServer, shaped: RID) -> int {
}
TextServer_shaped_text_overrun_trim_to_width :: (using self: *TextServer, shaped: RID, width: float, overrun_trim_flags: TextServer.TextOverrunFlag) {
}
TextServer_shaped_text_get_objects :: (using self: *TextServer, shaped: RID) -> Array {
}
TextServer_shaped_text_get_object_rect :: (using self: *TextServer, shaped: RID, key: Variant) -> Rect2 {
}
TextServer_shaped_text_get_object_range :: (using self: *TextServer, shaped: RID, key: Variant) -> Vector2i {
}
TextServer_shaped_text_get_object_glyph :: (using self: *TextServer, shaped: RID, key: Variant) -> int {
}
TextServer_shaped_text_get_size :: (using self: *TextServer, shaped: RID) -> Vector2 {
}
TextServer_shaped_text_get_ascent :: (using self: *TextServer, shaped: RID) -> float {
}
TextServer_shaped_text_get_descent :: (using self: *TextServer, shaped: RID) -> float {
}
TextServer_shaped_text_get_width :: (using self: *TextServer, shaped: RID) -> float {
}
TextServer_shaped_text_get_underline_position :: (using self: *TextServer, shaped: RID) -> float {
}
TextServer_shaped_text_get_underline_thickness :: (using self: *TextServer, shaped: RID) -> float {
}
TextServer_shaped_text_get_carets :: (using self: *TextServer, shaped: RID, position: int) -> Dictionary {
}
TextServer_shaped_text_get_selection :: (using self: *TextServer, shaped: RID, start: int, end: int) -> PackedVector2Array {
}
TextServer_shaped_text_hit_test_grapheme :: (using self: *TextServer, shaped: RID, coords: float) -> int {
}
TextServer_shaped_text_hit_test_position :: (using self: *TextServer, shaped: RID, coords: float) -> int {
}
TextServer_shaped_text_get_grapheme_bounds :: (using self: *TextServer, shaped: RID, pos: int) -> Vector2 {
}
TextServer_shaped_text_next_grapheme_pos :: (using self: *TextServer, shaped: RID, pos: int) -> int {
}
TextServer_shaped_text_prev_grapheme_pos :: (using self: *TextServer, shaped: RID, pos: int) -> int {
}
TextServer_shaped_text_get_character_breaks :: (using self: *TextServer, shaped: RID) -> PackedInt32Array {
}
TextServer_shaped_text_next_character_pos :: (using self: *TextServer, shaped: RID, pos: int) -> int {
}
TextServer_shaped_text_prev_character_pos :: (using self: *TextServer, shaped: RID, pos: int) -> int {
}
TextServer_shaped_text_closest_character_pos :: (using self: *TextServer, shaped: RID, pos: int) -> int {
}
TextServer_shaped_text_draw :: (using self: *TextServer, shaped: RID, canvas: RID, pos: Vector2, clip_l: float, clip_r: float, color: Color) {
}
TextServer_shaped_text_draw_outline :: (using self: *TextServer, shaped: RID, canvas: RID, pos: Vector2, clip_l: float, clip_r: float, outline_size: int, color: Color) {
}
TextServer_shaped_text_get_dominant_direction_in_range :: (using self: *TextServer, shaped: RID, start: int, end: int) -> TextServer.Direction {
}
TextServer_format_number :: (using self: *TextServer, number: String, language: String) -> String {
}
TextServer_parse_number :: (using self: *TextServer, number: String, language: String) -> String {
}
TextServer_percent_sign :: (using self: *TextServer, language: String) -> String {
}
TextServer_string_get_word_breaks :: (using self: *TextServer, _string: String, language: String, chars_per_line: int) -> PackedInt32Array {
}
TextServer_string_get_character_breaks :: (using self: *TextServer, _string: String, language: String) -> PackedInt32Array {
}
TextServer_is_confusable :: (using self: *TextServer, _string: String, dict: PackedStringArray) -> int {
}
TextServer_spoof_check :: (using self: *TextServer, _string: String) -> bool {
}
TextServer_strip_diacritics :: (using self: *TextServer, _string: String) -> String {
}
TextServer_is_valid_identifier :: (using self: *TextServer, _string: String) -> bool {
}
TextServer_is_valid_letter :: (using self: *TextServer, unicode: int) -> bool {
}
TextServer_string_to_upper :: (using self: *TextServer, _string: String, language: String) -> String {
}
TextServer_string_to_lower :: (using self: *TextServer, _string: String, language: String) -> String {
}
TextServer_string_to_title :: (using self: *TextServer, _string: String, language: String) -> String {
}
TextServer_parse_structured_text :: (using self: *TextServer, parser_type: TextServer.StructuredTextParser, args: Array, text: String) -> Array {
}

// TextServerAdvanced
TextServerAdvanced :: struct {
	__private: *void;
}

// TextServerDummy
TextServerDummy :: struct {
	__private: *void;
}

// TextServerExtension
TextServerExtension :: struct {
	__private: *void;
}

TextServerExtension__has_feature :: (using self: *TextServerExtension, feature: TextServer.Feature) -> bool {
}
TextServerExtension__get_name :: (using self: *TextServerExtension) -> String {
}
TextServerExtension__get_features :: (using self: *TextServerExtension) -> int {
}
TextServerExtension__free_rid :: (using self: *TextServerExtension, rid: RID) {
}
TextServerExtension__has :: (using self: *TextServerExtension, rid: RID) -> bool {
}
TextServerExtension__load_support_data :: (using self: *TextServerExtension, filename: String) -> bool {
}
TextServerExtension__get_support_data_filename :: (using self: *TextServerExtension) -> String {
}
TextServerExtension__get_support_data_info :: (using self: *TextServerExtension) -> String {
}
TextServerExtension__save_support_data :: (using self: *TextServerExtension, filename: String) -> bool {
}
TextServerExtension__is_locale_right_to_left :: (using self: *TextServerExtension, locale: String) -> bool {
}
TextServerExtension__name_to_tag :: (using self: *TextServerExtension, name: String) -> int {
}
TextServerExtension__tag_to_name :: (using self: *TextServerExtension, tag: int) -> String {
}
TextServerExtension__create_font :: (using self: *TextServerExtension) -> RID {
}
TextServerExtension__create_font_linked_variation :: (using self: *TextServerExtension, font_rid: RID) -> RID {
}
TextServerExtension__font_set_data :: (using self: *TextServerExtension, font_rid: RID, data: PackedByteArray) {
}
TextServerExtension__font_set_data_ptr :: (using self: *TextServerExtension, font_rid: RID, data_ptr: *u8, data_size: int) {
}
TextServerExtension__font_set_face_index :: (using self: *TextServerExtension, font_rid: RID, face_index: int) {
}
TextServerExtension__font_get_face_index :: (using self: *TextServerExtension, font_rid: RID) -> int {
}
TextServerExtension__font_get_face_count :: (using self: *TextServerExtension, font_rid: RID) -> int {
}
TextServerExtension__font_set_style :: (using self: *TextServerExtension, font_rid: RID, style: TextServer.FontStyle) {
}
TextServerExtension__font_get_style :: (using self: *TextServerExtension, font_rid: RID) -> TextServer.FontStyle {
}
TextServerExtension__font_set_name :: (using self: *TextServerExtension, font_rid: RID, name: String) {
}
TextServerExtension__font_get_name :: (using self: *TextServerExtension, font_rid: RID) -> String {
}
TextServerExtension__font_get_ot_name_strings :: (using self: *TextServerExtension, font_rid: RID) -> Dictionary {
}
TextServerExtension__font_set_style_name :: (using self: *TextServerExtension, font_rid: RID, name_style: String) {
}
TextServerExtension__font_get_style_name :: (using self: *TextServerExtension, font_rid: RID) -> String {
}
TextServerExtension__font_set_weight :: (using self: *TextServerExtension, font_rid: RID, weight: int) {
}
TextServerExtension__font_get_weight :: (using self: *TextServerExtension, font_rid: RID) -> int {
}
TextServerExtension__font_set_stretch :: (using self: *TextServerExtension, font_rid: RID, stretch: int) {
}
TextServerExtension__font_get_stretch :: (using self: *TextServerExtension, font_rid: RID) -> int {
}
TextServerExtension__font_set_antialiasing :: (using self: *TextServerExtension, font_rid: RID, antialiasing: TextServer.FontAntialiasing) {
}
TextServerExtension__font_get_antialiasing :: (using self: *TextServerExtension, font_rid: RID) -> TextServer.FontAntialiasing {
}
TextServerExtension__font_set_disable_embedded_bitmaps :: (using self: *TextServerExtension, font_rid: RID, disable_embedded_bitmaps: bool) {
}
TextServerExtension__font_get_disable_embedded_bitmaps :: (using self: *TextServerExtension, font_rid: RID) -> bool {
}
TextServerExtension__font_set_generate_mipmaps :: (using self: *TextServerExtension, font_rid: RID, generate_mipmaps: bool) {
}
TextServerExtension__font_get_generate_mipmaps :: (using self: *TextServerExtension, font_rid: RID) -> bool {
}
TextServerExtension__font_set_multichannel_signed_distance_field :: (using self: *TextServerExtension, font_rid: RID, msdf: bool) {
}
TextServerExtension__font_is_multichannel_signed_distance_field :: (using self: *TextServerExtension, font_rid: RID) -> bool {
}
TextServerExtension__font_set_msdf_pixel_range :: (using self: *TextServerExtension, font_rid: RID, msdf_pixel_range: int) {
}
TextServerExtension__font_get_msdf_pixel_range :: (using self: *TextServerExtension, font_rid: RID) -> int {
}
TextServerExtension__font_set_msdf_size :: (using self: *TextServerExtension, font_rid: RID, msdf_size: int) {
}
TextServerExtension__font_get_msdf_size :: (using self: *TextServerExtension, font_rid: RID) -> int {
}
TextServerExtension__font_set_fixed_size :: (using self: *TextServerExtension, font_rid: RID, fixed_size: int) {
}
TextServerExtension__font_get_fixed_size :: (using self: *TextServerExtension, font_rid: RID) -> int {
}
TextServerExtension__font_set_fixed_size_scale_mode :: (using self: *TextServerExtension, font_rid: RID, fixed_size_scale_mode: TextServer.FixedSizeScaleMode) {
}
TextServerExtension__font_get_fixed_size_scale_mode :: (using self: *TextServerExtension, font_rid: RID) -> TextServer.FixedSizeScaleMode {
}
TextServerExtension__font_set_allow_system_fallback :: (using self: *TextServerExtension, font_rid: RID, allow_system_fallback: bool) {
}
TextServerExtension__font_is_allow_system_fallback :: (using self: *TextServerExtension, font_rid: RID) -> bool {
}
TextServerExtension__font_set_force_autohinter :: (using self: *TextServerExtension, font_rid: RID, force_autohinter: bool) {
}
TextServerExtension__font_is_force_autohinter :: (using self: *TextServerExtension, font_rid: RID) -> bool {
}
TextServerExtension__font_set_hinting :: (using self: *TextServerExtension, font_rid: RID, hinting: TextServer.Hinting) {
}
TextServerExtension__font_get_hinting :: (using self: *TextServerExtension, font_rid: RID) -> TextServer.Hinting {
}
TextServerExtension__font_set_subpixel_positioning :: (using self: *TextServerExtension, font_rid: RID, subpixel_positioning: TextServer.SubpixelPositioning) {
}
TextServerExtension__font_get_subpixel_positioning :: (using self: *TextServerExtension, font_rid: RID) -> TextServer.SubpixelPositioning {
}
TextServerExtension__font_set_embolden :: (using self: *TextServerExtension, font_rid: RID, strength: float) {
}
TextServerExtension__font_get_embolden :: (using self: *TextServerExtension, font_rid: RID) -> float {
}
TextServerExtension__font_set_spacing :: (using self: *TextServerExtension, font_rid: RID, spacing: TextServer.SpacingType, value: int) {
}
TextServerExtension__font_get_spacing :: (using self: *TextServerExtension, font_rid: RID, spacing: TextServer.SpacingType) -> int {
}
TextServerExtension__font_set_baseline_offset :: (using self: *TextServerExtension, font_rid: RID, baseline_offset: float) {
}
TextServerExtension__font_get_baseline_offset :: (using self: *TextServerExtension, font_rid: RID) -> float {
}
TextServerExtension__font_set_transform :: (using self: *TextServerExtension, font_rid: RID, transform: Transform2D) {
}
TextServerExtension__font_get_transform :: (using self: *TextServerExtension, font_rid: RID) -> Transform2D {
}
TextServerExtension__font_set_variation_coordinates :: (using self: *TextServerExtension, font_rid: RID, variation_coordinates: Dictionary) {
}
TextServerExtension__font_get_variation_coordinates :: (using self: *TextServerExtension, font_rid: RID) -> Dictionary {
}
TextServerExtension__font_set_oversampling :: (using self: *TextServerExtension, font_rid: RID, oversampling: float) {
}
TextServerExtension__font_get_oversampling :: (using self: *TextServerExtension, font_rid: RID) -> float {
}
TextServerExtension__font_get_size_cache_list :: (using self: *TextServerExtension, font_rid: RID) -> Array {
}
TextServerExtension__font_clear_size_cache :: (using self: *TextServerExtension, font_rid: RID) {
}
TextServerExtension__font_remove_size_cache :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i) {
}
TextServerExtension__font_set_ascent :: (using self: *TextServerExtension, font_rid: RID, size: int, ascent: float) {
}
TextServerExtension__font_get_ascent :: (using self: *TextServerExtension, font_rid: RID, size: int) -> float {
}
TextServerExtension__font_set_descent :: (using self: *TextServerExtension, font_rid: RID, size: int, descent: float) {
}
TextServerExtension__font_get_descent :: (using self: *TextServerExtension, font_rid: RID, size: int) -> float {
}
TextServerExtension__font_set_underline_position :: (using self: *TextServerExtension, font_rid: RID, size: int, underline_position: float) {
}
TextServerExtension__font_get_underline_position :: (using self: *TextServerExtension, font_rid: RID, size: int) -> float {
}
TextServerExtension__font_set_underline_thickness :: (using self: *TextServerExtension, font_rid: RID, size: int, underline_thickness: float) {
}
TextServerExtension__font_get_underline_thickness :: (using self: *TextServerExtension, font_rid: RID, size: int) -> float {
}
TextServerExtension__font_set_scale :: (using self: *TextServerExtension, font_rid: RID, size: int, scale: float) {
}
TextServerExtension__font_get_scale :: (using self: *TextServerExtension, font_rid: RID, size: int) -> float {
}
TextServerExtension__font_get_texture_count :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i) -> int {
}
TextServerExtension__font_clear_textures :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i) {
}
TextServerExtension__font_remove_texture :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, texture_index: int) {
}
TextServerExtension__font_set_texture_image :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, texture_index: int, image: Image) {
}
TextServerExtension__font_get_texture_image :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, texture_index: int) -> Image {
}
TextServerExtension__font_set_texture_offsets :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, texture_index: int, offset: PackedInt32Array) {
}
TextServerExtension__font_get_texture_offsets :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, texture_index: int) -> PackedInt32Array {
}
TextServerExtension__font_get_glyph_list :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i) -> PackedInt32Array {
}
TextServerExtension__font_clear_glyphs :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i) {
}
TextServerExtension__font_remove_glyph :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, glyph: int) {
}
TextServerExtension__font_get_glyph_advance :: (using self: *TextServerExtension, font_rid: RID, size: int, glyph: int) -> Vector2 {
}
TextServerExtension__font_set_glyph_advance :: (using self: *TextServerExtension, font_rid: RID, size: int, glyph: int, advance: Vector2) {
}
TextServerExtension__font_get_glyph_offset :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, glyph: int) -> Vector2 {
}
TextServerExtension__font_set_glyph_offset :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, glyph: int, offset: Vector2) {
}
TextServerExtension__font_get_glyph_size :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, glyph: int) -> Vector2 {
}
TextServerExtension__font_set_glyph_size :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, glyph: int, gl_size: Vector2) {
}
TextServerExtension__font_get_glyph_uv_rect :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, glyph: int) -> Rect2 {
}
TextServerExtension__font_set_glyph_uv_rect :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, glyph: int, uv_rect: Rect2) {
}
TextServerExtension__font_get_glyph_texture_idx :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, glyph: int) -> int {
}
TextServerExtension__font_set_glyph_texture_idx :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, glyph: int, texture_idx: int) {
}
TextServerExtension__font_get_glyph_texture_rid :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, glyph: int) -> RID {
}
TextServerExtension__font_get_glyph_texture_size :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, glyph: int) -> Vector2 {
}
TextServerExtension__font_get_glyph_contours :: (using self: *TextServerExtension, font_rid: RID, size: int, index: int) -> Dictionary {
}
TextServerExtension__font_get_kerning_list :: (using self: *TextServerExtension, font_rid: RID, size: int) -> Array {
}
TextServerExtension__font_clear_kerning_map :: (using self: *TextServerExtension, font_rid: RID, size: int) {
}
TextServerExtension__font_remove_kerning :: (using self: *TextServerExtension, font_rid: RID, size: int, glyph_pair: Vector2i) {
}
TextServerExtension__font_set_kerning :: (using self: *TextServerExtension, font_rid: RID, size: int, glyph_pair: Vector2i, kerning: Vector2) {
}
TextServerExtension__font_get_kerning :: (using self: *TextServerExtension, font_rid: RID, size: int, glyph_pair: Vector2i) -> Vector2 {
}
TextServerExtension__font_get_glyph_index :: (using self: *TextServerExtension, font_rid: RID, size: int, char: int, variation_selector: int) -> int {
}
TextServerExtension__font_get_char_from_glyph_index :: (using self: *TextServerExtension, font_rid: RID, size: int, glyph_index: int) -> int {
}
TextServerExtension__font_has_char :: (using self: *TextServerExtension, font_rid: RID, char: int) -> bool {
}
TextServerExtension__font_get_supported_chars :: (using self: *TextServerExtension, font_rid: RID) -> String {
}
TextServerExtension__font_render_range :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, start: int, end: int) {
}
TextServerExtension__font_render_glyph :: (using self: *TextServerExtension, font_rid: RID, size: Vector2i, index: int) {
}
TextServerExtension__font_draw_glyph :: (using self: *TextServerExtension, font_rid: RID, canvas: RID, size: int, pos: Vector2, index: int, color: Color) {
}
TextServerExtension__font_draw_glyph_outline :: (using self: *TextServerExtension, font_rid: RID, canvas: RID, size: int, outline_size: int, pos: Vector2, index: int, color: Color) {
}
TextServerExtension__font_is_language_supported :: (using self: *TextServerExtension, font_rid: RID, language: String) -> bool {
}
TextServerExtension__font_set_language_support_override :: (using self: *TextServerExtension, font_rid: RID, language: String, supported: bool) {
}
TextServerExtension__font_get_language_support_override :: (using self: *TextServerExtension, font_rid: RID, language: String) -> bool {
}
TextServerExtension__font_remove_language_support_override :: (using self: *TextServerExtension, font_rid: RID, language: String) {
}
TextServerExtension__font_get_language_support_overrides :: (using self: *TextServerExtension, font_rid: RID) -> PackedStringArray {
}
TextServerExtension__font_is_script_supported :: (using self: *TextServerExtension, font_rid: RID, script: String) -> bool {
}
TextServerExtension__font_set_script_support_override :: (using self: *TextServerExtension, font_rid: RID, script: String, supported: bool) {
}
TextServerExtension__font_get_script_support_override :: (using self: *TextServerExtension, font_rid: RID, script: String) -> bool {
}
TextServerExtension__font_remove_script_support_override :: (using self: *TextServerExtension, font_rid: RID, script: String) {
}
TextServerExtension__font_get_script_support_overrides :: (using self: *TextServerExtension, font_rid: RID) -> PackedStringArray {
}
TextServerExtension__font_set_opentype_feature_overrides :: (using self: *TextServerExtension, font_rid: RID, overrides: Dictionary) {
}
TextServerExtension__font_get_opentype_feature_overrides :: (using self: *TextServerExtension, font_rid: RID) -> Dictionary {
}
TextServerExtension__font_supported_feature_list :: (using self: *TextServerExtension, font_rid: RID) -> Dictionary {
}
TextServerExtension__font_supported_variation_list :: (using self: *TextServerExtension, font_rid: RID) -> Dictionary {
}
TextServerExtension__font_get_global_oversampling :: (using self: *TextServerExtension) -> float {
}
TextServerExtension__font_set_global_oversampling :: (using self: *TextServerExtension, oversampling: float) {
}
TextServerExtension__get_hex_code_box_size :: (using self: *TextServerExtension, size: int, index: int) -> Vector2 {
}
TextServerExtension__draw_hex_code_box :: (using self: *TextServerExtension, canvas: RID, size: int, pos: Vector2, index: int, color: Color) {
}
TextServerExtension__create_shaped_text :: (using self: *TextServerExtension, direction: TextServer.Direction, orientation: TextServer.Orientation) -> RID {
}
TextServerExtension__shaped_text_clear :: (using self: *TextServerExtension, shaped: RID) {
}
TextServerExtension__shaped_text_set_direction :: (using self: *TextServerExtension, shaped: RID, direction: TextServer.Direction) {
}
TextServerExtension__shaped_text_get_direction :: (using self: *TextServerExtension, shaped: RID) -> TextServer.Direction {
}
TextServerExtension__shaped_text_get_inferred_direction :: (using self: *TextServerExtension, shaped: RID) -> TextServer.Direction {
}
TextServerExtension__shaped_text_set_bidi_override :: (using self: *TextServerExtension, shaped: RID, override: Array) {
}
TextServerExtension__shaped_text_set_custom_punctuation :: (using self: *TextServerExtension, shaped: RID, punct: String) {
}
TextServerExtension__shaped_text_get_custom_punctuation :: (using self: *TextServerExtension, shaped: RID) -> String {
}
TextServerExtension__shaped_text_set_custom_ellipsis :: (using self: *TextServerExtension, shaped: RID, char: int) {
}
TextServerExtension__shaped_text_get_custom_ellipsis :: (using self: *TextServerExtension, shaped: RID) -> int {
}
TextServerExtension__shaped_text_set_orientation :: (using self: *TextServerExtension, shaped: RID, orientation: TextServer.Orientation) {
}
TextServerExtension__shaped_text_get_orientation :: (using self: *TextServerExtension, shaped: RID) -> TextServer.Orientation {
}
TextServerExtension__shaped_text_set_preserve_invalid :: (using self: *TextServerExtension, shaped: RID, enabled: bool) {
}
TextServerExtension__shaped_text_get_preserve_invalid :: (using self: *TextServerExtension, shaped: RID) -> bool {
}
TextServerExtension__shaped_text_set_preserve_control :: (using self: *TextServerExtension, shaped: RID, enabled: bool) {
}
TextServerExtension__shaped_text_get_preserve_control :: (using self: *TextServerExtension, shaped: RID) -> bool {
}
TextServerExtension__shaped_text_set_spacing :: (using self: *TextServerExtension, shaped: RID, spacing: TextServer.SpacingType, value: int) {
}
TextServerExtension__shaped_text_get_spacing :: (using self: *TextServerExtension, shaped: RID, spacing: TextServer.SpacingType) -> int {
}
TextServerExtension__shaped_text_add_string :: (using self: *TextServerExtension, shaped: RID, text: String, fonts: Array, size: int, opentype_features: Dictionary, language: String, meta: Variant) -> bool {
}
TextServerExtension__shaped_text_add_object :: (using self: *TextServerExtension, shaped: RID, key: Variant, size: Vector2, inline_align: InlineAlignment, length: int, baseline: float) -> bool {
}
TextServerExtension__shaped_text_resize_object :: (using self: *TextServerExtension, shaped: RID, key: Variant, size: Vector2, inline_align: InlineAlignment, baseline: float) -> bool {
}
TextServerExtension__shaped_get_span_count :: (using self: *TextServerExtension, shaped: RID) -> int {
}
TextServerExtension__shaped_get_span_meta :: (using self: *TextServerExtension, shaped: RID, index: int) -> Variant {
}
TextServerExtension__shaped_set_span_update_font :: (using self: *TextServerExtension, shaped: RID, index: int, fonts: Array, size: int, opentype_features: Dictionary) {
}
TextServerExtension__shaped_text_substr :: (using self: *TextServerExtension, shaped: RID, start: int, length: int) -> RID {
}
TextServerExtension__shaped_text_get_parent :: (using self: *TextServerExtension, shaped: RID) -> RID {
}
TextServerExtension__shaped_text_fit_to_width :: (using self: *TextServerExtension, shaped: RID, width: float, justification_flags: TextServer.JustificationFlag) -> float {
}
TextServerExtension__shaped_text_tab_align :: (using self: *TextServerExtension, shaped: RID, tab_stops: PackedFloat32Array) -> float {
}
TextServerExtension__shaped_text_shape :: (using self: *TextServerExtension, shaped: RID) -> bool {
}
TextServerExtension__shaped_text_update_breaks :: (using self: *TextServerExtension, shaped: RID) -> bool {
}
TextServerExtension__shaped_text_update_justification_ops :: (using self: *TextServerExtension, shaped: RID) -> bool {
}
TextServerExtension__shaped_text_is_ready :: (using self: *TextServerExtension, shaped: RID) -> bool {
}
TextServerExtension__shaped_text_get_glyphs :: (using self: *TextServerExtension, shaped: RID) -> *Glyph {
}
TextServerExtension__shaped_text_sort_logical :: (using self: *TextServerExtension, shaped: RID) -> *Glyph {
}
TextServerExtension__shaped_text_get_glyph_count :: (using self: *TextServerExtension, shaped: RID) -> int {
}
TextServerExtension__shaped_text_get_range :: (using self: *TextServerExtension, shaped: RID) -> Vector2i {
}
TextServerExtension__shaped_text_get_line_breaks_adv :: (using self: *TextServerExtension, shaped: RID, width: PackedFloat32Array, start: int, once: bool, break_flags: TextServer.LineBreakFlag) -> PackedInt32Array {
}
TextServerExtension__shaped_text_get_line_breaks :: (using self: *TextServerExtension, shaped: RID, width: float, start: int, break_flags: TextServer.LineBreakFlag) -> PackedInt32Array {
}
TextServerExtension__shaped_text_get_word_breaks :: (using self: *TextServerExtension, shaped: RID, grapheme_flags: TextServer.GraphemeFlag, skip_grapheme_flags: TextServer.GraphemeFlag) -> PackedInt32Array {
}
TextServerExtension__shaped_text_get_trim_pos :: (using self: *TextServerExtension, shaped: RID) -> int {
}
TextServerExtension__shaped_text_get_ellipsis_pos :: (using self: *TextServerExtension, shaped: RID) -> int {
}
TextServerExtension__shaped_text_get_ellipsis_glyph_count :: (using self: *TextServerExtension, shaped: RID) -> int {
}
TextServerExtension__shaped_text_get_ellipsis_glyphs :: (using self: *TextServerExtension, shaped: RID) -> *Glyph {
}
TextServerExtension__shaped_text_overrun_trim_to_width :: (using self: *TextServerExtension, shaped: RID, width: float, trim_flags: TextServer.TextOverrunFlag) {
}
TextServerExtension__shaped_text_get_objects :: (using self: *TextServerExtension, shaped: RID) -> Array {
}
TextServerExtension__shaped_text_get_object_rect :: (using self: *TextServerExtension, shaped: RID, key: Variant) -> Rect2 {
}
TextServerExtension__shaped_text_get_object_range :: (using self: *TextServerExtension, shaped: RID, key: Variant) -> Vector2i {
}
TextServerExtension__shaped_text_get_object_glyph :: (using self: *TextServerExtension, shaped: RID, key: Variant) -> int {
}
TextServerExtension__shaped_text_get_size :: (using self: *TextServerExtension, shaped: RID) -> Vector2 {
}
TextServerExtension__shaped_text_get_ascent :: (using self: *TextServerExtension, shaped: RID) -> float {
}
TextServerExtension__shaped_text_get_descent :: (using self: *TextServerExtension, shaped: RID) -> float {
}
TextServerExtension__shaped_text_get_width :: (using self: *TextServerExtension, shaped: RID) -> float {
}
TextServerExtension__shaped_text_get_underline_position :: (using self: *TextServerExtension, shaped: RID) -> float {
}
TextServerExtension__shaped_text_get_underline_thickness :: (using self: *TextServerExtension, shaped: RID) -> float {
}
TextServerExtension__shaped_text_get_dominant_direction_in_range :: (using self: *TextServerExtension, shaped: RID, start: int, end: int) -> int {
}
TextServerExtension__shaped_text_get_carets :: (using self: *TextServerExtension, shaped: RID, position: int, caret: *CaretInfo) {
}
TextServerExtension__shaped_text_get_selection :: (using self: *TextServerExtension, shaped: RID, start: int, end: int) -> PackedVector2Array {
}
TextServerExtension__shaped_text_hit_test_grapheme :: (using self: *TextServerExtension, shaped: RID, coord: float) -> int {
}
TextServerExtension__shaped_text_hit_test_position :: (using self: *TextServerExtension, shaped: RID, coord: float) -> int {
}
TextServerExtension__shaped_text_draw :: (using self: *TextServerExtension, shaped: RID, canvas: RID, pos: Vector2, clip_l: float, clip_r: float, color: Color) {
}
TextServerExtension__shaped_text_draw_outline :: (using self: *TextServerExtension, shaped: RID, canvas: RID, pos: Vector2, clip_l: float, clip_r: float, outline_size: int, color: Color) {
}
TextServerExtension__shaped_text_get_grapheme_bounds :: (using self: *TextServerExtension, shaped: RID, pos: int) -> Vector2 {
}
TextServerExtension__shaped_text_next_grapheme_pos :: (using self: *TextServerExtension, shaped: RID, pos: int) -> int {
}
TextServerExtension__shaped_text_prev_grapheme_pos :: (using self: *TextServerExtension, shaped: RID, pos: int) -> int {
}
TextServerExtension__shaped_text_get_character_breaks :: (using self: *TextServerExtension, shaped: RID) -> PackedInt32Array {
}
TextServerExtension__shaped_text_next_character_pos :: (using self: *TextServerExtension, shaped: RID, pos: int) -> int {
}
TextServerExtension__shaped_text_prev_character_pos :: (using self: *TextServerExtension, shaped: RID, pos: int) -> int {
}
TextServerExtension__shaped_text_closest_character_pos :: (using self: *TextServerExtension, shaped: RID, pos: int) -> int {
}
TextServerExtension__format_number :: (using self: *TextServerExtension, number: String, language: String) -> String {
}
TextServerExtension__parse_number :: (using self: *TextServerExtension, number: String, language: String) -> String {
}
TextServerExtension__percent_sign :: (using self: *TextServerExtension, language: String) -> String {
}
TextServerExtension__strip_diacritics :: (using self: *TextServerExtension, _string: String) -> String {
}
TextServerExtension__is_valid_identifier :: (using self: *TextServerExtension, _string: String) -> bool {
}
TextServerExtension__is_valid_letter :: (using self: *TextServerExtension, unicode: int) -> bool {
}
TextServerExtension__string_get_word_breaks :: (using self: *TextServerExtension, _string: String, language: String, chars_per_line: int) -> PackedInt32Array {
}
TextServerExtension__string_get_character_breaks :: (using self: *TextServerExtension, _string: String, language: String) -> PackedInt32Array {
}
TextServerExtension__is_confusable :: (using self: *TextServerExtension, _string: String, dict: PackedStringArray) -> int {
}
TextServerExtension__spoof_check :: (using self: *TextServerExtension, _string: String) -> bool {
}
TextServerExtension__string_to_upper :: (using self: *TextServerExtension, _string: String, language: String) -> String {
}
TextServerExtension__string_to_lower :: (using self: *TextServerExtension, _string: String, language: String) -> String {
}
TextServerExtension__string_to_title :: (using self: *TextServerExtension, _string: String, language: String) -> String {
}
TextServerExtension__parse_structured_text :: (using self: *TextServerExtension, parser_type: TextServer.StructuredTextParser, args: Array, text: String) -> Array {
}
TextServerExtension__cleanup :: (using self: *TextServerExtension) {
}

// TextServerManager
TextServerManager :: struct {
	__private: *void;
}

TextServerManager_add_interface :: (using self: *TextServerManager, _interface: TextServer) {
}
TextServerManager_get_interface_count :: (using self: *TextServerManager) -> int {
}
TextServerManager_remove_interface :: (using self: *TextServerManager, _interface: TextServer) {
}
TextServerManager_get_interface :: (using self: *TextServerManager, idx: int) -> TextServer {
}
TextServerManager_get_interfaces :: (using self: *TextServerManager) -> Dictionary {
}
TextServerManager_find_interface :: (using self: *TextServerManager, name: String) -> TextServer {
}
TextServerManager_set_primary_interface :: (using self: *TextServerManager, index: TextServer) {
}
TextServerManager_get_primary_interface :: (using self: *TextServerManager) -> TextServer {
}

// Texture
Texture :: struct {
	__private: *void;
}

// Texture2D
Texture2D :: struct {
	__private: *void;
}

Texture2D__get_width :: (using self: *Texture2D) -> int {
}
Texture2D__get_height :: (using self: *Texture2D) -> int {
}
Texture2D__is_pixel_opaque :: (using self: *Texture2D, x: int, y: int) -> bool {
}
Texture2D__has_alpha :: (using self: *Texture2D) -> bool {
}
Texture2D__draw :: (using self: *Texture2D, to_canvas_item: RID, pos: Vector2, modulate: Color, transpose: bool) {
}
Texture2D__draw_rect :: (using self: *Texture2D, to_canvas_item: RID, rect: Rect2, tile: bool, modulate: Color, transpose: bool) {
}
Texture2D__draw_rect_region :: (using self: *Texture2D, to_canvas_item: RID, rect: Rect2, src_rect: Rect2, modulate: Color, transpose: bool, clip_uv: bool) {
}
Texture2D_get_width :: (using self: *Texture2D) -> int {
}
Texture2D_get_height :: (using self: *Texture2D) -> int {
}
Texture2D_get_size :: (using self: *Texture2D) -> Vector2 {
}
Texture2D_has_alpha :: (using self: *Texture2D) -> bool {
}
Texture2D_draw :: (using self: *Texture2D, canvas_item: RID, position: Vector2, modulate: Color, transpose: bool) {
}
Texture2D_draw_rect :: (using self: *Texture2D, canvas_item: RID, rect: Rect2, tile: bool, modulate: Color, transpose: bool) {
}
Texture2D_draw_rect_region :: (using self: *Texture2D, canvas_item: RID, rect: Rect2, src_rect: Rect2, modulate: Color, transpose: bool, clip_uv: bool) {
}
Texture2D_get_image :: (using self: *Texture2D) -> Image {
}
Texture2D_create_placeholder :: (using self: *Texture2D) -> Resource {
}

// Texture2DArray
Texture2DArray :: struct {
	__private: *void;
}

Texture2DArray_create_placeholder :: (using self: *Texture2DArray) -> Resource {
}

// Texture2DArrayRD
Texture2DArrayRD :: struct {
	__private: *void;
}

// Texture2DRD
Texture2DRD :: struct {
	__private: *void;
}

Texture2DRD_set_texture_rd_rid :: (using self: *Texture2DRD, texture_rd_rid: RID) {
}
Texture2DRD_get_texture_rd_rid :: (using self: *Texture2DRD) -> RID {
}

// Texture3D
Texture3D :: struct {
	__private: *void;
}

Texture3D__get_format :: (using self: *Texture3D) -> Image.Format {
}
Texture3D__get_width :: (using self: *Texture3D) -> int {
}
Texture3D__get_height :: (using self: *Texture3D) -> int {
}
Texture3D__get_depth :: (using self: *Texture3D) -> int {
}
Texture3D__has_mipmaps :: (using self: *Texture3D) -> bool {
}
Texture3D__get_data :: (using self: *Texture3D) -> Array {
}
Texture3D_get_format :: (using self: *Texture3D) -> Image.Format {
}
Texture3D_get_width :: (using self: *Texture3D) -> int {
}
Texture3D_get_height :: (using self: *Texture3D) -> int {
}
Texture3D_get_depth :: (using self: *Texture3D) -> int {
}
Texture3D_has_mipmaps :: (using self: *Texture3D) -> bool {
}
Texture3D_get_data :: (using self: *Texture3D) -> Array {
}
Texture3D_create_placeholder :: (using self: *Texture3D) -> Resource {
}

// Texture3DRD
Texture3DRD :: struct {
	__private: *void;
}

Texture3DRD_set_texture_rd_rid :: (using self: *Texture3DRD, texture_rd_rid: RID) {
}
Texture3DRD_get_texture_rd_rid :: (using self: *Texture3DRD) -> RID {
}

// TextureButton
TextureButton :: struct {
	__private: *void;

	StretchMode :: enum {
		STRETCH_SCALE :: 0;
		STRETCH_TILE :: 1;
		STRETCH_KEEP :: 2;
		STRETCH_KEEP_CENTERED :: 3;
		STRETCH_KEEP_ASPECT :: 4;
		STRETCH_KEEP_ASPECT_CENTERED :: 5;
		STRETCH_KEEP_ASPECT_COVERED :: 6;
	}
}

TextureButton_set_texture_normal :: (using self: *TextureButton, texture: Texture2D) {
}
TextureButton_set_texture_pressed :: (using self: *TextureButton, texture: Texture2D) {
}
TextureButton_set_texture_hover :: (using self: *TextureButton, texture: Texture2D) {
}
TextureButton_set_texture_disabled :: (using self: *TextureButton, texture: Texture2D) {
}
TextureButton_set_texture_focused :: (using self: *TextureButton, texture: Texture2D) {
}
TextureButton_set_click_mask :: (using self: *TextureButton, mask: BitMap) {
}
TextureButton_set_ignore_texture_size :: (using self: *TextureButton, ignore: bool) {
}
TextureButton_set_stretch_mode :: (using self: *TextureButton, mode: TextureButton.StretchMode) {
}
TextureButton_set_flip_h :: (using self: *TextureButton, enable: bool) {
}
TextureButton_is_flipped_h :: (using self: *TextureButton) -> bool {
}
TextureButton_set_flip_v :: (using self: *TextureButton, enable: bool) {
}
TextureButton_is_flipped_v :: (using self: *TextureButton) -> bool {
}
TextureButton_get_texture_normal :: (using self: *TextureButton) -> Texture2D {
}
TextureButton_get_texture_pressed :: (using self: *TextureButton) -> Texture2D {
}
TextureButton_get_texture_hover :: (using self: *TextureButton) -> Texture2D {
}
TextureButton_get_texture_disabled :: (using self: *TextureButton) -> Texture2D {
}
TextureButton_get_texture_focused :: (using self: *TextureButton) -> Texture2D {
}
TextureButton_get_click_mask :: (using self: *TextureButton) -> BitMap {
}
TextureButton_get_ignore_texture_size :: (using self: *TextureButton) -> bool {
}
TextureButton_get_stretch_mode :: (using self: *TextureButton) -> TextureButton.StretchMode {
}

// TextureCubemapArrayRD
TextureCubemapArrayRD :: struct {
	__private: *void;
}

// TextureCubemapRD
TextureCubemapRD :: struct {
	__private: *void;
}

// TextureLayered
TextureLayered :: struct {
	__private: *void;

	LayeredType :: enum {
		LAYERED_TYPE_2D_ARRAY :: 0;
		LAYERED_TYPE_CUBEMAP :: 1;
		LAYERED_TYPE_CUBEMAP_ARRAY :: 2;
	}
}

TextureLayered__get_format :: (using self: *TextureLayered) -> Image.Format {
}
TextureLayered__get_layered_type :: (using self: *TextureLayered) -> int {
}
TextureLayered__get_width :: (using self: *TextureLayered) -> int {
}
TextureLayered__get_height :: (using self: *TextureLayered) -> int {
}
TextureLayered__get_layers :: (using self: *TextureLayered) -> int {
}
TextureLayered__has_mipmaps :: (using self: *TextureLayered) -> bool {
}
TextureLayered__get_layer_data :: (using self: *TextureLayered, layer_index: int) -> Image {
}
TextureLayered_get_format :: (using self: *TextureLayered) -> Image.Format {
}
TextureLayered_get_layered_type :: (using self: *TextureLayered) -> TextureLayered.LayeredType {
}
TextureLayered_get_width :: (using self: *TextureLayered) -> int {
}
TextureLayered_get_height :: (using self: *TextureLayered) -> int {
}
TextureLayered_get_layers :: (using self: *TextureLayered) -> int {
}
TextureLayered_has_mipmaps :: (using self: *TextureLayered) -> bool {
}
TextureLayered_get_layer_data :: (using self: *TextureLayered, layer: int) -> Image {
}

// TextureLayeredRD
TextureLayeredRD :: struct {
	__private: *void;
}

TextureLayeredRD_set_texture_rd_rid :: (using self: *TextureLayeredRD, texture_rd_rid: RID) {
}
TextureLayeredRD_get_texture_rd_rid :: (using self: *TextureLayeredRD) -> RID {
}

// TextureProgressBar
TextureProgressBar :: struct {
	__private: *void;

	FillMode :: enum {
		FILL_LEFT_TO_RIGHT :: 0;
		FILL_RIGHT_TO_LEFT :: 1;
		FILL_TOP_TO_BOTTOM :: 2;
		FILL_BOTTOM_TO_TOP :: 3;
		FILL_CLOCKWISE :: 4;
		FILL_COUNTER_CLOCKWISE :: 5;
		FILL_BILINEAR_LEFT_AND_RIGHT :: 6;
		FILL_BILINEAR_TOP_AND_BOTTOM :: 7;
		FILL_CLOCKWISE_AND_COUNTER_CLOCKWISE :: 8;
	}
}

TextureProgressBar_set_under_texture :: (using self: *TextureProgressBar, tex: Texture2D) {
}
TextureProgressBar_get_under_texture :: (using self: *TextureProgressBar) -> Texture2D {
}
TextureProgressBar_set_progress_texture :: (using self: *TextureProgressBar, tex: Texture2D) {
}
TextureProgressBar_get_progress_texture :: (using self: *TextureProgressBar) -> Texture2D {
}
TextureProgressBar_set_over_texture :: (using self: *TextureProgressBar, tex: Texture2D) {
}
TextureProgressBar_get_over_texture :: (using self: *TextureProgressBar) -> Texture2D {
}
TextureProgressBar_set_fill_mode :: (using self: *TextureProgressBar, mode: int) {
}
TextureProgressBar_get_fill_mode :: (using self: *TextureProgressBar) -> int {
}
TextureProgressBar_set_tint_under :: (using self: *TextureProgressBar, tint: Color) {
}
TextureProgressBar_get_tint_under :: (using self: *TextureProgressBar) -> Color {
}
TextureProgressBar_set_tint_progress :: (using self: *TextureProgressBar, tint: Color) {
}
TextureProgressBar_get_tint_progress :: (using self: *TextureProgressBar) -> Color {
}
TextureProgressBar_set_tint_over :: (using self: *TextureProgressBar, tint: Color) {
}
TextureProgressBar_get_tint_over :: (using self: *TextureProgressBar) -> Color {
}
TextureProgressBar_set_texture_progress_offset :: (using self: *TextureProgressBar, offset: Vector2) {
}
TextureProgressBar_get_texture_progress_offset :: (using self: *TextureProgressBar) -> Vector2 {
}
TextureProgressBar_set_radial_initial_angle :: (using self: *TextureProgressBar, mode: float) {
}
TextureProgressBar_get_radial_initial_angle :: (using self: *TextureProgressBar) -> float {
}
TextureProgressBar_set_radial_center_offset :: (using self: *TextureProgressBar, mode: Vector2) {
}
TextureProgressBar_get_radial_center_offset :: (using self: *TextureProgressBar) -> Vector2 {
}
TextureProgressBar_set_fill_degrees :: (using self: *TextureProgressBar, mode: float) {
}
TextureProgressBar_get_fill_degrees :: (using self: *TextureProgressBar) -> float {
}
TextureProgressBar_set_stretch_margin :: (using self: *TextureProgressBar, margin: Side, value: int) {
}
TextureProgressBar_get_stretch_margin :: (using self: *TextureProgressBar, margin: Side) -> int {
}
TextureProgressBar_set_nine_patch_stretch :: (using self: *TextureProgressBar, stretch: bool) {
}
TextureProgressBar_get_nine_patch_stretch :: (using self: *TextureProgressBar) -> bool {
}

// TextureRect
TextureRect :: struct {
	__private: *void;

	ExpandMode :: enum {
		EXPAND_KEEP_SIZE :: 0;
		EXPAND_IGNORE_SIZE :: 1;
		EXPAND_FIT_WIDTH :: 2;
		EXPAND_FIT_WIDTH_PROPORTIONAL :: 3;
		EXPAND_FIT_HEIGHT :: 4;
		EXPAND_FIT_HEIGHT_PROPORTIONAL :: 5;
	}
	StretchMode :: enum {
		STRETCH_SCALE :: 0;
		STRETCH_TILE :: 1;
		STRETCH_KEEP :: 2;
		STRETCH_KEEP_CENTERED :: 3;
		STRETCH_KEEP_ASPECT :: 4;
		STRETCH_KEEP_ASPECT_CENTERED :: 5;
		STRETCH_KEEP_ASPECT_COVERED :: 6;
	}
}

TextureRect_set_texture :: (using self: *TextureRect, texture: Texture2D) {
}
TextureRect_get_texture :: (using self: *TextureRect) -> Texture2D {
}
TextureRect_set_expand_mode :: (using self: *TextureRect, expand_mode: TextureRect.ExpandMode) {
}
TextureRect_get_expand_mode :: (using self: *TextureRect) -> TextureRect.ExpandMode {
}
TextureRect_set_flip_h :: (using self: *TextureRect, enable: bool) {
}
TextureRect_is_flipped_h :: (using self: *TextureRect) -> bool {
}
TextureRect_set_flip_v :: (using self: *TextureRect, enable: bool) {
}
TextureRect_is_flipped_v :: (using self: *TextureRect) -> bool {
}
TextureRect_set_stretch_mode :: (using self: *TextureRect, stretch_mode: TextureRect.StretchMode) {
}
TextureRect_get_stretch_mode :: (using self: *TextureRect) -> TextureRect.StretchMode {
}

// Theme
Theme :: struct {
	__private: *void;

	DataType :: enum {
		DATA_TYPE_COLOR :: 0;
		DATA_TYPE_CONSTANT :: 1;
		DATA_TYPE_FONT :: 2;
		DATA_TYPE_FONT_SIZE :: 3;
		DATA_TYPE_ICON :: 4;
		DATA_TYPE_STYLEBOX :: 5;
		DATA_TYPE_MAX :: 6;
	}
}

Theme_set_icon :: (using self: *Theme, name: StringName, theme_type: StringName, texture: Texture2D) {
}
Theme_get_icon :: (using self: *Theme, name: StringName, theme_type: StringName) -> Texture2D {
}
Theme_has_icon :: (using self: *Theme, name: StringName, theme_type: StringName) -> bool {
}
Theme_rename_icon :: (using self: *Theme, old_name: StringName, name: StringName, theme_type: StringName) {
}
Theme_clear_icon :: (using self: *Theme, name: StringName, theme_type: StringName) {
}
Theme_get_icon_list :: (using self: *Theme, theme_type: String) -> PackedStringArray {
}
Theme_get_icon_type_list :: (using self: *Theme) -> PackedStringArray {
}
Theme_set_stylebox :: (using self: *Theme, name: StringName, theme_type: StringName, texture: StyleBox) {
}
Theme_get_stylebox :: (using self: *Theme, name: StringName, theme_type: StringName) -> StyleBox {
}
Theme_has_stylebox :: (using self: *Theme, name: StringName, theme_type: StringName) -> bool {
}
Theme_rename_stylebox :: (using self: *Theme, old_name: StringName, name: StringName, theme_type: StringName) {
}
Theme_clear_stylebox :: (using self: *Theme, name: StringName, theme_type: StringName) {
}
Theme_get_stylebox_list :: (using self: *Theme, theme_type: String) -> PackedStringArray {
}
Theme_get_stylebox_type_list :: (using self: *Theme) -> PackedStringArray {
}
Theme_set_font :: (using self: *Theme, name: StringName, theme_type: StringName, font: Font) {
}
Theme_get_font :: (using self: *Theme, name: StringName, theme_type: StringName) -> Font {
}
Theme_has_font :: (using self: *Theme, name: StringName, theme_type: StringName) -> bool {
}
Theme_rename_font :: (using self: *Theme, old_name: StringName, name: StringName, theme_type: StringName) {
}
Theme_clear_font :: (using self: *Theme, name: StringName, theme_type: StringName) {
}
Theme_get_font_list :: (using self: *Theme, theme_type: String) -> PackedStringArray {
}
Theme_get_font_type_list :: (using self: *Theme) -> PackedStringArray {
}
Theme_set_font_size :: (using self: *Theme, name: StringName, theme_type: StringName, font_size: int) {
}
Theme_get_font_size :: (using self: *Theme, name: StringName, theme_type: StringName) -> int {
}
Theme_has_font_size :: (using self: *Theme, name: StringName, theme_type: StringName) -> bool {
}
Theme_rename_font_size :: (using self: *Theme, old_name: StringName, name: StringName, theme_type: StringName) {
}
Theme_clear_font_size :: (using self: *Theme, name: StringName, theme_type: StringName) {
}
Theme_get_font_size_list :: (using self: *Theme, theme_type: String) -> PackedStringArray {
}
Theme_get_font_size_type_list :: (using self: *Theme) -> PackedStringArray {
}
Theme_set_color :: (using self: *Theme, name: StringName, theme_type: StringName, color: Color) {
}
Theme_get_color :: (using self: *Theme, name: StringName, theme_type: StringName) -> Color {
}
Theme_has_color :: (using self: *Theme, name: StringName, theme_type: StringName) -> bool {
}
Theme_rename_color :: (using self: *Theme, old_name: StringName, name: StringName, theme_type: StringName) {
}
Theme_clear_color :: (using self: *Theme, name: StringName, theme_type: StringName) {
}
Theme_get_color_list :: (using self: *Theme, theme_type: String) -> PackedStringArray {
}
Theme_get_color_type_list :: (using self: *Theme) -> PackedStringArray {
}
Theme_set_constant :: (using self: *Theme, name: StringName, theme_type: StringName, constant: int) {
}
Theme_get_constant :: (using self: *Theme, name: StringName, theme_type: StringName) -> int {
}
Theme_has_constant :: (using self: *Theme, name: StringName, theme_type: StringName) -> bool {
}
Theme_rename_constant :: (using self: *Theme, old_name: StringName, name: StringName, theme_type: StringName) {
}
Theme_clear_constant :: (using self: *Theme, name: StringName, theme_type: StringName) {
}
Theme_get_constant_list :: (using self: *Theme, theme_type: String) -> PackedStringArray {
}
Theme_get_constant_type_list :: (using self: *Theme) -> PackedStringArray {
}
Theme_set_default_base_scale :: (using self: *Theme, base_scale: float) {
}
Theme_get_default_base_scale :: (using self: *Theme) -> float {
}
Theme_has_default_base_scale :: (using self: *Theme) -> bool {
}
Theme_set_default_font :: (using self: *Theme, font: Font) {
}
Theme_get_default_font :: (using self: *Theme) -> Font {
}
Theme_has_default_font :: (using self: *Theme) -> bool {
}
Theme_set_default_font_size :: (using self: *Theme, font_size: int) {
}
Theme_get_default_font_size :: (using self: *Theme) -> int {
}
Theme_has_default_font_size :: (using self: *Theme) -> bool {
}
Theme_set_theme_item :: (using self: *Theme, data_type: Theme.DataType, name: StringName, theme_type: StringName, value: Variant) {
}
Theme_get_theme_item :: (using self: *Theme, data_type: Theme.DataType, name: StringName, theme_type: StringName) -> Variant {
}
Theme_has_theme_item :: (using self: *Theme, data_type: Theme.DataType, name: StringName, theme_type: StringName) -> bool {
}
Theme_rename_theme_item :: (using self: *Theme, data_type: Theme.DataType, old_name: StringName, name: StringName, theme_type: StringName) {
}
Theme_clear_theme_item :: (using self: *Theme, data_type: Theme.DataType, name: StringName, theme_type: StringName) {
}
Theme_get_theme_item_list :: (using self: *Theme, data_type: Theme.DataType, theme_type: String) -> PackedStringArray {
}
Theme_get_theme_item_type_list :: (using self: *Theme, data_type: Theme.DataType) -> PackedStringArray {
}
Theme_set_type_variation :: (using self: *Theme, theme_type: StringName, base_type: StringName) {
}
Theme_is_type_variation :: (using self: *Theme, theme_type: StringName, base_type: StringName) -> bool {
}
Theme_clear_type_variation :: (using self: *Theme, theme_type: StringName) {
}
Theme_get_type_variation_base :: (using self: *Theme, theme_type: StringName) -> StringName {
}
Theme_get_type_variation_list :: (using self: *Theme, base_type: StringName) -> PackedStringArray {
}
Theme_add_type :: (using self: *Theme, theme_type: StringName) {
}
Theme_remove_type :: (using self: *Theme, theme_type: StringName) {
}
Theme_get_type_list :: (using self: *Theme) -> PackedStringArray {
}
Theme_merge_with :: (using self: *Theme, other: Theme) {
}
Theme_clear :: (using self: *Theme) {
}

// ThemeDB
ThemeDB :: struct {
	__private: *void;
}

ThemeDB_get_default_theme :: (using self: *ThemeDB) -> Theme {
}
ThemeDB_get_project_theme :: (using self: *ThemeDB) -> Theme {
}
ThemeDB_set_fallback_base_scale :: (using self: *ThemeDB, base_scale: float) {
}
ThemeDB_get_fallback_base_scale :: (using self: *ThemeDB) -> float {
}
ThemeDB_set_fallback_font :: (using self: *ThemeDB, font: Font) {
}
ThemeDB_get_fallback_font :: (using self: *ThemeDB) -> Font {
}
ThemeDB_set_fallback_font_size :: (using self: *ThemeDB, font_size: int) {
}
ThemeDB_get_fallback_font_size :: (using self: *ThemeDB) -> int {
}
ThemeDB_set_fallback_icon :: (using self: *ThemeDB, icon: Texture2D) {
}
ThemeDB_get_fallback_icon :: (using self: *ThemeDB) -> Texture2D {
}
ThemeDB_set_fallback_stylebox :: (using self: *ThemeDB, stylebox: StyleBox) {
}
ThemeDB_get_fallback_stylebox :: (using self: *ThemeDB) -> StyleBox {
}

// Thread
Thread :: struct {
	__private: *void;

	Priority :: enum {
		PRIORITY_LOW :: 0;
		PRIORITY_NORMAL :: 1;
		PRIORITY_HIGH :: 2;
	}
}

Thread_start :: (using self: *Thread, callable: Callable, priority: Thread.Priority) -> Error {
}
Thread_get_id :: (using self: *Thread) -> String {
}
Thread_is_started :: (using self: *Thread) -> bool {
}
Thread_is_alive :: (using self: *Thread) -> bool {
}
Thread_wait_to_finish :: (using self: *Thread) -> Variant {
}
Thread_set_thread_safety_checks_enabled :: (using self: *Thread, enabled: bool) {
}

// TileData
TileData :: struct {
	__private: *void;
}

TileData_set_flip_h :: (using self: *TileData, flip_h: bool) {
}
TileData_get_flip_h :: (using self: *TileData) -> bool {
}
TileData_set_flip_v :: (using self: *TileData, flip_v: bool) {
}
TileData_get_flip_v :: (using self: *TileData) -> bool {
}
TileData_set_transpose :: (using self: *TileData, transpose: bool) {
}
TileData_get_transpose :: (using self: *TileData) -> bool {
}
TileData_set_material :: (using self: *TileData, material: Material) {
}
TileData_get_material :: (using self: *TileData) -> Material {
}
TileData_set_texture_origin :: (using self: *TileData, texture_origin: Vector2i) {
}
TileData_get_texture_origin :: (using self: *TileData) -> Vector2i {
}
TileData_set_modulate :: (using self: *TileData, modulate: Color) {
}
TileData_get_modulate :: (using self: *TileData) -> Color {
}
TileData_set_z_index :: (using self: *TileData, z_index: int) {
}
TileData_get_z_index :: (using self: *TileData) -> int {
}
TileData_set_y_sort_origin :: (using self: *TileData, y_sort_origin: int) {
}
TileData_get_y_sort_origin :: (using self: *TileData) -> int {
}
TileData_set_occluder :: (using self: *TileData, layer_id: int, occluder_polygon: OccluderPolygon2D) {
}
TileData_get_occluder :: (using self: *TileData, layer_id: int, flip_h: bool, flip_v: bool, transpose: bool) -> OccluderPolygon2D {
}
TileData_set_constant_linear_velocity :: (using self: *TileData, layer_id: int, velocity: Vector2) {
}
TileData_get_constant_linear_velocity :: (using self: *TileData, layer_id: int) -> Vector2 {
}
TileData_set_constant_angular_velocity :: (using self: *TileData, layer_id: int, velocity: float) {
}
TileData_get_constant_angular_velocity :: (using self: *TileData, layer_id: int) -> float {
}
TileData_set_collision_polygons_count :: (using self: *TileData, layer_id: int, polygons_count: int) {
}
TileData_get_collision_polygons_count :: (using self: *TileData, layer_id: int) -> int {
}
TileData_add_collision_polygon :: (using self: *TileData, layer_id: int) {
}
TileData_remove_collision_polygon :: (using self: *TileData, layer_id: int, polygon_index: int) {
}
TileData_set_collision_polygon_points :: (using self: *TileData, layer_id: int, polygon_index: int, polygon: PackedVector2Array) {
}
TileData_get_collision_polygon_points :: (using self: *TileData, layer_id: int, polygon_index: int) -> PackedVector2Array {
}
TileData_set_collision_polygon_one_way :: (using self: *TileData, layer_id: int, polygon_index: int, one_way: bool) {
}
TileData_is_collision_polygon_one_way :: (using self: *TileData, layer_id: int, polygon_index: int) -> bool {
}
TileData_set_collision_polygon_one_way_margin :: (using self: *TileData, layer_id: int, polygon_index: int, one_way_margin: float) {
}
TileData_get_collision_polygon_one_way_margin :: (using self: *TileData, layer_id: int, polygon_index: int) -> float {
}
TileData_set_terrain_set :: (using self: *TileData, terrain_set: int) {
}
TileData_get_terrain_set :: (using self: *TileData) -> int {
}
TileData_set_terrain :: (using self: *TileData, terrain: int) {
}
TileData_get_terrain :: (using self: *TileData) -> int {
}
TileData_set_terrain_peering_bit :: (using self: *TileData, peering_bit: TileSet.CellNeighbor, terrain: int) {
}
TileData_get_terrain_peering_bit :: (using self: *TileData, peering_bit: TileSet.CellNeighbor) -> int {
}
TileData_is_valid_terrain_peering_bit :: (using self: *TileData, peering_bit: TileSet.CellNeighbor) -> bool {
}
TileData_set_navigation_polygon :: (using self: *TileData, layer_id: int, navigation_polygon: NavigationPolygon) {
}
TileData_get_navigation_polygon :: (using self: *TileData, layer_id: int, flip_h: bool, flip_v: bool, transpose: bool) -> NavigationPolygon {
}
TileData_set_probability :: (using self: *TileData, probability: float) {
}
TileData_get_probability :: (using self: *TileData) -> float {
}
TileData_set_custom_data :: (using self: *TileData, layer_name: String, value: Variant) {
}
TileData_get_custom_data :: (using self: *TileData, layer_name: String) -> Variant {
}
TileData_set_custom_data_by_layer_id :: (using self: *TileData, layer_id: int, value: Variant) {
}
TileData_get_custom_data_by_layer_id :: (using self: *TileData, layer_id: int) -> Variant {
}

// TileMap
TileMap :: struct {
	__private: *void;

	VisibilityMode :: enum {
		VISIBILITY_MODE_DEFAULT :: 0;
		VISIBILITY_MODE_FORCE_HIDE :: 2;
		VISIBILITY_MODE_FORCE_SHOW :: 1;
	}
}

TileMap__use_tile_data_runtime_update :: (using self: *TileMap, layer: int, coords: Vector2i) -> bool {
}
TileMap__tile_data_runtime_update :: (using self: *TileMap, layer: int, coords: Vector2i, tile_data: TileData) {
}
TileMap_set_navigation_map :: (using self: *TileMap, layer: int, map: RID) {
}
TileMap_get_navigation_map :: (using self: *TileMap, layer: int) -> RID {
}
TileMap_force_update :: (using self: *TileMap, layer: int) {
}
TileMap_set_tileset :: (using self: *TileMap, tileset: TileSet) {
}
TileMap_get_tileset :: (using self: *TileMap) -> TileSet {
}
TileMap_set_rendering_quadrant_size :: (using self: *TileMap, size: int) {
}
TileMap_get_rendering_quadrant_size :: (using self: *TileMap) -> int {
}
TileMap_get_layers_count :: (using self: *TileMap) -> int {
}
TileMap_add_layer :: (using self: *TileMap, to_position: int) {
}
TileMap_move_layer :: (using self: *TileMap, layer: int, to_position: int) {
}
TileMap_remove_layer :: (using self: *TileMap, layer: int) {
}
TileMap_set_layer_name :: (using self: *TileMap, layer: int, name: String) {
}
TileMap_get_layer_name :: (using self: *TileMap, layer: int) -> String {
}
TileMap_set_layer_enabled :: (using self: *TileMap, layer: int, enabled: bool) {
}
TileMap_is_layer_enabled :: (using self: *TileMap, layer: int) -> bool {
}
TileMap_set_layer_modulate :: (using self: *TileMap, layer: int, modulate: Color) {
}
TileMap_get_layer_modulate :: (using self: *TileMap, layer: int) -> Color {
}
TileMap_set_layer_y_sort_enabled :: (using self: *TileMap, layer: int, y_sort_enabled: bool) {
}
TileMap_is_layer_y_sort_enabled :: (using self: *TileMap, layer: int) -> bool {
}
TileMap_set_layer_y_sort_origin :: (using self: *TileMap, layer: int, y_sort_origin: int) {
}
TileMap_get_layer_y_sort_origin :: (using self: *TileMap, layer: int) -> int {
}
TileMap_set_layer_z_index :: (using self: *TileMap, layer: int, z_index: int) {
}
TileMap_get_layer_z_index :: (using self: *TileMap, layer: int) -> int {
}
TileMap_set_layer_navigation_enabled :: (using self: *TileMap, layer: int, enabled: bool) {
}
TileMap_is_layer_navigation_enabled :: (using self: *TileMap, layer: int) -> bool {
}
TileMap_set_layer_navigation_map :: (using self: *TileMap, layer: int, map: RID) {
}
TileMap_get_layer_navigation_map :: (using self: *TileMap, layer: int) -> RID {
}
TileMap_set_collision_animatable :: (using self: *TileMap, enabled: bool) {
}
TileMap_is_collision_animatable :: (using self: *TileMap) -> bool {
}
TileMap_set_collision_visibility_mode :: (using self: *TileMap, collision_visibility_mode: TileMap.VisibilityMode) {
}
TileMap_get_collision_visibility_mode :: (using self: *TileMap) -> TileMap.VisibilityMode {
}
TileMap_set_navigation_visibility_mode :: (using self: *TileMap, navigation_visibility_mode: TileMap.VisibilityMode) {
}
TileMap_get_navigation_visibility_mode :: (using self: *TileMap) -> TileMap.VisibilityMode {
}
TileMap_set_cell :: (using self: *TileMap, layer: int, coords: Vector2i, source_id: int, atlas_coords: Vector2i, alternative_tile: int) {
}
TileMap_erase_cell :: (using self: *TileMap, layer: int, coords: Vector2i) {
}
TileMap_get_cell_source_id :: (using self: *TileMap, layer: int, coords: Vector2i, use_proxies: bool) -> int {
}
TileMap_get_cell_atlas_coords :: (using self: *TileMap, layer: int, coords: Vector2i, use_proxies: bool) -> Vector2i {
}
TileMap_get_cell_alternative_tile :: (using self: *TileMap, layer: int, coords: Vector2i, use_proxies: bool) -> int {
}
TileMap_get_cell_tile_data :: (using self: *TileMap, layer: int, coords: Vector2i, use_proxies: bool) -> TileData {
}
TileMap_get_coords_for_body_rid :: (using self: *TileMap, body: RID) -> Vector2i {
}
TileMap_get_layer_for_body_rid :: (using self: *TileMap, body: RID) -> int {
}
TileMap_get_pattern :: (using self: *TileMap, layer: int, coords_array: Array) -> TileMapPattern {
}
TileMap_map_pattern :: (using self: *TileMap, position_in_tilemap: Vector2i, coords_in_pattern: Vector2i, pattern: TileMapPattern) -> Vector2i {
}
TileMap_set_pattern :: (using self: *TileMap, layer: int, position: Vector2i, pattern: TileMapPattern) {
}
TileMap_set_cells_terrain_connect :: (using self: *TileMap, layer: int, cells: Array, terrain_set: int, terrain: int, ignore_empty_terrains: bool) {
}
TileMap_set_cells_terrain_path :: (using self: *TileMap, layer: int, path: Array, terrain_set: int, terrain: int, ignore_empty_terrains: bool) {
}
TileMap_fix_invalid_tiles :: (using self: *TileMap) {
}
TileMap_clear_layer :: (using self: *TileMap, layer: int) {
}
TileMap_clear :: (using self: *TileMap) {
}
TileMap_update_internals :: (using self: *TileMap) {
}
TileMap_notify_runtime_tile_data_update :: (using self: *TileMap, layer: int) {
}
TileMap_get_surrounding_cells :: (using self: *TileMap, coords: Vector2i) -> Array {
}
TileMap_get_used_cells :: (using self: *TileMap, layer: int) -> Array {
}
TileMap_get_used_cells_by_id :: (using self: *TileMap, layer: int, source_id: int, atlas_coords: Vector2i, alternative_tile: int) -> Array {
}
TileMap_get_used_rect :: (using self: *TileMap) -> Rect2i {
}
TileMap_map_to_local :: (using self: *TileMap, map_position: Vector2i) -> Vector2 {
}
TileMap_local_to_map :: (using self: *TileMap, local_position: Vector2) -> Vector2i {
}
TileMap_get_neighbor_cell :: (using self: *TileMap, coords: Vector2i, neighbor: TileSet.CellNeighbor) -> Vector2i {
}

// TileMapLayer
TileMapLayer :: struct {
	__private: *void;

	DebugVisibilityMode :: enum {
		DEBUG_VISIBILITY_MODE_DEFAULT :: 0;
		DEBUG_VISIBILITY_MODE_FORCE_HIDE :: 2;
		DEBUG_VISIBILITY_MODE_FORCE_SHOW :: 1;
	}
}

TileMapLayer__use_tile_data_runtime_update :: (using self: *TileMapLayer, coords: Vector2i) -> bool {
}
TileMapLayer__tile_data_runtime_update :: (using self: *TileMapLayer, coords: Vector2i, tile_data: TileData) {
}
TileMapLayer_set_cell :: (using self: *TileMapLayer, coords: Vector2i, source_id: int, atlas_coords: Vector2i, alternative_tile: int) {
}
TileMapLayer_erase_cell :: (using self: *TileMapLayer, coords: Vector2i) {
}
TileMapLayer_fix_invalid_tiles :: (using self: *TileMapLayer) {
}
TileMapLayer_clear :: (using self: *TileMapLayer) {
}
TileMapLayer_get_cell_source_id :: (using self: *TileMapLayer, coords: Vector2i) -> int {
}
TileMapLayer_get_cell_atlas_coords :: (using self: *TileMapLayer, coords: Vector2i) -> Vector2i {
}
TileMapLayer_get_cell_alternative_tile :: (using self: *TileMapLayer, coords: Vector2i) -> int {
}
TileMapLayer_get_cell_tile_data :: (using self: *TileMapLayer, coords: Vector2i) -> TileData {
}
TileMapLayer_get_used_cells :: (using self: *TileMapLayer) -> Array {
}
TileMapLayer_get_used_cells_by_id :: (using self: *TileMapLayer, source_id: int, atlas_coords: Vector2i, alternative_tile: int) -> Array {
}
TileMapLayer_get_used_rect :: (using self: *TileMapLayer) -> Rect2i {
}
TileMapLayer_get_pattern :: (using self: *TileMapLayer, coords_array: Array) -> TileMapPattern {
}
TileMapLayer_set_pattern :: (using self: *TileMapLayer, position: Vector2i, pattern: TileMapPattern) {
}
TileMapLayer_set_cells_terrain_connect :: (using self: *TileMapLayer, cells: Array, terrain_set: int, terrain: int, ignore_empty_terrains: bool) {
}
TileMapLayer_set_cells_terrain_path :: (using self: *TileMapLayer, path: Array, terrain_set: int, terrain: int, ignore_empty_terrains: bool) {
}
TileMapLayer_has_body_rid :: (using self: *TileMapLayer, body: RID) -> bool {
}
TileMapLayer_get_coords_for_body_rid :: (using self: *TileMapLayer, body: RID) -> Vector2i {
}
TileMapLayer_update_internals :: (using self: *TileMapLayer) {
}
TileMapLayer_notify_runtime_tile_data_update :: (using self: *TileMapLayer) {
}
TileMapLayer_map_pattern :: (using self: *TileMapLayer, position_in_tilemap: Vector2i, coords_in_pattern: Vector2i, pattern: TileMapPattern) -> Vector2i {
}
TileMapLayer_get_surrounding_cells :: (using self: *TileMapLayer, coords: Vector2i) -> Array {
}
TileMapLayer_get_neighbor_cell :: (using self: *TileMapLayer, coords: Vector2i, neighbor: TileSet.CellNeighbor) -> Vector2i {
}
TileMapLayer_map_to_local :: (using self: *TileMapLayer, map_position: Vector2i) -> Vector2 {
}
TileMapLayer_local_to_map :: (using self: *TileMapLayer, local_position: Vector2) -> Vector2i {
}
TileMapLayer_set_tile_map_data_from_array :: (using self: *TileMapLayer, tile_map_layer_data: PackedByteArray) {
}
TileMapLayer_get_tile_map_data_as_array :: (using self: *TileMapLayer) -> PackedByteArray {
}
TileMapLayer_set_enabled :: (using self: *TileMapLayer, enabled: bool) {
}
TileMapLayer_is_enabled :: (using self: *TileMapLayer) -> bool {
}
TileMapLayer_set_tile_set :: (using self: *TileMapLayer, tile_set: TileSet) {
}
TileMapLayer_get_tile_set :: (using self: *TileMapLayer) -> TileSet {
}
TileMapLayer_set_y_sort_origin :: (using self: *TileMapLayer, y_sort_origin: int) {
}
TileMapLayer_get_y_sort_origin :: (using self: *TileMapLayer) -> int {
}
TileMapLayer_set_x_draw_order_reversed :: (using self: *TileMapLayer, x_draw_order_reversed: bool) {
}
TileMapLayer_is_x_draw_order_reversed :: (using self: *TileMapLayer) -> bool {
}
TileMapLayer_set_rendering_quadrant_size :: (using self: *TileMapLayer, size: int) {
}
TileMapLayer_get_rendering_quadrant_size :: (using self: *TileMapLayer) -> int {
}
TileMapLayer_set_collision_enabled :: (using self: *TileMapLayer, enabled: bool) {
}
TileMapLayer_is_collision_enabled :: (using self: *TileMapLayer) -> bool {
}
TileMapLayer_set_use_kinematic_bodies :: (using self: *TileMapLayer, use_kinematic_bodies: bool) {
}
TileMapLayer_is_using_kinematic_bodies :: (using self: *TileMapLayer) -> bool {
}
TileMapLayer_set_collision_visibility_mode :: (using self: *TileMapLayer, visibility_mode: TileMapLayer.DebugVisibilityMode) {
}
TileMapLayer_get_collision_visibility_mode :: (using self: *TileMapLayer) -> TileMapLayer.DebugVisibilityMode {
}
TileMapLayer_set_navigation_enabled :: (using self: *TileMapLayer, enabled: bool) {
}
TileMapLayer_is_navigation_enabled :: (using self: *TileMapLayer) -> bool {
}
TileMapLayer_set_navigation_map :: (using self: *TileMapLayer, map: RID) {
}
TileMapLayer_get_navigation_map :: (using self: *TileMapLayer) -> RID {
}
TileMapLayer_set_navigation_visibility_mode :: (using self: *TileMapLayer, show_navigation: TileMapLayer.DebugVisibilityMode) {
}
TileMapLayer_get_navigation_visibility_mode :: (using self: *TileMapLayer) -> TileMapLayer.DebugVisibilityMode {
}

// TileMapPattern
TileMapPattern :: struct {
	__private: *void;
}

TileMapPattern_set_cell :: (using self: *TileMapPattern, coords: Vector2i, source_id: int, atlas_coords: Vector2i, alternative_tile: int) {
}
TileMapPattern_has_cell :: (using self: *TileMapPattern, coords: Vector2i) -> bool {
}
TileMapPattern_remove_cell :: (using self: *TileMapPattern, coords: Vector2i, update_size: bool) {
}
TileMapPattern_get_cell_source_id :: (using self: *TileMapPattern, coords: Vector2i) -> int {
}
TileMapPattern_get_cell_atlas_coords :: (using self: *TileMapPattern, coords: Vector2i) -> Vector2i {
}
TileMapPattern_get_cell_alternative_tile :: (using self: *TileMapPattern, coords: Vector2i) -> int {
}
TileMapPattern_get_used_cells :: (using self: *TileMapPattern) -> Array {
}
TileMapPattern_get_size :: (using self: *TileMapPattern) -> Vector2i {
}
TileMapPattern_set_size :: (using self: *TileMapPattern, size: Vector2i) {
}
TileMapPattern_is_empty :: (using self: *TileMapPattern) -> bool {
}

// TileSet
TileSet :: struct {
	__private: *void;

	TileShape :: enum {
		TILE_SHAPE_SQUARE :: 0;
		TILE_SHAPE_ISOMETRIC :: 1;
		TILE_SHAPE_HALF_OFFSET_SQUARE :: 2;
		TILE_SHAPE_HEXAGON :: 3;
	}
	TileLayout :: enum {
		TILE_LAYOUT_STACKED :: 0;
		TILE_LAYOUT_STACKED_OFFSET :: 1;
		TILE_LAYOUT_STAIRS_RIGHT :: 2;
		TILE_LAYOUT_STAIRS_DOWN :: 3;
		TILE_LAYOUT_DIAMOND_RIGHT :: 4;
		TILE_LAYOUT_DIAMOND_DOWN :: 5;
	}
	TileOffsetAxis :: enum {
		TILE_OFFSET_AXIS_HORIZONTAL :: 0;
		TILE_OFFSET_AXIS_VERTICAL :: 1;
	}
	CellNeighbor :: enum {
		CELL_NEIGHBOR_RIGHT_SIDE :: 0;
		CELL_NEIGHBOR_RIGHT_CORNER :: 1;
		CELL_NEIGHBOR_BOTTOM_RIGHT_SIDE :: 2;
		CELL_NEIGHBOR_BOTTOM_RIGHT_CORNER :: 3;
		CELL_NEIGHBOR_BOTTOM_SIDE :: 4;
		CELL_NEIGHBOR_BOTTOM_CORNER :: 5;
		CELL_NEIGHBOR_BOTTOM_LEFT_SIDE :: 6;
		CELL_NEIGHBOR_BOTTOM_LEFT_CORNER :: 7;
		CELL_NEIGHBOR_LEFT_SIDE :: 8;
		CELL_NEIGHBOR_LEFT_CORNER :: 9;
		CELL_NEIGHBOR_TOP_LEFT_SIDE :: 10;
		CELL_NEIGHBOR_TOP_LEFT_CORNER :: 11;
		CELL_NEIGHBOR_TOP_SIDE :: 12;
		CELL_NEIGHBOR_TOP_CORNER :: 13;
		CELL_NEIGHBOR_TOP_RIGHT_SIDE :: 14;
		CELL_NEIGHBOR_TOP_RIGHT_CORNER :: 15;
	}
	TerrainMode :: enum {
		TERRAIN_MODE_MATCH_CORNERS_AND_SIDES :: 0;
		TERRAIN_MODE_MATCH_CORNERS :: 1;
		TERRAIN_MODE_MATCH_SIDES :: 2;
	}
}

TileSet_get_next_source_id :: (using self: *TileSet) -> int {
}
TileSet_add_source :: (using self: *TileSet, source: TileSetSource, atlas_source_id_override: int) -> int {
}
TileSet_remove_source :: (using self: *TileSet, source_id: int) {
}
TileSet_set_source_id :: (using self: *TileSet, source_id: int, new_source_id: int) {
}
TileSet_get_source_count :: (using self: *TileSet) -> int {
}
TileSet_get_source_id :: (using self: *TileSet, index: int) -> int {
}
TileSet_has_source :: (using self: *TileSet, source_id: int) -> bool {
}
TileSet_get_source :: (using self: *TileSet, source_id: int) -> TileSetSource {
}
TileSet_set_tile_shape :: (using self: *TileSet, shape: TileSet.TileShape) {
}
TileSet_get_tile_shape :: (using self: *TileSet) -> TileSet.TileShape {
}
TileSet_set_tile_layout :: (using self: *TileSet, layout: TileSet.TileLayout) {
}
TileSet_get_tile_layout :: (using self: *TileSet) -> TileSet.TileLayout {
}
TileSet_set_tile_offset_axis :: (using self: *TileSet, alignment: TileSet.TileOffsetAxis) {
}
TileSet_get_tile_offset_axis :: (using self: *TileSet) -> TileSet.TileOffsetAxis {
}
TileSet_set_tile_size :: (using self: *TileSet, size: Vector2i) {
}
TileSet_get_tile_size :: (using self: *TileSet) -> Vector2i {
}
TileSet_set_uv_clipping :: (using self: *TileSet, uv_clipping: bool) {
}
TileSet_is_uv_clipping :: (using self: *TileSet) -> bool {
}
TileSet_get_occlusion_layers_count :: (using self: *TileSet) -> int {
}
TileSet_add_occlusion_layer :: (using self: *TileSet, to_position: int) {
}
TileSet_move_occlusion_layer :: (using self: *TileSet, layer_index: int, to_position: int) {
}
TileSet_remove_occlusion_layer :: (using self: *TileSet, layer_index: int) {
}
TileSet_set_occlusion_layer_light_mask :: (using self: *TileSet, layer_index: int, light_mask: int) {
}
TileSet_get_occlusion_layer_light_mask :: (using self: *TileSet, layer_index: int) -> int {
}
TileSet_set_occlusion_layer_sdf_collision :: (using self: *TileSet, layer_index: int, sdf_collision: bool) {
}
TileSet_get_occlusion_layer_sdf_collision :: (using self: *TileSet, layer_index: int) -> bool {
}
TileSet_get_physics_layers_count :: (using self: *TileSet) -> int {
}
TileSet_add_physics_layer :: (using self: *TileSet, to_position: int) {
}
TileSet_move_physics_layer :: (using self: *TileSet, layer_index: int, to_position: int) {
}
TileSet_remove_physics_layer :: (using self: *TileSet, layer_index: int) {
}
TileSet_set_physics_layer_collision_layer :: (using self: *TileSet, layer_index: int, layer: int) {
}
TileSet_get_physics_layer_collision_layer :: (using self: *TileSet, layer_index: int) -> int {
}
TileSet_set_physics_layer_collision_mask :: (using self: *TileSet, layer_index: int, mask: int) {
}
TileSet_get_physics_layer_collision_mask :: (using self: *TileSet, layer_index: int) -> int {
}
TileSet_set_physics_layer_physics_material :: (using self: *TileSet, layer_index: int, physics_material: PhysicsMaterial) {
}
TileSet_get_physics_layer_physics_material :: (using self: *TileSet, layer_index: int) -> PhysicsMaterial {
}
TileSet_get_terrain_sets_count :: (using self: *TileSet) -> int {
}
TileSet_add_terrain_set :: (using self: *TileSet, to_position: int) {
}
TileSet_move_terrain_set :: (using self: *TileSet, terrain_set: int, to_position: int) {
}
TileSet_remove_terrain_set :: (using self: *TileSet, terrain_set: int) {
}
TileSet_set_terrain_set_mode :: (using self: *TileSet, terrain_set: int, mode: TileSet.TerrainMode) {
}
TileSet_get_terrain_set_mode :: (using self: *TileSet, terrain_set: int) -> TileSet.TerrainMode {
}
TileSet_get_terrains_count :: (using self: *TileSet, terrain_set: int) -> int {
}
TileSet_add_terrain :: (using self: *TileSet, terrain_set: int, to_position: int) {
}
TileSet_move_terrain :: (using self: *TileSet, terrain_set: int, terrain_index: int, to_position: int) {
}
TileSet_remove_terrain :: (using self: *TileSet, terrain_set: int, terrain_index: int) {
}
TileSet_set_terrain_name :: (using self: *TileSet, terrain_set: int, terrain_index: int, name: String) {
}
TileSet_get_terrain_name :: (using self: *TileSet, terrain_set: int, terrain_index: int) -> String {
}
TileSet_set_terrain_color :: (using self: *TileSet, terrain_set: int, terrain_index: int, color: Color) {
}
TileSet_get_terrain_color :: (using self: *TileSet, terrain_set: int, terrain_index: int) -> Color {
}
TileSet_get_navigation_layers_count :: (using self: *TileSet) -> int {
}
TileSet_add_navigation_layer :: (using self: *TileSet, to_position: int) {
}
TileSet_move_navigation_layer :: (using self: *TileSet, layer_index: int, to_position: int) {
}
TileSet_remove_navigation_layer :: (using self: *TileSet, layer_index: int) {
}
TileSet_set_navigation_layer_layers :: (using self: *TileSet, layer_index: int, layers: int) {
}
TileSet_get_navigation_layer_layers :: (using self: *TileSet, layer_index: int) -> int {
}
TileSet_set_navigation_layer_layer_value :: (using self: *TileSet, layer_index: int, layer_number: int, value: bool) {
}
TileSet_get_navigation_layer_layer_value :: (using self: *TileSet, layer_index: int, layer_number: int) -> bool {
}
TileSet_get_custom_data_layers_count :: (using self: *TileSet) -> int {
}
TileSet_add_custom_data_layer :: (using self: *TileSet, to_position: int) {
}
TileSet_move_custom_data_layer :: (using self: *TileSet, layer_index: int, to_position: int) {
}
TileSet_remove_custom_data_layer :: (using self: *TileSet, layer_index: int) {
}
TileSet_get_custom_data_layer_by_name :: (using self: *TileSet, layer_name: String) -> int {
}
TileSet_set_custom_data_layer_name :: (using self: *TileSet, layer_index: int, layer_name: String) {
}
TileSet_get_custom_data_layer_name :: (using self: *TileSet, layer_index: int) -> String {
}
TileSet_set_custom_data_layer_type :: (using self: *TileSet, layer_index: int, layer_type: VariantType) {
}
TileSet_get_custom_data_layer_type :: (using self: *TileSet, layer_index: int) -> VariantType {
}
TileSet_set_source_level_tile_proxy :: (using self: *TileSet, source_from: int, source_to: int) {
}
TileSet_get_source_level_tile_proxy :: (using self: *TileSet, source_from: int) -> int {
}
TileSet_has_source_level_tile_proxy :: (using self: *TileSet, source_from: int) -> bool {
}
TileSet_remove_source_level_tile_proxy :: (using self: *TileSet, source_from: int) {
}
TileSet_set_coords_level_tile_proxy :: (using self: *TileSet, p_source_from: int, coords_from: Vector2i, source_to: int, coords_to: Vector2i) {
}
TileSet_get_coords_level_tile_proxy :: (using self: *TileSet, source_from: int, coords_from: Vector2i) -> Array {
}
TileSet_has_coords_level_tile_proxy :: (using self: *TileSet, source_from: int, coords_from: Vector2i) -> bool {
}
TileSet_remove_coords_level_tile_proxy :: (using self: *TileSet, source_from: int, coords_from: Vector2i) {
}
TileSet_set_alternative_level_tile_proxy :: (using self: *TileSet, source_from: int, coords_from: Vector2i, alternative_from: int, source_to: int, coords_to: Vector2i, alternative_to: int) {
}
TileSet_get_alternative_level_tile_proxy :: (using self: *TileSet, source_from: int, coords_from: Vector2i, alternative_from: int) -> Array {
}
TileSet_has_alternative_level_tile_proxy :: (using self: *TileSet, source_from: int, coords_from: Vector2i, alternative_from: int) -> bool {
}
TileSet_remove_alternative_level_tile_proxy :: (using self: *TileSet, source_from: int, coords_from: Vector2i, alternative_from: int) {
}
TileSet_map_tile_proxy :: (using self: *TileSet, source_from: int, coords_from: Vector2i, alternative_from: int) -> Array {
}
TileSet_cleanup_invalid_tile_proxies :: (using self: *TileSet) {
}
TileSet_clear_tile_proxies :: (using self: *TileSet) {
}
TileSet_add_pattern :: (using self: *TileSet, pattern: TileMapPattern, index: int) -> int {
}
TileSet_get_pattern :: (using self: *TileSet, index: int) -> TileMapPattern {
}
TileSet_remove_pattern :: (using self: *TileSet, index: int) {
}
TileSet_get_patterns_count :: (using self: *TileSet) -> int {
}

// TileSetAtlasSource
TileSetAtlasSource :: struct {
	__private: *void;

	TRANSFORM_FLIP_H :: 4096;
	TRANSFORM_FLIP_V :: 8192;
	TRANSFORM_TRANSPOSE :: 16384;

	TileAnimationMode :: enum {
		TILE_ANIMATION_MODE_DEFAULT :: 0;
		TILE_ANIMATION_MODE_RANDOM_START_TIMES :: 1;
		TILE_ANIMATION_MODE_MAX :: 2;
	}
}

TileSetAtlasSource_set_texture :: (using self: *TileSetAtlasSource, texture: Texture2D) {
}
TileSetAtlasSource_get_texture :: (using self: *TileSetAtlasSource) -> Texture2D {
}
TileSetAtlasSource_set_margins :: (using self: *TileSetAtlasSource, margins: Vector2i) {
}
TileSetAtlasSource_get_margins :: (using self: *TileSetAtlasSource) -> Vector2i {
}
TileSetAtlasSource_set_separation :: (using self: *TileSetAtlasSource, separation: Vector2i) {
}
TileSetAtlasSource_get_separation :: (using self: *TileSetAtlasSource) -> Vector2i {
}
TileSetAtlasSource_set_texture_region_size :: (using self: *TileSetAtlasSource, texture_region_size: Vector2i) {
}
TileSetAtlasSource_get_texture_region_size :: (using self: *TileSetAtlasSource) -> Vector2i {
}
TileSetAtlasSource_set_use_texture_padding :: (using self: *TileSetAtlasSource, use_texture_padding: bool) {
}
TileSetAtlasSource_get_use_texture_padding :: (using self: *TileSetAtlasSource) -> bool {
}
TileSetAtlasSource_create_tile :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, size: Vector2i) {
}
TileSetAtlasSource_remove_tile :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i) {
}
TileSetAtlasSource_move_tile_in_atlas :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, new_atlas_coords: Vector2i, new_size: Vector2i) {
}
TileSetAtlasSource_get_tile_size_in_atlas :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i) -> Vector2i {
}
TileSetAtlasSource_has_room_for_tile :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, size: Vector2i, animation_columns: int, animation_separation: Vector2i, frames_count: int, ignored_tile: Vector2i) -> bool {
}
TileSetAtlasSource_get_tiles_to_be_removed_on_change :: (using self: *TileSetAtlasSource, texture: Texture2D, margins: Vector2i, separation: Vector2i, texture_region_size: Vector2i) -> PackedVector2Array {
}
TileSetAtlasSource_get_tile_at_coords :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i) -> Vector2i {
}
TileSetAtlasSource_has_tiles_outside_texture :: (using self: *TileSetAtlasSource) -> bool {
}
TileSetAtlasSource_clear_tiles_outside_texture :: (using self: *TileSetAtlasSource) {
}
TileSetAtlasSource_set_tile_animation_columns :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, frame_columns: int) {
}
TileSetAtlasSource_get_tile_animation_columns :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i) -> int {
}
TileSetAtlasSource_set_tile_animation_separation :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, separation: Vector2i) {
}
TileSetAtlasSource_get_tile_animation_separation :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i) -> Vector2i {
}
TileSetAtlasSource_set_tile_animation_speed :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, speed: float) {
}
TileSetAtlasSource_get_tile_animation_speed :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i) -> float {
}
TileSetAtlasSource_set_tile_animation_mode :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, mode: TileSetAtlasSource.TileAnimationMode) {
}
TileSetAtlasSource_get_tile_animation_mode :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i) -> TileSetAtlasSource.TileAnimationMode {
}
TileSetAtlasSource_set_tile_animation_frames_count :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, frames_count: int) {
}
TileSetAtlasSource_get_tile_animation_frames_count :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i) -> int {
}
TileSetAtlasSource_set_tile_animation_frame_duration :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, frame_index: int, duration: float) {
}
TileSetAtlasSource_get_tile_animation_frame_duration :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, frame_index: int) -> float {
}
TileSetAtlasSource_get_tile_animation_total_duration :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i) -> float {
}
TileSetAtlasSource_create_alternative_tile :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, alternative_id_override: int) -> int {
}
TileSetAtlasSource_remove_alternative_tile :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, alternative_tile: int) {
}
TileSetAtlasSource_set_alternative_tile_id :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, alternative_tile: int, new_id: int) {
}
TileSetAtlasSource_get_next_alternative_tile_id :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i) -> int {
}
TileSetAtlasSource_get_tile_data :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, alternative_tile: int) -> TileData {
}
TileSetAtlasSource_get_atlas_grid_size :: (using self: *TileSetAtlasSource) -> Vector2i {
}
TileSetAtlasSource_get_tile_texture_region :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, frame: int) -> Rect2i {
}
TileSetAtlasSource_get_runtime_texture :: (using self: *TileSetAtlasSource) -> Texture2D {
}
TileSetAtlasSource_get_runtime_tile_texture_region :: (using self: *TileSetAtlasSource, atlas_coords: Vector2i, frame: int) -> Rect2i {
}

// TileSetScenesCollectionSource
TileSetScenesCollectionSource :: struct {
	__private: *void;
}

TileSetScenesCollectionSource_get_scene_tiles_count :: (using self: *TileSetScenesCollectionSource) -> int {
}
TileSetScenesCollectionSource_get_scene_tile_id :: (using self: *TileSetScenesCollectionSource, index: int) -> int {
}
TileSetScenesCollectionSource_has_scene_tile_id :: (using self: *TileSetScenesCollectionSource, id: int) -> bool {
}
TileSetScenesCollectionSource_create_scene_tile :: (using self: *TileSetScenesCollectionSource, packed_scene: PackedScene, id_override: int) -> int {
}
TileSetScenesCollectionSource_set_scene_tile_id :: (using self: *TileSetScenesCollectionSource, id: int, new_id: int) {
}
TileSetScenesCollectionSource_set_scene_tile_scene :: (using self: *TileSetScenesCollectionSource, id: int, packed_scene: PackedScene) {
}
TileSetScenesCollectionSource_get_scene_tile_scene :: (using self: *TileSetScenesCollectionSource, id: int) -> PackedScene {
}
TileSetScenesCollectionSource_set_scene_tile_display_placeholder :: (using self: *TileSetScenesCollectionSource, id: int, display_placeholder: bool) {
}
TileSetScenesCollectionSource_get_scene_tile_display_placeholder :: (using self: *TileSetScenesCollectionSource, id: int) -> bool {
}
TileSetScenesCollectionSource_remove_scene_tile :: (using self: *TileSetScenesCollectionSource, id: int) {
}
TileSetScenesCollectionSource_get_next_scene_tile_id :: (using self: *TileSetScenesCollectionSource) -> int {
}

// TileSetSource
TileSetSource :: struct {
	__private: *void;
}

TileSetSource_get_tiles_count :: (using self: *TileSetSource) -> int {
}
TileSetSource_get_tile_id :: (using self: *TileSetSource, index: int) -> Vector2i {
}
TileSetSource_has_tile :: (using self: *TileSetSource, atlas_coords: Vector2i) -> bool {
}
TileSetSource_get_alternative_tiles_count :: (using self: *TileSetSource, atlas_coords: Vector2i) -> int {
}
TileSetSource_get_alternative_tile_id :: (using self: *TileSetSource, atlas_coords: Vector2i, index: int) -> int {
}
TileSetSource_has_alternative_tile :: (using self: *TileSetSource, atlas_coords: Vector2i, alternative_tile: int) -> bool {
}

// Time
Time :: struct {
	__private: *void;

	Month :: enum {
		MONTH_JANUARY :: 1;
		MONTH_FEBRUARY :: 2;
		MONTH_MARCH :: 3;
		MONTH_APRIL :: 4;
		MONTH_MAY :: 5;
		MONTH_JUNE :: 6;
		MONTH_JULY :: 7;
		MONTH_AUGUST :: 8;
		MONTH_SEPTEMBER :: 9;
		MONTH_OCTOBER :: 10;
		MONTH_NOVEMBER :: 11;
		MONTH_DECEMBER :: 12;
	}
	Weekday :: enum {
		WEEKDAY_SUNDAY :: 0;
		WEEKDAY_MONDAY :: 1;
		WEEKDAY_TUESDAY :: 2;
		WEEKDAY_WEDNESDAY :: 3;
		WEEKDAY_THURSDAY :: 4;
		WEEKDAY_FRIDAY :: 5;
		WEEKDAY_SATURDAY :: 6;
	}
}

Time_get_datetime_dict_from_unix_time :: (using self: *Time, unix_time_val: int) -> Dictionary {
}
Time_get_date_dict_from_unix_time :: (using self: *Time, unix_time_val: int) -> Dictionary {
}
Time_get_time_dict_from_unix_time :: (using self: *Time, unix_time_val: int) -> Dictionary {
}
Time_get_datetime_string_from_unix_time :: (using self: *Time, unix_time_val: int, use_space: bool) -> String {
}
Time_get_date_string_from_unix_time :: (using self: *Time, unix_time_val: int) -> String {
}
Time_get_time_string_from_unix_time :: (using self: *Time, unix_time_val: int) -> String {
}
Time_get_datetime_dict_from_datetime_string :: (using self: *Time, datetime: String, weekday: bool) -> Dictionary {
}
Time_get_datetime_string_from_datetime_dict :: (using self: *Time, datetime: Dictionary, use_space: bool) -> String {
}
Time_get_unix_time_from_datetime_dict :: (using self: *Time, datetime: Dictionary) -> int {
}
Time_get_unix_time_from_datetime_string :: (using self: *Time, datetime: String) -> int {
}
Time_get_offset_string_from_offset_minutes :: (using self: *Time, offset_minutes: int) -> String {
}
Time_get_datetime_dict_from_system :: (using self: *Time, utc: bool) -> Dictionary {
}
Time_get_date_dict_from_system :: (using self: *Time, utc: bool) -> Dictionary {
}
Time_get_time_dict_from_system :: (using self: *Time, utc: bool) -> Dictionary {
}
Time_get_datetime_string_from_system :: (using self: *Time, utc: bool, use_space: bool) -> String {
}
Time_get_date_string_from_system :: (using self: *Time, utc: bool) -> String {
}
Time_get_time_string_from_system :: (using self: *Time, utc: bool) -> String {
}
Time_get_time_zone_from_system :: (using self: *Time) -> Dictionary {
}
Time_get_unix_time_from_system :: (using self: *Time) -> float {
}
Time_get_ticks_msec :: (using self: *Time) -> int {
}
Time_get_ticks_usec :: (using self: *Time) -> int {
}

// Timer
Timer :: struct {
	__private: *void;

	TimerProcessCallback :: enum {
		TIMER_PROCESS_PHYSICS :: 0;
		TIMER_PROCESS_IDLE :: 1;
	}
}

Timer_set_wait_time :: (using self: *Timer, time_sec: float) {
}
Timer_get_wait_time :: (using self: *Timer) -> float {
}
Timer_set_one_shot :: (using self: *Timer, enable: bool) {
}
Timer_is_one_shot :: (using self: *Timer) -> bool {
}
Timer_set_autostart :: (using self: *Timer, enable: bool) {
}
Timer_has_autostart :: (using self: *Timer) -> bool {
}
Timer_start :: (using self: *Timer, time_sec: float) {
}
Timer_stop :: (using self: *Timer) {
}
Timer_set_paused :: (using self: *Timer, paused: bool) {
}
Timer_is_paused :: (using self: *Timer) -> bool {
}
Timer_is_stopped :: (using self: *Timer) -> bool {
}
Timer_get_time_left :: (using self: *Timer) -> float {
}
Timer_set_timer_process_callback :: (using self: *Timer, callback: Timer.TimerProcessCallback) {
}
Timer_get_timer_process_callback :: (using self: *Timer) -> Timer.TimerProcessCallback {
}

// TorusMesh
TorusMesh :: struct {
	__private: *void;
}

TorusMesh_set_inner_radius :: (using self: *TorusMesh, radius: float) {
}
TorusMesh_get_inner_radius :: (using self: *TorusMesh) -> float {
}
TorusMesh_set_outer_radius :: (using self: *TorusMesh, radius: float) {
}
TorusMesh_get_outer_radius :: (using self: *TorusMesh) -> float {
}
TorusMesh_set_rings :: (using self: *TorusMesh, rings: int) {
}
TorusMesh_get_rings :: (using self: *TorusMesh) -> int {
}
TorusMesh_set_ring_segments :: (using self: *TorusMesh, rings: int) {
}
TorusMesh_get_ring_segments :: (using self: *TorusMesh) -> int {
}

// TouchScreenButton
TouchScreenButton :: struct {
	__private: *void;

	VisibilityMode :: enum {
		VISIBILITY_ALWAYS :: 0;
		VISIBILITY_TOUCHSCREEN_ONLY :: 1;
	}
}

TouchScreenButton_set_texture_normal :: (using self: *TouchScreenButton, texture: Texture2D) {
}
TouchScreenButton_get_texture_normal :: (using self: *TouchScreenButton) -> Texture2D {
}
TouchScreenButton_set_texture_pressed :: (using self: *TouchScreenButton, texture: Texture2D) {
}
TouchScreenButton_get_texture_pressed :: (using self: *TouchScreenButton) -> Texture2D {
}
TouchScreenButton_set_bitmask :: (using self: *TouchScreenButton, bitmask: BitMap) {
}
TouchScreenButton_get_bitmask :: (using self: *TouchScreenButton) -> BitMap {
}
TouchScreenButton_set_shape :: (using self: *TouchScreenButton, shape: Shape2D) {
}
TouchScreenButton_get_shape :: (using self: *TouchScreenButton) -> Shape2D {
}
TouchScreenButton_set_shape_centered :: (using self: *TouchScreenButton, _bool: bool) {
}
TouchScreenButton_is_shape_centered :: (using self: *TouchScreenButton) -> bool {
}
TouchScreenButton_set_shape_visible :: (using self: *TouchScreenButton, _bool: bool) {
}
TouchScreenButton_is_shape_visible :: (using self: *TouchScreenButton) -> bool {
}
TouchScreenButton_set_action :: (using self: *TouchScreenButton, action: String) {
}
TouchScreenButton_get_action :: (using self: *TouchScreenButton) -> String {
}
TouchScreenButton_set_visibility_mode :: (using self: *TouchScreenButton, mode: TouchScreenButton.VisibilityMode) {
}
TouchScreenButton_get_visibility_mode :: (using self: *TouchScreenButton) -> TouchScreenButton.VisibilityMode {
}
TouchScreenButton_set_passby_press :: (using self: *TouchScreenButton, enabled: bool) {
}
TouchScreenButton_is_passby_press_enabled :: (using self: *TouchScreenButton) -> bool {
}
TouchScreenButton_is_pressed :: (using self: *TouchScreenButton) -> bool {
}

// Translation
Translation :: struct {
	__private: *void;
}

Translation__get_plural_message :: (using self: *Translation, src_message: StringName, src_plural_message: StringName, n: int, _context: StringName) -> StringName {
}
Translation__get_message :: (using self: *Translation, src_message: StringName, _context: StringName) -> StringName {
}
Translation_set_locale :: (using self: *Translation, locale: String) {
}
Translation_get_locale :: (using self: *Translation) -> String {
}
Translation_add_message :: (using self: *Translation, src_message: StringName, xlated_message: StringName, _context: StringName) {
}
Translation_add_plural_message :: (using self: *Translation, src_message: StringName, xlated_messages: PackedStringArray, _context: StringName) {
}
Translation_get_message :: (using self: *Translation, src_message: StringName, _context: StringName) -> StringName {
}
Translation_get_plural_message :: (using self: *Translation, src_message: StringName, src_plural_message: StringName, n: int, _context: StringName) -> StringName {
}
Translation_erase_message :: (using self: *Translation, src_message: StringName, _context: StringName) {
}
Translation_get_message_list :: (using self: *Translation) -> PackedStringArray {
}
Translation_get_translated_message_list :: (using self: *Translation) -> PackedStringArray {
}
Translation_get_message_count :: (using self: *Translation) -> int {
}

// TranslationServer
TranslationServer :: struct {
	__private: *void;
}

TranslationServer_set_locale :: (using self: *TranslationServer, locale: String) {
}
TranslationServer_get_locale :: (using self: *TranslationServer) -> String {
}
TranslationServer_get_tool_locale :: (using self: *TranslationServer) -> String {
}
TranslationServer_compare_locales :: (using self: *TranslationServer, locale_a: String, locale_b: String) -> int {
}
TranslationServer_standardize_locale :: (using self: *TranslationServer, locale: String) -> String {
}
TranslationServer_get_all_languages :: (using self: *TranslationServer) -> PackedStringArray {
}
TranslationServer_get_language_name :: (using self: *TranslationServer, language: String) -> String {
}
TranslationServer_get_all_scripts :: (using self: *TranslationServer) -> PackedStringArray {
}
TranslationServer_get_script_name :: (using self: *TranslationServer, script: String) -> String {
}
TranslationServer_get_all_countries :: (using self: *TranslationServer) -> PackedStringArray {
}
TranslationServer_get_country_name :: (using self: *TranslationServer, country: String) -> String {
}
TranslationServer_get_locale_name :: (using self: *TranslationServer, locale: String) -> String {
}
TranslationServer_translate :: (using self: *TranslationServer, message: StringName, _context: StringName) -> StringName {
}
TranslationServer_translate_plural :: (using self: *TranslationServer, message: StringName, plural_message: StringName, n: int, _context: StringName) -> StringName {
}
TranslationServer_add_translation :: (using self: *TranslationServer, translation: Translation) {
}
TranslationServer_remove_translation :: (using self: *TranslationServer, translation: Translation) {
}
TranslationServer_get_translation_object :: (using self: *TranslationServer, locale: String) -> Translation {
}
TranslationServer_clear :: (using self: *TranslationServer) {
}
TranslationServer_get_loaded_locales :: (using self: *TranslationServer) -> PackedStringArray {
}
TranslationServer_is_pseudolocalization_enabled :: (using self: *TranslationServer) -> bool {
}
TranslationServer_set_pseudolocalization_enabled :: (using self: *TranslationServer, enabled: bool) {
}
TranslationServer_reload_pseudolocalization :: (using self: *TranslationServer) {
}
TranslationServer_pseudolocalize :: (using self: *TranslationServer, message: StringName) -> StringName {
}

// Tree
Tree :: struct {
	__private: *void;

	SelectMode :: enum {
		SELECT_SINGLE :: 0;
		SELECT_ROW :: 1;
		SELECT_MULTI :: 2;
	}
	DropModeFlags :: enum {
		DROP_MODE_DISABLED :: 0;
		DROP_MODE_ON_ITEM :: 1;
		DROP_MODE_INBETWEEN :: 2;
	}
}

Tree_clear :: (using self: *Tree) {
}
Tree_create_item :: (using self: *Tree, parent: TreeItem, index: int) -> TreeItem {
}
Tree_get_root :: (using self: *Tree) -> TreeItem {
}
Tree_set_column_custom_minimum_width :: (using self: *Tree, column: int, min_width: int) {
}
Tree_set_column_expand :: (using self: *Tree, column: int, expand: bool) {
}
Tree_set_column_expand_ratio :: (using self: *Tree, column: int, ratio: int) {
}
Tree_set_column_clip_content :: (using self: *Tree, column: int, enable: bool) {
}
Tree_is_column_expanding :: (using self: *Tree, column: int) -> bool {
}
Tree_is_column_clipping_content :: (using self: *Tree, column: int) -> bool {
}
Tree_get_column_expand_ratio :: (using self: *Tree, column: int) -> int {
}
Tree_get_column_width :: (using self: *Tree, column: int) -> int {
}
Tree_set_hide_root :: (using self: *Tree, enable: bool) {
}
Tree_is_root_hidden :: (using self: *Tree) -> bool {
}
Tree_get_next_selected :: (using self: *Tree, from: TreeItem) -> TreeItem {
}
Tree_get_selected :: (using self: *Tree) -> TreeItem {
}
Tree_set_selected :: (using self: *Tree, item: TreeItem, column: int) {
}
Tree_get_selected_column :: (using self: *Tree) -> int {
}
Tree_get_pressed_button :: (using self: *Tree) -> int {
}
Tree_set_select_mode :: (using self: *Tree, mode: Tree.SelectMode) {
}
Tree_get_select_mode :: (using self: *Tree) -> Tree.SelectMode {
}
Tree_deselect_all :: (using self: *Tree) {
}
Tree_set_columns :: (using self: *Tree, amount: int) {
}
Tree_get_columns :: (using self: *Tree) -> int {
}
Tree_get_edited :: (using self: *Tree) -> TreeItem {
}
Tree_get_edited_column :: (using self: *Tree) -> int {
}
Tree_edit_selected :: (using self: *Tree, force_edit: bool) -> bool {
}
Tree_get_custom_popup_rect :: (using self: *Tree) -> Rect2 {
}
Tree_get_item_area_rect :: (using self: *Tree, item: TreeItem, column: int, button_index: int) -> Rect2 {
}
Tree_get_item_at_position :: (using self: *Tree, position: Vector2) -> TreeItem {
}
Tree_get_column_at_position :: (using self: *Tree, position: Vector2) -> int {
}
Tree_get_drop_section_at_position :: (using self: *Tree, position: Vector2) -> int {
}
Tree_get_button_id_at_position :: (using self: *Tree, position: Vector2) -> int {
}
Tree_ensure_cursor_is_visible :: (using self: *Tree) {
}
Tree_set_column_titles_visible :: (using self: *Tree, visible: bool) {
}
Tree_are_column_titles_visible :: (using self: *Tree) -> bool {
}
Tree_set_column_title :: (using self: *Tree, column: int, title: String) {
}
Tree_get_column_title :: (using self: *Tree, column: int) -> String {
}
Tree_set_column_title_alignment :: (using self: *Tree, column: int, title_alignment: HorizontalAlignment) {
}
Tree_get_column_title_alignment :: (using self: *Tree, column: int) -> HorizontalAlignment {
}
Tree_set_column_title_direction :: (using self: *Tree, column: int, direction: Control.TextDirection) {
}
Tree_get_column_title_direction :: (using self: *Tree, column: int) -> Control.TextDirection {
}
Tree_set_column_title_language :: (using self: *Tree, column: int, language: String) {
}
Tree_get_column_title_language :: (using self: *Tree, column: int) -> String {
}
Tree_get_scroll :: (using self: *Tree) -> Vector2 {
}
Tree_scroll_to_item :: (using self: *Tree, item: TreeItem, center_on_item: bool) {
}
Tree_set_h_scroll_enabled :: (using self: *Tree, h_scroll: bool) {
}
Tree_is_h_scroll_enabled :: (using self: *Tree) -> bool {
}
Tree_set_v_scroll_enabled :: (using self: *Tree, h_scroll: bool) {
}
Tree_is_v_scroll_enabled :: (using self: *Tree) -> bool {
}
Tree_set_hide_folding :: (using self: *Tree, hide: bool) {
}
Tree_is_folding_hidden :: (using self: *Tree) -> bool {
}
Tree_set_enable_recursive_folding :: (using self: *Tree, enable: bool) {
}
Tree_is_recursive_folding_enabled :: (using self: *Tree) -> bool {
}
Tree_set_drop_mode_flags :: (using self: *Tree, flags: int) {
}
Tree_get_drop_mode_flags :: (using self: *Tree) -> int {
}
Tree_set_allow_rmb_select :: (using self: *Tree, allow: bool) {
}
Tree_get_allow_rmb_select :: (using self: *Tree) -> bool {
}
Tree_set_allow_reselect :: (using self: *Tree, allow: bool) {
}
Tree_get_allow_reselect :: (using self: *Tree) -> bool {
}
Tree_set_allow_search :: (using self: *Tree, allow: bool) {
}
Tree_get_allow_search :: (using self: *Tree) -> bool {
}

// TreeItem
TreeItem :: struct {
	__private: *void;

	TreeCellMode :: enum {
		CELL_MODE_STRING :: 0;
		CELL_MODE_CHECK :: 1;
		CELL_MODE_RANGE :: 2;
		CELL_MODE_ICON :: 3;
		CELL_MODE_CUSTOM :: 4;
	}
}

TreeItem_set_cell_mode :: (using self: *TreeItem, column: int, mode: TreeItem.TreeCellMode) {
}
TreeItem_get_cell_mode :: (using self: *TreeItem, column: int) -> TreeItem.TreeCellMode {
}
TreeItem_set_edit_multiline :: (using self: *TreeItem, column: int, multiline: bool) {
}
TreeItem_is_edit_multiline :: (using self: *TreeItem, column: int) -> bool {
}
TreeItem_set_checked :: (using self: *TreeItem, column: int, checked: bool) {
}
TreeItem_set_indeterminate :: (using self: *TreeItem, column: int, indeterminate: bool) {
}
TreeItem_is_checked :: (using self: *TreeItem, column: int) -> bool {
}
TreeItem_is_indeterminate :: (using self: *TreeItem, column: int) -> bool {
}
TreeItem_propagate_check :: (using self: *TreeItem, column: int, emit_signal: bool) {
}
TreeItem_set_text :: (using self: *TreeItem, column: int, text: String) {
}
TreeItem_get_text :: (using self: *TreeItem, column: int) -> String {
}
TreeItem_set_text_direction :: (using self: *TreeItem, column: int, direction: Control.TextDirection) {
}
TreeItem_get_text_direction :: (using self: *TreeItem, column: int) -> Control.TextDirection {
}
TreeItem_set_autowrap_mode :: (using self: *TreeItem, column: int, autowrap_mode: TextServer.AutowrapMode) {
}
TreeItem_get_autowrap_mode :: (using self: *TreeItem, column: int) -> TextServer.AutowrapMode {
}
TreeItem_set_text_overrun_behavior :: (using self: *TreeItem, column: int, overrun_behavior: TextServer.OverrunBehavior) {
}
TreeItem_get_text_overrun_behavior :: (using self: *TreeItem, column: int) -> TextServer.OverrunBehavior {
}
TreeItem_set_structured_text_bidi_override :: (using self: *TreeItem, column: int, parser: TextServer.StructuredTextParser) {
}
TreeItem_get_structured_text_bidi_override :: (using self: *TreeItem, column: int) -> TextServer.StructuredTextParser {
}
TreeItem_set_structured_text_bidi_override_options :: (using self: *TreeItem, column: int, args: Array) {
}
TreeItem_get_structured_text_bidi_override_options :: (using self: *TreeItem, column: int) -> Array {
}
TreeItem_set_language :: (using self: *TreeItem, column: int, language: String) {
}
TreeItem_get_language :: (using self: *TreeItem, column: int) -> String {
}
TreeItem_set_suffix :: (using self: *TreeItem, column: int, text: String) {
}
TreeItem_get_suffix :: (using self: *TreeItem, column: int) -> String {
}
TreeItem_set_icon :: (using self: *TreeItem, column: int, texture: Texture2D) {
}
TreeItem_get_icon :: (using self: *TreeItem, column: int) -> Texture2D {
}
TreeItem_set_icon_region :: (using self: *TreeItem, column: int, region: Rect2) {
}
TreeItem_get_icon_region :: (using self: *TreeItem, column: int) -> Rect2 {
}
TreeItem_set_icon_max_width :: (using self: *TreeItem, column: int, width: int) {
}
TreeItem_get_icon_max_width :: (using self: *TreeItem, column: int) -> int {
}
TreeItem_set_icon_modulate :: (using self: *TreeItem, column: int, modulate: Color) {
}
TreeItem_get_icon_modulate :: (using self: *TreeItem, column: int) -> Color {
}
TreeItem_set_range :: (using self: *TreeItem, column: int, value: float) {
}
TreeItem_get_range :: (using self: *TreeItem, column: int) -> float {
}
TreeItem_set_range_config :: (using self: *TreeItem, column: int, min: float, max: float, step: float, expr: bool) {
}
TreeItem_get_range_config :: (using self: *TreeItem, column: int) -> Dictionary {
}
TreeItem_set_metadata :: (using self: *TreeItem, column: int, meta: Variant) {
}
TreeItem_get_metadata :: (using self: *TreeItem, column: int) -> Variant {
}
TreeItem_set_custom_draw :: (using self: *TreeItem, column: int, object: Object, callback: StringName) {
}
TreeItem_set_custom_draw_callback :: (using self: *TreeItem, column: int, callback: Callable) {
}
TreeItem_get_custom_draw_callback :: (using self: *TreeItem, column: int) -> Callable {
}
TreeItem_set_collapsed :: (using self: *TreeItem, enable: bool) {
}
TreeItem_is_collapsed :: (using self: *TreeItem) -> bool {
}
TreeItem_set_collapsed_recursive :: (using self: *TreeItem, enable: bool) {
}
TreeItem_is_any_collapsed :: (using self: *TreeItem, only_visible: bool) -> bool {
}
TreeItem_set_visible :: (using self: *TreeItem, enable: bool) {
}
TreeItem_is_visible :: (using self: *TreeItem) -> bool {
}
TreeItem_is_visible_in_tree :: (using self: *TreeItem) -> bool {
}
TreeItem_uncollapse_tree :: (using self: *TreeItem) {
}
TreeItem_set_custom_minimum_height :: (using self: *TreeItem, height: int) {
}
TreeItem_get_custom_minimum_height :: (using self: *TreeItem) -> int {
}
TreeItem_set_selectable :: (using self: *TreeItem, column: int, selectable: bool) {
}
TreeItem_is_selectable :: (using self: *TreeItem, column: int) -> bool {
}
TreeItem_is_selected :: (using self: *TreeItem, column: int) -> bool {
}
TreeItem_select :: (using self: *TreeItem, column: int) {
}
TreeItem_deselect :: (using self: *TreeItem, column: int) {
}
TreeItem_set_editable :: (using self: *TreeItem, column: int, enabled: bool) {
}
TreeItem_is_editable :: (using self: *TreeItem, column: int) -> bool {
}
TreeItem_set_custom_color :: (using self: *TreeItem, column: int, color: Color) {
}
TreeItem_get_custom_color :: (using self: *TreeItem, column: int) -> Color {
}
TreeItem_clear_custom_color :: (using self: *TreeItem, column: int) {
}
TreeItem_set_custom_font :: (using self: *TreeItem, column: int, font: Font) {
}
TreeItem_get_custom_font :: (using self: *TreeItem, column: int) -> Font {
}
TreeItem_set_custom_font_size :: (using self: *TreeItem, column: int, font_size: int) {
}
TreeItem_get_custom_font_size :: (using self: *TreeItem, column: int) -> int {
}
TreeItem_set_custom_bg_color :: (using self: *TreeItem, column: int, color: Color, just_outline: bool) {
}
TreeItem_clear_custom_bg_color :: (using self: *TreeItem, column: int) {
}
TreeItem_get_custom_bg_color :: (using self: *TreeItem, column: int) -> Color {
}
TreeItem_set_custom_as_button :: (using self: *TreeItem, column: int, enable: bool) {
}
TreeItem_is_custom_set_as_button :: (using self: *TreeItem, column: int) -> bool {
}
TreeItem_add_button :: (using self: *TreeItem, column: int, button: Texture2D, id: int, disabled: bool, tooltip_text: String) {
}
TreeItem_get_button_count :: (using self: *TreeItem, column: int) -> int {
}
TreeItem_get_button_tooltip_text :: (using self: *TreeItem, column: int, button_index: int) -> String {
}
TreeItem_get_button_id :: (using self: *TreeItem, column: int, button_index: int) -> int {
}
TreeItem_get_button_by_id :: (using self: *TreeItem, column: int, id: int) -> int {
}
TreeItem_get_button_color :: (using self: *TreeItem, column: int, id: int) -> Color {
}
TreeItem_get_button :: (using self: *TreeItem, column: int, button_index: int) -> Texture2D {
}
TreeItem_set_button_tooltip_text :: (using self: *TreeItem, column: int, button_index: int, tooltip: String) {
}
TreeItem_set_button :: (using self: *TreeItem, column: int, button_index: int, button: Texture2D) {
}
TreeItem_erase_button :: (using self: *TreeItem, column: int, button_index: int) {
}
TreeItem_set_button_disabled :: (using self: *TreeItem, column: int, button_index: int, disabled: bool) {
}
TreeItem_set_button_color :: (using self: *TreeItem, column: int, button_index: int, color: Color) {
}
TreeItem_is_button_disabled :: (using self: *TreeItem, column: int, button_index: int) -> bool {
}
TreeItem_set_tooltip_text :: (using self: *TreeItem, column: int, tooltip: String) {
}
TreeItem_get_tooltip_text :: (using self: *TreeItem, column: int) -> String {
}
TreeItem_set_text_alignment :: (using self: *TreeItem, column: int, text_alignment: HorizontalAlignment) {
}
TreeItem_get_text_alignment :: (using self: *TreeItem, column: int) -> HorizontalAlignment {
}
TreeItem_set_expand_right :: (using self: *TreeItem, column: int, enable: bool) {
}
TreeItem_get_expand_right :: (using self: *TreeItem, column: int) -> bool {
}
TreeItem_set_disable_folding :: (using self: *TreeItem, disable: bool) {
}
TreeItem_is_folding_disabled :: (using self: *TreeItem) -> bool {
}
TreeItem_create_child :: (using self: *TreeItem, index: int) -> TreeItem {
}
TreeItem_add_child :: (using self: *TreeItem, child: TreeItem) {
}
TreeItem_remove_child :: (using self: *TreeItem, child: TreeItem) {
}
TreeItem_get_tree :: (using self: *TreeItem) -> Tree {
}
TreeItem_get_next :: (using self: *TreeItem) -> TreeItem {
}
TreeItem_get_prev :: (using self: *TreeItem) -> TreeItem {
}
TreeItem_get_parent :: (using self: *TreeItem) -> TreeItem {
}
TreeItem_get_first_child :: (using self: *TreeItem) -> TreeItem {
}
TreeItem_get_next_in_tree :: (using self: *TreeItem, wrap: bool) -> TreeItem {
}
TreeItem_get_prev_in_tree :: (using self: *TreeItem, wrap: bool) -> TreeItem {
}
TreeItem_get_next_visible :: (using self: *TreeItem, wrap: bool) -> TreeItem {
}
TreeItem_get_prev_visible :: (using self: *TreeItem, wrap: bool) -> TreeItem {
}
TreeItem_get_child :: (using self: *TreeItem, index: int) -> TreeItem {
}
TreeItem_get_child_count :: (using self: *TreeItem) -> int {
}
TreeItem_get_children :: (using self: *TreeItem) -> Array {
}
TreeItem_get_index :: (using self: *TreeItem) -> int {
}
TreeItem_move_before :: (using self: *TreeItem, item: TreeItem) {
}
TreeItem_move_after :: (using self: *TreeItem, item: TreeItem) {
}
TreeItem_call_recursive :: (using self: *TreeItem, method: StringName) {
}

// TriangleMesh
TriangleMesh :: struct {
	__private: *void;
}

// TubeTrailMesh
TubeTrailMesh :: struct {
	__private: *void;
}

TubeTrailMesh_set_radius :: (using self: *TubeTrailMesh, radius: float) {
}
TubeTrailMesh_get_radius :: (using self: *TubeTrailMesh) -> float {
}
TubeTrailMesh_set_radial_steps :: (using self: *TubeTrailMesh, radial_steps: int) {
}
TubeTrailMesh_get_radial_steps :: (using self: *TubeTrailMesh) -> int {
}
TubeTrailMesh_set_sections :: (using self: *TubeTrailMesh, sections: int) {
}
TubeTrailMesh_get_sections :: (using self: *TubeTrailMesh) -> int {
}
TubeTrailMesh_set_section_length :: (using self: *TubeTrailMesh, section_length: float) {
}
TubeTrailMesh_get_section_length :: (using self: *TubeTrailMesh) -> float {
}
TubeTrailMesh_set_section_rings :: (using self: *TubeTrailMesh, section_rings: int) {
}
TubeTrailMesh_get_section_rings :: (using self: *TubeTrailMesh) -> int {
}
TubeTrailMesh_set_cap_top :: (using self: *TubeTrailMesh, cap_top: bool) {
}
TubeTrailMesh_is_cap_top :: (using self: *TubeTrailMesh) -> bool {
}
TubeTrailMesh_set_cap_bottom :: (using self: *TubeTrailMesh, cap_bottom: bool) {
}
TubeTrailMesh_is_cap_bottom :: (using self: *TubeTrailMesh) -> bool {
}
TubeTrailMesh_set_curve :: (using self: *TubeTrailMesh, curve: Curve) {
}
TubeTrailMesh_get_curve :: (using self: *TubeTrailMesh) -> Curve {
}

// Tween
Tween :: struct {
	__private: *void;

	TweenProcessMode :: enum {
		TWEEN_PROCESS_PHYSICS :: 0;
		TWEEN_PROCESS_IDLE :: 1;
	}
	TweenPauseMode :: enum {
		TWEEN_PAUSE_BOUND :: 0;
		TWEEN_PAUSE_STOP :: 1;
		TWEEN_PAUSE_PROCESS :: 2;
	}
	TransitionType :: enum {
		TRANS_LINEAR :: 0;
		TRANS_SINE :: 1;
		TRANS_QUINT :: 2;
		TRANS_QUART :: 3;
		TRANS_QUAD :: 4;
		TRANS_EXPO :: 5;
		TRANS_ELASTIC :: 6;
		TRANS_CUBIC :: 7;
		TRANS_CIRC :: 8;
		TRANS_BOUNCE :: 9;
		TRANS_BACK :: 10;
		TRANS_SPRING :: 11;
	}
	EaseType :: enum {
		EASE_IN :: 0;
		EASE_OUT :: 1;
		EASE_IN_OUT :: 2;
		EASE_OUT_IN :: 3;
	}
}

Tween_tween_property :: (using self: *Tween, object: Object, property: NodePath, final_val: Variant, duration: float) -> PropertyTweener {
}
Tween_tween_interval :: (using self: *Tween, time: float) -> IntervalTweener {
}
Tween_tween_callback :: (using self: *Tween, callback: Callable) -> CallbackTweener {
}
Tween_tween_method :: (using self: *Tween, method: Callable, from: Variant, to: Variant, duration: float) -> MethodTweener {
}
Tween_custom_step :: (using self: *Tween, delta: float) -> bool {
}
Tween_stop :: (using self: *Tween) {
}
Tween_pause :: (using self: *Tween) {
}
Tween_play :: (using self: *Tween) {
}
Tween_kill :: (using self: *Tween) {
}
Tween_get_total_elapsed_time :: (using self: *Tween) -> float {
}
Tween_is_running :: (using self: *Tween) -> bool {
}
Tween_is_valid :: (using self: *Tween) -> bool {
}
Tween_bind_node :: (using self: *Tween, node: Node) -> Tween {
}
Tween_set_process_mode :: (using self: *Tween, mode: Tween.TweenProcessMode) -> Tween {
}
Tween_set_pause_mode :: (using self: *Tween, mode: Tween.TweenPauseMode) -> Tween {
}
Tween_set_parallel :: (using self: *Tween, parallel: bool) -> Tween {
}
Tween_set_loops :: (using self: *Tween, loops: int) -> Tween {
}
Tween_get_loops_left :: (using self: *Tween) -> int {
}
Tween_set_speed_scale :: (using self: *Tween, speed: float) -> Tween {
}
Tween_set_trans :: (using self: *Tween, trans: Tween.TransitionType) -> Tween {
}
Tween_set_ease :: (using self: *Tween, ease: Tween.EaseType) -> Tween {
}
Tween_parallel :: (using self: *Tween) -> Tween {
}
Tween_chain :: (using self: *Tween) -> Tween {
}
Tween_interpolate_value :: (using self: *Tween, initial_value: Variant, delta_value: Variant, elapsed_time: float, duration: float, trans_type: Tween.TransitionType, ease_type: Tween.EaseType) -> Variant {
}

// Tweener
Tweener :: struct {
	__private: *void;
}

// UDPServer
UDPServer :: struct {
	__private: *void;
}

UDPServer_listen :: (using self: *UDPServer, port: int, bind_address: String) -> Error {
}
UDPServer_poll :: (using self: *UDPServer) -> Error {
}
UDPServer_is_connection_available :: (using self: *UDPServer) -> bool {
}
UDPServer_get_local_port :: (using self: *UDPServer) -> int {
}
UDPServer_is_listening :: (using self: *UDPServer) -> bool {
}
UDPServer_take_connection :: (using self: *UDPServer) -> PacketPeerUDP {
}
UDPServer_stop :: (using self: *UDPServer) {
}
UDPServer_set_max_pending_connections :: (using self: *UDPServer, max_pending_connections: int) {
}
UDPServer_get_max_pending_connections :: (using self: *UDPServer) -> int {
}

// UPNP
UPNP :: struct {
	__private: *void;

	UPNPResult :: enum {
		UPNP_RESULT_SUCCESS :: 0;
		UPNP_RESULT_NOT_AUTHORIZED :: 1;
		UPNP_RESULT_PORT_MAPPING_NOT_FOUND :: 2;
		UPNP_RESULT_INCONSISTENT_PARAMETERS :: 3;
		UPNP_RESULT_NO_SUCH_ENTRY_IN_ARRAY :: 4;
		UPNP_RESULT_ACTION_FAILED :: 5;
		UPNP_RESULT_SRC_IP_WILDCARD_NOT_PERMITTED :: 6;
		UPNP_RESULT_EXT_PORT_WILDCARD_NOT_PERMITTED :: 7;
		UPNP_RESULT_INT_PORT_WILDCARD_NOT_PERMITTED :: 8;
		UPNP_RESULT_REMOTE_HOST_MUST_BE_WILDCARD :: 9;
		UPNP_RESULT_EXT_PORT_MUST_BE_WILDCARD :: 10;
		UPNP_RESULT_NO_PORT_MAPS_AVAILABLE :: 11;
		UPNP_RESULT_CONFLICT_WITH_OTHER_MECHANISM :: 12;
		UPNP_RESULT_CONFLICT_WITH_OTHER_MAPPING :: 13;
		UPNP_RESULT_SAME_PORT_VALUES_REQUIRED :: 14;
		UPNP_RESULT_ONLY_PERMANENT_LEASE_SUPPORTED :: 15;
		UPNP_RESULT_INVALID_GATEWAY :: 16;
		UPNP_RESULT_INVALID_PORT :: 17;
		UPNP_RESULT_INVALID_PROTOCOL :: 18;
		UPNP_RESULT_INVALID_DURATION :: 19;
		UPNP_RESULT_INVALID_ARGS :: 20;
		UPNP_RESULT_INVALID_RESPONSE :: 21;
		UPNP_RESULT_INVALID_PARAM :: 22;
		UPNP_RESULT_HTTP_ERROR :: 23;
		UPNP_RESULT_SOCKET_ERROR :: 24;
		UPNP_RESULT_MEM_ALLOC_ERROR :: 25;
		UPNP_RESULT_NO_GATEWAY :: 26;
		UPNP_RESULT_NO_DEVICES :: 27;
		UPNP_RESULT_UNKNOWN_ERROR :: 28;
	}
}

UPNP_get_device_count :: (using self: *UPNP) -> int {
}
UPNP_get_device :: (using self: *UPNP, index: int) -> UPNPDevice {
}
UPNP_add_device :: (using self: *UPNP, device: UPNPDevice) {
}
UPNP_set_device :: (using self: *UPNP, index: int, device: UPNPDevice) {
}
UPNP_remove_device :: (using self: *UPNP, index: int) {
}
UPNP_clear_devices :: (using self: *UPNP) {
}
UPNP_get_gateway :: (using self: *UPNP) -> UPNPDevice {
}
UPNP_discover :: (using self: *UPNP, timeout: int, ttl: int, device_filter: String) -> int {
}
UPNP_query_external_address :: (using self: *UPNP) -> String {
}
UPNP_add_port_mapping :: (using self: *UPNP, port: int, port_internal: int, desc: String, proto: String, duration: int) -> int {
}
UPNP_delete_port_mapping :: (using self: *UPNP, port: int, proto: String) -> int {
}
UPNP_set_discover_multicast_if :: (using self: *UPNP, m_if: String) {
}
UPNP_get_discover_multicast_if :: (using self: *UPNP) -> String {
}
UPNP_set_discover_local_port :: (using self: *UPNP, port: int) {
}
UPNP_get_discover_local_port :: (using self: *UPNP) -> int {
}
UPNP_set_discover_ipv6 :: (using self: *UPNP, ipv6: bool) {
}
UPNP_is_discover_ipv6 :: (using self: *UPNP) -> bool {
}

// UPNPDevice
UPNPDevice :: struct {
	__private: *void;

	IGDStatus :: enum {
		IGD_STATUS_OK :: 0;
		IGD_STATUS_HTTP_ERROR :: 1;
		IGD_STATUS_HTTP_EMPTY :: 2;
		IGD_STATUS_NO_URLS :: 3;
		IGD_STATUS_NO_IGD :: 4;
		IGD_STATUS_DISCONNECTED :: 5;
		IGD_STATUS_UNKNOWN_DEVICE :: 6;
		IGD_STATUS_INVALID_CONTROL :: 7;
		IGD_STATUS_MALLOC_ERROR :: 8;
		IGD_STATUS_UNKNOWN_ERROR :: 9;
	}
}

UPNPDevice_is_valid_gateway :: (using self: *UPNPDevice) -> bool {
}
UPNPDevice_query_external_address :: (using self: *UPNPDevice) -> String {
}
UPNPDevice_add_port_mapping :: (using self: *UPNPDevice, port: int, port_internal: int, desc: String, proto: String, duration: int) -> int {
}
UPNPDevice_delete_port_mapping :: (using self: *UPNPDevice, port: int, proto: String) -> int {
}
UPNPDevice_set_description_url :: (using self: *UPNPDevice, url: String) {
}
UPNPDevice_get_description_url :: (using self: *UPNPDevice) -> String {
}
UPNPDevice_set_service_type :: (using self: *UPNPDevice, type: String) {
}
UPNPDevice_get_service_type :: (using self: *UPNPDevice) -> String {
}
UPNPDevice_set_igd_control_url :: (using self: *UPNPDevice, url: String) {
}
UPNPDevice_get_igd_control_url :: (using self: *UPNPDevice) -> String {
}
UPNPDevice_set_igd_service_type :: (using self: *UPNPDevice, type: String) {
}
UPNPDevice_get_igd_service_type :: (using self: *UPNPDevice) -> String {
}
UPNPDevice_set_igd_our_addr :: (using self: *UPNPDevice, addr: String) {
}
UPNPDevice_get_igd_our_addr :: (using self: *UPNPDevice) -> String {
}
UPNPDevice_set_igd_status :: (using self: *UPNPDevice, status: UPNPDevice.IGDStatus) {
}
UPNPDevice_get_igd_status :: (using self: *UPNPDevice) -> UPNPDevice.IGDStatus {
}

// UndoRedo
UndoRedo :: struct {
	__private: *void;

	MergeMode :: enum {
		MERGE_DISABLE :: 0;
		MERGE_ENDS :: 1;
		MERGE_ALL :: 2;
	}
}

UndoRedo_create_action :: (using self: *UndoRedo, name: String, merge_mode: UndoRedo.MergeMode, backward_undo_ops: bool) {
}
UndoRedo_commit_action :: (using self: *UndoRedo, execute: bool) {
}
UndoRedo_is_committing_action :: (using self: *UndoRedo) -> bool {
}
UndoRedo_add_do_method :: (using self: *UndoRedo, callable: Callable) {
}
UndoRedo_add_undo_method :: (using self: *UndoRedo, callable: Callable) {
}
UndoRedo_add_do_property :: (using self: *UndoRedo, object: Object, property: StringName, value: Variant) {
}
UndoRedo_add_undo_property :: (using self: *UndoRedo, object: Object, property: StringName, value: Variant) {
}
UndoRedo_add_do_reference :: (using self: *UndoRedo, object: Object) {
}
UndoRedo_add_undo_reference :: (using self: *UndoRedo, object: Object) {
}
UndoRedo_start_force_keep_in_merge_ends :: (using self: *UndoRedo) {
}
UndoRedo_end_force_keep_in_merge_ends :: (using self: *UndoRedo) {
}
UndoRedo_get_history_count :: (using self: *UndoRedo) -> int {
}
UndoRedo_get_current_action :: (using self: *UndoRedo) -> int {
}
UndoRedo_get_action_name :: (using self: *UndoRedo, id: int) -> String {
}
UndoRedo_clear_history :: (using self: *UndoRedo, increase_version: bool) {
}
UndoRedo_get_current_action_name :: (using self: *UndoRedo) -> String {
}
UndoRedo_has_undo :: (using self: *UndoRedo) -> bool {
}
UndoRedo_has_redo :: (using self: *UndoRedo) -> bool {
}
UndoRedo_get_version :: (using self: *UndoRedo) -> int {
}
UndoRedo_set_max_steps :: (using self: *UndoRedo, max_steps: int) {
}
UndoRedo_get_max_steps :: (using self: *UndoRedo) -> int {
}
UndoRedo_redo :: (using self: *UndoRedo) -> bool {
}
UndoRedo_undo :: (using self: *UndoRedo) -> bool {
}

// UniformSetCacheRD
UniformSetCacheRD :: struct {
	__private: *void;
}

UniformSetCacheRD_get_cache :: (using self: *UniformSetCacheRD, shader: RID, set: int, uniforms: Array) -> RID {
}

// VBoxContainer
VBoxContainer :: struct {
	__private: *void;
}

// VFlowContainer
VFlowContainer :: struct {
	__private: *void;
}

// VScrollBar
VScrollBar :: struct {
	__private: *void;
}

// VSeparator
VSeparator :: struct {
	__private: *void;
}

// VSlider
VSlider :: struct {
	__private: *void;
}

// VSplitContainer
VSplitContainer :: struct {
	__private: *void;
}

// VehicleBody3D
VehicleBody3D :: struct {
	__private: *void;
}

VehicleBody3D_set_engine_force :: (using self: *VehicleBody3D, engine_force: float) {
}
VehicleBody3D_get_engine_force :: (using self: *VehicleBody3D) -> float {
}
VehicleBody3D_set_brake :: (using self: *VehicleBody3D, brake: float) {
}
VehicleBody3D_get_brake :: (using self: *VehicleBody3D) -> float {
}
VehicleBody3D_set_steering :: (using self: *VehicleBody3D, steering: float) {
}
VehicleBody3D_get_steering :: (using self: *VehicleBody3D) -> float {
}

// VehicleWheel3D
VehicleWheel3D :: struct {
	__private: *void;
}

VehicleWheel3D_set_radius :: (using self: *VehicleWheel3D, length: float) {
}
VehicleWheel3D_get_radius :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_set_suspension_rest_length :: (using self: *VehicleWheel3D, length: float) {
}
VehicleWheel3D_get_suspension_rest_length :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_set_suspension_travel :: (using self: *VehicleWheel3D, length: float) {
}
VehicleWheel3D_get_suspension_travel :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_set_suspension_stiffness :: (using self: *VehicleWheel3D, length: float) {
}
VehicleWheel3D_get_suspension_stiffness :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_set_suspension_max_force :: (using self: *VehicleWheel3D, length: float) {
}
VehicleWheel3D_get_suspension_max_force :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_set_damping_compression :: (using self: *VehicleWheel3D, length: float) {
}
VehicleWheel3D_get_damping_compression :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_set_damping_relaxation :: (using self: *VehicleWheel3D, length: float) {
}
VehicleWheel3D_get_damping_relaxation :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_set_use_as_traction :: (using self: *VehicleWheel3D, enable: bool) {
}
VehicleWheel3D_is_used_as_traction :: (using self: *VehicleWheel3D) -> bool {
}
VehicleWheel3D_set_use_as_steering :: (using self: *VehicleWheel3D, enable: bool) {
}
VehicleWheel3D_is_used_as_steering :: (using self: *VehicleWheel3D) -> bool {
}
VehicleWheel3D_set_friction_slip :: (using self: *VehicleWheel3D, length: float) {
}
VehicleWheel3D_get_friction_slip :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_is_in_contact :: (using self: *VehicleWheel3D) -> bool {
}
VehicleWheel3D_get_contact_body :: (using self: *VehicleWheel3D) -> Node3D {
}
VehicleWheel3D_set_roll_influence :: (using self: *VehicleWheel3D, roll_influence: float) {
}
VehicleWheel3D_get_roll_influence :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_get_skidinfo :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_get_rpm :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_set_engine_force :: (using self: *VehicleWheel3D, engine_force: float) {
}
VehicleWheel3D_get_engine_force :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_set_brake :: (using self: *VehicleWheel3D, brake: float) {
}
VehicleWheel3D_get_brake :: (using self: *VehicleWheel3D) -> float {
}
VehicleWheel3D_set_steering :: (using self: *VehicleWheel3D, steering: float) {
}
VehicleWheel3D_get_steering :: (using self: *VehicleWheel3D) -> float {
}

// VideoStream
VideoStream :: struct {
	__private: *void;
}

VideoStream__instantiate_playback :: (using self: *VideoStream) -> VideoStreamPlayback {
}
VideoStream_set_file :: (using self: *VideoStream, file: String) {
}
VideoStream_get_file :: (using self: *VideoStream) -> String {
}

// VideoStreamPlayback
VideoStreamPlayback :: struct {
	__private: *void;
}

VideoStreamPlayback__stop :: (using self: *VideoStreamPlayback) {
}
VideoStreamPlayback__play :: (using self: *VideoStreamPlayback) {
}
VideoStreamPlayback__is_playing :: (using self: *VideoStreamPlayback) -> bool {
}
VideoStreamPlayback__set_paused :: (using self: *VideoStreamPlayback, paused: bool) {
}
VideoStreamPlayback__is_paused :: (using self: *VideoStreamPlayback) -> bool {
}
VideoStreamPlayback__get_length :: (using self: *VideoStreamPlayback) -> float {
}
VideoStreamPlayback__get_playback_position :: (using self: *VideoStreamPlayback) -> float {
}
VideoStreamPlayback__seek :: (using self: *VideoStreamPlayback, time: float) {
}
VideoStreamPlayback__set_audio_track :: (using self: *VideoStreamPlayback, idx: int) {
}
VideoStreamPlayback__get_texture :: (using self: *VideoStreamPlayback) -> Texture2D {
}
VideoStreamPlayback__update :: (using self: *VideoStreamPlayback, delta: float) {
}
VideoStreamPlayback__get_channels :: (using self: *VideoStreamPlayback) -> int {
}
VideoStreamPlayback__get_mix_rate :: (using self: *VideoStreamPlayback) -> int {
}
VideoStreamPlayback_mix_audio :: (using self: *VideoStreamPlayback, num_frames: int, buffer: PackedFloat32Array, offset: int) -> int {
}

// VideoStreamPlayer
VideoStreamPlayer :: struct {
	__private: *void;
}

VideoStreamPlayer_set_stream :: (using self: *VideoStreamPlayer, stream: VideoStream) {
}
VideoStreamPlayer_get_stream :: (using self: *VideoStreamPlayer) -> VideoStream {
}
VideoStreamPlayer_play :: (using self: *VideoStreamPlayer) {
}
VideoStreamPlayer_stop :: (using self: *VideoStreamPlayer) {
}
VideoStreamPlayer_is_playing :: (using self: *VideoStreamPlayer) -> bool {
}
VideoStreamPlayer_set_paused :: (using self: *VideoStreamPlayer, paused: bool) {
}
VideoStreamPlayer_is_paused :: (using self: *VideoStreamPlayer) -> bool {
}
VideoStreamPlayer_set_loop :: (using self: *VideoStreamPlayer, loop: bool) {
}
VideoStreamPlayer_has_loop :: (using self: *VideoStreamPlayer) -> bool {
}
VideoStreamPlayer_set_volume :: (using self: *VideoStreamPlayer, volume: float) {
}
VideoStreamPlayer_get_volume :: (using self: *VideoStreamPlayer) -> float {
}
VideoStreamPlayer_set_volume_db :: (using self: *VideoStreamPlayer, db: float) {
}
VideoStreamPlayer_get_volume_db :: (using self: *VideoStreamPlayer) -> float {
}
VideoStreamPlayer_set_audio_track :: (using self: *VideoStreamPlayer, track: int) {
}
VideoStreamPlayer_get_audio_track :: (using self: *VideoStreamPlayer) -> int {
}
VideoStreamPlayer_get_stream_name :: (using self: *VideoStreamPlayer) -> String {
}
VideoStreamPlayer_get_stream_length :: (using self: *VideoStreamPlayer) -> float {
}
VideoStreamPlayer_set_stream_position :: (using self: *VideoStreamPlayer, position: float) {
}
VideoStreamPlayer_get_stream_position :: (using self: *VideoStreamPlayer) -> float {
}
VideoStreamPlayer_set_autoplay :: (using self: *VideoStreamPlayer, enabled: bool) {
}
VideoStreamPlayer_has_autoplay :: (using self: *VideoStreamPlayer) -> bool {
}
VideoStreamPlayer_set_expand :: (using self: *VideoStreamPlayer, enable: bool) {
}
VideoStreamPlayer_has_expand :: (using self: *VideoStreamPlayer) -> bool {
}
VideoStreamPlayer_set_buffering_msec :: (using self: *VideoStreamPlayer, msec: int) {
}
VideoStreamPlayer_get_buffering_msec :: (using self: *VideoStreamPlayer) -> int {
}
VideoStreamPlayer_set_bus :: (using self: *VideoStreamPlayer, bus: StringName) {
}
VideoStreamPlayer_get_bus :: (using self: *VideoStreamPlayer) -> StringName {
}
VideoStreamPlayer_get_video_texture :: (using self: *VideoStreamPlayer) -> Texture2D {
}

// VideoStreamTheora
VideoStreamTheora :: struct {
	__private: *void;
}

// Viewport
Viewport :: struct {
	__private: *void;

	PositionalShadowAtlasQuadrantSubdiv :: enum {
		SHADOW_ATLAS_QUADRANT_SUBDIV_DISABLED :: 0;
		SHADOW_ATLAS_QUADRANT_SUBDIV_1 :: 1;
		SHADOW_ATLAS_QUADRANT_SUBDIV_4 :: 2;
		SHADOW_ATLAS_QUADRANT_SUBDIV_16 :: 3;
		SHADOW_ATLAS_QUADRANT_SUBDIV_64 :: 4;
		SHADOW_ATLAS_QUADRANT_SUBDIV_256 :: 5;
		SHADOW_ATLAS_QUADRANT_SUBDIV_1024 :: 6;
		SHADOW_ATLAS_QUADRANT_SUBDIV_MAX :: 7;
	}
	Scaling3DMode :: enum {
		SCALING_3D_MODE_BILINEAR :: 0;
		SCALING_3D_MODE_FSR :: 1;
		SCALING_3D_MODE_FSR2 :: 2;
		SCALING_3D_MODE_MAX :: 3;
	}
	MSAA :: enum {
		MSAA_DISABLED :: 0;
		MSAA_2X :: 1;
		MSAA_4X :: 2;
		MSAA_8X :: 3;
		MSAA_MAX :: 4;
	}
	ScreenSpaceAA :: enum {
		SCREEN_SPACE_AA_DISABLED :: 0;
		SCREEN_SPACE_AA_FXAA :: 1;
		SCREEN_SPACE_AA_MAX :: 2;
	}
	RenderInfo :: enum {
		RENDER_INFO_OBJECTS_IN_FRAME :: 0;
		RENDER_INFO_PRIMITIVES_IN_FRAME :: 1;
		RENDER_INFO_DRAW_CALLS_IN_FRAME :: 2;
		RENDER_INFO_MAX :: 3;
	}
	RenderInfoType :: enum {
		RENDER_INFO_TYPE_VISIBLE :: 0;
		RENDER_INFO_TYPE_SHADOW :: 1;
		RENDER_INFO_TYPE_CANVAS :: 2;
		RENDER_INFO_TYPE_MAX :: 3;
	}
	DebugDraw :: enum {
		DEBUG_DRAW_DISABLED :: 0;
		DEBUG_DRAW_UNSHADED :: 1;
		DEBUG_DRAW_LIGHTING :: 2;
		DEBUG_DRAW_OVERDRAW :: 3;
		DEBUG_DRAW_WIREFRAME :: 4;
		DEBUG_DRAW_NORMAL_BUFFER :: 5;
		DEBUG_DRAW_VOXEL_GI_ALBEDO :: 6;
		DEBUG_DRAW_VOXEL_GI_LIGHTING :: 7;
		DEBUG_DRAW_VOXEL_GI_EMISSION :: 8;
		DEBUG_DRAW_SHADOW_ATLAS :: 9;
		DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS :: 10;
		DEBUG_DRAW_SCENE_LUMINANCE :: 11;
		DEBUG_DRAW_SSAO :: 12;
		DEBUG_DRAW_SSIL :: 13;
		DEBUG_DRAW_PSSM_SPLITS :: 14;
		DEBUG_DRAW_DECAL_ATLAS :: 15;
		DEBUG_DRAW_SDFGI :: 16;
		DEBUG_DRAW_SDFGI_PROBES :: 17;
		DEBUG_DRAW_GI_BUFFER :: 18;
		DEBUG_DRAW_DISABLE_LOD :: 19;
		DEBUG_DRAW_CLUSTER_OMNI_LIGHTS :: 20;
		DEBUG_DRAW_CLUSTER_SPOT_LIGHTS :: 21;
		DEBUG_DRAW_CLUSTER_DECALS :: 22;
		DEBUG_DRAW_CLUSTER_REFLECTION_PROBES :: 23;
		DEBUG_DRAW_OCCLUDERS :: 24;
		DEBUG_DRAW_MOTION_VECTORS :: 25;
		DEBUG_DRAW_INTERNAL_BUFFER :: 26;
	}
	DefaultCanvasItemTextureFilter :: enum {
		DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_NEAREST :: 0;
		DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_LINEAR :: 1;
		DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS :: 2;
		DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS :: 3;
		DEFAULT_CANVAS_ITEM_TEXTURE_FILTER_MAX :: 4;
	}
	DefaultCanvasItemTextureRepeat :: enum {
		DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_DISABLED :: 0;
		DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_ENABLED :: 1;
		DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_MIRROR :: 2;
		DEFAULT_CANVAS_ITEM_TEXTURE_REPEAT_MAX :: 3;
	}
	SDFOversize :: enum {
		SDF_OVERSIZE_100_PERCENT :: 0;
		SDF_OVERSIZE_120_PERCENT :: 1;
		SDF_OVERSIZE_150_PERCENT :: 2;
		SDF_OVERSIZE_200_PERCENT :: 3;
		SDF_OVERSIZE_MAX :: 4;
	}
	SDFScale :: enum {
		SDF_SCALE_100_PERCENT :: 0;
		SDF_SCALE_50_PERCENT :: 1;
		SDF_SCALE_25_PERCENT :: 2;
		SDF_SCALE_MAX :: 3;
	}
	VRSMode :: enum {
		VRS_DISABLED :: 0;
		VRS_TEXTURE :: 1;
		VRS_XR :: 2;
		VRS_MAX :: 3;
	}
	VRSUpdateMode :: enum {
		VRS_UPDATE_DISABLED :: 0;
		VRS_UPDATE_ONCE :: 1;
		VRS_UPDATE_ALWAYS :: 2;
		VRS_UPDATE_MAX :: 3;
	}
}

Viewport_set_world_2d :: (using self: *Viewport, world_2d: World2D) {
}
Viewport_get_world_2d :: (using self: *Viewport) -> World2D {
}
Viewport_find_world_2d :: (using self: *Viewport) -> World2D {
}
Viewport_set_canvas_transform :: (using self: *Viewport, xform: Transform2D) {
}
Viewport_get_canvas_transform :: (using self: *Viewport) -> Transform2D {
}
Viewport_set_global_canvas_transform :: (using self: *Viewport, xform: Transform2D) {
}
Viewport_get_global_canvas_transform :: (using self: *Viewport) -> Transform2D {
}
Viewport_get_final_transform :: (using self: *Viewport) -> Transform2D {
}
Viewport_get_screen_transform :: (using self: *Viewport) -> Transform2D {
}
Viewport_get_visible_rect :: (using self: *Viewport) -> Rect2 {
}
Viewport_set_transparent_background :: (using self: *Viewport, enable: bool) {
}
Viewport_has_transparent_background :: (using self: *Viewport) -> bool {
}
Viewport_set_use_hdr_2d :: (using self: *Viewport, enable: bool) {
}
Viewport_is_using_hdr_2d :: (using self: *Viewport) -> bool {
}
Viewport_set_msaa_2d :: (using self: *Viewport, msaa: Viewport.MSAA) {
}
Viewport_get_msaa_2d :: (using self: *Viewport) -> Viewport.MSAA {
}
Viewport_set_msaa_3d :: (using self: *Viewport, msaa: Viewport.MSAA) {
}
Viewport_get_msaa_3d :: (using self: *Viewport) -> Viewport.MSAA {
}
Viewport_set_screen_space_aa :: (using self: *Viewport, screen_space_aa: Viewport.ScreenSpaceAA) {
}
Viewport_get_screen_space_aa :: (using self: *Viewport) -> Viewport.ScreenSpaceAA {
}
Viewport_set_use_taa :: (using self: *Viewport, enable: bool) {
}
Viewport_is_using_taa :: (using self: *Viewport) -> bool {
}
Viewport_set_use_debanding :: (using self: *Viewport, enable: bool) {
}
Viewport_is_using_debanding :: (using self: *Viewport) -> bool {
}
Viewport_set_use_occlusion_culling :: (using self: *Viewport, enable: bool) {
}
Viewport_is_using_occlusion_culling :: (using self: *Viewport) -> bool {
}
Viewport_set_debug_draw :: (using self: *Viewport, debug_draw: Viewport.DebugDraw) {
}
Viewport_get_debug_draw :: (using self: *Viewport) -> Viewport.DebugDraw {
}
Viewport_get_render_info :: (using self: *Viewport, type: Viewport.RenderInfoType, info: Viewport.RenderInfo) -> int {
}
Viewport_get_texture :: (using self: *Viewport) -> ViewportTexture {
}
Viewport_set_physics_object_picking :: (using self: *Viewport, enable: bool) {
}
Viewport_get_physics_object_picking :: (using self: *Viewport) -> bool {
}
Viewport_set_physics_object_picking_sort :: (using self: *Viewport, enable: bool) {
}
Viewport_get_physics_object_picking_sort :: (using self: *Viewport) -> bool {
}
Viewport_set_physics_object_picking_first_only :: (using self: *Viewport, enable: bool) {
}
Viewport_get_physics_object_picking_first_only :: (using self: *Viewport) -> bool {
}
Viewport_get_viewport_rid :: (using self: *Viewport) -> RID {
}
Viewport_push_text_input :: (using self: *Viewport, text: String) {
}
Viewport_push_input :: (using self: *Viewport, event: InputEvent, in_local_coords: bool) {
}
Viewport_push_unhandled_input :: (using self: *Viewport, event: InputEvent, in_local_coords: bool) {
}
Viewport_get_mouse_position :: (using self: *Viewport) -> Vector2 {
}
Viewport_warp_mouse :: (using self: *Viewport, position: Vector2) {
}
Viewport_update_mouse_cursor_state :: (using self: *Viewport) {
}
Viewport_gui_get_drag_data :: (using self: *Viewport) -> Variant {
}
Viewport_gui_is_dragging :: (using self: *Viewport) -> bool {
}
Viewport_gui_is_drag_successful :: (using self: *Viewport) -> bool {
}
Viewport_gui_release_focus :: (using self: *Viewport) {
}
Viewport_gui_get_focus_owner :: (using self: *Viewport) -> Control {
}
Viewport_gui_get_hovered_control :: (using self: *Viewport) -> Control {
}
Viewport_set_disable_input :: (using self: *Viewport, disable: bool) {
}
Viewport_is_input_disabled :: (using self: *Viewport) -> bool {
}
Viewport_set_positional_shadow_atlas_size :: (using self: *Viewport, size: int) {
}
Viewport_get_positional_shadow_atlas_size :: (using self: *Viewport) -> int {
}
Viewport_set_positional_shadow_atlas_16_bits :: (using self: *Viewport, enable: bool) {
}
Viewport_get_positional_shadow_atlas_16_bits :: (using self: *Viewport) -> bool {
}
Viewport_set_snap_controls_to_pixels :: (using self: *Viewport, enabled: bool) {
}
Viewport_is_snap_controls_to_pixels_enabled :: (using self: *Viewport) -> bool {
}
Viewport_set_snap_2d_transforms_to_pixel :: (using self: *Viewport, enabled: bool) {
}
Viewport_is_snap_2d_transforms_to_pixel_enabled :: (using self: *Viewport) -> bool {
}
Viewport_set_snap_2d_vertices_to_pixel :: (using self: *Viewport, enabled: bool) {
}
Viewport_is_snap_2d_vertices_to_pixel_enabled :: (using self: *Viewport) -> bool {
}
Viewport_set_positional_shadow_atlas_quadrant_subdiv :: (using self: *Viewport, quadrant: int, subdiv: Viewport.PositionalShadowAtlasQuadrantSubdiv) {
}
Viewport_get_positional_shadow_atlas_quadrant_subdiv :: (using self: *Viewport, quadrant: int) -> Viewport.PositionalShadowAtlasQuadrantSubdiv {
}
Viewport_set_input_as_handled :: (using self: *Viewport) {
}
Viewport_is_input_handled :: (using self: *Viewport) -> bool {
}
Viewport_set_handle_input_locally :: (using self: *Viewport, enable: bool) {
}
Viewport_is_handling_input_locally :: (using self: *Viewport) -> bool {
}
Viewport_set_default_canvas_item_texture_filter :: (using self: *Viewport, mode: Viewport.DefaultCanvasItemTextureFilter) {
}
Viewport_get_default_canvas_item_texture_filter :: (using self: *Viewport) -> Viewport.DefaultCanvasItemTextureFilter {
}
Viewport_set_embedding_subwindows :: (using self: *Viewport, enable: bool) {
}
Viewport_is_embedding_subwindows :: (using self: *Viewport) -> bool {
}
Viewport_get_embedded_subwindows :: (using self: *Viewport) -> Array {
}
Viewport_set_canvas_cull_mask :: (using self: *Viewport, mask: int) {
}
Viewport_get_canvas_cull_mask :: (using self: *Viewport) -> int {
}
Viewport_set_canvas_cull_mask_bit :: (using self: *Viewport, layer: int, enable: bool) {
}
Viewport_get_canvas_cull_mask_bit :: (using self: *Viewport, layer: int) -> bool {
}
Viewport_set_default_canvas_item_texture_repeat :: (using self: *Viewport, mode: Viewport.DefaultCanvasItemTextureRepeat) {
}
Viewport_get_default_canvas_item_texture_repeat :: (using self: *Viewport) -> Viewport.DefaultCanvasItemTextureRepeat {
}
Viewport_set_sdf_oversize :: (using self: *Viewport, oversize: Viewport.SDFOversize) {
}
Viewport_get_sdf_oversize :: (using self: *Viewport) -> Viewport.SDFOversize {
}
Viewport_set_sdf_scale :: (using self: *Viewport, scale: Viewport.SDFScale) {
}
Viewport_get_sdf_scale :: (using self: *Viewport) -> Viewport.SDFScale {
}
Viewport_set_mesh_lod_threshold :: (using self: *Viewport, pixels: float) {
}
Viewport_get_mesh_lod_threshold :: (using self: *Viewport) -> float {
}
Viewport_set_as_audio_listener_2d :: (using self: *Viewport, enable: bool) {
}
Viewport_is_audio_listener_2d :: (using self: *Viewport) -> bool {
}
Viewport_get_camera_2d :: (using self: *Viewport) -> Camera2D {
}
Viewport_set_world_3d :: (using self: *Viewport, world_3d: World3D) {
}
Viewport_get_world_3d :: (using self: *Viewport) -> World3D {
}
Viewport_find_world_3d :: (using self: *Viewport) -> World3D {
}
Viewport_set_use_own_world_3d :: (using self: *Viewport, enable: bool) {
}
Viewport_is_using_own_world_3d :: (using self: *Viewport) -> bool {
}
Viewport_get_camera_3d :: (using self: *Viewport) -> Camera3D {
}
Viewport_set_as_audio_listener_3d :: (using self: *Viewport, enable: bool) {
}
Viewport_is_audio_listener_3d :: (using self: *Viewport) -> bool {
}
Viewport_set_disable_3d :: (using self: *Viewport, disable: bool) {
}
Viewport_is_3d_disabled :: (using self: *Viewport) -> bool {
}
Viewport_set_use_xr :: (using self: *Viewport, use: bool) {
}
Viewport_is_using_xr :: (using self: *Viewport) -> bool {
}
Viewport_set_scaling_3d_mode :: (using self: *Viewport, scaling_3d_mode: Viewport.Scaling3DMode) {
}
Viewport_get_scaling_3d_mode :: (using self: *Viewport) -> Viewport.Scaling3DMode {
}
Viewport_set_scaling_3d_scale :: (using self: *Viewport, scale: float) {
}
Viewport_get_scaling_3d_scale :: (using self: *Viewport) -> float {
}
Viewport_set_fsr_sharpness :: (using self: *Viewport, fsr_sharpness: float) {
}
Viewport_get_fsr_sharpness :: (using self: *Viewport) -> float {
}
Viewport_set_texture_mipmap_bias :: (using self: *Viewport, texture_mipmap_bias: float) {
}
Viewport_get_texture_mipmap_bias :: (using self: *Viewport) -> float {
}
Viewport_set_vrs_mode :: (using self: *Viewport, mode: Viewport.VRSMode) {
}
Viewport_get_vrs_mode :: (using self: *Viewport) -> Viewport.VRSMode {
}
Viewport_set_vrs_update_mode :: (using self: *Viewport, mode: Viewport.VRSUpdateMode) {
}
Viewport_get_vrs_update_mode :: (using self: *Viewport) -> Viewport.VRSUpdateMode {
}
Viewport_set_vrs_texture :: (using self: *Viewport, texture: Texture2D) {
}
Viewport_get_vrs_texture :: (using self: *Viewport) -> Texture2D {
}

// ViewportTexture
ViewportTexture :: struct {
	__private: *void;
}

ViewportTexture_set_viewport_path_in_scene :: (using self: *ViewportTexture, path: NodePath) {
}
ViewportTexture_get_viewport_path_in_scene :: (using self: *ViewportTexture) -> NodePath {
}

// VisibleOnScreenEnabler2D
VisibleOnScreenEnabler2D :: struct {
	__private: *void;

	EnableMode :: enum {
		ENABLE_MODE_INHERIT :: 0;
		ENABLE_MODE_ALWAYS :: 1;
		ENABLE_MODE_WHEN_PAUSED :: 2;
	}
}

VisibleOnScreenEnabler2D_set_enable_mode :: (using self: *VisibleOnScreenEnabler2D, mode: VisibleOnScreenEnabler2D.EnableMode) {
}
VisibleOnScreenEnabler2D_get_enable_mode :: (using self: *VisibleOnScreenEnabler2D) -> VisibleOnScreenEnabler2D.EnableMode {
}
VisibleOnScreenEnabler2D_set_enable_node_path :: (using self: *VisibleOnScreenEnabler2D, path: NodePath) {
}
VisibleOnScreenEnabler2D_get_enable_node_path :: (using self: *VisibleOnScreenEnabler2D) -> NodePath {
}

// VisibleOnScreenEnabler3D
VisibleOnScreenEnabler3D :: struct {
	__private: *void;

	EnableMode :: enum {
		ENABLE_MODE_INHERIT :: 0;
		ENABLE_MODE_ALWAYS :: 1;
		ENABLE_MODE_WHEN_PAUSED :: 2;
	}
}

VisibleOnScreenEnabler3D_set_enable_mode :: (using self: *VisibleOnScreenEnabler3D, mode: VisibleOnScreenEnabler3D.EnableMode) {
}
VisibleOnScreenEnabler3D_get_enable_mode :: (using self: *VisibleOnScreenEnabler3D) -> VisibleOnScreenEnabler3D.EnableMode {
}
VisibleOnScreenEnabler3D_set_enable_node_path :: (using self: *VisibleOnScreenEnabler3D, path: NodePath) {
}
VisibleOnScreenEnabler3D_get_enable_node_path :: (using self: *VisibleOnScreenEnabler3D) -> NodePath {
}

// VisibleOnScreenNotifier2D
VisibleOnScreenNotifier2D :: struct {
	__private: *void;
}

VisibleOnScreenNotifier2D_set_rect :: (using self: *VisibleOnScreenNotifier2D, rect: Rect2) {
}
VisibleOnScreenNotifier2D_get_rect :: (using self: *VisibleOnScreenNotifier2D) -> Rect2 {
}
VisibleOnScreenNotifier2D_is_on_screen :: (using self: *VisibleOnScreenNotifier2D) -> bool {
}

// VisibleOnScreenNotifier3D
VisibleOnScreenNotifier3D :: struct {
	__private: *void;
}

VisibleOnScreenNotifier3D_set_aabb :: (using self: *VisibleOnScreenNotifier3D, rect: AABB) {
}
VisibleOnScreenNotifier3D_is_on_screen :: (using self: *VisibleOnScreenNotifier3D) -> bool {
}

// VisualInstance3D
VisualInstance3D :: struct {
	__private: *void;
}

VisualInstance3D__get_aabb :: (using self: *VisualInstance3D) -> AABB {
}
VisualInstance3D_set_base :: (using self: *VisualInstance3D, base: RID) {
}
VisualInstance3D_get_base :: (using self: *VisualInstance3D) -> RID {
}
VisualInstance3D_get_instance :: (using self: *VisualInstance3D) -> RID {
}
VisualInstance3D_set_layer_mask :: (using self: *VisualInstance3D, mask: int) {
}
VisualInstance3D_get_layer_mask :: (using self: *VisualInstance3D) -> int {
}
VisualInstance3D_set_layer_mask_value :: (using self: *VisualInstance3D, layer_number: int, value: bool) {
}
VisualInstance3D_get_layer_mask_value :: (using self: *VisualInstance3D, layer_number: int) -> bool {
}
VisualInstance3D_set_sorting_offset :: (using self: *VisualInstance3D, offset: float) {
}
VisualInstance3D_get_sorting_offset :: (using self: *VisualInstance3D) -> float {
}
VisualInstance3D_set_sorting_use_aabb_center :: (using self: *VisualInstance3D, enabled: bool) {
}
VisualInstance3D_is_sorting_use_aabb_center :: (using self: *VisualInstance3D) -> bool {
}
VisualInstance3D_get_aabb :: (using self: *VisualInstance3D) -> AABB {
}

// VisualShader
VisualShader :: struct {
	__private: *void;

	NODE_ID_INVALID :: -1;
	NODE_ID_OUTPUT :: 0;

	Type :: enum {
		TYPE_VERTEX :: 0;
		TYPE_FRAGMENT :: 1;
		TYPE_LIGHT :: 2;
		TYPE_START :: 3;
		TYPE_PROCESS :: 4;
		TYPE_COLLIDE :: 5;
		TYPE_START_CUSTOM :: 6;
		TYPE_PROCESS_CUSTOM :: 7;
		TYPE_SKY :: 8;
		TYPE_FOG :: 9;
		TYPE_MAX :: 10;
	}
	VaryingMode :: enum {
		VARYING_MODE_VERTEX_TO_FRAG_LIGHT :: 0;
		VARYING_MODE_FRAG_TO_LIGHT :: 1;
		VARYING_MODE_MAX :: 2;
	}
	VaryingType :: enum {
		VARYING_TYPE_FLOAT :: 0;
		VARYING_TYPE_INT :: 1;
		VARYING_TYPE_UINT :: 2;
		VARYING_TYPE_VECTOR_2D :: 3;
		VARYING_TYPE_VECTOR_3D :: 4;
		VARYING_TYPE_VECTOR_4D :: 5;
		VARYING_TYPE_BOOLEAN :: 6;
		VARYING_TYPE_TRANSFORM :: 7;
		VARYING_TYPE_MAX :: 8;
	}
}

VisualShader_set_mode :: (using self: *VisualShader, mode: Shader.Mode) {
}
VisualShader_add_node :: (using self: *VisualShader, type: VisualShader.Type, node: VisualShaderNode, position: Vector2, id: int) {
}
VisualShader_get_node :: (using self: *VisualShader, type: VisualShader.Type, id: int) -> VisualShaderNode {
}
VisualShader_set_node_position :: (using self: *VisualShader, type: VisualShader.Type, id: int, position: Vector2) {
}
VisualShader_get_node_position :: (using self: *VisualShader, type: VisualShader.Type, id: int) -> Vector2 {
}
VisualShader_get_node_list :: (using self: *VisualShader, type: VisualShader.Type) -> PackedInt32Array {
}
VisualShader_get_valid_node_id :: (using self: *VisualShader, type: VisualShader.Type) -> int {
}
VisualShader_remove_node :: (using self: *VisualShader, type: VisualShader.Type, id: int) {
}
VisualShader_replace_node :: (using self: *VisualShader, type: VisualShader.Type, id: int, new_class: StringName) {
}
VisualShader_is_node_connection :: (using self: *VisualShader, type: VisualShader.Type, from_node: int, from_port: int, to_node: int, to_port: int) -> bool {
}
VisualShader_can_connect_nodes :: (using self: *VisualShader, type: VisualShader.Type, from_node: int, from_port: int, to_node: int, to_port: int) -> bool {
}
VisualShader_connect_nodes :: (using self: *VisualShader, type: VisualShader.Type, from_node: int, from_port: int, to_node: int, to_port: int) -> Error {
}
VisualShader_disconnect_nodes :: (using self: *VisualShader, type: VisualShader.Type, from_node: int, from_port: int, to_node: int, to_port: int) {
}
VisualShader_connect_nodes_forced :: (using self: *VisualShader, type: VisualShader.Type, from_node: int, from_port: int, to_node: int, to_port: int) {
}
VisualShader_get_node_connections :: (using self: *VisualShader, type: VisualShader.Type) -> Dictionary {
}
VisualShader_set_graph_offset :: (using self: *VisualShader, offset: Vector2) {
}
VisualShader_get_graph_offset :: (using self: *VisualShader) -> Vector2 {
}
VisualShader_attach_node_to_frame :: (using self: *VisualShader, type: VisualShader.Type, id: int, frame: int) {
}
VisualShader_detach_node_from_frame :: (using self: *VisualShader, type: VisualShader.Type, id: int) {
}
VisualShader_add_varying :: (using self: *VisualShader, name: String, mode: VisualShader.VaryingMode, type: VisualShader.VaryingType) {
}
VisualShader_remove_varying :: (using self: *VisualShader, name: String) {
}
VisualShader_has_varying :: (using self: *VisualShader, name: String) -> bool {
}

// VisualShaderNode
VisualShaderNode :: struct {
	__private: *void;

	PortType :: enum {
		PORT_TYPE_SCALAR :: 0;
		PORT_TYPE_SCALAR_INT :: 1;
		PORT_TYPE_SCALAR_UINT :: 2;
		PORT_TYPE_VECTOR_2D :: 3;
		PORT_TYPE_VECTOR_3D :: 4;
		PORT_TYPE_VECTOR_4D :: 5;
		PORT_TYPE_BOOLEAN :: 6;
		PORT_TYPE_TRANSFORM :: 7;
		PORT_TYPE_SAMPLER :: 8;
		PORT_TYPE_MAX :: 9;
	}
}

VisualShaderNode_get_default_input_port :: (using self: *VisualShaderNode, type: VisualShaderNode.PortType) -> int {
}
VisualShaderNode_set_output_port_for_preview :: (using self: *VisualShaderNode, port: int) {
}
VisualShaderNode_get_output_port_for_preview :: (using self: *VisualShaderNode) -> int {
}
VisualShaderNode_set_input_port_default_value :: (using self: *VisualShaderNode, port: int, value: Variant, prev_value: Variant) {
}
VisualShaderNode_get_input_port_default_value :: (using self: *VisualShaderNode, port: int) -> Variant {
}
VisualShaderNode_remove_input_port_default_value :: (using self: *VisualShaderNode, port: int) {
}
VisualShaderNode_clear_default_input_values :: (using self: *VisualShaderNode) {
}
VisualShaderNode_set_default_input_values :: (using self: *VisualShaderNode, values: Array) {
}
VisualShaderNode_get_default_input_values :: (using self: *VisualShaderNode) -> Array {
}
VisualShaderNode_set_frame :: (using self: *VisualShaderNode, frame: int) {
}
VisualShaderNode_get_frame :: (using self: *VisualShaderNode) -> int {
}

// VisualShaderNodeBillboard
VisualShaderNodeBillboard :: struct {
	__private: *void;

	BillboardType :: enum {
		BILLBOARD_TYPE_DISABLED :: 0;
		BILLBOARD_TYPE_ENABLED :: 1;
		BILLBOARD_TYPE_FIXED_Y :: 2;
		BILLBOARD_TYPE_PARTICLES :: 3;
		BILLBOARD_TYPE_MAX :: 4;
	}
}

VisualShaderNodeBillboard_set_billboard_type :: (using self: *VisualShaderNodeBillboard, billboard_type: VisualShaderNodeBillboard.BillboardType) {
}
VisualShaderNodeBillboard_get_billboard_type :: (using self: *VisualShaderNodeBillboard) -> VisualShaderNodeBillboard.BillboardType {
}
VisualShaderNodeBillboard_set_keep_scale_enabled :: (using self: *VisualShaderNodeBillboard, enabled: bool) {
}
VisualShaderNodeBillboard_is_keep_scale_enabled :: (using self: *VisualShaderNodeBillboard) -> bool {
}

// VisualShaderNodeBooleanConstant
VisualShaderNodeBooleanConstant :: struct {
	__private: *void;
}

VisualShaderNodeBooleanConstant_set_constant :: (using self: *VisualShaderNodeBooleanConstant, constant: bool) {
}
VisualShaderNodeBooleanConstant_get_constant :: (using self: *VisualShaderNodeBooleanConstant) -> bool {
}

// VisualShaderNodeBooleanParameter
VisualShaderNodeBooleanParameter :: struct {
	__private: *void;
}

VisualShaderNodeBooleanParameter_set_default_value_enabled :: (using self: *VisualShaderNodeBooleanParameter, enabled: bool) {
}
VisualShaderNodeBooleanParameter_is_default_value_enabled :: (using self: *VisualShaderNodeBooleanParameter) -> bool {
}
VisualShaderNodeBooleanParameter_set_default_value :: (using self: *VisualShaderNodeBooleanParameter, value: bool) {
}
VisualShaderNodeBooleanParameter_get_default_value :: (using self: *VisualShaderNodeBooleanParameter) -> bool {
}

// VisualShaderNodeClamp
VisualShaderNodeClamp :: struct {
	__private: *void;

	OpType :: enum {
		OP_TYPE_FLOAT :: 0;
		OP_TYPE_INT :: 1;
		OP_TYPE_UINT :: 2;
		OP_TYPE_VECTOR_2D :: 3;
		OP_TYPE_VECTOR_3D :: 4;
		OP_TYPE_VECTOR_4D :: 5;
		OP_TYPE_MAX :: 6;
	}
}

VisualShaderNodeClamp_set_op_type :: (using self: *VisualShaderNodeClamp, op_type: VisualShaderNodeClamp.OpType) {
}
VisualShaderNodeClamp_get_op_type :: (using self: *VisualShaderNodeClamp) -> VisualShaderNodeClamp.OpType {
}

// VisualShaderNodeColorConstant
VisualShaderNodeColorConstant :: struct {
	__private: *void;
}

VisualShaderNodeColorConstant_set_constant :: (using self: *VisualShaderNodeColorConstant, constant: Color) {
}
VisualShaderNodeColorConstant_get_constant :: (using self: *VisualShaderNodeColorConstant) -> Color {
}

// VisualShaderNodeColorFunc
VisualShaderNodeColorFunc :: struct {
	__private: *void;

	Function :: enum {
		FUNC_GRAYSCALE :: 0;
		FUNC_HSV2RGB :: 1;
		FUNC_RGB2HSV :: 2;
		FUNC_SEPIA :: 3;
		FUNC_MAX :: 4;
	}
}

VisualShaderNodeColorFunc_set_function :: (using self: *VisualShaderNodeColorFunc, func: VisualShaderNodeColorFunc.Function) {
}
VisualShaderNodeColorFunc_get_function :: (using self: *VisualShaderNodeColorFunc) -> VisualShaderNodeColorFunc.Function {
}

// VisualShaderNodeColorOp
VisualShaderNodeColorOp :: struct {
	__private: *void;

	Operator :: enum {
		OP_SCREEN :: 0;
		OP_DIFFERENCE :: 1;
		OP_DARKEN :: 2;
		OP_LIGHTEN :: 3;
		OP_OVERLAY :: 4;
		OP_DODGE :: 5;
		OP_BURN :: 6;
		OP_SOFT_LIGHT :: 7;
		OP_HARD_LIGHT :: 8;
		OP_MAX :: 9;
	}
}

VisualShaderNodeColorOp_set_operator :: (using self: *VisualShaderNodeColorOp, op: VisualShaderNodeColorOp.Operator) {
}
VisualShaderNodeColorOp_get_operator :: (using self: *VisualShaderNodeColorOp) -> VisualShaderNodeColorOp.Operator {
}

// VisualShaderNodeColorParameter
VisualShaderNodeColorParameter :: struct {
	__private: *void;
}

VisualShaderNodeColorParameter_set_default_value_enabled :: (using self: *VisualShaderNodeColorParameter, enabled: bool) {
}
VisualShaderNodeColorParameter_is_default_value_enabled :: (using self: *VisualShaderNodeColorParameter) -> bool {
}
VisualShaderNodeColorParameter_set_default_value :: (using self: *VisualShaderNodeColorParameter, value: Color) {
}
VisualShaderNodeColorParameter_get_default_value :: (using self: *VisualShaderNodeColorParameter) -> Color {
}

// VisualShaderNodeComment
VisualShaderNodeComment :: struct {
	__private: *void;
}

VisualShaderNodeComment_set_description :: (using self: *VisualShaderNodeComment, description: String) {
}
VisualShaderNodeComment_get_description :: (using self: *VisualShaderNodeComment) -> String {
}

// VisualShaderNodeCompare
VisualShaderNodeCompare :: struct {
	__private: *void;

	ComparisonType :: enum {
		CTYPE_SCALAR :: 0;
		CTYPE_SCALAR_INT :: 1;
		CTYPE_SCALAR_UINT :: 2;
		CTYPE_VECTOR_2D :: 3;
		CTYPE_VECTOR_3D :: 4;
		CTYPE_VECTOR_4D :: 5;
		CTYPE_BOOLEAN :: 6;
		CTYPE_TRANSFORM :: 7;
		CTYPE_MAX :: 8;
	}
	Function :: enum {
		FUNC_EQUAL :: 0;
		FUNC_NOT_EQUAL :: 1;
		FUNC_GREATER_THAN :: 2;
		FUNC_GREATER_THAN_EQUAL :: 3;
		FUNC_LESS_THAN :: 4;
		FUNC_LESS_THAN_EQUAL :: 5;
		FUNC_MAX :: 6;
	}
	Condition :: enum {
		COND_ALL :: 0;
		COND_ANY :: 1;
		COND_MAX :: 2;
	}
}

VisualShaderNodeCompare_set_comparison_type :: (using self: *VisualShaderNodeCompare, type: VisualShaderNodeCompare.ComparisonType) {
}
VisualShaderNodeCompare_get_comparison_type :: (using self: *VisualShaderNodeCompare) -> VisualShaderNodeCompare.ComparisonType {
}
VisualShaderNodeCompare_set_function :: (using self: *VisualShaderNodeCompare, func: VisualShaderNodeCompare.Function) {
}
VisualShaderNodeCompare_get_function :: (using self: *VisualShaderNodeCompare) -> VisualShaderNodeCompare.Function {
}
VisualShaderNodeCompare_set_condition :: (using self: *VisualShaderNodeCompare, condition: VisualShaderNodeCompare.Condition) {
}
VisualShaderNodeCompare_get_condition :: (using self: *VisualShaderNodeCompare) -> VisualShaderNodeCompare.Condition {
}

// VisualShaderNodeConstant
VisualShaderNodeConstant :: struct {
	__private: *void;
}

// VisualShaderNodeCubemap
VisualShaderNodeCubemap :: struct {
	__private: *void;

	Source :: enum {
		SOURCE_TEXTURE :: 0;
		SOURCE_PORT :: 1;
		SOURCE_MAX :: 2;
	}
	TextureType :: enum {
		TYPE_DATA :: 0;
		TYPE_COLOR :: 1;
		TYPE_NORMAL_MAP :: 2;
		TYPE_MAX :: 3;
	}
}

VisualShaderNodeCubemap_set_source :: (using self: *VisualShaderNodeCubemap, value: VisualShaderNodeCubemap.Source) {
}
VisualShaderNodeCubemap_get_source :: (using self: *VisualShaderNodeCubemap) -> VisualShaderNodeCubemap.Source {
}
VisualShaderNodeCubemap_set_cube_map :: (using self: *VisualShaderNodeCubemap, value: Cubemap) {
}
VisualShaderNodeCubemap_get_cube_map :: (using self: *VisualShaderNodeCubemap) -> Cubemap {
}
VisualShaderNodeCubemap_set_texture_type :: (using self: *VisualShaderNodeCubemap, value: VisualShaderNodeCubemap.TextureType) {
}
VisualShaderNodeCubemap_get_texture_type :: (using self: *VisualShaderNodeCubemap) -> VisualShaderNodeCubemap.TextureType {
}

// VisualShaderNodeCubemapParameter
VisualShaderNodeCubemapParameter :: struct {
	__private: *void;
}

// VisualShaderNodeCurveTexture
VisualShaderNodeCurveTexture :: struct {
	__private: *void;
}

VisualShaderNodeCurveTexture_set_texture :: (using self: *VisualShaderNodeCurveTexture, texture: CurveTexture) {
}
VisualShaderNodeCurveTexture_get_texture :: (using self: *VisualShaderNodeCurveTexture) -> CurveTexture {
}

// VisualShaderNodeCurveXYZTexture
VisualShaderNodeCurveXYZTexture :: struct {
	__private: *void;
}

VisualShaderNodeCurveXYZTexture_set_texture :: (using self: *VisualShaderNodeCurveXYZTexture, texture: CurveXYZTexture) {
}
VisualShaderNodeCurveXYZTexture_get_texture :: (using self: *VisualShaderNodeCurveXYZTexture) -> CurveXYZTexture {
}

// VisualShaderNodeCustom
VisualShaderNodeCustom :: struct {
	__private: *void;
}

VisualShaderNodeCustom__get_name :: (using self: *VisualShaderNodeCustom) -> String {
}
VisualShaderNodeCustom__get_description :: (using self: *VisualShaderNodeCustom) -> String {
}
VisualShaderNodeCustom__get_category :: (using self: *VisualShaderNodeCustom) -> String {
}
VisualShaderNodeCustom__get_return_icon_type :: (using self: *VisualShaderNodeCustom) -> VisualShaderNode.PortType {
}
VisualShaderNodeCustom__get_input_port_count :: (using self: *VisualShaderNodeCustom) -> int {
}
VisualShaderNodeCustom__get_input_port_type :: (using self: *VisualShaderNodeCustom, port: int) -> VisualShaderNode.PortType {
}
VisualShaderNodeCustom__get_input_port_name :: (using self: *VisualShaderNodeCustom, port: int) -> String {
}
VisualShaderNodeCustom__get_input_port_default_value :: (using self: *VisualShaderNodeCustom, port: int) -> Variant {
}
VisualShaderNodeCustom__get_default_input_port :: (using self: *VisualShaderNodeCustom, type: VisualShaderNode.PortType) -> int {
}
VisualShaderNodeCustom__get_output_port_count :: (using self: *VisualShaderNodeCustom) -> int {
}
VisualShaderNodeCustom__get_output_port_type :: (using self: *VisualShaderNodeCustom, port: int) -> VisualShaderNode.PortType {
}
VisualShaderNodeCustom__get_output_port_name :: (using self: *VisualShaderNodeCustom, port: int) -> String {
}
VisualShaderNodeCustom__get_property_count :: (using self: *VisualShaderNodeCustom) -> int {
}
VisualShaderNodeCustom__get_property_name :: (using self: *VisualShaderNodeCustom, index: int) -> String {
}
VisualShaderNodeCustom__get_property_default_index :: (using self: *VisualShaderNodeCustom, index: int) -> int {
}
VisualShaderNodeCustom__get_property_options :: (using self: *VisualShaderNodeCustom, index: int) -> PackedStringArray {
}
VisualShaderNodeCustom__get_code :: (using self: *VisualShaderNodeCustom, input_vars: Array, output_vars: Array, mode: Shader.Mode, type: VisualShader.Type) -> String {
}
VisualShaderNodeCustom__get_func_code :: (using self: *VisualShaderNodeCustom, mode: Shader.Mode, type: VisualShader.Type) -> String {
}
VisualShaderNodeCustom__get_global_code :: (using self: *VisualShaderNodeCustom, mode: Shader.Mode) -> String {
}
VisualShaderNodeCustom__is_highend :: (using self: *VisualShaderNodeCustom) -> bool {
}
VisualShaderNodeCustom__is_available :: (using self: *VisualShaderNodeCustom, mode: Shader.Mode, type: VisualShader.Type) -> bool {
}
VisualShaderNodeCustom_get_option_index :: (using self: *VisualShaderNodeCustom, option: int) -> int {
}

// VisualShaderNodeDerivativeFunc
VisualShaderNodeDerivativeFunc :: struct {
	__private: *void;

	OpType :: enum {
		OP_TYPE_SCALAR :: 0;
		OP_TYPE_VECTOR_2D :: 1;
		OP_TYPE_VECTOR_3D :: 2;
		OP_TYPE_VECTOR_4D :: 3;
		OP_TYPE_MAX :: 4;
	}
	Function :: enum {
		FUNC_SUM :: 0;
		FUNC_X :: 1;
		FUNC_Y :: 2;
		FUNC_MAX :: 3;
	}
	Precision :: enum {
		PRECISION_NONE :: 0;
		PRECISION_COARSE :: 1;
		PRECISION_FINE :: 2;
		PRECISION_MAX :: 3;
	}
}

VisualShaderNodeDerivativeFunc_set_op_type :: (using self: *VisualShaderNodeDerivativeFunc, type: VisualShaderNodeDerivativeFunc.OpType) {
}
VisualShaderNodeDerivativeFunc_get_op_type :: (using self: *VisualShaderNodeDerivativeFunc) -> VisualShaderNodeDerivativeFunc.OpType {
}
VisualShaderNodeDerivativeFunc_set_function :: (using self: *VisualShaderNodeDerivativeFunc, func: VisualShaderNodeDerivativeFunc.Function) {
}
VisualShaderNodeDerivativeFunc_get_function :: (using self: *VisualShaderNodeDerivativeFunc) -> VisualShaderNodeDerivativeFunc.Function {
}
VisualShaderNodeDerivativeFunc_set_precision :: (using self: *VisualShaderNodeDerivativeFunc, precision: VisualShaderNodeDerivativeFunc.Precision) {
}
VisualShaderNodeDerivativeFunc_get_precision :: (using self: *VisualShaderNodeDerivativeFunc) -> VisualShaderNodeDerivativeFunc.Precision {
}

// VisualShaderNodeDeterminant
VisualShaderNodeDeterminant :: struct {
	__private: *void;
}

// VisualShaderNodeDistanceFade
VisualShaderNodeDistanceFade :: struct {
	__private: *void;
}

// VisualShaderNodeDotProduct
VisualShaderNodeDotProduct :: struct {
	__private: *void;
}

// VisualShaderNodeExpression
VisualShaderNodeExpression :: struct {
	__private: *void;
}

VisualShaderNodeExpression_set_expression :: (using self: *VisualShaderNodeExpression, expression: String) {
}
VisualShaderNodeExpression_get_expression :: (using self: *VisualShaderNodeExpression) -> String {
}

// VisualShaderNodeFaceForward
VisualShaderNodeFaceForward :: struct {
	__private: *void;
}

// VisualShaderNodeFloatConstant
VisualShaderNodeFloatConstant :: struct {
	__private: *void;
}

VisualShaderNodeFloatConstant_set_constant :: (using self: *VisualShaderNodeFloatConstant, constant: float) {
}
VisualShaderNodeFloatConstant_get_constant :: (using self: *VisualShaderNodeFloatConstant) -> float {
}

// VisualShaderNodeFloatFunc
VisualShaderNodeFloatFunc :: struct {
	__private: *void;

	Function :: enum {
		FUNC_SIN :: 0;
		FUNC_COS :: 1;
		FUNC_TAN :: 2;
		FUNC_ASIN :: 3;
		FUNC_ACOS :: 4;
		FUNC_ATAN :: 5;
		FUNC_SINH :: 6;
		FUNC_COSH :: 7;
		FUNC_TANH :: 8;
		FUNC_LOG :: 9;
		FUNC_EXP :: 10;
		FUNC_SQRT :: 11;
		FUNC_ABS :: 12;
		FUNC_SIGN :: 13;
		FUNC_FLOOR :: 14;
		FUNC_ROUND :: 15;
		FUNC_CEIL :: 16;
		FUNC_FRACT :: 17;
		FUNC_SATURATE :: 18;
		FUNC_NEGATE :: 19;
		FUNC_ACOSH :: 20;
		FUNC_ASINH :: 21;
		FUNC_ATANH :: 22;
		FUNC_DEGREES :: 23;
		FUNC_EXP2 :: 24;
		FUNC_INVERSE_SQRT :: 25;
		FUNC_LOG2 :: 26;
		FUNC_RADIANS :: 27;
		FUNC_RECIPROCAL :: 28;
		FUNC_ROUNDEVEN :: 29;
		FUNC_TRUNC :: 30;
		FUNC_ONEMINUS :: 31;
		FUNC_MAX :: 32;
	}
}

VisualShaderNodeFloatFunc_set_function :: (using self: *VisualShaderNodeFloatFunc, func: VisualShaderNodeFloatFunc.Function) {
}
VisualShaderNodeFloatFunc_get_function :: (using self: *VisualShaderNodeFloatFunc) -> VisualShaderNodeFloatFunc.Function {
}

// VisualShaderNodeFloatOp
VisualShaderNodeFloatOp :: struct {
	__private: *void;

	Operator :: enum {
		OP_ADD :: 0;
		OP_SUB :: 1;
		OP_MUL :: 2;
		OP_DIV :: 3;
		OP_MOD :: 4;
		OP_POW :: 5;
		OP_MAX :: 6;
		OP_MIN :: 7;
		OP_ATAN2 :: 8;
		OP_STEP :: 9;
		OP_ENUM_SIZE :: 10;
	}
}

VisualShaderNodeFloatOp_set_operator :: (using self: *VisualShaderNodeFloatOp, op: VisualShaderNodeFloatOp.Operator) {
}
VisualShaderNodeFloatOp_get_operator :: (using self: *VisualShaderNodeFloatOp) -> VisualShaderNodeFloatOp.Operator {
}

// VisualShaderNodeFloatParameter
VisualShaderNodeFloatParameter :: struct {
	__private: *void;

	Hint :: enum {
		HINT_NONE :: 0;
		HINT_RANGE :: 1;
		HINT_RANGE_STEP :: 2;
		HINT_MAX :: 3;
	}
}

VisualShaderNodeFloatParameter_set_hint :: (using self: *VisualShaderNodeFloatParameter, hint: VisualShaderNodeFloatParameter.Hint) {
}
VisualShaderNodeFloatParameter_get_hint :: (using self: *VisualShaderNodeFloatParameter) -> VisualShaderNodeFloatParameter.Hint {
}
VisualShaderNodeFloatParameter_set_min :: (using self: *VisualShaderNodeFloatParameter, value: float) {
}
VisualShaderNodeFloatParameter_get_min :: (using self: *VisualShaderNodeFloatParameter) -> float {
}
VisualShaderNodeFloatParameter_set_max :: (using self: *VisualShaderNodeFloatParameter, value: float) {
}
VisualShaderNodeFloatParameter_get_max :: (using self: *VisualShaderNodeFloatParameter) -> float {
}
VisualShaderNodeFloatParameter_set_step :: (using self: *VisualShaderNodeFloatParameter, value: float) {
}
VisualShaderNodeFloatParameter_get_step :: (using self: *VisualShaderNodeFloatParameter) -> float {
}
VisualShaderNodeFloatParameter_set_default_value_enabled :: (using self: *VisualShaderNodeFloatParameter, enabled: bool) {
}
VisualShaderNodeFloatParameter_is_default_value_enabled :: (using self: *VisualShaderNodeFloatParameter) -> bool {
}
VisualShaderNodeFloatParameter_set_default_value :: (using self: *VisualShaderNodeFloatParameter, value: float) {
}
VisualShaderNodeFloatParameter_get_default_value :: (using self: *VisualShaderNodeFloatParameter) -> float {
}

// VisualShaderNodeFrame
VisualShaderNodeFrame :: struct {
	__private: *void;
}

VisualShaderNodeFrame_set_title :: (using self: *VisualShaderNodeFrame, title: String) {
}
VisualShaderNodeFrame_get_title :: (using self: *VisualShaderNodeFrame) -> String {
}
VisualShaderNodeFrame_set_tint_color_enabled :: (using self: *VisualShaderNodeFrame, enable: bool) {
}
VisualShaderNodeFrame_is_tint_color_enabled :: (using self: *VisualShaderNodeFrame) -> bool {
}
VisualShaderNodeFrame_set_tint_color :: (using self: *VisualShaderNodeFrame, color: Color) {
}
VisualShaderNodeFrame_get_tint_color :: (using self: *VisualShaderNodeFrame) -> Color {
}
VisualShaderNodeFrame_set_autoshrink_enabled :: (using self: *VisualShaderNodeFrame, enable: bool) {
}
VisualShaderNodeFrame_is_autoshrink_enabled :: (using self: *VisualShaderNodeFrame) -> bool {
}
VisualShaderNodeFrame_add_attached_node :: (using self: *VisualShaderNodeFrame, node: int) {
}
VisualShaderNodeFrame_remove_attached_node :: (using self: *VisualShaderNodeFrame, node: int) {
}
VisualShaderNodeFrame_set_attached_nodes :: (using self: *VisualShaderNodeFrame, attached_nodes: PackedInt32Array) {
}
VisualShaderNodeFrame_get_attached_nodes :: (using self: *VisualShaderNodeFrame) -> PackedInt32Array {
}

// VisualShaderNodeFresnel
VisualShaderNodeFresnel :: struct {
	__private: *void;
}

// VisualShaderNodeGlobalExpression
VisualShaderNodeGlobalExpression :: struct {
	__private: *void;
}

// VisualShaderNodeGroupBase
VisualShaderNodeGroupBase :: struct {
	__private: *void;
}

VisualShaderNodeGroupBase_set_inputs :: (using self: *VisualShaderNodeGroupBase, inputs: String) {
}
VisualShaderNodeGroupBase_get_inputs :: (using self: *VisualShaderNodeGroupBase) -> String {
}
VisualShaderNodeGroupBase_set_outputs :: (using self: *VisualShaderNodeGroupBase, outputs: String) {
}
VisualShaderNodeGroupBase_get_outputs :: (using self: *VisualShaderNodeGroupBase) -> String {
}
VisualShaderNodeGroupBase_is_valid_port_name :: (using self: *VisualShaderNodeGroupBase, name: String) -> bool {
}
VisualShaderNodeGroupBase_add_input_port :: (using self: *VisualShaderNodeGroupBase, id: int, type: int, name: String) {
}
VisualShaderNodeGroupBase_remove_input_port :: (using self: *VisualShaderNodeGroupBase, id: int) {
}
VisualShaderNodeGroupBase_get_input_port_count :: (using self: *VisualShaderNodeGroupBase) -> int {
}
VisualShaderNodeGroupBase_has_input_port :: (using self: *VisualShaderNodeGroupBase, id: int) -> bool {
}
VisualShaderNodeGroupBase_clear_input_ports :: (using self: *VisualShaderNodeGroupBase) {
}
VisualShaderNodeGroupBase_add_output_port :: (using self: *VisualShaderNodeGroupBase, id: int, type: int, name: String) {
}
VisualShaderNodeGroupBase_remove_output_port :: (using self: *VisualShaderNodeGroupBase, id: int) {
}
VisualShaderNodeGroupBase_get_output_port_count :: (using self: *VisualShaderNodeGroupBase) -> int {
}
VisualShaderNodeGroupBase_has_output_port :: (using self: *VisualShaderNodeGroupBase, id: int) -> bool {
}
VisualShaderNodeGroupBase_clear_output_ports :: (using self: *VisualShaderNodeGroupBase) {
}
VisualShaderNodeGroupBase_set_input_port_name :: (using self: *VisualShaderNodeGroupBase, id: int, name: String) {
}
VisualShaderNodeGroupBase_set_input_port_type :: (using self: *VisualShaderNodeGroupBase, id: int, type: int) {
}
VisualShaderNodeGroupBase_set_output_port_name :: (using self: *VisualShaderNodeGroupBase, id: int, name: String) {
}
VisualShaderNodeGroupBase_set_output_port_type :: (using self: *VisualShaderNodeGroupBase, id: int, type: int) {
}
VisualShaderNodeGroupBase_get_free_input_port_id :: (using self: *VisualShaderNodeGroupBase) -> int {
}
VisualShaderNodeGroupBase_get_free_output_port_id :: (using self: *VisualShaderNodeGroupBase) -> int {
}

// VisualShaderNodeIf
VisualShaderNodeIf :: struct {
	__private: *void;
}

// VisualShaderNodeInput
VisualShaderNodeInput :: struct {
	__private: *void;
}

VisualShaderNodeInput_set_input_name :: (using self: *VisualShaderNodeInput, name: String) {
}
VisualShaderNodeInput_get_input_name :: (using self: *VisualShaderNodeInput) -> String {
}
VisualShaderNodeInput_get_input_real_name :: (using self: *VisualShaderNodeInput) -> String {
}

// VisualShaderNodeIntConstant
VisualShaderNodeIntConstant :: struct {
	__private: *void;
}

VisualShaderNodeIntConstant_set_constant :: (using self: *VisualShaderNodeIntConstant, constant: int) {
}
VisualShaderNodeIntConstant_get_constant :: (using self: *VisualShaderNodeIntConstant) -> int {
}

// VisualShaderNodeIntFunc
VisualShaderNodeIntFunc :: struct {
	__private: *void;

	Function :: enum {
		FUNC_ABS :: 0;
		FUNC_NEGATE :: 1;
		FUNC_SIGN :: 2;
		FUNC_BITWISE_NOT :: 3;
		FUNC_MAX :: 4;
	}
}

VisualShaderNodeIntFunc_set_function :: (using self: *VisualShaderNodeIntFunc, func: VisualShaderNodeIntFunc.Function) {
}
VisualShaderNodeIntFunc_get_function :: (using self: *VisualShaderNodeIntFunc) -> VisualShaderNodeIntFunc.Function {
}

// VisualShaderNodeIntOp
VisualShaderNodeIntOp :: struct {
	__private: *void;

	Operator :: enum {
		OP_ADD :: 0;
		OP_SUB :: 1;
		OP_MUL :: 2;
		OP_DIV :: 3;
		OP_MOD :: 4;
		OP_MAX :: 5;
		OP_MIN :: 6;
		OP_BITWISE_AND :: 7;
		OP_BITWISE_OR :: 8;
		OP_BITWISE_XOR :: 9;
		OP_BITWISE_LEFT_SHIFT :: 10;
		OP_BITWISE_RIGHT_SHIFT :: 11;
		OP_ENUM_SIZE :: 12;
	}
}

VisualShaderNodeIntOp_set_operator :: (using self: *VisualShaderNodeIntOp, op: VisualShaderNodeIntOp.Operator) {
}
VisualShaderNodeIntOp_get_operator :: (using self: *VisualShaderNodeIntOp) -> VisualShaderNodeIntOp.Operator {
}

// VisualShaderNodeIntParameter
VisualShaderNodeIntParameter :: struct {
	__private: *void;

	Hint :: enum {
		HINT_NONE :: 0;
		HINT_RANGE :: 1;
		HINT_RANGE_STEP :: 2;
		HINT_MAX :: 3;
	}
}

VisualShaderNodeIntParameter_set_hint :: (using self: *VisualShaderNodeIntParameter, hint: VisualShaderNodeIntParameter.Hint) {
}
VisualShaderNodeIntParameter_get_hint :: (using self: *VisualShaderNodeIntParameter) -> VisualShaderNodeIntParameter.Hint {
}
VisualShaderNodeIntParameter_set_min :: (using self: *VisualShaderNodeIntParameter, value: int) {
}
VisualShaderNodeIntParameter_get_min :: (using self: *VisualShaderNodeIntParameter) -> int {
}
VisualShaderNodeIntParameter_set_max :: (using self: *VisualShaderNodeIntParameter, value: int) {
}
VisualShaderNodeIntParameter_get_max :: (using self: *VisualShaderNodeIntParameter) -> int {
}
VisualShaderNodeIntParameter_set_step :: (using self: *VisualShaderNodeIntParameter, value: int) {
}
VisualShaderNodeIntParameter_get_step :: (using self: *VisualShaderNodeIntParameter) -> int {
}
VisualShaderNodeIntParameter_set_default_value_enabled :: (using self: *VisualShaderNodeIntParameter, enabled: bool) {
}
VisualShaderNodeIntParameter_is_default_value_enabled :: (using self: *VisualShaderNodeIntParameter) -> bool {
}
VisualShaderNodeIntParameter_set_default_value :: (using self: *VisualShaderNodeIntParameter, value: int) {
}
VisualShaderNodeIntParameter_get_default_value :: (using self: *VisualShaderNodeIntParameter) -> int {
}

// VisualShaderNodeIs
VisualShaderNodeIs :: struct {
	__private: *void;

	Function :: enum {
		FUNC_IS_INF :: 0;
		FUNC_IS_NAN :: 1;
		FUNC_MAX :: 2;
	}
}

VisualShaderNodeIs_set_function :: (using self: *VisualShaderNodeIs, func: VisualShaderNodeIs.Function) {
}
VisualShaderNodeIs_get_function :: (using self: *VisualShaderNodeIs) -> VisualShaderNodeIs.Function {
}

// VisualShaderNodeLinearSceneDepth
VisualShaderNodeLinearSceneDepth :: struct {
	__private: *void;
}

// VisualShaderNodeMix
VisualShaderNodeMix :: struct {
	__private: *void;

	OpType :: enum {
		OP_TYPE_SCALAR :: 0;
		OP_TYPE_VECTOR_2D :: 1;
		OP_TYPE_VECTOR_2D_SCALAR :: 2;
		OP_TYPE_VECTOR_3D :: 3;
		OP_TYPE_VECTOR_3D_SCALAR :: 4;
		OP_TYPE_VECTOR_4D :: 5;
		OP_TYPE_VECTOR_4D_SCALAR :: 6;
		OP_TYPE_MAX :: 7;
	}
}

VisualShaderNodeMix_set_op_type :: (using self: *VisualShaderNodeMix, op_type: VisualShaderNodeMix.OpType) {
}
VisualShaderNodeMix_get_op_type :: (using self: *VisualShaderNodeMix) -> VisualShaderNodeMix.OpType {
}

// VisualShaderNodeMultiplyAdd
VisualShaderNodeMultiplyAdd :: struct {
	__private: *void;

	OpType :: enum {
		OP_TYPE_SCALAR :: 0;
		OP_TYPE_VECTOR_2D :: 1;
		OP_TYPE_VECTOR_3D :: 2;
		OP_TYPE_VECTOR_4D :: 3;
		OP_TYPE_MAX :: 4;
	}
}

VisualShaderNodeMultiplyAdd_set_op_type :: (using self: *VisualShaderNodeMultiplyAdd, type: VisualShaderNodeMultiplyAdd.OpType) {
}
VisualShaderNodeMultiplyAdd_get_op_type :: (using self: *VisualShaderNodeMultiplyAdd) -> VisualShaderNodeMultiplyAdd.OpType {
}

// VisualShaderNodeOuterProduct
VisualShaderNodeOuterProduct :: struct {
	__private: *void;
}

// VisualShaderNodeOutput
VisualShaderNodeOutput :: struct {
	__private: *void;
}

// VisualShaderNodeParameter
VisualShaderNodeParameter :: struct {
	__private: *void;

	Qualifier :: enum {
		QUAL_NONE :: 0;
		QUAL_GLOBAL :: 1;
		QUAL_INSTANCE :: 2;
		QUAL_MAX :: 3;
	}
}

VisualShaderNodeParameter_set_parameter_name :: (using self: *VisualShaderNodeParameter, name: String) {
}
VisualShaderNodeParameter_get_parameter_name :: (using self: *VisualShaderNodeParameter) -> String {
}
VisualShaderNodeParameter_set_qualifier :: (using self: *VisualShaderNodeParameter, qualifier: VisualShaderNodeParameter.Qualifier) {
}
VisualShaderNodeParameter_get_qualifier :: (using self: *VisualShaderNodeParameter) -> VisualShaderNodeParameter.Qualifier {
}

// VisualShaderNodeParameterRef
VisualShaderNodeParameterRef :: struct {
	__private: *void;
}

VisualShaderNodeParameterRef_set_parameter_name :: (using self: *VisualShaderNodeParameterRef, name: String) {
}
VisualShaderNodeParameterRef_get_parameter_name :: (using self: *VisualShaderNodeParameterRef) -> String {
}

// VisualShaderNodeParticleAccelerator
VisualShaderNodeParticleAccelerator :: struct {
	__private: *void;

	Mode :: enum {
		MODE_LINEAR :: 0;
		MODE_RADIAL :: 1;
		MODE_TANGENTIAL :: 2;
		MODE_MAX :: 3;
	}
}

VisualShaderNodeParticleAccelerator_set_mode :: (using self: *VisualShaderNodeParticleAccelerator, mode: VisualShaderNodeParticleAccelerator.Mode) {
}
VisualShaderNodeParticleAccelerator_get_mode :: (using self: *VisualShaderNodeParticleAccelerator) -> VisualShaderNodeParticleAccelerator.Mode {
}

// VisualShaderNodeParticleBoxEmitter
VisualShaderNodeParticleBoxEmitter :: struct {
	__private: *void;
}

// VisualShaderNodeParticleConeVelocity
VisualShaderNodeParticleConeVelocity :: struct {
	__private: *void;
}

// VisualShaderNodeParticleEmit
VisualShaderNodeParticleEmit :: struct {
	__private: *void;

	EmitFlags :: enum {
		EMIT_FLAG_POSITION :: 1;
		EMIT_FLAG_ROT_SCALE :: 2;
		EMIT_FLAG_VELOCITY :: 4;
		EMIT_FLAG_COLOR :: 8;
		EMIT_FLAG_CUSTOM :: 16;
	}
}

VisualShaderNodeParticleEmit_set_flags :: (using self: *VisualShaderNodeParticleEmit, flags: VisualShaderNodeParticleEmit.EmitFlags) {
}
VisualShaderNodeParticleEmit_get_flags :: (using self: *VisualShaderNodeParticleEmit) -> VisualShaderNodeParticleEmit.EmitFlags {
}

// VisualShaderNodeParticleEmitter
VisualShaderNodeParticleEmitter :: struct {
	__private: *void;
}

VisualShaderNodeParticleEmitter_set_mode_2d :: (using self: *VisualShaderNodeParticleEmitter, enabled: bool) {
}
VisualShaderNodeParticleEmitter_is_mode_2d :: (using self: *VisualShaderNodeParticleEmitter) -> bool {
}

// VisualShaderNodeParticleMeshEmitter
VisualShaderNodeParticleMeshEmitter :: struct {
	__private: *void;
}

VisualShaderNodeParticleMeshEmitter_set_mesh :: (using self: *VisualShaderNodeParticleMeshEmitter, mesh: Mesh) {
}
VisualShaderNodeParticleMeshEmitter_get_mesh :: (using self: *VisualShaderNodeParticleMeshEmitter) -> Mesh {
}
VisualShaderNodeParticleMeshEmitter_set_use_all_surfaces :: (using self: *VisualShaderNodeParticleMeshEmitter, enabled: bool) {
}
VisualShaderNodeParticleMeshEmitter_is_use_all_surfaces :: (using self: *VisualShaderNodeParticleMeshEmitter) -> bool {
}
VisualShaderNodeParticleMeshEmitter_set_surface_index :: (using self: *VisualShaderNodeParticleMeshEmitter, surface_index: int) {
}
VisualShaderNodeParticleMeshEmitter_get_surface_index :: (using self: *VisualShaderNodeParticleMeshEmitter) -> int {
}

// VisualShaderNodeParticleMultiplyByAxisAngle
VisualShaderNodeParticleMultiplyByAxisAngle :: struct {
	__private: *void;
}

VisualShaderNodeParticleMultiplyByAxisAngle_set_degrees_mode :: (using self: *VisualShaderNodeParticleMultiplyByAxisAngle, enabled: bool) {
}
VisualShaderNodeParticleMultiplyByAxisAngle_is_degrees_mode :: (using self: *VisualShaderNodeParticleMultiplyByAxisAngle) -> bool {
}

// VisualShaderNodeParticleOutput
VisualShaderNodeParticleOutput :: struct {
	__private: *void;
}

// VisualShaderNodeParticleRandomness
VisualShaderNodeParticleRandomness :: struct {
	__private: *void;

	OpType :: enum {
		OP_TYPE_SCALAR :: 0;
		OP_TYPE_VECTOR_2D :: 1;
		OP_TYPE_VECTOR_3D :: 2;
		OP_TYPE_VECTOR_4D :: 3;
		OP_TYPE_MAX :: 4;
	}
}

VisualShaderNodeParticleRandomness_set_op_type :: (using self: *VisualShaderNodeParticleRandomness, type: VisualShaderNodeParticleRandomness.OpType) {
}
VisualShaderNodeParticleRandomness_get_op_type :: (using self: *VisualShaderNodeParticleRandomness) -> VisualShaderNodeParticleRandomness.OpType {
}

// VisualShaderNodeParticleRingEmitter
VisualShaderNodeParticleRingEmitter :: struct {
	__private: *void;
}

// VisualShaderNodeParticleSphereEmitter
VisualShaderNodeParticleSphereEmitter :: struct {
	__private: *void;
}

// VisualShaderNodeProximityFade
VisualShaderNodeProximityFade :: struct {
	__private: *void;
}

// VisualShaderNodeRandomRange
VisualShaderNodeRandomRange :: struct {
	__private: *void;
}

// VisualShaderNodeRemap
VisualShaderNodeRemap :: struct {
	__private: *void;
}

// VisualShaderNodeReroute
VisualShaderNodeReroute :: struct {
	__private: *void;
}

VisualShaderNodeReroute_get_port_type :: (using self: *VisualShaderNodeReroute) -> VisualShaderNode.PortType {
}

// VisualShaderNodeResizableBase
VisualShaderNodeResizableBase :: struct {
	__private: *void;
}

VisualShaderNodeResizableBase_set_size :: (using self: *VisualShaderNodeResizableBase, size: Vector2) {
}
VisualShaderNodeResizableBase_get_size :: (using self: *VisualShaderNodeResizableBase) -> Vector2 {
}

// VisualShaderNodeRotationByAxis
VisualShaderNodeRotationByAxis :: struct {
	__private: *void;
}

// VisualShaderNodeSDFRaymarch
VisualShaderNodeSDFRaymarch :: struct {
	__private: *void;
}

// VisualShaderNodeSDFToScreenUV
VisualShaderNodeSDFToScreenUV :: struct {
	__private: *void;
}

// VisualShaderNodeSample3D
VisualShaderNodeSample3D :: struct {
	__private: *void;

	Source :: enum {
		SOURCE_TEXTURE :: 0;
		SOURCE_PORT :: 1;
		SOURCE_MAX :: 2;
	}
}

VisualShaderNodeSample3D_set_source :: (using self: *VisualShaderNodeSample3D, value: VisualShaderNodeSample3D.Source) {
}
VisualShaderNodeSample3D_get_source :: (using self: *VisualShaderNodeSample3D) -> VisualShaderNodeSample3D.Source {
}

// VisualShaderNodeScreenNormalWorldSpace
VisualShaderNodeScreenNormalWorldSpace :: struct {
	__private: *void;
}

// VisualShaderNodeScreenUVToSDF
VisualShaderNodeScreenUVToSDF :: struct {
	__private: *void;
}

// VisualShaderNodeSmoothStep
VisualShaderNodeSmoothStep :: struct {
	__private: *void;

	OpType :: enum {
		OP_TYPE_SCALAR :: 0;
		OP_TYPE_VECTOR_2D :: 1;
		OP_TYPE_VECTOR_2D_SCALAR :: 2;
		OP_TYPE_VECTOR_3D :: 3;
		OP_TYPE_VECTOR_3D_SCALAR :: 4;
		OP_TYPE_VECTOR_4D :: 5;
		OP_TYPE_VECTOR_4D_SCALAR :: 6;
		OP_TYPE_MAX :: 7;
	}
}

VisualShaderNodeSmoothStep_set_op_type :: (using self: *VisualShaderNodeSmoothStep, op_type: VisualShaderNodeSmoothStep.OpType) {
}
VisualShaderNodeSmoothStep_get_op_type :: (using self: *VisualShaderNodeSmoothStep) -> VisualShaderNodeSmoothStep.OpType {
}

// VisualShaderNodeStep
VisualShaderNodeStep :: struct {
	__private: *void;

	OpType :: enum {
		OP_TYPE_SCALAR :: 0;
		OP_TYPE_VECTOR_2D :: 1;
		OP_TYPE_VECTOR_2D_SCALAR :: 2;
		OP_TYPE_VECTOR_3D :: 3;
		OP_TYPE_VECTOR_3D_SCALAR :: 4;
		OP_TYPE_VECTOR_4D :: 5;
		OP_TYPE_VECTOR_4D_SCALAR :: 6;
		OP_TYPE_MAX :: 7;
	}
}

VisualShaderNodeStep_set_op_type :: (using self: *VisualShaderNodeStep, op_type: VisualShaderNodeStep.OpType) {
}
VisualShaderNodeStep_get_op_type :: (using self: *VisualShaderNodeStep) -> VisualShaderNodeStep.OpType {
}

// VisualShaderNodeSwitch
VisualShaderNodeSwitch :: struct {
	__private: *void;

	OpType :: enum {
		OP_TYPE_FLOAT :: 0;
		OP_TYPE_INT :: 1;
		OP_TYPE_UINT :: 2;
		OP_TYPE_VECTOR_2D :: 3;
		OP_TYPE_VECTOR_3D :: 4;
		OP_TYPE_VECTOR_4D :: 5;
		OP_TYPE_BOOLEAN :: 6;
		OP_TYPE_TRANSFORM :: 7;
		OP_TYPE_MAX :: 8;
	}
}

VisualShaderNodeSwitch_set_op_type :: (using self: *VisualShaderNodeSwitch, type: VisualShaderNodeSwitch.OpType) {
}
VisualShaderNodeSwitch_get_op_type :: (using self: *VisualShaderNodeSwitch) -> VisualShaderNodeSwitch.OpType {
}

// VisualShaderNodeTexture
VisualShaderNodeTexture :: struct {
	__private: *void;

	Source :: enum {
		SOURCE_TEXTURE :: 0;
		SOURCE_SCREEN :: 1;
		SOURCE_2D_TEXTURE :: 2;
		SOURCE_2D_NORMAL :: 3;
		SOURCE_DEPTH :: 4;
		SOURCE_PORT :: 5;
		SOURCE_3D_NORMAL :: 6;
		SOURCE_ROUGHNESS :: 7;
		SOURCE_MAX :: 8;
	}
	TextureType :: enum {
		TYPE_DATA :: 0;
		TYPE_COLOR :: 1;
		TYPE_NORMAL_MAP :: 2;
		TYPE_MAX :: 3;
	}
}

VisualShaderNodeTexture_set_source :: (using self: *VisualShaderNodeTexture, value: VisualShaderNodeTexture.Source) {
}
VisualShaderNodeTexture_get_source :: (using self: *VisualShaderNodeTexture) -> VisualShaderNodeTexture.Source {
}
VisualShaderNodeTexture_set_texture :: (using self: *VisualShaderNodeTexture, value: Texture2D) {
}
VisualShaderNodeTexture_get_texture :: (using self: *VisualShaderNodeTexture) -> Texture2D {
}
VisualShaderNodeTexture_set_texture_type :: (using self: *VisualShaderNodeTexture, value: VisualShaderNodeTexture.TextureType) {
}
VisualShaderNodeTexture_get_texture_type :: (using self: *VisualShaderNodeTexture) -> VisualShaderNodeTexture.TextureType {
}

// VisualShaderNodeTexture2DArray
VisualShaderNodeTexture2DArray :: struct {
	__private: *void;
}

VisualShaderNodeTexture2DArray_set_texture_array :: (using self: *VisualShaderNodeTexture2DArray, value: Texture2DArray) {
}
VisualShaderNodeTexture2DArray_get_texture_array :: (using self: *VisualShaderNodeTexture2DArray) -> Texture2DArray {
}

// VisualShaderNodeTexture2DArrayParameter
VisualShaderNodeTexture2DArrayParameter :: struct {
	__private: *void;
}

// VisualShaderNodeTexture2DParameter
VisualShaderNodeTexture2DParameter :: struct {
	__private: *void;
}

// VisualShaderNodeTexture3D
VisualShaderNodeTexture3D :: struct {
	__private: *void;
}

VisualShaderNodeTexture3D_set_texture :: (using self: *VisualShaderNodeTexture3D, value: Texture3D) {
}
VisualShaderNodeTexture3D_get_texture :: (using self: *VisualShaderNodeTexture3D) -> Texture3D {
}

// VisualShaderNodeTexture3DParameter
VisualShaderNodeTexture3DParameter :: struct {
	__private: *void;
}

// VisualShaderNodeTextureParameter
VisualShaderNodeTextureParameter :: struct {
	__private: *void;

	TextureType :: enum {
		TYPE_DATA :: 0;
		TYPE_COLOR :: 1;
		TYPE_NORMAL_MAP :: 2;
		TYPE_ANISOTROPY :: 3;
		TYPE_MAX :: 4;
	}
	ColorDefault :: enum {
		COLOR_DEFAULT_WHITE :: 0;
		COLOR_DEFAULT_BLACK :: 1;
		COLOR_DEFAULT_TRANSPARENT :: 2;
		COLOR_DEFAULT_MAX :: 3;
	}
	TextureFilter :: enum {
		FILTER_DEFAULT :: 0;
		FILTER_NEAREST :: 1;
		FILTER_LINEAR :: 2;
		FILTER_NEAREST_MIPMAP :: 3;
		FILTER_LINEAR_MIPMAP :: 4;
		FILTER_NEAREST_MIPMAP_ANISOTROPIC :: 5;
		FILTER_LINEAR_MIPMAP_ANISOTROPIC :: 6;
		FILTER_MAX :: 7;
	}
	TextureRepeat :: enum {
		REPEAT_DEFAULT :: 0;
		REPEAT_ENABLED :: 1;
		REPEAT_DISABLED :: 2;
		REPEAT_MAX :: 3;
	}
	TextureSource :: enum {
		SOURCE_NONE :: 0;
		SOURCE_SCREEN :: 1;
		SOURCE_DEPTH :: 2;
		SOURCE_NORMAL_ROUGHNESS :: 3;
		SOURCE_MAX :: 4;
	}
}

VisualShaderNodeTextureParameter_set_texture_type :: (using self: *VisualShaderNodeTextureParameter, type: VisualShaderNodeTextureParameter.TextureType) {
}
VisualShaderNodeTextureParameter_get_texture_type :: (using self: *VisualShaderNodeTextureParameter) -> VisualShaderNodeTextureParameter.TextureType {
}
VisualShaderNodeTextureParameter_set_color_default :: (using self: *VisualShaderNodeTextureParameter, color: VisualShaderNodeTextureParameter.ColorDefault) {
}
VisualShaderNodeTextureParameter_get_color_default :: (using self: *VisualShaderNodeTextureParameter) -> VisualShaderNodeTextureParameter.ColorDefault {
}
VisualShaderNodeTextureParameter_set_texture_filter :: (using self: *VisualShaderNodeTextureParameter, filter: VisualShaderNodeTextureParameter.TextureFilter) {
}
VisualShaderNodeTextureParameter_get_texture_filter :: (using self: *VisualShaderNodeTextureParameter) -> VisualShaderNodeTextureParameter.TextureFilter {
}
VisualShaderNodeTextureParameter_set_texture_repeat :: (using self: *VisualShaderNodeTextureParameter, repeat: VisualShaderNodeTextureParameter.TextureRepeat) {
}
VisualShaderNodeTextureParameter_get_texture_repeat :: (using self: *VisualShaderNodeTextureParameter) -> VisualShaderNodeTextureParameter.TextureRepeat {
}
VisualShaderNodeTextureParameter_set_texture_source :: (using self: *VisualShaderNodeTextureParameter, source: VisualShaderNodeTextureParameter.TextureSource) {
}
VisualShaderNodeTextureParameter_get_texture_source :: (using self: *VisualShaderNodeTextureParameter) -> VisualShaderNodeTextureParameter.TextureSource {
}

// VisualShaderNodeTextureParameterTriplanar
VisualShaderNodeTextureParameterTriplanar :: struct {
	__private: *void;
}

// VisualShaderNodeTextureSDF
VisualShaderNodeTextureSDF :: struct {
	__private: *void;
}

// VisualShaderNodeTextureSDFNormal
VisualShaderNodeTextureSDFNormal :: struct {
	__private: *void;
}

// VisualShaderNodeTransformCompose
VisualShaderNodeTransformCompose :: struct {
	__private: *void;
}

// VisualShaderNodeTransformConstant
VisualShaderNodeTransformConstant :: struct {
	__private: *void;
}

VisualShaderNodeTransformConstant_set_constant :: (using self: *VisualShaderNodeTransformConstant, constant: Transform3D) {
}
VisualShaderNodeTransformConstant_get_constant :: (using self: *VisualShaderNodeTransformConstant) -> Transform3D {
}

// VisualShaderNodeTransformDecompose
VisualShaderNodeTransformDecompose :: struct {
	__private: *void;
}

// VisualShaderNodeTransformFunc
VisualShaderNodeTransformFunc :: struct {
	__private: *void;

	Function :: enum {
		FUNC_INVERSE :: 0;
		FUNC_TRANSPOSE :: 1;
		FUNC_MAX :: 2;
	}
}

VisualShaderNodeTransformFunc_set_function :: (using self: *VisualShaderNodeTransformFunc, func: VisualShaderNodeTransformFunc.Function) {
}
VisualShaderNodeTransformFunc_get_function :: (using self: *VisualShaderNodeTransformFunc) -> VisualShaderNodeTransformFunc.Function {
}

// VisualShaderNodeTransformOp
VisualShaderNodeTransformOp :: struct {
	__private: *void;

	Operator :: enum {
		OP_AxB :: 0;
		OP_BxA :: 1;
		OP_AxB_COMP :: 2;
		OP_BxA_COMP :: 3;
		OP_ADD :: 4;
		OP_A_MINUS_B :: 5;
		OP_B_MINUS_A :: 6;
		OP_A_DIV_B :: 7;
		OP_B_DIV_A :: 8;
		OP_MAX :: 9;
	}
}

VisualShaderNodeTransformOp_set_operator :: (using self: *VisualShaderNodeTransformOp, op: VisualShaderNodeTransformOp.Operator) {
}
VisualShaderNodeTransformOp_get_operator :: (using self: *VisualShaderNodeTransformOp) -> VisualShaderNodeTransformOp.Operator {
}

// VisualShaderNodeTransformParameter
VisualShaderNodeTransformParameter :: struct {
	__private: *void;
}

VisualShaderNodeTransformParameter_set_default_value_enabled :: (using self: *VisualShaderNodeTransformParameter, enabled: bool) {
}
VisualShaderNodeTransformParameter_is_default_value_enabled :: (using self: *VisualShaderNodeTransformParameter) -> bool {
}
VisualShaderNodeTransformParameter_set_default_value :: (using self: *VisualShaderNodeTransformParameter, value: Transform3D) {
}
VisualShaderNodeTransformParameter_get_default_value :: (using self: *VisualShaderNodeTransformParameter) -> Transform3D {
}

// VisualShaderNodeTransformVecMult
VisualShaderNodeTransformVecMult :: struct {
	__private: *void;

	Operator :: enum {
		OP_AxB :: 0;
		OP_BxA :: 1;
		OP_3x3_AxB :: 2;
		OP_3x3_BxA :: 3;
		OP_MAX :: 4;
	}
}

VisualShaderNodeTransformVecMult_set_operator :: (using self: *VisualShaderNodeTransformVecMult, op: VisualShaderNodeTransformVecMult.Operator) {
}
VisualShaderNodeTransformVecMult_get_operator :: (using self: *VisualShaderNodeTransformVecMult) -> VisualShaderNodeTransformVecMult.Operator {
}

// VisualShaderNodeUIntConstant
VisualShaderNodeUIntConstant :: struct {
	__private: *void;
}

VisualShaderNodeUIntConstant_set_constant :: (using self: *VisualShaderNodeUIntConstant, constant: int) {
}
VisualShaderNodeUIntConstant_get_constant :: (using self: *VisualShaderNodeUIntConstant) -> int {
}

// VisualShaderNodeUIntFunc
VisualShaderNodeUIntFunc :: struct {
	__private: *void;

	Function :: enum {
		FUNC_NEGATE :: 0;
		FUNC_BITWISE_NOT :: 1;
		FUNC_MAX :: 2;
	}
}

VisualShaderNodeUIntFunc_set_function :: (using self: *VisualShaderNodeUIntFunc, func: VisualShaderNodeUIntFunc.Function) {
}
VisualShaderNodeUIntFunc_get_function :: (using self: *VisualShaderNodeUIntFunc) -> VisualShaderNodeUIntFunc.Function {
}

// VisualShaderNodeUIntOp
VisualShaderNodeUIntOp :: struct {
	__private: *void;

	Operator :: enum {
		OP_ADD :: 0;
		OP_SUB :: 1;
		OP_MUL :: 2;
		OP_DIV :: 3;
		OP_MOD :: 4;
		OP_MAX :: 5;
		OP_MIN :: 6;
		OP_BITWISE_AND :: 7;
		OP_BITWISE_OR :: 8;
		OP_BITWISE_XOR :: 9;
		OP_BITWISE_LEFT_SHIFT :: 10;
		OP_BITWISE_RIGHT_SHIFT :: 11;
		OP_ENUM_SIZE :: 12;
	}
}

VisualShaderNodeUIntOp_set_operator :: (using self: *VisualShaderNodeUIntOp, op: VisualShaderNodeUIntOp.Operator) {
}
VisualShaderNodeUIntOp_get_operator :: (using self: *VisualShaderNodeUIntOp) -> VisualShaderNodeUIntOp.Operator {
}

// VisualShaderNodeUIntParameter
VisualShaderNodeUIntParameter :: struct {
	__private: *void;
}

VisualShaderNodeUIntParameter_set_default_value_enabled :: (using self: *VisualShaderNodeUIntParameter, enabled: bool) {
}
VisualShaderNodeUIntParameter_is_default_value_enabled :: (using self: *VisualShaderNodeUIntParameter) -> bool {
}
VisualShaderNodeUIntParameter_set_default_value :: (using self: *VisualShaderNodeUIntParameter, value: int) {
}
VisualShaderNodeUIntParameter_get_default_value :: (using self: *VisualShaderNodeUIntParameter) -> int {
}

// VisualShaderNodeUVFunc
VisualShaderNodeUVFunc :: struct {
	__private: *void;

	Function :: enum {
		FUNC_PANNING :: 0;
		FUNC_SCALING :: 1;
		FUNC_MAX :: 2;
	}
}

VisualShaderNodeUVFunc_set_function :: (using self: *VisualShaderNodeUVFunc, func: VisualShaderNodeUVFunc.Function) {
}
VisualShaderNodeUVFunc_get_function :: (using self: *VisualShaderNodeUVFunc) -> VisualShaderNodeUVFunc.Function {
}

// VisualShaderNodeUVPolarCoord
VisualShaderNodeUVPolarCoord :: struct {
	__private: *void;
}

// VisualShaderNodeVarying
VisualShaderNodeVarying :: struct {
	__private: *void;
}

VisualShaderNodeVarying_set_varying_name :: (using self: *VisualShaderNodeVarying, name: String) {
}
VisualShaderNodeVarying_get_varying_name :: (using self: *VisualShaderNodeVarying) -> String {
}
VisualShaderNodeVarying_set_varying_type :: (using self: *VisualShaderNodeVarying, type: VisualShader.VaryingType) {
}
VisualShaderNodeVarying_get_varying_type :: (using self: *VisualShaderNodeVarying) -> VisualShader.VaryingType {
}

// VisualShaderNodeVaryingGetter
VisualShaderNodeVaryingGetter :: struct {
	__private: *void;
}

// VisualShaderNodeVaryingSetter
VisualShaderNodeVaryingSetter :: struct {
	__private: *void;
}

// VisualShaderNodeVec2Constant
VisualShaderNodeVec2Constant :: struct {
	__private: *void;
}

VisualShaderNodeVec2Constant_set_constant :: (using self: *VisualShaderNodeVec2Constant, constant: Vector2) {
}
VisualShaderNodeVec2Constant_get_constant :: (using self: *VisualShaderNodeVec2Constant) -> Vector2 {
}

// VisualShaderNodeVec2Parameter
VisualShaderNodeVec2Parameter :: struct {
	__private: *void;
}

VisualShaderNodeVec2Parameter_set_default_value_enabled :: (using self: *VisualShaderNodeVec2Parameter, enabled: bool) {
}
VisualShaderNodeVec2Parameter_is_default_value_enabled :: (using self: *VisualShaderNodeVec2Parameter) -> bool {
}
VisualShaderNodeVec2Parameter_set_default_value :: (using self: *VisualShaderNodeVec2Parameter, value: Vector2) {
}
VisualShaderNodeVec2Parameter_get_default_value :: (using self: *VisualShaderNodeVec2Parameter) -> Vector2 {
}

// VisualShaderNodeVec3Constant
VisualShaderNodeVec3Constant :: struct {
	__private: *void;
}

VisualShaderNodeVec3Constant_set_constant :: (using self: *VisualShaderNodeVec3Constant, constant: Vector3) {
}
VisualShaderNodeVec3Constant_get_constant :: (using self: *VisualShaderNodeVec3Constant) -> Vector3 {
}

// VisualShaderNodeVec3Parameter
VisualShaderNodeVec3Parameter :: struct {
	__private: *void;
}

VisualShaderNodeVec3Parameter_set_default_value_enabled :: (using self: *VisualShaderNodeVec3Parameter, enabled: bool) {
}
VisualShaderNodeVec3Parameter_is_default_value_enabled :: (using self: *VisualShaderNodeVec3Parameter) -> bool {
}
VisualShaderNodeVec3Parameter_set_default_value :: (using self: *VisualShaderNodeVec3Parameter, value: Vector3) {
}
VisualShaderNodeVec3Parameter_get_default_value :: (using self: *VisualShaderNodeVec3Parameter) -> Vector3 {
}

// VisualShaderNodeVec4Constant
VisualShaderNodeVec4Constant :: struct {
	__private: *void;
}

VisualShaderNodeVec4Constant_set_constant :: (using self: *VisualShaderNodeVec4Constant, constant: Quaternion) {
}
VisualShaderNodeVec4Constant_get_constant :: (using self: *VisualShaderNodeVec4Constant) -> Quaternion {
}

// VisualShaderNodeVec4Parameter
VisualShaderNodeVec4Parameter :: struct {
	__private: *void;
}

VisualShaderNodeVec4Parameter_set_default_value_enabled :: (using self: *VisualShaderNodeVec4Parameter, enabled: bool) {
}
VisualShaderNodeVec4Parameter_is_default_value_enabled :: (using self: *VisualShaderNodeVec4Parameter) -> bool {
}
VisualShaderNodeVec4Parameter_set_default_value :: (using self: *VisualShaderNodeVec4Parameter, value: Vector4) {
}
VisualShaderNodeVec4Parameter_get_default_value :: (using self: *VisualShaderNodeVec4Parameter) -> Vector4 {
}

// VisualShaderNodeVectorBase
VisualShaderNodeVectorBase :: struct {
	__private: *void;

	OpType :: enum {
		OP_TYPE_VECTOR_2D :: 0;
		OP_TYPE_VECTOR_3D :: 1;
		OP_TYPE_VECTOR_4D :: 2;
		OP_TYPE_MAX :: 3;
	}
}

VisualShaderNodeVectorBase_set_op_type :: (using self: *VisualShaderNodeVectorBase, type: VisualShaderNodeVectorBase.OpType) {
}
VisualShaderNodeVectorBase_get_op_type :: (using self: *VisualShaderNodeVectorBase) -> VisualShaderNodeVectorBase.OpType {
}

// VisualShaderNodeVectorCompose
VisualShaderNodeVectorCompose :: struct {
	__private: *void;
}

// VisualShaderNodeVectorDecompose
VisualShaderNodeVectorDecompose :: struct {
	__private: *void;
}

// VisualShaderNodeVectorDistance
VisualShaderNodeVectorDistance :: struct {
	__private: *void;
}

// VisualShaderNodeVectorFunc
VisualShaderNodeVectorFunc :: struct {
	__private: *void;

	Function :: enum {
		FUNC_NORMALIZE :: 0;
		FUNC_SATURATE :: 1;
		FUNC_NEGATE :: 2;
		FUNC_RECIPROCAL :: 3;
		FUNC_ABS :: 4;
		FUNC_ACOS :: 5;
		FUNC_ACOSH :: 6;
		FUNC_ASIN :: 7;
		FUNC_ASINH :: 8;
		FUNC_ATAN :: 9;
		FUNC_ATANH :: 10;
		FUNC_CEIL :: 11;
		FUNC_COS :: 12;
		FUNC_COSH :: 13;
		FUNC_DEGREES :: 14;
		FUNC_EXP :: 15;
		FUNC_EXP2 :: 16;
		FUNC_FLOOR :: 17;
		FUNC_FRACT :: 18;
		FUNC_INVERSE_SQRT :: 19;
		FUNC_LOG :: 20;
		FUNC_LOG2 :: 21;
		FUNC_RADIANS :: 22;
		FUNC_ROUND :: 23;
		FUNC_ROUNDEVEN :: 24;
		FUNC_SIGN :: 25;
		FUNC_SIN :: 26;
		FUNC_SINH :: 27;
		FUNC_SQRT :: 28;
		FUNC_TAN :: 29;
		FUNC_TANH :: 30;
		FUNC_TRUNC :: 31;
		FUNC_ONEMINUS :: 32;
		FUNC_MAX :: 33;
	}
}

VisualShaderNodeVectorFunc_set_function :: (using self: *VisualShaderNodeVectorFunc, func: VisualShaderNodeVectorFunc.Function) {
}
VisualShaderNodeVectorFunc_get_function :: (using self: *VisualShaderNodeVectorFunc) -> VisualShaderNodeVectorFunc.Function {
}

// VisualShaderNodeVectorLen
VisualShaderNodeVectorLen :: struct {
	__private: *void;
}

// VisualShaderNodeVectorOp
VisualShaderNodeVectorOp :: struct {
	__private: *void;

	Operator :: enum {
		OP_ADD :: 0;
		OP_SUB :: 1;
		OP_MUL :: 2;
		OP_DIV :: 3;
		OP_MOD :: 4;
		OP_POW :: 5;
		OP_MAX :: 6;
		OP_MIN :: 7;
		OP_CROSS :: 8;
		OP_ATAN2 :: 9;
		OP_REFLECT :: 10;
		OP_STEP :: 11;
		OP_ENUM_SIZE :: 12;
	}
}

VisualShaderNodeVectorOp_set_operator :: (using self: *VisualShaderNodeVectorOp, op: VisualShaderNodeVectorOp.Operator) {
}
VisualShaderNodeVectorOp_get_operator :: (using self: *VisualShaderNodeVectorOp) -> VisualShaderNodeVectorOp.Operator {
}

// VisualShaderNodeVectorRefract
VisualShaderNodeVectorRefract :: struct {
	__private: *void;
}

// VisualShaderNodeWorldPositionFromDepth
VisualShaderNodeWorldPositionFromDepth :: struct {
	__private: *void;
}

// VoxelGI
VoxelGI :: struct {
	__private: *void;

	Subdiv :: enum {
		SUBDIV_64 :: 0;
		SUBDIV_128 :: 1;
		SUBDIV_256 :: 2;
		SUBDIV_512 :: 3;
		SUBDIV_MAX :: 4;
	}
}

VoxelGI_set_probe_data :: (using self: *VoxelGI, data: VoxelGIData) {
}
VoxelGI_get_probe_data :: (using self: *VoxelGI) -> VoxelGIData {
}
VoxelGI_set_subdiv :: (using self: *VoxelGI, subdiv: VoxelGI.Subdiv) {
}
VoxelGI_get_subdiv :: (using self: *VoxelGI) -> VoxelGI.Subdiv {
}
VoxelGI_set_size :: (using self: *VoxelGI, size: Vector3) {
}
VoxelGI_get_size :: (using self: *VoxelGI) -> Vector3 {
}
VoxelGI_set_camera_attributes :: (using self: *VoxelGI, camera_attributes: CameraAttributes) {
}
VoxelGI_get_camera_attributes :: (using self: *VoxelGI) -> CameraAttributes {
}
VoxelGI_bake :: (using self: *VoxelGI, from_node: Node, create_visual_debug: bool) {
}
VoxelGI_debug_bake :: (using self: *VoxelGI) {
}

// VoxelGIData
VoxelGIData :: struct {
	__private: *void;
}

VoxelGIData_allocate :: (using self: *VoxelGIData, to_cell_xform: Transform3D, aabb: AABB, octree_size: Vector3, octree_cells: PackedByteArray, data_cells: PackedByteArray, distance_field: PackedByteArray, level_counts: PackedInt32Array) {
}
VoxelGIData_get_bounds :: (using self: *VoxelGIData) -> AABB {
}
VoxelGIData_get_octree_size :: (using self: *VoxelGIData) -> Vector3 {
}
VoxelGIData_get_to_cell_xform :: (using self: *VoxelGIData) -> Transform3D {
}
VoxelGIData_get_octree_cells :: (using self: *VoxelGIData) -> PackedByteArray {
}
VoxelGIData_get_data_cells :: (using self: *VoxelGIData) -> PackedByteArray {
}
VoxelGIData_get_level_counts :: (using self: *VoxelGIData) -> PackedInt32Array {
}
VoxelGIData_set_dynamic_range :: (using self: *VoxelGIData, dynamic_range: float) {
}
VoxelGIData_get_dynamic_range :: (using self: *VoxelGIData) -> float {
}
VoxelGIData_set_energy :: (using self: *VoxelGIData, energy: float) {
}
VoxelGIData_get_energy :: (using self: *VoxelGIData) -> float {
}
VoxelGIData_set_bias :: (using self: *VoxelGIData, bias: float) {
}
VoxelGIData_get_bias :: (using self: *VoxelGIData) -> float {
}
VoxelGIData_set_normal_bias :: (using self: *VoxelGIData, bias: float) {
}
VoxelGIData_get_normal_bias :: (using self: *VoxelGIData) -> float {
}
VoxelGIData_set_propagation :: (using self: *VoxelGIData, propagation: float) {
}
VoxelGIData_get_propagation :: (using self: *VoxelGIData) -> float {
}
VoxelGIData_set_interior :: (using self: *VoxelGIData, interior: bool) {
}
VoxelGIData_is_interior :: (using self: *VoxelGIData) -> bool {
}
VoxelGIData_set_use_two_bounces :: (using self: *VoxelGIData, enable: bool) {
}
VoxelGIData_is_using_two_bounces :: (using self: *VoxelGIData) -> bool {
}

// WeakRef
WeakRef :: struct {
	__private: *void;
}

WeakRef_get_ref :: (using self: *WeakRef) -> Variant {
}

// WebRTCDataChannel
WebRTCDataChannel :: struct {
	__private: *void;

	WriteMode :: enum {
		WRITE_MODE_TEXT :: 0;
		WRITE_MODE_BINARY :: 1;
	}
	ChannelState :: enum {
		STATE_CONNECTING :: 0;
		STATE_OPEN :: 1;
		STATE_CLOSING :: 2;
		STATE_CLOSED :: 3;
	}
}

WebRTCDataChannel_poll :: (using self: *WebRTCDataChannel) -> Error {
}
WebRTCDataChannel_close :: (using self: *WebRTCDataChannel) {
}
WebRTCDataChannel_was_string_packet :: (using self: *WebRTCDataChannel) -> bool {
}
WebRTCDataChannel_set_write_mode :: (using self: *WebRTCDataChannel, write_mode: WebRTCDataChannel.WriteMode) {
}
WebRTCDataChannel_get_write_mode :: (using self: *WebRTCDataChannel) -> WebRTCDataChannel.WriteMode {
}
WebRTCDataChannel_get_ready_state :: (using self: *WebRTCDataChannel) -> WebRTCDataChannel.ChannelState {
}
WebRTCDataChannel_get_label :: (using self: *WebRTCDataChannel) -> String {
}
WebRTCDataChannel_is_ordered :: (using self: *WebRTCDataChannel) -> bool {
}
WebRTCDataChannel_get_id :: (using self: *WebRTCDataChannel) -> int {
}
WebRTCDataChannel_get_max_packet_life_time :: (using self: *WebRTCDataChannel) -> int {
}
WebRTCDataChannel_get_max_retransmits :: (using self: *WebRTCDataChannel) -> int {
}
WebRTCDataChannel_get_protocol :: (using self: *WebRTCDataChannel) -> String {
}
WebRTCDataChannel_is_negotiated :: (using self: *WebRTCDataChannel) -> bool {
}
WebRTCDataChannel_get_buffered_amount :: (using self: *WebRTCDataChannel) -> int {
}

// WebRTCDataChannelExtension
WebRTCDataChannelExtension :: struct {
	__private: *void;
}

WebRTCDataChannelExtension__get_packet :: (using self: *WebRTCDataChannelExtension, r_buffer: **u8, r_buffer_size: *s32) -> Error {
}
WebRTCDataChannelExtension__put_packet :: (using self: *WebRTCDataChannelExtension, p_buffer: *u8, p_buffer_size: int) -> Error {
}
WebRTCDataChannelExtension__get_available_packet_count :: (using self: *WebRTCDataChannelExtension) -> int {
}
WebRTCDataChannelExtension__get_max_packet_size :: (using self: *WebRTCDataChannelExtension) -> int {
}
WebRTCDataChannelExtension__poll :: (using self: *WebRTCDataChannelExtension) -> Error {
}
WebRTCDataChannelExtension__close :: (using self: *WebRTCDataChannelExtension) {
}
WebRTCDataChannelExtension__set_write_mode :: (using self: *WebRTCDataChannelExtension, p_write_mode: WebRTCDataChannel.WriteMode) {
}
WebRTCDataChannelExtension__get_write_mode :: (using self: *WebRTCDataChannelExtension) -> WebRTCDataChannel.WriteMode {
}
WebRTCDataChannelExtension__was_string_packet :: (using self: *WebRTCDataChannelExtension) -> bool {
}
WebRTCDataChannelExtension__get_ready_state :: (using self: *WebRTCDataChannelExtension) -> WebRTCDataChannel.ChannelState {
}
WebRTCDataChannelExtension__get_label :: (using self: *WebRTCDataChannelExtension) -> String {
}
WebRTCDataChannelExtension__is_ordered :: (using self: *WebRTCDataChannelExtension) -> bool {
}
WebRTCDataChannelExtension__get_id :: (using self: *WebRTCDataChannelExtension) -> int {
}
WebRTCDataChannelExtension__get_max_packet_life_time :: (using self: *WebRTCDataChannelExtension) -> int {
}
WebRTCDataChannelExtension__get_max_retransmits :: (using self: *WebRTCDataChannelExtension) -> int {
}
WebRTCDataChannelExtension__get_protocol :: (using self: *WebRTCDataChannelExtension) -> String {
}
WebRTCDataChannelExtension__is_negotiated :: (using self: *WebRTCDataChannelExtension) -> bool {
}
WebRTCDataChannelExtension__get_buffered_amount :: (using self: *WebRTCDataChannelExtension) -> int {
}

// WebRTCMultiplayerPeer
WebRTCMultiplayerPeer :: struct {
	__private: *void;
}

WebRTCMultiplayerPeer_create_server :: (using self: *WebRTCMultiplayerPeer, channels_config: Array) -> Error {
}
WebRTCMultiplayerPeer_create_client :: (using self: *WebRTCMultiplayerPeer, peer_id: int, channels_config: Array) -> Error {
}
WebRTCMultiplayerPeer_create_mesh :: (using self: *WebRTCMultiplayerPeer, peer_id: int, channels_config: Array) -> Error {
}
WebRTCMultiplayerPeer_add_peer :: (using self: *WebRTCMultiplayerPeer, peer: WebRTCPeerConnection, peer_id: int, unreliable_lifetime: int) -> Error {
}
WebRTCMultiplayerPeer_remove_peer :: (using self: *WebRTCMultiplayerPeer, peer_id: int) {
}
WebRTCMultiplayerPeer_has_peer :: (using self: *WebRTCMultiplayerPeer, peer_id: int) -> bool {
}
WebRTCMultiplayerPeer_get_peer :: (using self: *WebRTCMultiplayerPeer, peer_id: int) -> Dictionary {
}
WebRTCMultiplayerPeer_get_peers :: (using self: *WebRTCMultiplayerPeer) -> Dictionary {
}

// WebRTCPeerConnection
WebRTCPeerConnection :: struct {
	__private: *void;

	ConnectionState :: enum {
		STATE_NEW :: 0;
		STATE_CONNECTING :: 1;
		STATE_CONNECTED :: 2;
		STATE_DISCONNECTED :: 3;
		STATE_FAILED :: 4;
		STATE_CLOSED :: 5;
	}
	GatheringState :: enum {
		GATHERING_STATE_NEW :: 0;
		GATHERING_STATE_GATHERING :: 1;
		GATHERING_STATE_COMPLETE :: 2;
	}
	SignalingState :: enum {
		SIGNALING_STATE_STABLE :: 0;
		SIGNALING_STATE_HAVE_LOCAL_OFFER :: 1;
		SIGNALING_STATE_HAVE_REMOTE_OFFER :: 2;
		SIGNALING_STATE_HAVE_LOCAL_PRANSWER :: 3;
		SIGNALING_STATE_HAVE_REMOTE_PRANSWER :: 4;
		SIGNALING_STATE_CLOSED :: 5;
	}
}

WebRTCPeerConnection_set_default_extension :: (using self: *WebRTCPeerConnection, extension_class: StringName) {
}
WebRTCPeerConnection_initialize :: (using self: *WebRTCPeerConnection, configuration: Dictionary) -> Error {
}
WebRTCPeerConnection_create_data_channel :: (using self: *WebRTCPeerConnection, label: String, options: Dictionary) -> WebRTCDataChannel {
}
WebRTCPeerConnection_create_offer :: (using self: *WebRTCPeerConnection) -> Error {
}
WebRTCPeerConnection_set_local_description :: (using self: *WebRTCPeerConnection, type: String, sdp: String) -> Error {
}
WebRTCPeerConnection_set_remote_description :: (using self: *WebRTCPeerConnection, type: String, sdp: String) -> Error {
}
WebRTCPeerConnection_add_ice_candidate :: (using self: *WebRTCPeerConnection, media: String, index: int, name: String) -> Error {
}
WebRTCPeerConnection_poll :: (using self: *WebRTCPeerConnection) -> Error {
}
WebRTCPeerConnection_close :: (using self: *WebRTCPeerConnection) {
}
WebRTCPeerConnection_get_connection_state :: (using self: *WebRTCPeerConnection) -> WebRTCPeerConnection.ConnectionState {
}
WebRTCPeerConnection_get_gathering_state :: (using self: *WebRTCPeerConnection) -> WebRTCPeerConnection.GatheringState {
}
WebRTCPeerConnection_get_signaling_state :: (using self: *WebRTCPeerConnection) -> WebRTCPeerConnection.SignalingState {
}

// WebRTCPeerConnectionExtension
WebRTCPeerConnectionExtension :: struct {
	__private: *void;
}

WebRTCPeerConnectionExtension__get_connection_state :: (using self: *WebRTCPeerConnectionExtension) -> WebRTCPeerConnection.ConnectionState {
}
WebRTCPeerConnectionExtension__get_gathering_state :: (using self: *WebRTCPeerConnectionExtension) -> WebRTCPeerConnection.GatheringState {
}
WebRTCPeerConnectionExtension__get_signaling_state :: (using self: *WebRTCPeerConnectionExtension) -> WebRTCPeerConnection.SignalingState {
}
WebRTCPeerConnectionExtension__initialize :: (using self: *WebRTCPeerConnectionExtension, p_config: Dictionary) -> Error {
}
WebRTCPeerConnectionExtension__create_data_channel :: (using self: *WebRTCPeerConnectionExtension, p_label: String, p_config: Dictionary) -> WebRTCDataChannel {
}
WebRTCPeerConnectionExtension__create_offer :: (using self: *WebRTCPeerConnectionExtension) -> Error {
}
WebRTCPeerConnectionExtension__set_remote_description :: (using self: *WebRTCPeerConnectionExtension, p_type: String, p_sdp: String) -> Error {
}
WebRTCPeerConnectionExtension__set_local_description :: (using self: *WebRTCPeerConnectionExtension, p_type: String, p_sdp: String) -> Error {
}
WebRTCPeerConnectionExtension__add_ice_candidate :: (using self: *WebRTCPeerConnectionExtension, p_sdp_mid_name: String, p_sdp_mline_index: int, p_sdp_name: String) -> Error {
}
WebRTCPeerConnectionExtension__poll :: (using self: *WebRTCPeerConnectionExtension) -> Error {
}
WebRTCPeerConnectionExtension__close :: (using self: *WebRTCPeerConnectionExtension) {
}

// WebSocketMultiplayerPeer
WebSocketMultiplayerPeer :: struct {
	__private: *void;
}

WebSocketMultiplayerPeer_create_client :: (using self: *WebSocketMultiplayerPeer, url: String, tls_client_options: TLSOptions) -> Error {
}
WebSocketMultiplayerPeer_create_server :: (using self: *WebSocketMultiplayerPeer, port: int, bind_address: String, tls_server_options: TLSOptions) -> Error {
}
WebSocketMultiplayerPeer_get_peer :: (using self: *WebSocketMultiplayerPeer, peer_id: int) -> WebSocketPeer {
}
WebSocketMultiplayerPeer_get_peer_address :: (using self: *WebSocketMultiplayerPeer, id: int) -> String {
}
WebSocketMultiplayerPeer_get_peer_port :: (using self: *WebSocketMultiplayerPeer, id: int) -> int {
}
WebSocketMultiplayerPeer_get_supported_protocols :: (using self: *WebSocketMultiplayerPeer) -> PackedStringArray {
}
WebSocketMultiplayerPeer_set_supported_protocols :: (using self: *WebSocketMultiplayerPeer, protocols: PackedStringArray) {
}
WebSocketMultiplayerPeer_get_handshake_headers :: (using self: *WebSocketMultiplayerPeer) -> PackedStringArray {
}
WebSocketMultiplayerPeer_set_handshake_headers :: (using self: *WebSocketMultiplayerPeer, protocols: PackedStringArray) {
}
WebSocketMultiplayerPeer_get_inbound_buffer_size :: (using self: *WebSocketMultiplayerPeer) -> int {
}
WebSocketMultiplayerPeer_set_inbound_buffer_size :: (using self: *WebSocketMultiplayerPeer, buffer_size: int) {
}
WebSocketMultiplayerPeer_get_outbound_buffer_size :: (using self: *WebSocketMultiplayerPeer) -> int {
}
WebSocketMultiplayerPeer_set_outbound_buffer_size :: (using self: *WebSocketMultiplayerPeer, buffer_size: int) {
}
WebSocketMultiplayerPeer_get_handshake_timeout :: (using self: *WebSocketMultiplayerPeer) -> float {
}
WebSocketMultiplayerPeer_set_handshake_timeout :: (using self: *WebSocketMultiplayerPeer, timeout: float) {
}
WebSocketMultiplayerPeer_set_max_queued_packets :: (using self: *WebSocketMultiplayerPeer, max_queued_packets: int) {
}
WebSocketMultiplayerPeer_get_max_queued_packets :: (using self: *WebSocketMultiplayerPeer) -> int {
}

// WebSocketPeer
WebSocketPeer :: struct {
	__private: *void;

	WriteMode :: enum {
		WRITE_MODE_TEXT :: 0;
		WRITE_MODE_BINARY :: 1;
	}
	State :: enum {
		STATE_CONNECTING :: 0;
		STATE_OPEN :: 1;
		STATE_CLOSING :: 2;
		STATE_CLOSED :: 3;
	}
}

WebSocketPeer_connect_to_url :: (using self: *WebSocketPeer, url: String, tls_client_options: TLSOptions) -> Error {
}
WebSocketPeer_accept_stream :: (using self: *WebSocketPeer, stream: StreamPeer) -> Error {
}
WebSocketPeer_send :: (using self: *WebSocketPeer, message: PackedByteArray, write_mode: WebSocketPeer.WriteMode) -> Error {
}
WebSocketPeer_send_text :: (using self: *WebSocketPeer, message: String) -> Error {
}
WebSocketPeer_was_string_packet :: (using self: *WebSocketPeer) -> bool {
}
WebSocketPeer_poll :: (using self: *WebSocketPeer) {
}
WebSocketPeer_close :: (using self: *WebSocketPeer, code: int, reason: String) {
}
WebSocketPeer_get_connected_host :: (using self: *WebSocketPeer) -> String {
}
WebSocketPeer_get_connected_port :: (using self: *WebSocketPeer) -> int {
}
WebSocketPeer_get_selected_protocol :: (using self: *WebSocketPeer) -> String {
}
WebSocketPeer_get_requested_url :: (using self: *WebSocketPeer) -> String {
}
WebSocketPeer_set_no_delay :: (using self: *WebSocketPeer, enabled: bool) {
}
WebSocketPeer_get_current_outbound_buffered_amount :: (using self: *WebSocketPeer) -> int {
}
WebSocketPeer_get_ready_state :: (using self: *WebSocketPeer) -> WebSocketPeer.State {
}
WebSocketPeer_get_close_code :: (using self: *WebSocketPeer) -> int {
}
WebSocketPeer_get_close_reason :: (using self: *WebSocketPeer) -> String {
}
WebSocketPeer_get_supported_protocols :: (using self: *WebSocketPeer) -> PackedStringArray {
}
WebSocketPeer_set_supported_protocols :: (using self: *WebSocketPeer, protocols: PackedStringArray) {
}
WebSocketPeer_get_handshake_headers :: (using self: *WebSocketPeer) -> PackedStringArray {
}
WebSocketPeer_set_handshake_headers :: (using self: *WebSocketPeer, protocols: PackedStringArray) {
}
WebSocketPeer_get_inbound_buffer_size :: (using self: *WebSocketPeer) -> int {
}
WebSocketPeer_set_inbound_buffer_size :: (using self: *WebSocketPeer, buffer_size: int) {
}
WebSocketPeer_get_outbound_buffer_size :: (using self: *WebSocketPeer) -> int {
}
WebSocketPeer_set_outbound_buffer_size :: (using self: *WebSocketPeer, buffer_size: int) {
}
WebSocketPeer_set_max_queued_packets :: (using self: *WebSocketPeer, buffer_size: int) {
}
WebSocketPeer_get_max_queued_packets :: (using self: *WebSocketPeer) -> int {
}

// WebXRInterface
WebXRInterface :: struct {
	__private: *void;

	TargetRayMode :: enum {
		TARGET_RAY_MODE_UNKNOWN :: 0;
		TARGET_RAY_MODE_GAZE :: 1;
		TARGET_RAY_MODE_TRACKED_POINTER :: 2;
		TARGET_RAY_MODE_SCREEN :: 3;
	}
}

WebXRInterface_is_session_supported :: (using self: *WebXRInterface, session_mode: String) {
}
WebXRInterface_set_session_mode :: (using self: *WebXRInterface, session_mode: String) {
}
WebXRInterface_get_session_mode :: (using self: *WebXRInterface) -> String {
}
WebXRInterface_set_required_features :: (using self: *WebXRInterface, required_features: String) {
}
WebXRInterface_get_required_features :: (using self: *WebXRInterface) -> String {
}
WebXRInterface_set_optional_features :: (using self: *WebXRInterface, optional_features: String) {
}
WebXRInterface_get_optional_features :: (using self: *WebXRInterface) -> String {
}
WebXRInterface_get_reference_space_type :: (using self: *WebXRInterface) -> String {
}
WebXRInterface_get_enabled_features :: (using self: *WebXRInterface) -> String {
}
WebXRInterface_set_requested_reference_space_types :: (using self: *WebXRInterface, requested_reference_space_types: String) {
}
WebXRInterface_get_requested_reference_space_types :: (using self: *WebXRInterface) -> String {
}
WebXRInterface_is_input_source_active :: (using self: *WebXRInterface, input_source_id: int) -> bool {
}
WebXRInterface_get_input_source_tracker :: (using self: *WebXRInterface, input_source_id: int) -> XRControllerTracker {
}
WebXRInterface_get_input_source_target_ray_mode :: (using self: *WebXRInterface, input_source_id: int) -> WebXRInterface.TargetRayMode {
}
WebXRInterface_get_visibility_state :: (using self: *WebXRInterface) -> String {
}
WebXRInterface_get_display_refresh_rate :: (using self: *WebXRInterface) -> float {
}
WebXRInterface_set_display_refresh_rate :: (using self: *WebXRInterface, refresh_rate: float) {
}
WebXRInterface_get_available_display_refresh_rates :: (using self: *WebXRInterface) -> Array {
}

// Window
Window :: struct {
	__private: *void;

	NOTIFICATION_VISIBILITY_CHANGED :: 30;
	NOTIFICATION_THEME_CHANGED :: 32;

	Mode :: enum {
		MODE_WINDOWED :: 0;
		MODE_MINIMIZED :: 1;
		MODE_MAXIMIZED :: 2;
		MODE_FULLSCREEN :: 3;
		MODE_EXCLUSIVE_FULLSCREEN :: 4;
	}
	Flags :: enum {
		FLAG_RESIZE_DISABLED :: 0;
		FLAG_BORDERLESS :: 1;
		FLAG_ALWAYS_ON_TOP :: 2;
		FLAG_TRANSPARENT :: 3;
		FLAG_NO_FOCUS :: 4;
		FLAG_POPUP :: 5;
		FLAG_EXTEND_TO_TITLE :: 6;
		FLAG_MOUSE_PASSTHROUGH :: 7;
		FLAG_MAX :: 8;
	}
	ContentScaleMode :: enum {
		CONTENT_SCALE_MODE_DISABLED :: 0;
		CONTENT_SCALE_MODE_CANVAS_ITEMS :: 1;
		CONTENT_SCALE_MODE_VIEWPORT :: 2;
	}
	ContentScaleAspect :: enum {
		CONTENT_SCALE_ASPECT_IGNORE :: 0;
		CONTENT_SCALE_ASPECT_KEEP :: 1;
		CONTENT_SCALE_ASPECT_KEEP_WIDTH :: 2;
		CONTENT_SCALE_ASPECT_KEEP_HEIGHT :: 3;
		CONTENT_SCALE_ASPECT_EXPAND :: 4;
	}
	ContentScaleStretch :: enum {
		CONTENT_SCALE_STRETCH_FRACTIONAL :: 0;
		CONTENT_SCALE_STRETCH_INTEGER :: 1;
	}
	LayoutDirection :: enum {
		LAYOUT_DIRECTION_INHERITED :: 0;
		LAYOUT_DIRECTION_LOCALE :: 1;
		LAYOUT_DIRECTION_LTR :: 2;
		LAYOUT_DIRECTION_RTL :: 3;
	}
	WindowInitialPosition :: enum {
		WINDOW_INITIAL_POSITION_ABSOLUTE :: 0;
		WINDOW_INITIAL_POSITION_CENTER_PRIMARY_SCREEN :: 1;
		WINDOW_INITIAL_POSITION_CENTER_MAIN_WINDOW_SCREEN :: 2;
		WINDOW_INITIAL_POSITION_CENTER_OTHER_SCREEN :: 3;
		WINDOW_INITIAL_POSITION_CENTER_SCREEN_WITH_MOUSE_FOCUS :: 4;
		WINDOW_INITIAL_POSITION_CENTER_SCREEN_WITH_KEYBOARD_FOCUS :: 5;
	}
}

Window__get_contents_minimum_size :: (using self: *Window) -> Vector2 {
}
Window_set_title :: (using self: *Window, title: String) {
}
Window_get_title :: (using self: *Window) -> String {
}
Window_get_window_id :: (using self: *Window) -> int {
}
Window_set_initial_position :: (using self: *Window, initial_position: Window.WindowInitialPosition) {
}
Window_get_initial_position :: (using self: *Window) -> Window.WindowInitialPosition {
}
Window_set_current_screen :: (using self: *Window, index: int) {
}
Window_get_current_screen :: (using self: *Window) -> int {
}
Window_set_position :: (using self: *Window, position: Vector2i) {
}
Window_get_position :: (using self: *Window) -> Vector2i {
}
Window_move_to_center :: (using self: *Window) {
}
Window_set_size :: (using self: *Window, size: Vector2i) {
}
Window_get_size :: (using self: *Window) -> Vector2i {
}
Window_reset_size :: (using self: *Window) {
}
Window_get_position_with_decorations :: (using self: *Window) -> Vector2i {
}
Window_get_size_with_decorations :: (using self: *Window) -> Vector2i {
}
Window_set_max_size :: (using self: *Window, max_size: Vector2i) {
}
Window_get_max_size :: (using self: *Window) -> Vector2i {
}
Window_set_min_size :: (using self: *Window, min_size: Vector2i) {
}
Window_get_min_size :: (using self: *Window) -> Vector2i {
}
Window_set_mode :: (using self: *Window, mode: Window.Mode) {
}
Window_get_mode :: (using self: *Window) -> Window.Mode {
}
Window_set_flag :: (using self: *Window, flag: Window.Flags, enabled: bool) {
}
Window_get_flag :: (using self: *Window, flag: Window.Flags) -> bool {
}
Window_is_maximize_allowed :: (using self: *Window) -> bool {
}
Window_request_attention :: (using self: *Window) {
}
Window_move_to_foreground :: (using self: *Window) {
}
Window_set_visible :: (using self: *Window, visible: bool) {
}
Window_is_visible :: (using self: *Window) -> bool {
}
Window_hide :: (using self: *Window) {
}
Window_show :: (using self: *Window) {
}
Window_set_transient :: (using self: *Window, transient: bool) {
}
Window_is_transient :: (using self: *Window) -> bool {
}
Window_set_transient_to_focused :: (using self: *Window, enable: bool) {
}
Window_is_transient_to_focused :: (using self: *Window) -> bool {
}
Window_set_exclusive :: (using self: *Window, exclusive: bool) {
}
Window_is_exclusive :: (using self: *Window) -> bool {
}
Window_set_unparent_when_invisible :: (using self: *Window, unparent: bool) {
}
Window_can_draw :: (using self: *Window) -> bool {
}
Window_has_focus :: (using self: *Window) -> bool {
}
Window_grab_focus :: (using self: *Window) {
}
Window_set_ime_active :: (using self: *Window, active: bool) {
}
Window_set_ime_position :: (using self: *Window, position: Vector2i) {
}
Window_is_embedded :: (using self: *Window) -> bool {
}
Window_get_contents_minimum_size :: (using self: *Window) -> Vector2 {
}
Window_set_force_native :: (using self: *Window, force_native: bool) {
}
Window_get_force_native :: (using self: *Window) -> bool {
}
Window_set_content_scale_size :: (using self: *Window, size: Vector2i) {
}
Window_get_content_scale_size :: (using self: *Window) -> Vector2i {
}
Window_set_content_scale_mode :: (using self: *Window, mode: Window.ContentScaleMode) {
}
Window_get_content_scale_mode :: (using self: *Window) -> Window.ContentScaleMode {
}
Window_set_content_scale_aspect :: (using self: *Window, aspect: Window.ContentScaleAspect) {
}
Window_get_content_scale_aspect :: (using self: *Window) -> Window.ContentScaleAspect {
}
Window_set_content_scale_stretch :: (using self: *Window, stretch: Window.ContentScaleStretch) {
}
Window_get_content_scale_stretch :: (using self: *Window) -> Window.ContentScaleStretch {
}
Window_set_keep_title_visible :: (using self: *Window, title_visible: bool) {
}
Window_get_keep_title_visible :: (using self: *Window) -> bool {
}
Window_set_content_scale_factor :: (using self: *Window, factor: float) {
}
Window_get_content_scale_factor :: (using self: *Window) -> float {
}
Window_set_use_font_oversampling :: (using self: *Window, enable: bool) {
}
Window_is_using_font_oversampling :: (using self: *Window) -> bool {
}
Window_set_mouse_passthrough_polygon :: (using self: *Window, polygon: PackedVector2Array) {
}
Window_get_mouse_passthrough_polygon :: (using self: *Window) -> PackedVector2Array {
}
Window_set_wrap_controls :: (using self: *Window, enable: bool) {
}
Window_is_wrapping_controls :: (using self: *Window) -> bool {
}
Window_child_controls_changed :: (using self: *Window) {
}
Window_set_theme :: (using self: *Window, theme: Theme) {
}
Window_get_theme :: (using self: *Window) -> Theme {
}
Window_set_theme_type_variation :: (using self: *Window, theme_type: StringName) {
}
Window_get_theme_type_variation :: (using self: *Window) -> StringName {
}
Window_begin_bulk_theme_override :: (using self: *Window) {
}
Window_end_bulk_theme_override :: (using self: *Window) {
}
Window_add_theme_icon_override :: (using self: *Window, name: StringName, texture: Texture2D) {
}
Window_add_theme_stylebox_override :: (using self: *Window, name: StringName, stylebox: StyleBox) {
}
Window_add_theme_font_override :: (using self: *Window, name: StringName, font: Font) {
}
Window_add_theme_font_size_override :: (using self: *Window, name: StringName, font_size: int) {
}
Window_add_theme_color_override :: (using self: *Window, name: StringName, color: Color) {
}
Window_add_theme_constant_override :: (using self: *Window, name: StringName, constant: int) {
}
Window_remove_theme_icon_override :: (using self: *Window, name: StringName) {
}
Window_remove_theme_stylebox_override :: (using self: *Window, name: StringName) {
}
Window_remove_theme_font_override :: (using self: *Window, name: StringName) {
}
Window_remove_theme_font_size_override :: (using self: *Window, name: StringName) {
}
Window_remove_theme_color_override :: (using self: *Window, name: StringName) {
}
Window_remove_theme_constant_override :: (using self: *Window, name: StringName) {
}
Window_get_theme_icon :: (using self: *Window, name: StringName, theme_type: StringName) -> Texture2D {
}
Window_get_theme_stylebox :: (using self: *Window, name: StringName, theme_type: StringName) -> StyleBox {
}
Window_get_theme_font :: (using self: *Window, name: StringName, theme_type: StringName) -> Font {
}
Window_get_theme_font_size :: (using self: *Window, name: StringName, theme_type: StringName) -> int {
}
Window_get_theme_color :: (using self: *Window, name: StringName, theme_type: StringName) -> Color {
}
Window_get_theme_constant :: (using self: *Window, name: StringName, theme_type: StringName) -> int {
}
Window_has_theme_icon_override :: (using self: *Window, name: StringName) -> bool {
}
Window_has_theme_stylebox_override :: (using self: *Window, name: StringName) -> bool {
}
Window_has_theme_font_override :: (using self: *Window, name: StringName) -> bool {
}
Window_has_theme_font_size_override :: (using self: *Window, name: StringName) -> bool {
}
Window_has_theme_color_override :: (using self: *Window, name: StringName) -> bool {
}
Window_has_theme_constant_override :: (using self: *Window, name: StringName) -> bool {
}
Window_has_theme_icon :: (using self: *Window, name: StringName, theme_type: StringName) -> bool {
}
Window_has_theme_stylebox :: (using self: *Window, name: StringName, theme_type: StringName) -> bool {
}
Window_has_theme_font :: (using self: *Window, name: StringName, theme_type: StringName) -> bool {
}
Window_has_theme_font_size :: (using self: *Window, name: StringName, theme_type: StringName) -> bool {
}
Window_has_theme_color :: (using self: *Window, name: StringName, theme_type: StringName) -> bool {
}
Window_has_theme_constant :: (using self: *Window, name: StringName, theme_type: StringName) -> bool {
}
Window_get_theme_default_base_scale :: (using self: *Window) -> float {
}
Window_get_theme_default_font :: (using self: *Window) -> Font {
}
Window_get_theme_default_font_size :: (using self: *Window) -> int {
}
Window_set_layout_direction :: (using self: *Window, direction: Window.LayoutDirection) {
}
Window_get_layout_direction :: (using self: *Window) -> Window.LayoutDirection {
}
Window_is_layout_rtl :: (using self: *Window) -> bool {
}
Window_set_auto_translate :: (using self: *Window, enable: bool) {
}
Window_is_auto_translating :: (using self: *Window) -> bool {
}
Window_popup :: (using self: *Window, rect: Rect2i) {
}
Window_popup_on_parent :: (using self: *Window, parent_rect: Rect2i) {
}
Window_popup_centered :: (using self: *Window, minsize: Vector2i) {
}
Window_popup_centered_ratio :: (using self: *Window, ratio: float) {
}
Window_popup_centered_clamped :: (using self: *Window, minsize: Vector2i, fallback_ratio: float) {
}
Window_popup_exclusive :: (using self: *Window, from_node: Node, rect: Rect2i) {
}
Window_popup_exclusive_on_parent :: (using self: *Window, from_node: Node, parent_rect: Rect2i) {
}
Window_popup_exclusive_centered :: (using self: *Window, from_node: Node, minsize: Vector2i) {
}
Window_popup_exclusive_centered_ratio :: (using self: *Window, from_node: Node, ratio: float) {
}
Window_popup_exclusive_centered_clamped :: (using self: *Window, from_node: Node, minsize: Vector2i, fallback_ratio: float) {
}

// WorkerThreadPool
WorkerThreadPool :: struct {
	__private: *void;
}

WorkerThreadPool_add_task :: (using self: *WorkerThreadPool, action: Callable, high_priority: bool, description: String) -> int {
}
WorkerThreadPool_is_task_completed :: (using self: *WorkerThreadPool, task_id: int) -> bool {
}
WorkerThreadPool_wait_for_task_completion :: (using self: *WorkerThreadPool, task_id: int) -> Error {
}
WorkerThreadPool_add_group_task :: (using self: *WorkerThreadPool, action: Callable, elements: int, tasks_needed: int, high_priority: bool, description: String) -> int {
}
WorkerThreadPool_is_group_task_completed :: (using self: *WorkerThreadPool, group_id: int) -> bool {
}
WorkerThreadPool_get_group_processed_element_count :: (using self: *WorkerThreadPool, group_id: int) -> int {
}
WorkerThreadPool_wait_for_group_task_completion :: (using self: *WorkerThreadPool, group_id: int) {
}

// World2D
World2D :: struct {
	__private: *void;
}

World2D_get_canvas :: (using self: *World2D) -> RID {
}
World2D_get_space :: (using self: *World2D) -> RID {
}
World2D_get_navigation_map :: (using self: *World2D) -> RID {
}
World2D_get_direct_space_state :: (using self: *World2D) -> PhysicsDirectSpaceState2D {
}

// World3D
World3D :: struct {
	__private: *void;
}

World3D_get_space :: (using self: *World3D) -> RID {
}
World3D_get_navigation_map :: (using self: *World3D) -> RID {
}
World3D_get_scenario :: (using self: *World3D) -> RID {
}
World3D_set_environment :: (using self: *World3D, env: Environment) {
}
World3D_get_environment :: (using self: *World3D) -> Environment {
}
World3D_set_fallback_environment :: (using self: *World3D, env: Environment) {
}
World3D_get_fallback_environment :: (using self: *World3D) -> Environment {
}
World3D_set_camera_attributes :: (using self: *World3D, attributes: CameraAttributes) {
}
World3D_get_camera_attributes :: (using self: *World3D) -> CameraAttributes {
}
World3D_get_direct_space_state :: (using self: *World3D) -> PhysicsDirectSpaceState3D {
}

// WorldBoundaryShape2D
WorldBoundaryShape2D :: struct {
	__private: *void;
}

WorldBoundaryShape2D_set_normal :: (using self: *WorldBoundaryShape2D, normal: Vector2) {
}
WorldBoundaryShape2D_get_normal :: (using self: *WorldBoundaryShape2D) -> Vector2 {
}
WorldBoundaryShape2D_set_distance :: (using self: *WorldBoundaryShape2D, distance: float) {
}
WorldBoundaryShape2D_get_distance :: (using self: *WorldBoundaryShape2D) -> float {
}

// WorldBoundaryShape3D
WorldBoundaryShape3D :: struct {
	__private: *void;
}

WorldBoundaryShape3D_set_plane :: (using self: *WorldBoundaryShape3D, plane: Plane) {
}
WorldBoundaryShape3D_get_plane :: (using self: *WorldBoundaryShape3D) -> Plane {
}

// WorldEnvironment
WorldEnvironment :: struct {
	__private: *void;
}

WorldEnvironment_set_environment :: (using self: *WorldEnvironment, env: Environment) {
}
WorldEnvironment_get_environment :: (using self: *WorldEnvironment) -> Environment {
}
WorldEnvironment_set_camera_attributes :: (using self: *WorldEnvironment, camera_attributes: CameraAttributes) {
}
WorldEnvironment_get_camera_attributes :: (using self: *WorldEnvironment) -> CameraAttributes {
}
WorldEnvironment_set_compositor :: (using self: *WorldEnvironment, compositor: Compositor) {
}
WorldEnvironment_get_compositor :: (using self: *WorldEnvironment) -> Compositor {
}

// X509Certificate
X509Certificate :: struct {
	__private: *void;
}

X509Certificate_save :: (using self: *X509Certificate, path: String) -> Error {
}
X509Certificate_load :: (using self: *X509Certificate, path: String) -> Error {
}
X509Certificate_save_to_string :: (using self: *X509Certificate) -> String {
}
X509Certificate_load_from_string :: (using self: *X509Certificate, _string: String) -> Error {
}

// XMLParser
XMLParser :: struct {
	__private: *void;

	NodeType :: enum {
		NODE_NONE :: 0;
		NODE_ELEMENT :: 1;
		NODE_ELEMENT_END :: 2;
		NODE_TEXT :: 3;
		NODE_COMMENT :: 4;
		NODE_CDATA :: 5;
		NODE_UNKNOWN :: 6;
	}
}

XMLParser_read :: (using self: *XMLParser) -> Error {
}
XMLParser_get_node_type :: (using self: *XMLParser) -> XMLParser.NodeType {
}
XMLParser_get_node_name :: (using self: *XMLParser) -> String {
}
XMLParser_get_node_data :: (using self: *XMLParser) -> String {
}
XMLParser_get_node_offset :: (using self: *XMLParser) -> int {
}
XMLParser_get_attribute_count :: (using self: *XMLParser) -> int {
}
XMLParser_get_attribute_name :: (using self: *XMLParser, idx: int) -> String {
}
XMLParser_get_attribute_value :: (using self: *XMLParser, idx: int) -> String {
}
XMLParser_has_attribute :: (using self: *XMLParser, name: String) -> bool {
}
XMLParser_get_named_attribute_value :: (using self: *XMLParser, name: String) -> String {
}
XMLParser_get_named_attribute_value_safe :: (using self: *XMLParser, name: String) -> String {
}
XMLParser_is_empty :: (using self: *XMLParser) -> bool {
}
XMLParser_get_current_line :: (using self: *XMLParser) -> int {
}
XMLParser_skip_section :: (using self: *XMLParser) {
}
XMLParser_seek :: (using self: *XMLParser, position: int) -> Error {
}
XMLParser_open :: (using self: *XMLParser, file: String) -> Error {
}
XMLParser_open_buffer :: (using self: *XMLParser, buffer: PackedByteArray) -> Error {
}

// XRAnchor3D
XRAnchor3D :: struct {
	__private: *void;
}

XRAnchor3D_get_size :: (using self: *XRAnchor3D) -> Vector3 {
}
XRAnchor3D_get_plane :: (using self: *XRAnchor3D) -> Plane {
}

// XRBodyModifier3D
XRBodyModifier3D :: struct {
	__private: *void;

	BodyUpdate :: enum_flags {
		BODY_UPDATE_UPPER_BODY :: 1;
		BODY_UPDATE_LOWER_BODY :: 2;
		BODY_UPDATE_HANDS :: 4;
	}
	BoneUpdate :: enum {
		BONE_UPDATE_FULL :: 0;
		BONE_UPDATE_ROTATION_ONLY :: 1;
		BONE_UPDATE_MAX :: 2;
	}
}

XRBodyModifier3D_set_body_tracker :: (using self: *XRBodyModifier3D, tracker_name: StringName) {
}
XRBodyModifier3D_get_body_tracker :: (using self: *XRBodyModifier3D) -> StringName {
}
XRBodyModifier3D_set_body_update :: (using self: *XRBodyModifier3D, body_update: XRBodyModifier3D.BodyUpdate) {
}
XRBodyModifier3D_get_body_update :: (using self: *XRBodyModifier3D) -> XRBodyModifier3D.BodyUpdate {
}
XRBodyModifier3D_set_bone_update :: (using self: *XRBodyModifier3D, bone_update: XRBodyModifier3D.BoneUpdate) {
}
XRBodyModifier3D_get_bone_update :: (using self: *XRBodyModifier3D) -> XRBodyModifier3D.BoneUpdate {
}

// XRBodyTracker
XRBodyTracker :: struct {
	__private: *void;

	BodyFlags :: enum_flags {
		BODY_FLAG_UPPER_BODY_SUPPORTED :: 1;
		BODY_FLAG_LOWER_BODY_SUPPORTED :: 2;
		BODY_FLAG_HANDS_SUPPORTED :: 4;
	}
	Joint :: enum {
		JOINT_ROOT :: 0;
		JOINT_HIPS :: 1;
		JOINT_SPINE :: 2;
		JOINT_CHEST :: 3;
		JOINT_UPPER_CHEST :: 4;
		JOINT_NECK :: 5;
		JOINT_HEAD :: 6;
		JOINT_HEAD_TIP :: 7;
		JOINT_LEFT_SHOULDER :: 8;
		JOINT_LEFT_UPPER_ARM :: 9;
		JOINT_LEFT_LOWER_ARM :: 10;
		JOINT_RIGHT_SHOULDER :: 11;
		JOINT_RIGHT_UPPER_ARM :: 12;
		JOINT_RIGHT_LOWER_ARM :: 13;
		JOINT_LEFT_UPPER_LEG :: 14;
		JOINT_LEFT_LOWER_LEG :: 15;
		JOINT_LEFT_FOOT :: 16;
		JOINT_LEFT_TOES :: 17;
		JOINT_RIGHT_UPPER_LEG :: 18;
		JOINT_RIGHT_LOWER_LEG :: 19;
		JOINT_RIGHT_FOOT :: 20;
		JOINT_RIGHT_TOES :: 21;
		JOINT_LEFT_HAND :: 22;
		JOINT_LEFT_PALM :: 23;
		JOINT_LEFT_WRIST :: 24;
		JOINT_LEFT_THUMB_METACARPAL :: 25;
		JOINT_LEFT_THUMB_PHALANX_PROXIMAL :: 26;
		JOINT_LEFT_THUMB_PHALANX_DISTAL :: 27;
		JOINT_LEFT_THUMB_TIP :: 28;
		JOINT_LEFT_INDEX_FINGER_METACARPAL :: 29;
		JOINT_LEFT_INDEX_FINGER_PHALANX_PROXIMAL :: 30;
		JOINT_LEFT_INDEX_FINGER_PHALANX_INTERMEDIATE :: 31;
		JOINT_LEFT_INDEX_FINGER_PHALANX_DISTAL :: 32;
		JOINT_LEFT_INDEX_FINGER_TIP :: 33;
		JOINT_LEFT_MIDDLE_FINGER_METACARPAL :: 34;
		JOINT_LEFT_MIDDLE_FINGER_PHALANX_PROXIMAL :: 35;
		JOINT_LEFT_MIDDLE_FINGER_PHALANX_INTERMEDIATE :: 36;
		JOINT_LEFT_MIDDLE_FINGER_PHALANX_DISTAL :: 37;
		JOINT_LEFT_MIDDLE_FINGER_TIP :: 38;
		JOINT_LEFT_RING_FINGER_METACARPAL :: 39;
		JOINT_LEFT_RING_FINGER_PHALANX_PROXIMAL :: 40;
		JOINT_LEFT_RING_FINGER_PHALANX_INTERMEDIATE :: 41;
		JOINT_LEFT_RING_FINGER_PHALANX_DISTAL :: 42;
		JOINT_LEFT_RING_FINGER_TIP :: 43;
		JOINT_LEFT_PINKY_FINGER_METACARPAL :: 44;
		JOINT_LEFT_PINKY_FINGER_PHALANX_PROXIMAL :: 45;
		JOINT_LEFT_PINKY_FINGER_PHALANX_INTERMEDIATE :: 46;
		JOINT_LEFT_PINKY_FINGER_PHALANX_DISTAL :: 47;
		JOINT_LEFT_PINKY_FINGER_TIP :: 48;
		JOINT_RIGHT_HAND :: 49;
		JOINT_RIGHT_PALM :: 50;
		JOINT_RIGHT_WRIST :: 51;
		JOINT_RIGHT_THUMB_METACARPAL :: 52;
		JOINT_RIGHT_THUMB_PHALANX_PROXIMAL :: 53;
		JOINT_RIGHT_THUMB_PHALANX_DISTAL :: 54;
		JOINT_RIGHT_THUMB_TIP :: 55;
		JOINT_RIGHT_INDEX_FINGER_METACARPAL :: 56;
		JOINT_RIGHT_INDEX_FINGER_PHALANX_PROXIMAL :: 57;
		JOINT_RIGHT_INDEX_FINGER_PHALANX_INTERMEDIATE :: 58;
		JOINT_RIGHT_INDEX_FINGER_PHALANX_DISTAL :: 59;
		JOINT_RIGHT_INDEX_FINGER_TIP :: 60;
		JOINT_RIGHT_MIDDLE_FINGER_METACARPAL :: 61;
		JOINT_RIGHT_MIDDLE_FINGER_PHALANX_PROXIMAL :: 62;
		JOINT_RIGHT_MIDDLE_FINGER_PHALANX_INTERMEDIATE :: 63;
		JOINT_RIGHT_MIDDLE_FINGER_PHALANX_DISTAL :: 64;
		JOINT_RIGHT_MIDDLE_FINGER_TIP :: 65;
		JOINT_RIGHT_RING_FINGER_METACARPAL :: 66;
		JOINT_RIGHT_RING_FINGER_PHALANX_PROXIMAL :: 67;
		JOINT_RIGHT_RING_FINGER_PHALANX_INTERMEDIATE :: 68;
		JOINT_RIGHT_RING_FINGER_PHALANX_DISTAL :: 69;
		JOINT_RIGHT_RING_FINGER_TIP :: 70;
		JOINT_RIGHT_PINKY_FINGER_METACARPAL :: 71;
		JOINT_RIGHT_PINKY_FINGER_PHALANX_PROXIMAL :: 72;
		JOINT_RIGHT_PINKY_FINGER_PHALANX_INTERMEDIATE :: 73;
		JOINT_RIGHT_PINKY_FINGER_PHALANX_DISTAL :: 74;
		JOINT_RIGHT_PINKY_FINGER_TIP :: 75;
		JOINT_MAX :: 76;
	}
	JointFlags :: enum_flags {
		JOINT_FLAG_ORIENTATION_VALID :: 1;
		JOINT_FLAG_ORIENTATION_TRACKED :: 2;
		JOINT_FLAG_POSITION_VALID :: 4;
		JOINT_FLAG_POSITION_TRACKED :: 8;
	}
}

XRBodyTracker_set_has_tracking_data :: (using self: *XRBodyTracker, has_data: bool) {
}
XRBodyTracker_get_has_tracking_data :: (using self: *XRBodyTracker) -> bool {
}
XRBodyTracker_set_body_flags :: (using self: *XRBodyTracker, flags: XRBodyTracker.BodyFlags) {
}
XRBodyTracker_get_body_flags :: (using self: *XRBodyTracker) -> XRBodyTracker.BodyFlags {
}
XRBodyTracker_set_joint_flags :: (using self: *XRBodyTracker, joint: XRBodyTracker.Joint, flags: XRBodyTracker.JointFlags) {
}
XRBodyTracker_get_joint_flags :: (using self: *XRBodyTracker, joint: XRBodyTracker.Joint) -> XRBodyTracker.JointFlags {
}
XRBodyTracker_set_joint_transform :: (using self: *XRBodyTracker, joint: XRBodyTracker.Joint, transform: Transform3D) {
}
XRBodyTracker_get_joint_transform :: (using self: *XRBodyTracker, joint: XRBodyTracker.Joint) -> Transform3D {
}

// XRCamera3D
XRCamera3D :: struct {
	__private: *void;
}

// XRController3D
XRController3D :: struct {
	__private: *void;
}

XRController3D_is_button_pressed :: (using self: *XRController3D, name: StringName) -> bool {
}
XRController3D_get_input :: (using self: *XRController3D, name: StringName) -> Variant {
}
XRController3D_get_float :: (using self: *XRController3D, name: StringName) -> float {
}
XRController3D_get_vector2 :: (using self: *XRController3D, name: StringName) -> Vector2 {
}
XRController3D_get_tracker_hand :: (using self: *XRController3D) -> XRPositionalTracker.TrackerHand {
}

// XRControllerTracker
XRControllerTracker :: struct {
	__private: *void;
}

// XRFaceModifier3D
XRFaceModifier3D :: struct {
	__private: *void;
}

XRFaceModifier3D_set_face_tracker :: (using self: *XRFaceModifier3D, tracker_name: StringName) {
}
XRFaceModifier3D_get_face_tracker :: (using self: *XRFaceModifier3D) -> StringName {
}
XRFaceModifier3D_set_target :: (using self: *XRFaceModifier3D, target: NodePath) {
}
XRFaceModifier3D_get_target :: (using self: *XRFaceModifier3D) -> NodePath {
}

// XRFaceTracker
XRFaceTracker :: struct {
	__private: *void;

	BlendShapeEntry :: enum {
		FT_EYE_LOOK_OUT_RIGHT :: 0;
		FT_EYE_LOOK_IN_RIGHT :: 1;
		FT_EYE_LOOK_UP_RIGHT :: 2;
		FT_EYE_LOOK_DOWN_RIGHT :: 3;
		FT_EYE_LOOK_OUT_LEFT :: 4;
		FT_EYE_LOOK_IN_LEFT :: 5;
		FT_EYE_LOOK_UP_LEFT :: 6;
		FT_EYE_LOOK_DOWN_LEFT :: 7;
		FT_EYE_CLOSED_RIGHT :: 8;
		FT_EYE_CLOSED_LEFT :: 9;
		FT_EYE_SQUINT_RIGHT :: 10;
		FT_EYE_SQUINT_LEFT :: 11;
		FT_EYE_WIDE_RIGHT :: 12;
		FT_EYE_WIDE_LEFT :: 13;
		FT_EYE_DILATION_RIGHT :: 14;
		FT_EYE_DILATION_LEFT :: 15;
		FT_EYE_CONSTRICT_RIGHT :: 16;
		FT_EYE_CONSTRICT_LEFT :: 17;
		FT_BROW_PINCH_RIGHT :: 18;
		FT_BROW_PINCH_LEFT :: 19;
		FT_BROW_LOWERER_RIGHT :: 20;
		FT_BROW_LOWERER_LEFT :: 21;
		FT_BROW_INNER_UP_RIGHT :: 22;
		FT_BROW_INNER_UP_LEFT :: 23;
		FT_BROW_OUTER_UP_RIGHT :: 24;
		FT_BROW_OUTER_UP_LEFT :: 25;
		FT_NOSE_SNEER_RIGHT :: 26;
		FT_NOSE_SNEER_LEFT :: 27;
		FT_NASAL_DILATION_RIGHT :: 28;
		FT_NASAL_DILATION_LEFT :: 29;
		FT_NASAL_CONSTRICT_RIGHT :: 30;
		FT_NASAL_CONSTRICT_LEFT :: 31;
		FT_CHEEK_SQUINT_RIGHT :: 32;
		FT_CHEEK_SQUINT_LEFT :: 33;
		FT_CHEEK_PUFF_RIGHT :: 34;
		FT_CHEEK_PUFF_LEFT :: 35;
		FT_CHEEK_SUCK_RIGHT :: 36;
		FT_CHEEK_SUCK_LEFT :: 37;
		FT_JAW_OPEN :: 38;
		FT_MOUTH_CLOSED :: 39;
		FT_JAW_RIGHT :: 40;
		FT_JAW_LEFT :: 41;
		FT_JAW_FORWARD :: 42;
		FT_JAW_BACKWARD :: 43;
		FT_JAW_CLENCH :: 44;
		FT_JAW_MANDIBLE_RAISE :: 45;
		FT_LIP_SUCK_UPPER_RIGHT :: 46;
		FT_LIP_SUCK_UPPER_LEFT :: 47;
		FT_LIP_SUCK_LOWER_RIGHT :: 48;
		FT_LIP_SUCK_LOWER_LEFT :: 49;
		FT_LIP_SUCK_CORNER_RIGHT :: 50;
		FT_LIP_SUCK_CORNER_LEFT :: 51;
		FT_LIP_FUNNEL_UPPER_RIGHT :: 52;
		FT_LIP_FUNNEL_UPPER_LEFT :: 53;
		FT_LIP_FUNNEL_LOWER_RIGHT :: 54;
		FT_LIP_FUNNEL_LOWER_LEFT :: 55;
		FT_LIP_PUCKER_UPPER_RIGHT :: 56;
		FT_LIP_PUCKER_UPPER_LEFT :: 57;
		FT_LIP_PUCKER_LOWER_RIGHT :: 58;
		FT_LIP_PUCKER_LOWER_LEFT :: 59;
		FT_MOUTH_UPPER_UP_RIGHT :: 60;
		FT_MOUTH_UPPER_UP_LEFT :: 61;
		FT_MOUTH_LOWER_DOWN_RIGHT :: 62;
		FT_MOUTH_LOWER_DOWN_LEFT :: 63;
		FT_MOUTH_UPPER_DEEPEN_RIGHT :: 64;
		FT_MOUTH_UPPER_DEEPEN_LEFT :: 65;
		FT_MOUTH_UPPER_RIGHT :: 66;
		FT_MOUTH_UPPER_LEFT :: 67;
		FT_MOUTH_LOWER_RIGHT :: 68;
		FT_MOUTH_LOWER_LEFT :: 69;
		FT_MOUTH_CORNER_PULL_RIGHT :: 70;
		FT_MOUTH_CORNER_PULL_LEFT :: 71;
		FT_MOUTH_CORNER_SLANT_RIGHT :: 72;
		FT_MOUTH_CORNER_SLANT_LEFT :: 73;
		FT_MOUTH_FROWN_RIGHT :: 74;
		FT_MOUTH_FROWN_LEFT :: 75;
		FT_MOUTH_STRETCH_RIGHT :: 76;
		FT_MOUTH_STRETCH_LEFT :: 77;
		FT_MOUTH_DIMPLE_RIGHT :: 78;
		FT_MOUTH_DIMPLE_LEFT :: 79;
		FT_MOUTH_RAISER_UPPER :: 80;
		FT_MOUTH_RAISER_LOWER :: 81;
		FT_MOUTH_PRESS_RIGHT :: 82;
		FT_MOUTH_PRESS_LEFT :: 83;
		FT_MOUTH_TIGHTENER_RIGHT :: 84;
		FT_MOUTH_TIGHTENER_LEFT :: 85;
		FT_TONGUE_OUT :: 86;
		FT_TONGUE_UP :: 87;
		FT_TONGUE_DOWN :: 88;
		FT_TONGUE_RIGHT :: 89;
		FT_TONGUE_LEFT :: 90;
		FT_TONGUE_ROLL :: 91;
		FT_TONGUE_BLEND_DOWN :: 92;
		FT_TONGUE_CURL_UP :: 93;
		FT_TONGUE_SQUISH :: 94;
		FT_TONGUE_FLAT :: 95;
		FT_TONGUE_TWIST_RIGHT :: 96;
		FT_TONGUE_TWIST_LEFT :: 97;
		FT_SOFT_PALATE_CLOSE :: 98;
		FT_THROAT_SWALLOW :: 99;
		FT_NECK_FLEX_RIGHT :: 100;
		FT_NECK_FLEX_LEFT :: 101;
		FT_EYE_CLOSED :: 102;
		FT_EYE_WIDE :: 103;
		FT_EYE_SQUINT :: 104;
		FT_EYE_DILATION :: 105;
		FT_EYE_CONSTRICT :: 106;
		FT_BROW_DOWN_RIGHT :: 107;
		FT_BROW_DOWN_LEFT :: 108;
		FT_BROW_DOWN :: 109;
		FT_BROW_UP_RIGHT :: 110;
		FT_BROW_UP_LEFT :: 111;
		FT_BROW_UP :: 112;
		FT_NOSE_SNEER :: 113;
		FT_NASAL_DILATION :: 114;
		FT_NASAL_CONSTRICT :: 115;
		FT_CHEEK_PUFF :: 116;
		FT_CHEEK_SUCK :: 117;
		FT_CHEEK_SQUINT :: 118;
		FT_LIP_SUCK_UPPER :: 119;
		FT_LIP_SUCK_LOWER :: 120;
		FT_LIP_SUCK :: 121;
		FT_LIP_FUNNEL_UPPER :: 122;
		FT_LIP_FUNNEL_LOWER :: 123;
		FT_LIP_FUNNEL :: 124;
		FT_LIP_PUCKER_UPPER :: 125;
		FT_LIP_PUCKER_LOWER :: 126;
		FT_LIP_PUCKER :: 127;
		FT_MOUTH_UPPER_UP :: 128;
		FT_MOUTH_LOWER_DOWN :: 129;
		FT_MOUTH_OPEN :: 130;
		FT_MOUTH_RIGHT :: 131;
		FT_MOUTH_LEFT :: 132;
		FT_MOUTH_SMILE_RIGHT :: 133;
		FT_MOUTH_SMILE_LEFT :: 134;
		FT_MOUTH_SMILE :: 135;
		FT_MOUTH_SAD_RIGHT :: 136;
		FT_MOUTH_SAD_LEFT :: 137;
		FT_MOUTH_SAD :: 138;
		FT_MOUTH_STRETCH :: 139;
		FT_MOUTH_DIMPLE :: 140;
		FT_MOUTH_TIGHTENER :: 141;
		FT_MOUTH_PRESS :: 142;
		FT_MAX :: 143;
	}
}

XRFaceTracker_get_blend_shape :: (using self: *XRFaceTracker, blend_shape: XRFaceTracker.BlendShapeEntry) -> float {
}
XRFaceTracker_set_blend_shape :: (using self: *XRFaceTracker, blend_shape: XRFaceTracker.BlendShapeEntry, weight: float) {
}
XRFaceTracker_get_blend_shapes :: (using self: *XRFaceTracker) -> PackedFloat32Array {
}
XRFaceTracker_set_blend_shapes :: (using self: *XRFaceTracker, weights: PackedFloat32Array) {
}

// XRHandModifier3D
XRHandModifier3D :: struct {
	__private: *void;

	BoneUpdate :: enum {
		BONE_UPDATE_FULL :: 0;
		BONE_UPDATE_ROTATION_ONLY :: 1;
		BONE_UPDATE_MAX :: 2;
	}
}

XRHandModifier3D_set_hand_tracker :: (using self: *XRHandModifier3D, tracker_name: StringName) {
}
XRHandModifier3D_get_hand_tracker :: (using self: *XRHandModifier3D) -> StringName {
}
XRHandModifier3D_set_bone_update :: (using self: *XRHandModifier3D, bone_update: XRHandModifier3D.BoneUpdate) {
}
XRHandModifier3D_get_bone_update :: (using self: *XRHandModifier3D) -> XRHandModifier3D.BoneUpdate {
}

// XRHandTracker
XRHandTracker :: struct {
	__private: *void;

	HandTrackingSource :: enum {
		HAND_TRACKING_SOURCE_UNKNOWN :: 0;
		HAND_TRACKING_SOURCE_UNOBSTRUCTED :: 1;
		HAND_TRACKING_SOURCE_CONTROLLER :: 2;
		HAND_TRACKING_SOURCE_MAX :: 3;
	}
	HandJoint :: enum {
		HAND_JOINT_PALM :: 0;
		HAND_JOINT_WRIST :: 1;
		HAND_JOINT_THUMB_METACARPAL :: 2;
		HAND_JOINT_THUMB_PHALANX_PROXIMAL :: 3;
		HAND_JOINT_THUMB_PHALANX_DISTAL :: 4;
		HAND_JOINT_THUMB_TIP :: 5;
		HAND_JOINT_INDEX_FINGER_METACARPAL :: 6;
		HAND_JOINT_INDEX_FINGER_PHALANX_PROXIMAL :: 7;
		HAND_JOINT_INDEX_FINGER_PHALANX_INTERMEDIATE :: 8;
		HAND_JOINT_INDEX_FINGER_PHALANX_DISTAL :: 9;
		HAND_JOINT_INDEX_FINGER_TIP :: 10;
		HAND_JOINT_MIDDLE_FINGER_METACARPAL :: 11;
		HAND_JOINT_MIDDLE_FINGER_PHALANX_PROXIMAL :: 12;
		HAND_JOINT_MIDDLE_FINGER_PHALANX_INTERMEDIATE :: 13;
		HAND_JOINT_MIDDLE_FINGER_PHALANX_DISTAL :: 14;
		HAND_JOINT_MIDDLE_FINGER_TIP :: 15;
		HAND_JOINT_RING_FINGER_METACARPAL :: 16;
		HAND_JOINT_RING_FINGER_PHALANX_PROXIMAL :: 17;
		HAND_JOINT_RING_FINGER_PHALANX_INTERMEDIATE :: 18;
		HAND_JOINT_RING_FINGER_PHALANX_DISTAL :: 19;
		HAND_JOINT_RING_FINGER_TIP :: 20;
		HAND_JOINT_PINKY_FINGER_METACARPAL :: 21;
		HAND_JOINT_PINKY_FINGER_PHALANX_PROXIMAL :: 22;
		HAND_JOINT_PINKY_FINGER_PHALANX_INTERMEDIATE :: 23;
		HAND_JOINT_PINKY_FINGER_PHALANX_DISTAL :: 24;
		HAND_JOINT_PINKY_FINGER_TIP :: 25;
		HAND_JOINT_MAX :: 26;
	}
	HandJointFlags :: enum_flags {
		HAND_JOINT_FLAG_ORIENTATION_VALID :: 1;
		HAND_JOINT_FLAG_ORIENTATION_TRACKED :: 2;
		HAND_JOINT_FLAG_POSITION_VALID :: 4;
		HAND_JOINT_FLAG_POSITION_TRACKED :: 8;
		HAND_JOINT_FLAG_LINEAR_VELOCITY_VALID :: 16;
		HAND_JOINT_FLAG_ANGULAR_VELOCITY_VALID :: 32;
	}
}

XRHandTracker_set_has_tracking_data :: (using self: *XRHandTracker, has_data: bool) {
}
XRHandTracker_get_has_tracking_data :: (using self: *XRHandTracker) -> bool {
}
XRHandTracker_set_hand_tracking_source :: (using self: *XRHandTracker, source: XRHandTracker.HandTrackingSource) {
}
XRHandTracker_get_hand_tracking_source :: (using self: *XRHandTracker) -> XRHandTracker.HandTrackingSource {
}
XRHandTracker_set_hand_joint_flags :: (using self: *XRHandTracker, joint: XRHandTracker.HandJoint, flags: XRHandTracker.HandJointFlags) {
}
XRHandTracker_get_hand_joint_flags :: (using self: *XRHandTracker, joint: XRHandTracker.HandJoint) -> XRHandTracker.HandJointFlags {
}
XRHandTracker_set_hand_joint_transform :: (using self: *XRHandTracker, joint: XRHandTracker.HandJoint, transform: Transform3D) {
}
XRHandTracker_get_hand_joint_transform :: (using self: *XRHandTracker, joint: XRHandTracker.HandJoint) -> Transform3D {
}
XRHandTracker_set_hand_joint_radius :: (using self: *XRHandTracker, joint: XRHandTracker.HandJoint, radius: float) {
}
XRHandTracker_get_hand_joint_radius :: (using self: *XRHandTracker, joint: XRHandTracker.HandJoint) -> float {
}
XRHandTracker_set_hand_joint_linear_velocity :: (using self: *XRHandTracker, joint: XRHandTracker.HandJoint, linear_velocity: Vector3) {
}
XRHandTracker_get_hand_joint_linear_velocity :: (using self: *XRHandTracker, joint: XRHandTracker.HandJoint) -> Vector3 {
}
XRHandTracker_set_hand_joint_angular_velocity :: (using self: *XRHandTracker, joint: XRHandTracker.HandJoint, angular_velocity: Vector3) {
}
XRHandTracker_get_hand_joint_angular_velocity :: (using self: *XRHandTracker, joint: XRHandTracker.HandJoint) -> Vector3 {
}

// XRInterface
XRInterface :: struct {
	__private: *void;

	Capabilities :: enum {
		XR_NONE :: 0;
		XR_MONO :: 1;
		XR_STEREO :: 2;
		XR_QUAD :: 4;
		XR_VR :: 8;
		XR_AR :: 16;
		XR_EXTERNAL :: 32;
	}
	TrackingStatus :: enum {
		XR_NORMAL_TRACKING :: 0;
		XR_EXCESSIVE_MOTION :: 1;
		XR_INSUFFICIENT_FEATURES :: 2;
		XR_UNKNOWN_TRACKING :: 3;
		XR_NOT_TRACKING :: 4;
	}
	PlayAreaMode :: enum {
		XR_PLAY_AREA_UNKNOWN :: 0;
		XR_PLAY_AREA_3DOF :: 1;
		XR_PLAY_AREA_SITTING :: 2;
		XR_PLAY_AREA_ROOMSCALE :: 3;
		XR_PLAY_AREA_STAGE :: 4;
	}
	EnvironmentBlendMode :: enum {
		XR_ENV_BLEND_MODE_OPAQUE :: 0;
		XR_ENV_BLEND_MODE_ADDITIVE :: 1;
		XR_ENV_BLEND_MODE_ALPHA_BLEND :: 2;
	}
}

XRInterface_get_name :: (using self: *XRInterface) -> StringName {
}
XRInterface_get_capabilities :: (using self: *XRInterface) -> int {
}
XRInterface_is_primary :: (using self: *XRInterface) -> bool {
}
XRInterface_set_primary :: (using self: *XRInterface, primary: bool) {
}
XRInterface_is_initialized :: (using self: *XRInterface) -> bool {
}
XRInterface_initialize :: (using self: *XRInterface) -> bool {
}
XRInterface_uninitialize :: (using self: *XRInterface) {
}
XRInterface_get_system_info :: (using self: *XRInterface) -> Dictionary {
}
XRInterface_get_tracking_status :: (using self: *XRInterface) -> XRInterface.TrackingStatus {
}
XRInterface_get_render_target_size :: (using self: *XRInterface) -> Vector2 {
}
XRInterface_get_view_count :: (using self: *XRInterface) -> int {
}
XRInterface_trigger_haptic_pulse :: (using self: *XRInterface, action_name: String, tracker_name: StringName, frequency: float, amplitude: float, duration_sec: float, delay_sec: float) {
}
XRInterface_supports_play_area_mode :: (using self: *XRInterface, mode: XRInterface.PlayAreaMode) -> bool {
}
XRInterface_get_play_area_mode :: (using self: *XRInterface) -> XRInterface.PlayAreaMode {
}
XRInterface_set_play_area_mode :: (using self: *XRInterface, mode: XRInterface.PlayAreaMode) -> bool {
}
XRInterface_get_play_area :: (using self: *XRInterface) -> PackedVector3Array {
}
XRInterface_get_anchor_detection_is_enabled :: (using self: *XRInterface) -> bool {
}
XRInterface_set_anchor_detection_is_enabled :: (using self: *XRInterface, enable: bool) {
}
XRInterface_get_camera_feed_id :: (using self: *XRInterface) -> int {
}
XRInterface_is_passthrough_supported :: (using self: *XRInterface) -> bool {
}
XRInterface_is_passthrough_enabled :: (using self: *XRInterface) -> bool {
}
XRInterface_start_passthrough :: (using self: *XRInterface) -> bool {
}
XRInterface_stop_passthrough :: (using self: *XRInterface) {
}
XRInterface_get_transform_for_view :: (using self: *XRInterface, view: int, cam_transform: Transform3D) -> Transform3D {
}
XRInterface_get_projection_for_view :: (using self: *XRInterface, view: int, aspect: float, near: float, far: float) -> Projection {
}
XRInterface_get_supported_environment_blend_modes :: (using self: *XRInterface) -> Array {
}
XRInterface_set_environment_blend_mode :: (using self: *XRInterface, mode: XRInterface.EnvironmentBlendMode) -> bool {
}
XRInterface_get_environment_blend_mode :: (using self: *XRInterface) -> XRInterface.EnvironmentBlendMode {
}

// XRInterfaceExtension
XRInterfaceExtension :: struct {
	__private: *void;
}

XRInterfaceExtension__get_name :: (using self: *XRInterfaceExtension) -> StringName {
}
XRInterfaceExtension__get_capabilities :: (using self: *XRInterfaceExtension) -> int {
}
XRInterfaceExtension__is_initialized :: (using self: *XRInterfaceExtension) -> bool {
}
XRInterfaceExtension__initialize :: (using self: *XRInterfaceExtension) -> bool {
}
XRInterfaceExtension__uninitialize :: (using self: *XRInterfaceExtension) {
}
XRInterfaceExtension__get_system_info :: (using self: *XRInterfaceExtension) -> Dictionary {
}
XRInterfaceExtension__supports_play_area_mode :: (using self: *XRInterfaceExtension, mode: XRInterface.PlayAreaMode) -> bool {
}
XRInterfaceExtension__get_play_area_mode :: (using self: *XRInterfaceExtension) -> XRInterface.PlayAreaMode {
}
XRInterfaceExtension__set_play_area_mode :: (using self: *XRInterfaceExtension, mode: XRInterface.PlayAreaMode) -> bool {
}
XRInterfaceExtension__get_play_area :: (using self: *XRInterfaceExtension) -> PackedVector3Array {
}
XRInterfaceExtension__get_render_target_size :: (using self: *XRInterfaceExtension) -> Vector2 {
}
XRInterfaceExtension__get_view_count :: (using self: *XRInterfaceExtension) -> int {
}
XRInterfaceExtension__get_camera_transform :: (using self: *XRInterfaceExtension) -> Transform3D {
}
XRInterfaceExtension__get_transform_for_view :: (using self: *XRInterfaceExtension, view: int, cam_transform: Transform3D) -> Transform3D {
}
XRInterfaceExtension__get_projection_for_view :: (using self: *XRInterfaceExtension, view: int, aspect: float, z_near: float, z_far: float) -> PackedFloat64Array {
}
XRInterfaceExtension__get_vrs_texture :: (using self: *XRInterfaceExtension) -> RID {
}
XRInterfaceExtension__process :: (using self: *XRInterfaceExtension) {
}
XRInterfaceExtension__pre_render :: (using self: *XRInterfaceExtension) {
}
XRInterfaceExtension__pre_draw_viewport :: (using self: *XRInterfaceExtension, render_target: RID) -> bool {
}
XRInterfaceExtension__post_draw_viewport :: (using self: *XRInterfaceExtension, render_target: RID, screen_rect: Rect2) {
}
XRInterfaceExtension__end_frame :: (using self: *XRInterfaceExtension) {
}
XRInterfaceExtension__get_suggested_tracker_names :: (using self: *XRInterfaceExtension) -> PackedStringArray {
}
XRInterfaceExtension__get_suggested_pose_names :: (using self: *XRInterfaceExtension, tracker_name: StringName) -> PackedStringArray {
}
XRInterfaceExtension__get_tracking_status :: (using self: *XRInterfaceExtension) -> XRInterface.TrackingStatus {
}
XRInterfaceExtension__trigger_haptic_pulse :: (using self: *XRInterfaceExtension, action_name: String, tracker_name: StringName, frequency: float, amplitude: float, duration_sec: float, delay_sec: float) {
}
XRInterfaceExtension__get_anchor_detection_is_enabled :: (using self: *XRInterfaceExtension) -> bool {
}
XRInterfaceExtension__set_anchor_detection_is_enabled :: (using self: *XRInterfaceExtension, enabled: bool) {
}
XRInterfaceExtension__get_camera_feed_id :: (using self: *XRInterfaceExtension) -> int {
}
XRInterfaceExtension__get_color_texture :: (using self: *XRInterfaceExtension) -> RID {
}
XRInterfaceExtension__get_depth_texture :: (using self: *XRInterfaceExtension) -> RID {
}
XRInterfaceExtension__get_velocity_texture :: (using self: *XRInterfaceExtension) -> RID {
}
XRInterfaceExtension_get_color_texture :: (using self: *XRInterfaceExtension) -> RID {
}
XRInterfaceExtension_get_depth_texture :: (using self: *XRInterfaceExtension) -> RID {
}
XRInterfaceExtension_get_velocity_texture :: (using self: *XRInterfaceExtension) -> RID {
}
XRInterfaceExtension_add_blit :: (using self: *XRInterfaceExtension, render_target: RID, src_rect: Rect2, dst_rect: Rect2i, use_layer: bool, layer: int, apply_lens_distortion: bool, eye_center: Vector2, k1: float, k2: float, upscale: float, aspect_ratio: float) {
}
XRInterfaceExtension_get_render_target_texture :: (using self: *XRInterfaceExtension, render_target: RID) -> RID {
}

// XRNode3D
XRNode3D :: struct {
	__private: *void;
}

XRNode3D_set_tracker :: (using self: *XRNode3D, tracker_name: StringName) {
}
XRNode3D_get_tracker :: (using self: *XRNode3D) -> StringName {
}
XRNode3D_set_pose_name :: (using self: *XRNode3D, pose: StringName) {
}
XRNode3D_get_pose_name :: (using self: *XRNode3D) -> StringName {
}
XRNode3D_set_show_when_tracked :: (using self: *XRNode3D, show: bool) {
}
XRNode3D_get_show_when_tracked :: (using self: *XRNode3D) -> bool {
}
XRNode3D_get_is_active :: (using self: *XRNode3D) -> bool {
}
XRNode3D_get_has_tracking_data :: (using self: *XRNode3D) -> bool {
}
XRNode3D_get_pose :: (using self: *XRNode3D) -> XRPose {
}
XRNode3D_trigger_haptic_pulse :: (using self: *XRNode3D, action_name: String, frequency: float, amplitude: float, duration_sec: float, delay_sec: float) {
}

// XROrigin3D
XROrigin3D :: struct {
	__private: *void;
}

XROrigin3D_set_world_scale :: (using self: *XROrigin3D, world_scale: float) {
}
XROrigin3D_get_world_scale :: (using self: *XROrigin3D) -> float {
}
XROrigin3D_set_current :: (using self: *XROrigin3D, enabled: bool) {
}
XROrigin3D_is_current :: (using self: *XROrigin3D) -> bool {
}

// XRPose
XRPose :: struct {
	__private: *void;

	TrackingConfidence :: enum {
		XR_TRACKING_CONFIDENCE_NONE :: 0;
		XR_TRACKING_CONFIDENCE_LOW :: 1;
		XR_TRACKING_CONFIDENCE_HIGH :: 2;
	}
}

XRPose_set_has_tracking_data :: (using self: *XRPose, has_tracking_data: bool) {
}
XRPose_get_has_tracking_data :: (using self: *XRPose) -> bool {
}
XRPose_set_name :: (using self: *XRPose, name: StringName) {
}
XRPose_get_name :: (using self: *XRPose) -> StringName {
}
XRPose_set_transform :: (using self: *XRPose, transform: Transform3D) {
}
XRPose_get_transform :: (using self: *XRPose) -> Transform3D {
}
XRPose_get_adjusted_transform :: (using self: *XRPose) -> Transform3D {
}
XRPose_set_linear_velocity :: (using self: *XRPose, velocity: Vector3) {
}
XRPose_get_linear_velocity :: (using self: *XRPose) -> Vector3 {
}
XRPose_set_angular_velocity :: (using self: *XRPose, velocity: Vector3) {
}
XRPose_get_angular_velocity :: (using self: *XRPose) -> Vector3 {
}
XRPose_set_tracking_confidence :: (using self: *XRPose, tracking_confidence: XRPose.TrackingConfidence) {
}
XRPose_get_tracking_confidence :: (using self: *XRPose) -> XRPose.TrackingConfidence {
}

// XRPositionalTracker
XRPositionalTracker :: struct {
	__private: *void;

	TrackerHand :: enum {
		TRACKER_HAND_UNKNOWN :: 0;
		TRACKER_HAND_LEFT :: 1;
		TRACKER_HAND_RIGHT :: 2;
		TRACKER_HAND_MAX :: 3;
	}
}

XRPositionalTracker_get_tracker_profile :: (using self: *XRPositionalTracker) -> String {
}
XRPositionalTracker_set_tracker_profile :: (using self: *XRPositionalTracker, profile: String) {
}
XRPositionalTracker_get_tracker_hand :: (using self: *XRPositionalTracker) -> XRPositionalTracker.TrackerHand {
}
XRPositionalTracker_set_tracker_hand :: (using self: *XRPositionalTracker, hand: XRPositionalTracker.TrackerHand) {
}
XRPositionalTracker_has_pose :: (using self: *XRPositionalTracker, name: StringName) -> bool {
}
XRPositionalTracker_get_pose :: (using self: *XRPositionalTracker, name: StringName) -> XRPose {
}
XRPositionalTracker_invalidate_pose :: (using self: *XRPositionalTracker, name: StringName) {
}
XRPositionalTracker_set_pose :: (using self: *XRPositionalTracker, name: StringName, transform: Transform3D, linear_velocity: Vector3, angular_velocity: Vector3, tracking_confidence: XRPose.TrackingConfidence) {
}
XRPositionalTracker_get_input :: (using self: *XRPositionalTracker, name: StringName) -> Variant {
}
XRPositionalTracker_set_input :: (using self: *XRPositionalTracker, name: StringName, value: Variant) {
}

// XRServer
XRServer :: struct {
	__private: *void;

	TrackerType :: enum {
		TRACKER_HEAD :: 1;
		TRACKER_CONTROLLER :: 2;
		TRACKER_BASESTATION :: 4;
		TRACKER_ANCHOR :: 8;
		TRACKER_HAND :: 16;
		TRACKER_BODY :: 32;
		TRACKER_FACE :: 64;
		TRACKER_ANY_KNOWN :: 127;
		TRACKER_UNKNOWN :: 128;
		TRACKER_ANY :: 255;
	}
	RotationMode :: enum {
		RESET_FULL_ROTATION :: 0;
		RESET_BUT_KEEP_TILT :: 1;
		DONT_RESET_ROTATION :: 2;
	}
}

XRServer_get_world_scale :: (using self: *XRServer) -> float {
}
XRServer_set_world_scale :: (using self: *XRServer, scale: float) {
}
XRServer_get_world_origin :: (using self: *XRServer) -> Transform3D {
}
XRServer_set_world_origin :: (using self: *XRServer, world_origin: Transform3D) {
}
XRServer_get_reference_frame :: (using self: *XRServer) -> Transform3D {
}
XRServer_clear_reference_frame :: (using self: *XRServer) {
}
XRServer_center_on_hmd :: (using self: *XRServer, rotation_mode: XRServer.RotationMode, keep_height: bool) {
}
XRServer_get_hmd_transform :: (using self: *XRServer) -> Transform3D {
}
XRServer_add_interface :: (using self: *XRServer, _interface: XRInterface) {
}
XRServer_get_interface_count :: (using self: *XRServer) -> int {
}
XRServer_remove_interface :: (using self: *XRServer, _interface: XRInterface) {
}
XRServer_get_interface :: (using self: *XRServer, idx: int) -> XRInterface {
}
XRServer_get_interfaces :: (using self: *XRServer) -> Dictionary {
}
XRServer_find_interface :: (using self: *XRServer, name: String) -> XRInterface {
}
XRServer_add_tracker :: (using self: *XRServer, tracker: XRTracker) {
}
XRServer_remove_tracker :: (using self: *XRServer, tracker: XRTracker) {
}
XRServer_get_trackers :: (using self: *XRServer, tracker_types: int) -> Dictionary {
}
XRServer_get_tracker :: (using self: *XRServer, tracker_name: StringName) -> XRTracker {
}
XRServer_get_primary_interface :: (using self: *XRServer) -> XRInterface {
}
XRServer_set_primary_interface :: (using self: *XRServer, _interface: XRInterface) {
}

// XRTracker
XRTracker :: struct {
	__private: *void;
}

XRTracker_get_tracker_type :: (using self: *XRTracker) -> XRServer.TrackerType {
}
XRTracker_set_tracker_type :: (using self: *XRTracker, type: XRServer.TrackerType) {
}
XRTracker_get_tracker_name :: (using self: *XRTracker) -> StringName {
}
XRTracker_set_tracker_name :: (using self: *XRTracker, name: StringName) {
}
XRTracker_get_tracker_desc :: (using self: *XRTracker) -> String {
}
XRTracker_set_tracker_desc :: (using self: *XRTracker, description: String) {
}

// XRVRS
XRVRS :: struct {
	__private: *void;
}

XRVRS_get_vrs_min_radius :: (using self: *XRVRS) -> float {
}
XRVRS_set_vrs_min_radius :: (using self: *XRVRS, radius: float) {
}
XRVRS_get_vrs_strength :: (using self: *XRVRS) -> float {
}
XRVRS_set_vrs_strength :: (using self: *XRVRS, strength: float) {
}
XRVRS_make_vrs_texture :: (using self: *XRVRS, target_size: Vector2, eye_foci: PackedVector2Array) -> RID {
}

// ZIPPacker
ZIPPacker :: struct {
	__private: *void;

	ZipAppend :: enum {
		APPEND_CREATE :: 0;
		APPEND_CREATEAFTER :: 1;
		APPEND_ADDINZIP :: 2;
	}
}

ZIPPacker_open :: (using self: *ZIPPacker, path: String, append: ZIPPacker.ZipAppend) -> Error {
}
ZIPPacker_start_file :: (using self: *ZIPPacker, path: String) -> Error {
}
ZIPPacker_write_file :: (using self: *ZIPPacker, data: PackedByteArray) -> Error {
}
ZIPPacker_close_file :: (using self: *ZIPPacker) -> Error {
}
ZIPPacker_close :: (using self: *ZIPPacker) -> Error {
}

// ZIPReader
ZIPReader :: struct {
	__private: *void;
}

ZIPReader_open :: (using self: *ZIPReader, path: String) -> Error {
}
ZIPReader_close :: (using self: *ZIPReader) -> Error {
}
ZIPReader_get_files :: (using self: *ZIPReader) -> PackedStringArray {
}
ZIPReader_read_file :: (using self: *ZIPReader, path: String, case_sensitive: bool) -> PackedByteArray {
}
ZIPReader_file_exists :: (using self: *ZIPReader, path: String, case_sensitive: bool) -> bool {
}


AudioFrame :: struct {
	left: float;
	right: float;
}

CaretInfo :: struct {
	leading_caret: Rect2;
	trailing_caret: Rect2;
	leading_direction: TextServer.Direction;
	trailing_direction: TextServer.Direction;
}

Glyph :: struct {
	start: int = -1;
	end: int = -1;
	count: u8 = 0;
	repeat: u8 = 1;
	flags: u16 = 0;
	x_off: float = 0;
	y_off: float = 0;
	advance: float = 0;
	font_rid: RID;
	font_size: int = 0;
	index: s32 = 0;
}

ObjectID :: struct {
	id: u64 = 0;
}

PhysicsServer2DExtensionMotionResult :: struct {
	travel: Vector2;
	remainder: Vector2;
	collision_point: Vector2;
	collision_normal: Vector2;
	collider_velocity: Vector2;
	collision_depth: float;
	collision_safe_fraction: float;
	collision_unsafe_fraction: float;
	collision_local_shape: int;
	collider_id: ObjectID;
	collider: RID;
	collider_shape: int;
}

PhysicsServer2DExtensionRayResult :: struct {
	position: Vector2;
	normal: Vector2;
	rid: RID;
	collider_id: ObjectID;
	collider: *Object;
	shape: int;
}

PhysicsServer2DExtensionShapeRestInfo :: struct {
	point: Vector2;
	normal: Vector2;
	rid: RID;
	collider_id: ObjectID;
	shape: int;
	linear_velocity: Vector2;
}

PhysicsServer2DExtensionShapeResult :: struct {
	rid: RID;
	collider_id: ObjectID;
	collider: *Object;
	shape: int;
}

PhysicsServer3DExtensionMotionCollision :: struct {
	position: Vector3;
	normal: Vector3;
	collider_velocity: Vector3;
	collider_angular_velocity: Vector3;
	depth: float;
	local_shape: int;
	collider_id: ObjectID;
	collider: RID;
	collider_shape: int;
}

PhysicsServer3DExtensionMotionResult :: struct {
	travel: Vector3;
	remainder: Vector3;
	collision_depth: float;
	collision_safe_fraction: float;
	collision_unsafe_fraction: float;
	collisions: [32]PhysicsServer3DExtensionMotionCollision;
	collision_count: int;
}

PhysicsServer3DExtensionRayResult :: struct {
	position: Vector3;
	normal: Vector3;
	rid: RID;
	collider_id: ObjectID;
	collider: *Object;
	shape: int;
	face_index: int;
}

PhysicsServer3DExtensionShapeRestInfo :: struct {
	point: Vector3;
	normal: Vector3;
	rid: RID;
	collider_id: ObjectID;
	shape: int;
	linear_velocity: Vector3;
}

PhysicsServer3DExtensionShapeResult :: struct {
	rid: RID;
	collider_id: ObjectID;
	collider: *Object;
	shape: int;
}

ScriptLanguageExtensionProfilingInfo :: struct {
	signature: StringName;
	call_count: u64;
	total_time: u64;
	self_time: u64;
}

